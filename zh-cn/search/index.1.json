[{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1. 简介 通常来说，shell要启动一个新的程序，会先fork一个新进程，然后执行exec系统调用将替换新进程的执行程序。posix规定了posix_spawn函数，封装了fork+exec的过程，提供了更加高效的接口。\n2. 追踪进程 2.1. 一个比hello world还简单的程序 C语言编程通常会以printf(\u0026quot;hello world\\n\u0026quot;);作为第一个程序。这里写一个简单的程序来演示进程的创建、执行和退出。\nmain函数的返回值会被作为进程的退出码传递给exit系统调用，如果使用void main(void)，进程的退出值可能是不确定的，这里为了方便理解，使main函数的返回值为0。\n1int main(void) 2{ 3 return 0; 4} 2.2. strace追踪系统调用 这里使用qemu模拟ARM64环境，可以参考https://gitee.com/kingdix10/eel。\n由于buildroot构建的根文件系统默认只有一个shell会话，这里使用前后台程序的方式来实现追踪。 如果可以启动多个终端，可以在另一终端运行strace。\nstrace可以使用-e指定要追踪的系统调用，这里为了记录所有系统调用进行分析，在追踪完成后使用grep命令过滤出感兴趣的系统调用。\n使用ps -e -o ppid,pid,comm | grep -w 'ps'命令查看当前shell的进程id，也就是ps的ppid 使用strace -f -p 133 -o trace.txt \u0026amp;在后台追踪 运行程序./dummy_arm64 使用fg %1命令将strace进程放到前台，然后使用Ctrl + C结束strace，停止追踪 使用grep -E 'fork|clone|exec|wait|exit' trace.txt查看strace的输出 1# grep -E \u0026#39;fork|clone|exec|wait|exit\u0026#39; trace.txt 2133 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xffff8d0310e0) = 158 3133 wait4(-1, \u0026lt;unfinished ...\u0026gt; 4158 execve(\u0026#34;./dummy_arm64\u0026#34;, [\u0026#34;./dummy_arm64\u0026#34;], 0xaaab1c5be680 /* 11 vars */) = 0 5158 exit_group(0) = ? 6158 +++ exited with 0 +++ 7133 \u0026lt;... wait4 resumed\u0026gt;[{WIFEXITED(s) \u0026amp;\u0026amp; WEXITSTATUS(s) == 0}], WSTOPPED, NULL) = 158 8133 wait4(-1, 0xffffc00c7b9c, WNOHANG|WSTOPPED, NULL) = 0 9133 wait4(-1, \u0026lt;detached ...\u0026gt; 2.3. ftrace追踪内核流程 与strace类似，这里也将trace-cmd放到后台进行追踪。\n使用trace-cmd record -P 133 ... \u0026amp;命令在后台追踪，完整命令见代码块，注意等待trace-cmd输出信息再执行下一步 运行程序./dummy_arm64 使用fg %1命令将trace-cmd放到前台，然后使用Ctrl + C结束trace-cmd，停止追踪，注意只能按一次Ctrl + C，按完Ctrl + C后可以按Enter 使用trace-cmd report \u0026gt; dummy.txt命令将输出内容保存到文件 使用grep __arm64_sys_ dummy.txt命令查看感兴趣的系统调用 1trace-cmd record -P 133 -p function_graph -g __arm64_sys_fork -g __arm64_sys_clone -g __arm64_sys_clone3 -g __arm64_sys_execve* -g __arm64_sys_exit_group -g __arm64_sys_waitid -g __arm64_sys_wait4 -n gic_handle_irq -n down_read -n down_write -n up_read -n up_write -n *spin_*lock* --max-graph-depth 5 -c \u0026amp; 2 3grep __arm64_sys_ dummy.txt 4 sh-133 [000] 772.904058: funcgraph_entry: | __arm64_sys_clone() { 5 sh-133 [000] 772.908318: funcgraph_entry: | __arm64_sys_wait4() { 6 dummy_arm64-164 [001] 772.910101: funcgraph_entry: | __arm64_sys_execve() { 7 dummy_arm64-164 [001] 772.939417: funcgraph_entry: | __arm64_sys_exit_group() { 8 sh-133 [000] 772.946847: funcgraph_entry: | __arm64_sys_wait4() { 9 sh-133 [000] 777.114793: funcgraph_entry: | __arm64_sys_wait4() { 3. 流程说明 3.1. 父进程clone shell作为父进程，执行clone系统调用，在内核态，clone和fork最终都会调用到kernel_fork，再调到copy_process。\n在copy_process中复制父进程的资源和环境到子进程。\n3.2. 子进程execve 新进程创建后，子进程调用execve系统调用，向内核传递可执行文件路径。内核读取并解析elf文件，替换子进程的代码段、数据段等。\n3.3. 子进程exit 按照进程的默认行为，新进程执行完毕后，会调用exit系统调用，最终会调用到do_exit函数，释放进程的文件、内存等资源，但是会保留子进程的struct task_struct。\n默认子进程退出时还会向父进程发送SIGCHLD信号。\n3.4. 父进程wait 在clone后，父进程会调用wait4系统调用，进入阻塞状态，之后被子进程发送的信号唤醒。之后内核会释放子进程的struct task_struct。\n","date":"August 31, 2024","img":"https://kingdix10.github.io/covers/texture_background_color_72786_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/sched/task_life/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"Linux","url":"/zh-cn/tags/linux/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1725062400,"title":"用trace追踪Linux进程的一生"},{"categories":[{"title":"内核基础","url":"/zh-cn/categories/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"}],"content":" 1. 简介 Linux内核中的notifier_chain是一种用于跨模块通信的机制。当一个模块需要通知其他模块某些事件时，它可以使用notifier_chain将这些事件通知给其他模块。这种机制使得模块之间的耦合度降低，提高了代码的可维护性和可扩展性。\n在Linux内核中，有四种类型的通知链：\n原子通知链适用于对原子性要求高的中断上下文 阻塞通知链适用于进程上下文的复杂处理 原始通知链提供了最大的灵活性但需要谨慎使用 SRCU 通知链则在读写锁保护的场景中发挥作用 1/// include/linux/notifier.h 2/* 3 * Notifier chains are of four types: 4 * 5 *\tAtomic notifier chains: Chain callbacks run in interrupt/atomic 6 *\tcontext. Callouts are not allowed to block. 7 *\tBlocking notifier chains: Chain callbacks run in process context. 8 *\tCallouts are allowed to block. 9 *\tRaw notifier chains: There are no restrictions on callbacks, 10 *\tregistration, or unregistration. All locking and protection 11 *\tmust be provided by the caller. 12 *\tSRCU notifier chains: A variant of blocking notifier chains, with 13 *\tthe same restrictions. 14 * 15 * atomic_notifier_chain_register() may be called from an atomic context, 16 * but blocking_notifier_chain_register() and srcu_notifier_chain_register() 17 * must be called from a process context. Ditto for the corresponding 18 * _unregister() routines. 19 * 20 * atomic_notifier_chain_unregister(), blocking_notifier_chain_unregister(), 21 * and srcu_notifier_chain_unregister() _must not_ be called from within 22 * the call chain. 23 * 24 * SRCU notifier chains are an alternative form of blocking notifier chains. 25 * They use SRCU (Sleepable Read-Copy Update) instead of rw-semaphores for 26 * protection of the chain links. This means there is _very_ low overhead 27 * in srcu_notifier_call_chain(): no cache bounces and no memory barriers. 28 * As compensation, srcu_notifier_chain_unregister() is rather expensive. 29 * SRCU notifier chains should be used when the chain will be called very 30 * often but notifier_blocks will seldom be removed. 31 */ 32 33struct notifier_block; 34 35typedef\tint (*notifier_fn_t)(struct notifier_block *nb, 36 unsigned long action, void *data); 37 38struct notifier_block { 39 notifier_fn_t notifier_call; 40 struct notifier_block __rcu *next; 41 int priority; 42}; 43 44struct atomic_notifier_head { 45 spinlock_t lock; 46 struct notifier_block __rcu *head; 47}; 48 49struct blocking_notifier_head { 50 struct rw_semaphore rwsem; 51 struct notifier_block __rcu *head; 52}; 53 54struct raw_notifier_head { 55 struct notifier_block __rcu *head; 56}; 57 58struct srcu_notifier_head { 59 struct mutex mutex; 60 struct srcu_usage srcuu; 61 struct srcu_struct srcu; 62 struct notifier_block __rcu *head; 63}; 1.1. 原子通知链 原子通知链用于在中断上下文中或者其他不允许阻塞的场景中进行通知。其特点是通知的处理过程必须是原子的，不能被打断。\n在实现上，原子通知链通过使用原子操作来保证通知的顺序和完整性。当事件发生时，内核会遍历原子通知链上注册的回调函数，并依次执行它们。\n优点：适用于对实时性和原子性要求较高的场景，能够确保通知的快速处理且不会被中断。\n缺点：由于不能阻塞，所以在处理复杂逻辑时可能会受到限制。\n1.2. 阻塞通知链 阻塞通知链允许在通知处理过程中进行阻塞操作，例如等待资源、睡眠等。\n这种通知链通常在进程上下文使用，因为阻塞操作在中断上下文是不被允许的。当通知被触发时，内核会按照注册的顺序依次调用回调函数，如果某个回调函数进行了阻塞操作，内核会暂停当前回调函数的执行，切换到其他可运行的任务。\n优点：能够处理较为复杂的逻辑，包括需要阻塞等待的情况。\n缺点：可能会导致系统的响应时间变长，特别是在处理耗时的阻塞操作时。\n1.3. 原始通知链 原始通知链提供了一种最低级别的通知机制，不对通知的执行顺序和并发访问进行任何保证。\n它适用于那些对通知的顺序和并发处理要求不高，或者需要自定义处理方式的场景。\n优点：灵活性高，能够满足一些特殊的需求。\n缺点：由于缺乏保证，使用时需要特别小心，以避免出现竞态条件和不确定的行为。\n1.4. SRCU 通知链 SRCU 通知链用于在读写锁保护的场景中进行通知。它结合了读锁的并发访问和写锁的同步更新特性。\n在使用 SRCU 通知链时，读端可以并发地访问通知链，而写端在更新通知链时需要获取写锁。\n优点：在保证一定的并发性能的同时，能够安全地进行通知链的更新。\n缺点：实现相对复杂，需要对读写锁和 SRCU 机制有深入的理解。\n2. 原理 2.1. 注册 核心函数：notifier_chain_register。\n1/// kernel/notifier.c 2static int notifier_chain_register(struct notifier_block **nl, 3 struct notifier_block *n, 4 bool unique_priority) 5{ 6 while ((*nl) != NULL) { 7 /// 已经存在，返回错误 8 if (unlikely((*nl) == n)) { 9 WARN(1, \u0026#34;notifier callback %ps already registered\u0026#34;, 10 n-\u0026gt;notifier_call); 11 return -EEXIST; 12 } 13 /// 优先级高于当前节点，插入到当前节点之前 14 if (n-\u0026gt;priority \u0026gt; (*nl)-\u0026gt;priority) 15 break; 16 /// 优先级相同，且要求唯一性，返回错误 17 if (n-\u0026gt;priority == (*nl)-\u0026gt;priority \u0026amp;\u0026amp; unique_priority) 18 return -EBUSY; 19 /// 遍历下一个节点 20 nl = \u0026amp;((*nl)-\u0026gt;next); 21 } 22 /// 插入新节点 23 n-\u0026gt;next = *nl; 24 rcu_assign_pointer(*nl, n); 25 26 trace_notifier_register((void *)n-\u0026gt;notifier_call); 27 return 0; 28} 2.2. 调用 核心函数：notifier_call_chain。\n1/// kernel/notifier.c 2/** 3 * notifier_call_chain - Informs the registered notifiers about an event. 4 *\t@nl:\tPointer to head of the blocking notifier chain 5 *\t@val:\tValue passed unmodified to notifier function 6 *\t@v:\tPointer passed unmodified to notifier function 7 *\t@nr_to_call:\tNumber of notifier functions to be called. Don\u0026#39;t care 8 *\tvalue of this parameter is -1. 9 *\t@nr_calls:\tRecords the number of notifications sent. Don\u0026#39;t care 10 *\tvalue of this field is NULL. 11 *\tReturn:\tnotifier_call_chain returns the value returned by the 12 *\tlast notifier function called. 13 */ 14static int notifier_call_chain(struct notifier_block **nl, 15 unsigned long val, void *v, 16 int nr_to_call, int *nr_calls) 17{ 18 int ret = NOTIFY_DONE; 19 struct notifier_block *nb, *next_nb; 20 21 /// 获取当前链表第一个节点 22 nb = rcu_dereference_raw(*nl); 23 24 while (nb \u0026amp;\u0026amp; nr_to_call) { 25 /// 获取下一个节点 26 next_nb = rcu_dereference_raw(nb-\u0026gt;next); 27 28#ifdef CONFIG_DEBUG_NOTIFIERS 29 /// ... .. 30#endif 31 trace_notifier_run((void *)nb-\u0026gt;notifier_call); 32 /// 调用回调函数 33 ret = nb-\u0026gt;notifier_call(nb, val, v); 34 35 if (nr_calls) 36 (*nr_calls)++; /// 更新调用次数 37 38 /// 判断回调函数是否需要停止调用 39 if (ret \u0026amp; NOTIFY_STOP_MASK) 40 break; 41 42 /// 更新当前节点 43 nb = next_nb; 44 nr_to_call--; 45 } 46 return ret; 47} 48NOKPROBE_SYMBOL(notifier_call_chain); ","date":"August 14, 2024","img":"https://kingdix10.github.io/covers/neon_lights_dark_133133_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/notifier_chain/notifier_chain/","series":[{"title":"内核基础","url":"/zh-cn/series/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"}],"smallImg":"","tags":[{"title":"通知链","url":"/zh-cn/tags/%E9%80%9A%E7%9F%A5%E9%93%BE/"}],"timestamp":1723593600,"title":"Linux内核的通知链机制"},{"categories":[{"title":"编译","url":"/zh-cn/categories/%E7%BC%96%E8%AF%91/"}],"content":" 命令行选项 1# -n, --just-print 2# -d, --debug=brief Makefile打印 在rule外，可以使用如下方法\n1# 仅输出信息 2$(info TEXT…) 3 4# 输出文件名、行号和信息 5$(warning TEXT…) 6 7# 输出文件名、行号和信息后停止 8$(error TEXT…) 在rule内，直接使用echo输出，或者去掉@即可。\n1target: 2 @echo $(VAR) ","date":"August 5, 2024","img":"https://kingdix10.github.io/covers/pattern_color_mosaic_131243_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/05-program/compile/make_debug/","series":[{"title":"编译","url":"/zh-cn/series/%E7%BC%96%E8%AF%91/"}],"smallImg":"","tags":[{"title":"编译","url":"/zh-cn/tags/%E7%BC%96%E8%AF%91/"}],"timestamp":1722816000,"title":"make调试"},{"categories":[{"title":"工具","url":"/zh-cn/categories/%E5%B7%A5%E5%85%B7/"}],"content":" 1. 基本原理 文件系统未占用的空间数据写完全0，会被视为空闲空间，可以被虚拟机软件回收。\n操作步骤：\n虚拟机内，空闲空间数据写0。 关闭虚拟机 回收虚拟磁盘文件空间 2. 文件系统和磁盘空闲区间擦除 对于根文件系统，只能使用dd命令创建全零文件模拟擦除。\n1df # 查看剩余空间大小 2dd if=/dev/zero of=zero.bin bs=1MiB count=1024 3sync 4rm -f zero.bin 其他可重新挂载的分区可以使用如下几种方式：\n卸载或将文件系统挂为只读后，使用zerofree回收，注意zerofree只适用于ext2、ext3、ext4文件系统。 使用resize2fs压缩文件文件系统后，缩小磁盘分区，为空出来的磁盘空间建立分区并使用dd清零。 理论上方式2可以回收更多空间。\n2.1. umount: device is busy处理 这是文件系统还在被占用，可以尝试如下几种方式：\n强制结束进程，fuser -kvm /path/to/mountpoint。 强制卸载文件系统，umount -f /path/to/mountpoint。 使用sudo lsof /path/to/mountpoint查看占用进程，手动结束进程。 2.2. 使用zerofree 1# 两种方式选一种 2umount /dev/xxx 3mount -o ro,remount /path/to/mountpoint 4 5# 回收空间， 6zerofree /dev/xxx 7zerofree /path/to/mountpoint 2.3. 使用reseize2fs 详细参考《磁盘和文件系统扩容/缩容》。\n1umount /path/to/mountpoint 2e2fsck -f /dev/xxx 3# 查看文件系统最小占用空间 4resize2fs -P /dev/xxx 5# 压缩文件系统 6resize2fs /dev/xxx xxG 7# 进入parted命令行，调整分区大小，为空出来的空间创建分区 8parted /dev/xxx 9 10# 退出parted命令行，使用dd清零 11dd if=/dev/zero of=/dev/yyy bs=1M 3. 回收虚拟磁盘文件空间 完成上边虚拟机内的操作后，可以关闭虚拟机回收空间。\n3.1. VMware回收空间 关闭虚拟机，进入编辑虚拟机设置，找到对应磁盘，点击压缩后等待完成即可。完成后，切换其他选项再切回对应磁盘，可以看到磁盘空间被回收。\n3.2. Hyper-V回收空间 关闭虚拟机，使用管理员启动powershell，输入diskpart进入磁盘管理。\n针对每个虚拟磁盘文件，进行如下操作：\n1select vdisk file=\u0026#34;D:\\HyperV\\data.vhdx\u0026#34; 2compact vdisk 完成后，通过Hyper-V管理器，打开检查磁盘，选择对应磁盘文件，可以看到磁盘空间被回收。\n","date":"August 5, 2024","img":"https://kingdix10.github.io/covers/gold_background_lines_72322_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/02-dev_env/vdisk_compact/","series":[{"title":"工具","url":"/zh-cn/series/%E5%B7%A5%E5%85%B7/"}],"smallImg":"","tags":[{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"}],"timestamp":1722816000,"title":"VMware和Hyper-V回收虚拟磁盘空间"},{"categories":[{"title":"编译","url":"/zh-cn/categories/%E7%BC%96%E8%AF%91/"}],"content":" 1. gcc 在线文档：https://gcc.gnu.org/onlinedocs\n1.1. 编译选项 1# -Wall 2# -Werror/-Werror= 1.2. 调试选项 1## -save-temps=obj 2 3# -fcallgraph-info 2. objcopy 1objcopy -I binary -O elf32-little --change-section-address .data=0x08000000 input.bin output.elf 3. gdb 1target remote localhost:1234 2 3file /path/to/vmlinux 4 5add-symbol-file /path/to/vmlinux -s .head.text 0x40200000 6add-symbol-file /path/to/vmlinux -s .text 0x40210000 7add-symbol-file /path/to/vmlinux -s .init.text 0x41630000 ","date":"August 5, 2024","img":"https://kingdix10.github.io/covers/metal_plates_lattice_199631_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/05-program/ccpp/gcc_tools/","series":[{"title":"编译","url":"/zh-cn/series/%E7%BC%96%E8%AF%91/"}],"smallImg":"","tags":[{"title":"编译","url":"/zh-cn/tags/%E7%BC%96%E8%AF%91/"}],"timestamp":1722816000,"title":"编译工具杂记"},{"categories":[{"title":"启动流程","url":"/zh-cn/categories/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"content":"rt-thread版本：4.0\n","date":"August 4, 2024","img":"https://kingdix10.github.io/covers/cubes_colorful_bright_128866_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/03-boot/rtthread_smp_cortex_a9/","series":[{"title":"启动流程","url":"/zh-cn/series/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"smallImg":"","tags":[{"title":"启动流程","url":"/zh-cn/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"timestamp":1722729600,"title":"rt-thread Cortex-A9 SMP启动"},{"categories":[{"title":"Windows","url":"/zh-cn/categories/windows/"},{"title":"开发环境","url":"/zh-cn/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"content":" 1. 准备工作 wsl需要安装openssh-server，有可能需要修改/etc/sshd_config中端口号。\n2. wsl运行程序 ssh连接wsl后，需要将Windows中PATH环境变量指定的路径添加到wsl的PATH变量中。格式如下：\n1export PATH=\u0026#34;${PATH}:/mnt/c/Program Files/Microsoft SQL Server/120/Tools/Binn/\u0026#34; 2export PATH=\u0026#34;${PATH}:/mnt/c/Program Files/dotnet/\u0026#34; 3export PATH=\u0026#34;${PATH}:/mnt/c/Programs/Git/cmd\u0026#34; 4export PATH=\u0026#34;${PATH}:/mnt/c/Programs/Graphviz/bin\u0026#34; 5export PATH=\u0026#34;${PATH}:/mnt/c/Programs/Meld/\u0026#34; 6export PATH=\u0026#34;${PATH}:/mnt/c/Programs/Microsoft VS Code/bin\u0026#34; 7export PATH=\u0026#34;${PATH}:/mnt/c/Programs/Python/Python310/\u0026#34; 8export PATH=\u0026#34;${PATH}:/mnt/c/Programs/Python/Python310/Scripts/\u0026#34; 9export PATH=\u0026#34;${PATH}:/mnt/c/Programs/VMware/VMware Player/bin/\u0026#34; 10export PATH=\u0026#34;${PATH}:/mnt/c/Programs/VanDyke Software/Clients/\u0026#34; 11export PATH=\u0026#34;${PATH}:/mnt/c/Programs/swigwin-4.1.1\u0026#34; 12export PATH=\u0026#34;${PATH}:/mnt/c/Users/WDN/.dotnet/tools\u0026#39;\u0026#34; 13export PATH=\u0026#34;${PATH}:/mnt/c/Users/WDN/AppData/Local/Microsoft/WindowsApps\u0026#34; 14export PATH=\u0026#34;${PATH}:/mnt/c/WINDOWS\u0026#34; 15export PATH=\u0026#34;${PATH}:/mnt/c/WINDOWS/System32/OpenSSH/\u0026#34; 16export PATH=\u0026#34;${PATH}:/mnt/c/WINDOWS/System32/Wbem\u0026#34; 17export PATH=\u0026#34;${PATH}:/mnt/c/WINDOWS/System32/WindowsPowerShell/v1.0/\u0026#34; 18export PATH=\u0026#34;${PATH}:/mnt/c/WINDOWS/system32\u0026#34; 19export PATH=\u0026#34;${PATH}:/mnt/c/Windows\u0026#34; 20export PATH=\u0026#34;${PATH}:/mnt/c/Windows/System32/OpenSSH/\u0026#34; 21export PATH=\u0026#34;${PATH}:/mnt/c/Windows/System32/Wbem\u0026#34; 22export PATH=\u0026#34;${PATH}:/mnt/c/Windows/System32/WindowsPowerShell/v1.0/\u0026#34; 23export PATH=\u0026#34;${PATH}:/mnt/c/Windows/system32\u0026#34; 添加环境变量后，可以开始调用Windows程序，如powershell.exe。\n如果上述环境变量有遗漏，可以使用powershell来获取后继续添加。\n3. powershell查看环境变量 在 ‌PowerShell 中，可以通过使用 Get-ChildItem 命令配合环境变量名称来查看环境变量的值。例如，要查看 PATH 环境变量的值，可以执行以下命令：\n1Get-ChildItem -Path env:PATH 2echo ${env:Path} 这将列出 PATH 环境变量中包含的所有路径。类似地，要查看其他环境变量，只需将 PATH 替换为相应的环境变量名称即可。例如，查看 SystemRoot 环境变量：\n1Get-ChildItem -Path env:SystemRoot 此外，如果需要查看所有环境变量的列表，可以使用 env: 驱动器直接列出其下的所有项：\n1Get-ChildItem env:* 这将显示所有环境变量的名称和值。这些命令在 PowerShell 中直接执行，无需额外的设置或配置。‌\n","date":"July 29, 2024","img":"https://kingdix10.github.io/covers/cockpit_panel_display_169481_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/win/ssh_wsl_exe/","series":[{"title":"开发环境","url":"/zh-cn/series/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"smallImg":"","tags":[{"title":"Windows","url":"/zh-cn/tags/windows/"},{"title":"wsl","url":"/zh-cn/tags/wsl/"}],"timestamp":1722211200,"title":"ssh连接wsl后执行Windows程序"},{"categories":[{"title":"系统管理","url":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"}],"content":" 1. 网址 1.1. Debian 官网：https://www.debian.org\n下载链接：\nhttps://www.debian.org/distrib https://www.debian.org/distrib/netinst 如果不使用图形界面，可以下载网络安装ISO。\n1.2. ElementaryOS elementaryOS基于Ubuntu。\nhttps://elementary.io/zh_CN https://elementary.io\n2. Debian安装 仅做一些注意事项的备忘记录和速查，不做详细介绍。\n升级过程会尝试自动更新，国内安装建议断开网络或在安装步骤中不去配置网络，在安装完成后更换apt源之后再手动更新。\n2.1. 磁盘容量划分 包括物理机、虚拟机\n分区时，可以选择Manual模式手动划分分区， 为方便后续恢复，根目录根据划分约20~30G。 swap分区可不划分，安装完成后使用swapfile。 2.1.1. 虚拟磁盘文件 与VMware和VirtualBox基本一致，按步骤执行即可。\n2.2. 安装到U盘 可能与主板有关，安装Debian到U盘时，需创建约100M的EFI分区，之后再创建根文件系统。\n2.3. Hyper-V物理磁盘安装 注意：虚拟机选择第二代，禁用安全启动和检查点。\n优势：\nHyper-V使用独立的物理磁盘后，重启后BIOS可以看到debian启动项，debian可以用物理机启动，也可以用Hyper-V启动 Hyper-V支持虚拟化显卡 可以配置跟随物理机启动，不需要手动启动 不足\nHyper-V不能按分区使用物理磁盘，要使用物理磁盘，必须要离线驱动器 安装步骤：\n在Windows磁盘管理器中将磁盘离线，不能按分区操作，只能按磁盘离线。 使用ISO安装Debian，注意安装完成之后，提示启动顺序是从文件启动，不能删除vmcx文件。 这个efi启动文件应该跟包含在下边这两个文件中的一个里，不能随意删除。\nHyper-V固定IP Hyper-V内的虚拟机在每次Windows重启后，ip地址会自动变化，使用网络上提供的固定IP的方法，遇到debian无法上网问题，可能是debian网络管理配置的问题，暂时用python脚本解决。\n2.4. Hyper-V添加显卡 新建add_vgpu.ps1，使用管理员运行powershell，Set-ExecutionPolicy RemoteSigned后执行脚本。\n1$vm=Read-Host -Prompt \u0026#34;vm name\u0026#34; 2$vmem=Read-Host -Prompt \u0026#34;memory size(G)\u0026#34; 3$vmem=($vmem/1)* 1GB 4 5Add-VMGpuPartitionAdapter -VMName $vm 6Set-VMGpuPartitionAdapter -VMName $vm 7 8Set-VM -GuestControlledCacheTypes $true -VMName $vm 9Set-VM -LowMemoryMappedIoSpace 256MB -VMName $vm 10Set-VM -HighMemoryMappedIoSpace \u0026#34;$vmem\u0026#34; -VMName $vm 3. 获取Debian/Ubuntu版本 1lsb_release -a 2uname -a 3 4cat /etc/debian_version 5cat /etc/os-release 6cat /etc/lsb-release 4. Debian配置 4.1. 中文 使用root或者sudo执行dpkg-reconfigure locales，选择zh_CN.UTF-8。\n4.2. 时区 使用root或者sudo运行。\n工具脚本：timezone.sh\n1apt-get install tzdata 2ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 3dpkg-reconfigure -f noninteractive tzdata 4.3. 修改Debian欢迎信息 1/etc/update-motd.d/ 2/etc/motd 4.4. swap配置 4.4.1. swap分区 需在安装时或使用安装盘进入rescue模式创建，之后修改/etc/fstab。\n4.4.2. swapfile 1# 创建swap分区的文件 2# 其中bs是每块的大小，count是块的数量；bs*count，就是swap文件的大小：这里1M*1024=1G 3dd if=/dev/zero of=/var/swapfile bs=1M count=1024 4# 格式化交换分区文件 5mkswap /var/swapfile 6# 启用swap分区文件 7swapon /var/swapfile 8 9# 添加开机自动生效，此项不是必须的。如果不修改开机启动配置，重启之后的swap空间会重置，之前配置丢失。 10# vi /etc/fstab这个文件，添加或者修改这一行，注意最后两个是零，不是大写字母O。 11/var/swapfile swap swap defaults 0 0 12 13# 查看swap分区文件 14swapon -s 15# 查看swap分区 16free -h 4.5. SSH Server配置 4.5.1. SSH免密登录 4.6. 修改启动参数 配置文件：/etc/default/grub。\n1GRUB_DEFAULT=0 2GRUB_TIMEOUT_STYLE=hidden 3GRUB_TIMEOUT=5 # modify this line 4GRUB_DISTRIBUTOR=`lsb_release -i -s 2\u0026gt; /dev/null || echo Debian` 5GRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;quiet splash\u0026#34; # modify this line 6GRUB_CMDLINE_LINUX=\u0026#34;\u0026#34; 完成后需要使用update-grub写入修改\n1sudo update-grub 5. 图形界面 5.1. 命令行或图形界面切换 需要用root或者sudo运行。\n1# 查看当前的默认目标 2systemctl get-default 3 4# 设置为多用户文本模式（命令行）启动 5systemctl set-default multi-user.target 6 7# 设置为图形界面（GUI）模式启动 8systemctl set-default graphical.target 9 10# 立即进入图形界面模式，两种方式任选其一 11systemctl isolate graphical.target 12init 5 13 14# 立即进入多用户文本（命令行）格式，两种方式任选其一 15systemctl isolate multi-user.target 16init 3 5.2. gnome安装及配置 工具脚本：install_gnome.sh\n参考\nhttps://wiki.debian.org/zh_CN/DesktopEnvironment https://wiki.debian.org/zh_CN/Gnome 1set -e 2 3apt-get install -y gnome-core 4apt-get install -y --dry-run gnome 5# apt-get install -y --dry-run task-gnome-desktop 6 7# run gnome-extensions-app in terminal or search in apps 8apt-get install -y gnome-shell-extension-dashtodock 9 10# run gnome-tweaks in terminal or search in apps 11apt-get install -y gnome-tweaks 安装完成后，会有一些可能不需要的软件，可以卸载。\n1apt autopurge -y gnome-games 2apt autopurge -y firefox-esr 3 4apt autoremove -y 6. Linux工具/命令 原命令 替换 du ncdu,dfu top htop cd pushd 6.1. python3 venv 直接执行python3会提示需要创建venv。\n1python3 -m venv /data/.venvs/eel/ 2export PATH=\u0026#34;/data/.venvs/eel/bin/:${PATH}\u0026#34; 3python3 -m pip install pygraphviz 7. 其他软件 7.1. google chrome 参考https://blog.csdn.net/howard2005/article/details/124906494\n1wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 2dpkg -i temp/google-chrome-stable_current_amd64.deb 3 4Selecting previously unselected package google-chrome-stable. 5(Reading database ... 340010 files and directories currently installed.) 6Preparing to unpack .../google-chrome-stable_current_amd64.deb ... 7Unpacking google-chrome-stable (123.0.6312.105-1) ... 8dpkg: dependency problems prevent configuration of google-chrome-stable: 9 google-chrome-stable depends on libvulkan1; however: 10 Package libvulkan1 is not installed. 11 12dpkg: error processing package google-chrome-stable (--install): 13 dependency problems - leaving unconfigured 14Processing triggers for gnome-menus (3.13.3-11ubuntu1.1) ... 15Processing triggers for desktop-file-utils (0.23-1ubuntu3.18.04.2) ... 16Processing triggers for mime-support (3.60ubuntu1) ... 17Processing triggers for man-db (2.8.3-2ubuntu0.1) ... 18Errors were encountered while processing: 19 google-chrome-stable 7.2. AX210无线网卡驱动(基于Debian 11) 1/lib/firmware/ 2 3apt install firmware-linux 4 5apt install firmware-iwlwifi 英特尔®无线适配器的 Linux* 支持 (intel.cn)\nHow to Configure Bluetooth On Debian (linuxhint.com)\n尝鲜一波？Pop!_OS安装Wi-Fi 6E无线网卡intel AX210NGW_网卡_什么值得买 (smzdm.com)\njouranlctl -xe看到udev会重复受到蓝牙插入和拔出事件，导致设置中，蓝牙相关的开关一直跳变。 卸载btusb和btintel驱动 重命名btintel.ko和btusb.ko 将btintel和btusb加入到自启动黑名单 vi /etc/modprobe.d/blacklist.conf。 1blacklist btusb 2blacklist btintel ","date":"July 28, 2024","img":"https://kingdix10.github.io/covers/paint_canvas_stains_124156_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/linux/debian_setup/","series":[{"title":"系统管理","url":"/zh-cn/series/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"系统管理","url":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"}],"timestamp":1722124800,"title":"Debian安装和配置"},{"categories":[{"title":"系统管理","url":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"},{"title":"开发环境","url":"/zh-cn/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"content":" 1. Docker安装 参考docker-ce | 镜像站使用帮助 | 清华大学开源软件镜像站，可以使用https://gitee.com/kingdix10/envsetup下的工具脚本。\nscript function debian_install_docker.sh 安装docker，使用tsinghua apt源 docker_conf_mirrors.sh 修改docker镜像源 1.1. 添加用户到docker组 安装docker需要添加用户到docker组，否则需要以root运行。\n1adduser $username sudo 2adduser $username docker 2. Docker换源 国内源已经不能用了。\n1systemctl stop docker.service 2 3cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/docker/daemon.json 4{ 5 \u0026#34;registry-mirrors\u0026#34;: [ 6 \u0026#34;http://hub-mirror.c.163.com\u0026#34;, 7 \u0026#34;https://registry.docker-cn.com\u0026#34;, 8 \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34; 9 ] 10} 11EOF 12systemctl daemon-reload 13systemctl restart docker 3. 修改docker默认存储路径 docker镜像的默认存储路径是/var/lib/docker，这相当于直接挂载系统目录下，而一般在搭系统时，这个区都不会太大，所以如果长期使用docker开发应用，就需要把默认的路径更改到需要路径下或外挂存储\n首先使用systemctl stop docker.service停止docker服务，完成下面任一操作后，执行systemctl daemon-reload; systemctl restart docker。\n查看docker的默认存储路径。\n1dokcer info Docker Root Dir: /data/docker\n3.1. mount bind【推荐】 挂载一个新目录到这个路径。\n1$ mkdir -p /data/docker 2$ mount -o bind /data/docker /var/lib/docker 如果要开机自动挂载，需要将其写到/etc/fstab中。\n1$ echo \u0026#34;/data/docker /var/lib/docker none bind 0 0\u0026#34; \u0026gt;\u0026gt; /etc/fstab 相比于软链接的方式，使用mount bind不会删除原/var/lib/docker下的文件，只需要umount即可看到原/var/lib/docker下的文件。\n相比于改docker.service文件的方式，mount bind不会随着docker升级而失效。\n3.2. 软链接 删除默认路径，并创建软链接。\n1$ rm -rf /var/lib/docker 2$ ln -s /data/docker /var/lib/docker 3.3. 修改docker.service文件 可能的文件路径如下：\n1/usr/lib/systemd/system/docker.service 2/lib/systemd/system/docker.service 搜索containerd/containerd.sock，将其改为containerd/containerd.sock --graph=${img_path}。\n4. Docker内开启SSH server 方便VS Code远程连接，启动docker时需映射端口。\ndocker run时，-p参数指定端口，如-p :10022:22，或-p :20000-20010:20000-20010。端口映射范围不宜多大，否则会占用较大内存。\ndocker内.bashrc添加\n1/etc/init.d/ssh status || sudo /etc/init.d/ssh restart 5. build镜像、启动docker容器 1docker pull debian:stable-20230612 2 3cd mydebian 4docker build -t mydebian:\u0026lt;tag\u0026gt; ./ 5 6 7# docker run -i --privileged --name=temp -h EEL -p 9022:22 -v /dev/shm:/dev/shm -v /storage/data:/data -t mydebian:\u0026lt;tag\u0026gt; 8docker run -d --privileged --name=new -h EEL -p 0.0.0.0:56092:22 -p 0.0.0.0:26000-26010:26000-26010 -v /dev/shm:/dev/shm -v /storage/data:/data -t mydebian:20230814 9 10docker run -d --privileged --name=new -h EEL -p :56092:22 -p :26000-26010:26000-26010 -v /dev/shm:/dev/shm -v /storage/data:/data -t mydebian:20230814 11 12 13docker run -i --privileged --name=temp -h EEL -v /storage/data:/data -t mydebian:\u0026lt;tag\u0026gt; 14 15docker exec -it temp bash 16 17# do something in docker 18 19docker commit temp eel:\u0026lt;tag\u0026gt; 20docker tag eel:tag eel[:latest] 21 22docker stop temp 23docker rm -f temp 24 25 26docker volume ls 27docker run -d --privileged --restart always --name=dev -h EEL -p :56092:22 -p :26000-26010:26000-26010 -v /dev/shm:/dev/shm -v f78e0fd6f219a74d7156dc0f8df8463b94bbce4f6cb5b622853daf29dea4f192:/home/dix -v /storage/data:/data -t eel 28 29# interactive 30docker run -i --privileged --restart=always --name=eel -h EEL -p 9022:22 -v /storage/data:/data -t eel:[tag] 31# deamon 32docker run -d --privileged --restart=always --name=eel -h EEL -p 9022:22 -v /storage/data:/data -t eel:[tag] 6. docker使用 1# 登陆运行中的docker 2docker exec -it temp bash 3 4# 查看信息 5docker info 6docker images 7docker ps [-as] 8docker system df 9 10# 删除容器 11docker rm [-f] \u0026lt;container\u0026gt; 12# 删除所有容器 13docker rm $(docker ps -aq) 14# 按条件筛选之后删除容器 15docker rm $(docker ps -a | grep xxxxx | awk \u0026#39;{print $1}\u0026#39;) 16 17# 删除镜像 18docker rmi [-f] \u0026lt;image\u0026gt; 19# 删除所有镜像 20docker rmi [-f] $(docker images -q) 21# 按条件筛选之后删除镜像 22docker rmi $(docker images | grep xxxxx | awk \u0026#39;{print $3}\u0026#39;) ","date":"July 28, 2024","img":"https://kingdix10.github.io/covers/code_text_colorful_140555_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/linux/docker_setup/","series":[{"title":"系统管理","url":"/zh-cn/series/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"系统管理","url":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"},{"title":"开发环境","url":"/zh-cn/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"timestamp":1722124800,"title":"Docker安装和配置"},{"categories":[{"title":"linux命令","url":"/zh-cn/categories/linux%E5%91%BD%E4%BB%A4/"},{"title":"文本工具","url":"/zh-cn/categories/%E6%96%87%E6%9C%AC%E5%B7%A5%E5%85%B7/"}],"content":" 1. grep 1.1. 常用选项 1# 输出start到end 2grep -o \u0026#39;start.*end\u0026#39; file 3# 文件作为文本处理 4grep -a \u0026#39;xxx\u0026#39; file 5# 忽略二进制文件 6grep -rsnI \u0026#39;xxx\u0026#39; ./ 7# 递归目录 8grep -r \u0026#39;xxx\u0026#39; ./ 9 10# 忽略大小写(-i, --ignore-case) 11# 全词匹配(-w, --word-regexp) 12# 输出计数(-c, --count) 13# 显示行号(-n, --line-number) 14# 只列出匹配的文件名(-l, --files-with-matches) 1.2. 其他选项 1# --color：显示颜色，默认开启 2. sed示例 1# 在第5行前插入新行 2sed -i \u0026#39;5i\\string\u0026#39; file 3 4# 全词匹配替换 5sed -e \u0026#39;s%\\\u0026lt;old\\\u0026gt;%new%g\u0026#39; file 6# 忽略大小写匹配替换 7sed -e \u0026#39;s%\\\u0026lt;old\\\u0026gt;%new%ig\u0026#39; file 8 9# 输出图片链接，输出完整 \u0026#34;![...](...)\u0026#34; 10sed -n \u0026#39;/!\\[.*\\]\\(.*\\)/p\u0026#39; *.md 11sed -n \u0026#39;s/!\\[.*\\]\\(.*\\)/\\0/p\u0026#39; *.md 12 13# 输出图片链接，只输出 \u0026#34;(...)\u0026#34; 14sed -n \u0026#39;s/!\\[.*\\]\\(.*\\)/\\1/p\u0026#39; *.md 1sed -i \\ 2 -e \u0026#39;/^description:/a\\featured: false\u0026#39; \\ 3 -e \u0026#39;/^image:.*/d\u0026#39; \\ 4 -e \u0026#39;/^hidden:/a\\image:\\nfigurePositionShow:\\nfeatureImage:\\nfeatureImageAlt:\\nfeatureImageCap:\\nthumbnail:\\nshareImage:\\ncodeMaxLines:\\ncodeLineNumbers:\\n\u0026#39; \\ 5 -e \u0026#39;/^tags:$/i\\series:\u0026#39; \\ 6 $* 3. awk 4. patch 1patch -t -p 1 \u0026lt; patchfile.patch 5. hexdump 5.1. 按4字节显示 1hexdump -e \u0026#39;\\\u0026#34;0x%08_ax: \\\u0026#34;\u0026#39; -e \u0026#39;4/4 \\\u0026#34;%08X \\\u0026#34;\u0026#39; -e \u0026#39;\\\u0026#34;\\n\\\u0026#34;\u0026#39; 1alias xdump=\u0026#39;hexdump -e \u0026#39;\\\u0026#39;\u0026#39;\u0026#34;0x%08_ax: \u0026#34;\u0026#39;\\\u0026#39;\u0026#39; -e \u0026#39;\\\u0026#39;\u0026#39;4/4 \u0026#34;%08X \u0026#34;\u0026#39;\\\u0026#39;\u0026#39; -e \u0026#39;\\\u0026#39;\u0026#39;\u0026#34;\\n\u0026#34;\u0026#39;\\\u0026#39;\u0026#39;\u0026#39; ","date":"July 28, 2024","img":"https://kingdix10.github.io/covers/lines_intersection_oblique_153331_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/linux/shell/cmd_text/","series":[{"title":"linux命令","url":"/zh-cn/series/linux%E5%91%BD%E4%BB%A4/"}],"smallImg":"","tags":[{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"},{"title":"linux命令","url":"/zh-cn/tags/linux%E5%91%BD%E4%BB%A4/"}],"timestamp":1722124800,"title":"linux常用命令-文本处理"},{"categories":[{"title":"linux命令","url":"/zh-cn/categories/linux%E5%91%BD%E4%BB%A4/"}],"content":" iozone 1#!/bin/bash 2 3dd_test_file_one() 4{ 5\tcnt=$1 6\tbs_uint=$2 7\toutdir=$3 8 9\tdd if=/dev/urandom of=${outdir}/test_${cnt}${bs_uint}.bin \\ 10\tbs=1${bs_uint} count=${cnt} 11} 12 13dd_test_file() 14{ 15\toutdir=$1 16 17\tmkdir -p ${outdir} 18 19\tdd_test_file_one 1 k ${outdir} 20\tdd_test_file_one 4 k ${outdir} 21\tdd_test_file_one 64 k ${outdir} 22\tdd_test_file_one 512 k ${outdir} 23\tdd_test_file_one 1 M ${outdir} 24\tdd_test_file_one 4 M ${outdir} 25\tdd_test_file_one 64 M ${outdir} 26\tdd_test_file_one 128 M ${outdir} 27\tdd_test_file_one 512 M ${outdir} 28} 29 30__iozone_test_one_erofs() 31{ 32\tcnt=$1 33\tbs_uint=$2 34\toutdir=$3 35 36\tblk_sz=$4 37 38\techo 3 \u0026gt; /proc/sys/vm/drop_caches 39 40\tiozone -i 1 \\ 41\t-+E \\ 42\t-r ${blk_sz} \\ 43\t-s ${cnt}${bs_uint} -f ${outdir}/test_${cnt}${bs_uint}.bin \\ 44\t-Rb ./erofs_test_${cnt}${bs_uint}-${blk_sz}.xls 45} 46 47iozone_test_one_erofs() 48{ 49\tcnt=$1 50\tbs_uint=$2 51\toutdir=$3 52\tfor sz in 1k 2k 4k 8k 16k 32k 64k 128k; do 53\t__iozone_test_one_erofs ${cnt} ${bs_uint} ${outdir} ${sz} 54\tdone 55} 56 57__iozone_test_one_rw() 58{ 59\tcnt=$1 60\tbs_uint=$2 61\toutdir=$3 62 63\tblk_sz=$4 64\tfstype=$5 65 66\tif [[ ! -e ${outdir}/test_${cnt}${bs_uint}.bin ]]; then 67\tdd_test_file_one ${cnt} ${bs_uint} ${outdir} 68\tfi 69\tsync 70 71\techo 3 \u0026gt; /proc/sys/vm/drop_caches 72 73\tiozone -i 0 -i 1 \\ 74\t-r ${blk_sz} \\ 75\t-s ${cnt}${bs_uint} -f ${outdir}/test_${cnt}${bs_uint}.bin \\ 76\t-Rb ./${fstype}_test_${cnt}${bs_uint}-${blk_sz}.xls 77 78\tif [[ ! -e ${outdir}/test_${cnt}${bs_uint}.bin ]]; then 79\tdd_test_file_one ${cnt} ${bs_uint} ${outdir} 80\tfi 81\tsync 82\techo 3 \u0026gt; /proc/sys/vm/drop_caches 83 84\tiozone -i 0 -i 2 \\ 85\t-r ${blk_sz} \\ 86\t-s ${cnt}${bs_uint} -f ${outdir}/test_${cnt}${bs_uint}.bin \\ 87\t-Rb ./${fstype}_test_${cnt}${bs_uint}-${blk_sz}-2.xls 88} 89 90 91iozone_test_one_rw() 92{ 93\tcnt=$1 94\tbs_uint=$2 95\toutdir=$3 96 97\tfstype=$4 98 99\tfor sz in 1k 2k 4k 8k 16k 32k 64k 128k; do 100\t__iozone_test_one_rw ${cnt} ${bs_uint} ${outdir} ${sz} ${fstype} 101\tdone 102 103# iozone -a -i 0 -i 1 -i 2 \\ 104# -y 1k -q 128k \\ 105# -s ${cnt}${bs_uint} -f ${outdir}/test_${cnt}${bs_uint}.bin \\ 106# -Rb ./${fstype}_test_${cnt}${bs_uint}.xls 107 108} 109 110 111iozone_test_erofs() 112{ 113\toutdir=$1 114 115\tmkdir -p ${outdir} 116 117\tiozone_test_one_erofs 1 k ${outdir} 118\tiozone_test_one_erofs 4 k ${outdir} 119\tiozone_test_one_erofs 64 k ${outdir} 120\tiozone_test_one_erofs 512 k ${outdir} 121\tiozone_test_one_erofs 1 M ${outdir} 122\tiozone_test_one_erofs 4 M ${outdir} 123\tiozone_test_one_erofs 64 M ${outdir} 124\tiozone_test_one_erofs 128 M ${outdir} 125\tiozone_test_one_erofs 512 M ${outdir} 126} 127 128iozone_test_rw() 129{ 130\toutdir=$1 131\tfstype=$2 132 133\tmkdir -p ${outdir} 134 135\tiozone_test_one_rw 1 k ${outdir} ${fstype} 136\tiozone_test_one_rw 4 k ${outdir} ${fstype} 137\tiozone_test_one_rw 64 k ${outdir} ${fstype} 138\tiozone_test_one_rw 512 k ${outdir} ${fstype} 139\tiozone_test_one_rw 1 M ${outdir} ${fstype} 140\tiozone_test_one_rw 4 M ${outdir} ${fstype} 141\tiozone_test_one_rw 64 M ${outdir} ${fstype} 142\tiozone_test_one_rw 128 M ${outdir} ${fstype} 143\tiozone_test_one_rw 512 M ${outdir} ${fstype} 144} 145 146# dd_test_file /export/temp/test_fs 147 148iozone_test_erofs /mnt/erofs 149 150iozone_test_rw /mnt/ext4 ext4 151iozone_test_rw /mnt/f2fs f2fs ","date":"July 28, 2024","img":"https://kingdix10.github.io/covers/paint_wall_shabby_135205_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/linux/shell/cmd_benchmark/","series":[{"title":"linux命令","url":"/zh-cn/series/linux%E5%91%BD%E4%BB%A4/"}],"smallImg":"","tags":[{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"},{"title":"linux命令","url":"/zh-cn/tags/linux%E5%91%BD%E4%BB%A4/"}],"timestamp":1722124800,"title":"linux常用命令-性能"},{"categories":[{"title":"linux命令","url":"/zh-cn/categories/linux%E5%91%BD%E4%BB%A4/"}],"content":"官方资料：Git Community Book 中文版\n1. 个人gitconfig 1# cat ~/.gitconfig 2 3[color] 4\tui = auto 5 6[safe] 7#\tdirectory = * 8 9[core] 10# 支持中文 11\tquotepath = false 12\teditor = vim 13# 14\tpager = less -x1,5 15# 支持https下保存用户名密码 16[credential] 17\thelper = store 参考git 显示中文和解决中文乱码\n1git config --global core.quotepath false 3. 使用git grep快速搜索 1git grep -Inw xxx 2git grep -Inw -p xxx 3git grep -Inw --heading xxx 5. 取消git clone \u0026ndash;depth=1 1git pull --unshadow 4. git统计每个人的代码量 1git log --format=\u0026#39;%aN\u0026#39; | sort -u \\ 2\t| while read name; do \\ 3\techo -en \u0026#34;${name}\\t\u0026#34;; \\ 4\tgit log --author=\u0026#34;${name}\u0026#34; --pretty=tformat: --numstat \\ 5\t| awk \u0026#39;{add += $1; subs += $2; loc += $1 - $2 } END {printf \u0026#34;add lines: %s, total lines: %s\\n\u0026#34;, add, subs, loc }\u0026#39; -; \\ 6\tdone 6. 解决warning: refname \u0026lsquo;private\u0026rsquo; is ambiguous 6.1. 现象 1$ git checkout private 2warning: refname \u0026#39;private\u0026#39; is ambiguous. 3Switched to branch \u0026#39;private\u0026#39; 4Your branch is up to date with \u0026#39;private/private\u0026#39;. 5 6$ git branch -a 7 main 8* private 9 remotes/origin/main 10 remotes/private/HEAD -\u0026gt; private/private 11 remotes/private/private 6.2. 解决方法 1$ find .git -name HEAD 2.git/logs/refs/remotes/private/HEAD 3.git/logs/HEAD 4.git/refs/remotes/private/HEAD 5.git/HEAD 6 7find .git -name HEAD | grep -w private | xargs rm -f 6.3. 处理后的现象 1$ git checkout private 2Switched to branch \u0026#39;private\u0026#39; 3Your branch is up to date with \u0026#39;private/private\u0026#39;. 7. 合并git仓库并保留commit记录 参考【Git教程】如何清除git仓库的所有提交记录，成为一个新的干净仓库\n从网上查到的使用git merge的方式不能满足需求。就改成了将一个仓库的历史记录生成patch，再在另一个仓库中使用git am应用patch来实现合并仓库。\n仓库目录结构如下，需要将repoBBB中的提交记录合并到repoAAA中，之后就可以删除repoBBB了。\n1. 2├── patch 3├── repoAAA 4└── repoBBB 7.1. 没有同名文件 两个参考下没有同名文件（包括.gitignore等以.开头的文件），或同名文件已经移动或重命名，并commit。\n需要注意，repoAAA中不能存在任何repoBBB历史中曾出现过的文件，否则会导致patch应用失败。\n1rm -f patch/* 2cd repoAAA 3# 把$BRANCH分支所有commit都生成patch 4git format-patch --root -o ../patch $BRANCH 5 6 7cd repoBBB 8# 防止之前有未完成的操作 9git am --abort 10# 应用所有patch 11git am ../patch/* 12git push 7.2. 存在同名文件 需要首先将同名文件用新仓库中的文件覆盖。\n需要注意，repoAAA中不能存在任何repoBBB历史中曾出现过的文件，否则会导致patch应用失败。\n1rm -f patch/* 2cd repoAAA 3 4first_commit=$(git rev-list --max-parents=0 HEAD) 5# first_commit=$(git log --reverse | head -1 | cut -d \u0026#39; \u0026#39; -f 2) 6 7# 除第一次提交之外，其他的commit都生成patch 8git format-patch -o ../patch ${first_commit} 9# 回退到第一次commit时的状态，为了后续覆盖repoBBB中的同名文件使用 10git reset --hard ${first_commit} 11 12 13cd repoBBB 14cp -fr ../repoAAA/* ./ 15# 使用repoBBB中的文件覆盖当前目录的同名文件 16cp -fr ../repoAAA/.* ./ 17git add . 18# 这次commit是为了保证repoAAA中的文件与repoBBB的${first_commit}一致，以便后续应用patch 19git commit -m \u0026#34;message\u0026#34; 20 21git am --abort 22git am ../patch/* 23git push ","date":"July 27, 2024","img":"https://kingdix10.github.io/covers/wall_brick_purple_141823_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/linux/git/git_misc/","series":[{"title":"linux命令","url":"/zh-cn/series/linux%E5%91%BD%E4%BB%A4/"}],"smallImg":"","tags":[{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"},{"title":"git","url":"/zh-cn/tags/git/"}],"timestamp":1722038400,"title":"git配置和操作"},{"categories":[{"title":"中断管理","url":"/zh-cn/categories/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"content":" 1. IRQ domain注册 中断控制器初始化的过程中，要向中断子系统注册irq domain。核心函数__irq_domain_add。\ngic-v2使用irq_domain_create_linear，gic-v3则使用irq_domain_add_tree。\n__irq_domain_add的实现在kernel/irq/irqdomain.c，逻辑并不复杂，主要就是申请struct irq_domain结构体和对各个成员进行赋值，细节可以自己分析。\n1/// kernel/irq/irqdomain.c 2/** 3 * __irq_domain_add() - Allocate a new irq_domain data structure 4 * @fwnode: firmware node for the interrupt controller 5 * @size: Size of linear map; 0 for radix mapping only 6 * @hwirq_max: Maximum number of interrupts supported by controller 7 * @direct_max: Maximum value of direct maps; Use ~0 for no limit; 0 for no 8 * direct mapping 9 * @ops: domain callbacks 10 * @host_data: Controller private data pointer 11 * 12 * Allocates and initializes an irq_domain structure. 13 * Returns pointer to IRQ domain, or NULL on failure. 14 */ 15struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, unsigned int size, 16 irq_hw_number_t hwirq_max, int direct_max, 17 const struct irq_domain_ops *ops, 18 void *host_data) 19{ 20 struct irq_domain *domain; 21 22 domain = __irq_domain_create(fwnode, size, hwirq_max, direct_max, 23 ops, host_data); 24 if (domain) 25 /// 将domain添加到irq_domain_list链表 26 __irq_domain_publish(domain); 27 28 return domain; 29} 30EXPORT_SYMBOL_GPL(__irq_domain_add); 2. irq_domain_ops的调用关系 注册irq domain后，就可以调用irq_domain_ops的回调函数，各个成员的调用关系如下：\n注意有些回调只会在使能CONFIG_IRQ_DOMAIN_HIERARCHY时才会调用，如irq_domain_check_hierarchy。\n在__irq_domain_add的最后，会调用irq_domain_check_hierarchy，\n1/// kernel/irq/irqdomain.c 2static void irq_domain_check_hierarchy(struct irq_domain *domain) 3{ 4 /* Hierarchy irq_domains must implement callback alloc() */ 5 if (domain-\u0026gt;ops-\u0026gt;alloc) 6 domain-\u0026gt;flags |= IRQ_DOMAIN_FLAG_HIERARCHY; 7} ","date":"July 16, 2024","img":"https://kingdix10.github.io/covers/travel_map_compass_123078_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/interrupt/irq_domain_add/","series":[{"title":"中断管理","url":"/zh-cn/series/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1721088000,"title":"Linux中断子系统（二）domain注册"},{"categories":[{"title":"中断管理","url":"/zh-cn/categories/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"content":" 1. 设备中断注册 gic-v3的中断号划分在《IHI0069H_gic_architecture_specification.pdf》有所罗列：\n前边介绍，在gic初始化时，已经使用了0-7号SGI来作为IPI。\n对于设备中断，使用的是PPI和SPI。设备probe时调用irq_of_parse_and_map等函数，如timer_of_irq_init。会调用函数来向系统注册中断，常用函数有如下几个：\n1/// include/linux/of_irq.h 2extern int of_irq_get(struct device_node *dev, int index); 3extern int of_irq_get_byname(struct device_node *dev, const char *name); 4/// ... ... 5/* 6 * irq_of_parse_and_map() is used by all OF enabled platforms; but SPARC 7 * implements it differently. However, the prototype is the same for all, 8 * so declare it here regardless of the CONFIG_OF_IRQ setting. 9 */ 10extern unsigned int irq_of_parse_and_map(struct device_node *node, int index); 中断注册函数的调用关系如下： 2. irq_create_fwspec_mapping分析 注册主要查找活建立hwirq和struct irq_desc的映射关系，这个映射记录到struct irq_domain中。\n主要流程是找到设备在所属的domain中使用的hwirq，然后irq_find_mapping根据domain和hwirq查找struct irq_desc，如果查找成功，将struct irq_desc转为virq，irq_create_fwspec_mapping完成工作。\n如果irq_find_mapping查找失败，则调用irq_create_mapping_affinity_locked分配struct irq_desc（非线性映射），创建映射。\n1/// kernel/irq/irqdomain.c 2unsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec) 3{ 4 /// ... ... 5 /// 通过fwspec找到设备在所属domain中的hwirq 6 if (irq_domain_translate(domain, fwspec, \u0026amp;hwirq, \u0026amp;type)) 7 return 0; 8 9 /* 10 * WARN if the irqchip returns a type with bits 11 * outside the sense mask set and clear these bits. 12 */ 13 if (WARN_ON(type \u0026amp; ~IRQ_TYPE_SENSE_MASK)) 14 type \u0026amp;= IRQ_TYPE_SENSE_MASK; 15 16 mutex_lock(\u0026amp;domain-\u0026gt;root-\u0026gt;mutex); 17 18 /* 19 * If we\u0026#39;ve already configured this interrupt, 20 * don\u0026#39;t do it again, or hell will break loose. 21 */ 22 virq = irq_find_mapping(domain, hwirq); 23 if (virq) { 24 /// 已经存在映射关系，进行一些检查后直接使用goto out返回 25 } 26 27 if (irq_domain_is_hierarchy(domain)) { 28 /// 级联中断，暂不分析 29 virq = irq_domain_alloc_irqs_locked(domain, -1, 1, NUMA_NO_NODE, 30 fwspec, false, NULL); 31 if (virq \u0026lt;= 0) { 32 virq = 0; 33 goto out; 34 } 35 } else { 36 /* Create mapping */ 37 virq = irq_create_mapping_affinity_locked(domain, hwirq, NULL); 38 if (!virq) 39 goto out; 40 } 41 42 irq_data = irq_get_irq_data(virq); 43 if (WARN_ON(!irq_data)) { 44 virq = 0; 45 goto out; 46 } 47 48 /* Store trigger type */ 49 irqd_set_trigger_type(irq_data, type); 50out: 51 mutex_unlock(\u0026amp;domain-\u0026gt;root-\u0026gt;mutex); 52 53 return virq; 54} 55EXPORT_SYMBOL_GPL(irq_create_fwspec_mapping); 2.1. 查找映射 查找映射关系由irq_find_mapping实现，其内部调用__irq_resolve_mapping。\n1/// include/linux/irqdomain.h 2/** 3 * irq_find_mapping() - Find a linux irq from a hw irq number. 4 * @domain: domain owning this hardware interrupt 5 * @hwirq: hardware irq number in that domain space 6 */ 7static inline unsigned int irq_find_mapping(struct irq_domain *domain, 8 irq_hw_number_t hwirq) 9{ 10 unsigned int irq; 11 12 if (__irq_resolve_mapping(domain, hwirq, \u0026amp;irq)) 13 return irq; 14 15 return 0; 16} __irq_resolve_mapping分析如下\n1/// kernel/irq/irqdomain.c 2/** 3 * __irq_resolve_mapping() - Find a linux irq from a hw irq number. 4 * @domain: domain owning this hardware interrupt 5 * @hwirq: hardware irq number in that domain space 6 * @irq: optional pointer to return the Linux irq if required 7 * 8 * Returns the interrupt descriptor. 9 */ 10struct irq_desc *__irq_resolve_mapping(struct irq_domain *domain, 11 irq_hw_number_t hwirq, 12 unsigned int *irq) 13{ 14 struct irq_desc *desc = NULL; 15 struct irq_data *data; 16 17 /* Look for default domain if necessary */ 18 if (domain == NULL) 19 domain = irq_default_domain; /// irq_default_domain默认为NULL 20 if (domain == NULL) 21 return desc; 22 23 if (irq_domain_is_nomap(domain)) { 24 /// ... ... 25 return desc; 26 } 27 28 rcu_read_lock(); 29 /* Check if the hwirq is in the linear revmap. */ 30 if (hwirq \u0026lt; domain-\u0026gt;revmap_size) /// 线性映射 31 data = rcu_dereference(domain-\u0026gt;revmap[hwirq]); 32 else 33 /// 非线性映射 34 data = radix_tree_lookup(\u0026amp;domain-\u0026gt;revmap_tree, hwirq); 35 36 /// 中断已经映射过，无需重新映射 37 if (likely(data)) { 38 desc = irq_data_to_desc(data); 39 if (irq) 40 *irq = data-\u0026gt;irq; 41 } 42 43 rcu_read_unlock(); 44 return desc; 45} 46EXPORT_SYMBOL_GPL(__irq_resolve_mapping); struct irq_desc内嵌了struct irq_data，通过irq_data_to_desc即可获取struct irq_desc。\n1/// include/linux/irqdesc.h 2struct irq_desc { 3 struct irq_common_data\tirq_common_data; 4 struct irq_data\tirq_data; 5 /// ... ... 6} ____cacheline_internodealigned_in_smp; 2.2. 创建映射 irq_create_mapping_affinity_locked的流程并不复杂，参考上边流程图对比代码分析即可。\n注意struct maple_tree sparse_irqs不论是线性映射还是非线性映射都会声明，线性映射和非线性映射在申请中断时，都会调用irq_insert_desc将struct irq_desc插入到sparse_irqs中。\n2.2.1. irq_create_mapping_affinity_locked irq_domain_alloc_descs函数用于分配中断号，最后会调到alloc_descs，这个函数依据线性映射或者非线性映射由不同的实现。\n1/// kernel/irq/irqdomain.c 2static unsigned int irq_create_mapping_affinity_locked(struct irq_domain *domain, 3 irq_hw_number_t hwirq, 4 const struct irq_affinity_desc *affinity) 5{ 6 struct device_node *of_node = irq_domain_get_of_node(domain); 7 int virq; 8 9 pr_debug(\u0026#34;irq_create_mapping(0x%p, 0x%lx)\\n\u0026#34;, domain, hwirq); 10 11 /* Allocate a virtual interrupt number */ 12 virq = irq_domain_alloc_descs(-1, 1, hwirq, of_node_to_nid(of_node), 13 affinity); 14 if (virq \u0026lt;= 0) { 15 pr_debug(\u0026#34;-\u0026gt; virq allocation failed\\n\u0026#34;); 16 return 0; 17 } 18 19 if (irq_domain_associate_locked(domain, virq, hwirq)) { 20 irq_free_desc(virq); 21 return 0; 22 } 23 24 pr_debug(\u0026#34;irq %lu on domain %s mapped to virtual irq %u\\n\u0026#34;, 25 hwirq, of_node_full_name(of_node), virq); 26 27 return virq; 28} 2.2.2. irq_domain_associate_locked irq_domain_associate_locked通过irq_get_irq_data从virq获取struct irq_data\n1/// kernel/irq/irqdomain.c 2static int irq_domain_associate_locked(struct irq_domain *domain, unsigned int virq, 3 irq_hw_number_t hwirq) 4{ 5 struct irq_data *irq_data = irq_get_irq_data(virq); 6 int ret; 7 8 /// ... ... 9 10 irq_data-\u0026gt;hwirq = hwirq; 11 irq_data-\u0026gt;domain = domain; 12 if (domain-\u0026gt;ops-\u0026gt;map) { 13 ret = domain-\u0026gt;ops-\u0026gt;map(domain, virq, hwirq); 14 if (ret != 0) { 15 /* 16 * If map() returns -EPERM, this interrupt is protected 17 * by the firmware or some other service and shall not 18 * be mapped. Don\u0026#39;t bother telling the user about it. 19 */ 20 if (ret != -EPERM) { 21 pr_info(\u0026#34;%s didn\u0026#39;t like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\u0026#34;, 22 domain-\u0026gt;name, hwirq, virq, ret); 23 } 24 irq_data-\u0026gt;domain = NULL; 25 irq_data-\u0026gt;hwirq = 0; 26 return ret; 27 } 28 } 29 30 domain-\u0026gt;mapcount++; 31 irq_domain_set_mapping(domain, hwirq, irq_data); 32 33 irq_clear_status_flags(virq, IRQ_NOREQUEST); 34 35 return 0; 36} 2.2.3. irq_domain_set_mapping irq_domain记录hwirq和irq_data的关系\n1/// kernel/irq/irqdomain.c 2static void irq_domain_set_mapping(struct irq_domain *domain, 3 irq_hw_number_t hwirq, 4 struct irq_data *irq_data) 5{ 6 /* 7 * This also makes sure that all domains point to the same root when 8 * called from irq_domain_insert_irq() for each domain in a hierarchy. 9 */ 10 lockdep_assert_held(\u0026amp;domain-\u0026gt;root-\u0026gt;mutex); 11 12 if (irq_domain_is_nomap(domain)) 13 return; 14 15 if (hwirq \u0026lt; domain-\u0026gt;revmap_size) 16 rcu_assign_pointer(domain-\u0026gt;revmap[hwirq], irq_data); 17 else 18 radix_tree_insert(\u0026amp;domain-\u0026gt;revmap_tree, hwirq, irq_data); 19} ","date":"July 16, 2024","img":"https://kingdix10.github.io/covers/pixels_cubes_shapes_127558_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/interrupt/irq_create_mapping/","series":[{"title":"中断管理","url":"/zh-cn/series/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1721088000,"title":"Linux中断子系统（三）设备中断注册"},{"categories":[{"title":"中断管理","url":"/zh-cn/categories/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"content":" 1. 申请中断 __setup_irq是用于设置和注册中断的核心函数，它是request_threaded_irq等函数的内部实现。 1.1. irqaction handler和thread_fn是struct irqaction的两个重要成员，由程序员指定或在__setup_irq中自动设置， 在中断发生后的处理函数被调用。\n1/// include/linux/interrupt.h 2/** 3 * struct irqaction - per interrupt action descriptor 4 * @handler:\tinterrupt handler function 5 * @name:\tname of the device 6 * @dev_id:\tcookie to identify the device 7 * @percpu_dev_id:\tcookie to identify the device 8 * @next:\tpointer to the next irqaction for shared interrupts 9 * @irq:\tinterrupt number 10 * @flags:\tflags (see IRQF_* above) 11 * @thread_fn:\tinterrupt handler function for threaded interrupts 12 * @thread:\tthread pointer for threaded interrupts 13 * @secondary:\tpointer to secondary irqaction (force threading) 14 * @thread_flags:\tflags related to @thread 15 * @thread_mask:\tbitmask for keeping track of @thread activity 16 * @dir:\tpointer to the proc/irq/NN/name entry 17 */ 18struct irqaction { 19\tirq_handler_t\thandler; 20\tvoid\t*dev_id; 21\tvoid __percpu\t*percpu_dev_id; 22\tstruct irqaction\t*next; 23\tirq_handler_t\tthread_fn; 24\tstruct task_struct\t*thread; 25\tstruct irqaction\t*secondary; 26\tunsigned int\tirq; 27\tunsigned int\tflags; 28\tunsigned long\tthread_flags; 29\tunsigned long\tthread_mask; 30\tconst char\t*name; 31\tstruct proc_dir_entry\t*dir; 32} ____cacheline_internodealigned_in_smp; 2. __setup_irq __setup_irq的代码量比较多，整理其主要流程如下：\n如果支持使用中断线程化，使用setup_irq_thread修改irqaction的handler。 如果直接已经为中断添加过irqaction，将新的irqaction挂到struct irqaction单链表的最后。 如果是第一次申请中断，根据需要设置厨房类型、激活中断，并进行一下其他配置。 1/// kernel/irq/manage.c 2/* 3 * Internal function to register an irqaction - typically used to 4 * allocate special interrupts that are part of the architecture. 5 * 6 * Locking rules: 7 * 8 * desc-\u0026gt;request_mutex\tProvides serialization against a concurrent free_irq() 9 * chip_bus_lock\tProvides serialization for slow bus operations 10 * desc-\u0026gt;lock\tProvides serialization against hard interrupts 11 * 12 * chip_bus_lock and desc-\u0026gt;lock are sufficient for all other management and 13 * interrupt related functions. desc-\u0026gt;request_mutex solely serializes 14 * request/free_irq(). 15 */ 16static int 17__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new) 18{ 19 struct irqaction *old, **old_ptr; 20 unsigned long flags, thread_mask = 0; 21 int ret, nested, shared = 0; 22 23 /// ... ... 24 25 new-\u0026gt;irq = irq; 26 27 /* 28 * If the trigger type is not specified by the caller, 29 * then use the default for this interrupt. 30 */ 31 if (!(new-\u0026gt;flags \u0026amp; IRQF_TRIGGER_MASK)) 32 new-\u0026gt;flags |= irqd_get_trigger_type(\u0026amp;desc-\u0026gt;irq_data); 33 34 /* 35 * Check whether the interrupt nests into another interrupt 36 * thread. 37 */ 38 nested = irq_settings_is_nested_thread(desc); 39 if (nested) { 40 /// ... ... 41 } else { 42 if (irq_settings_can_thread(desc)) { 43 ret = irq_setup_forced_threading(new); 44 if (ret) 45 goto out_mput; 46 } 47 } 48 49 /* 50 * Create a handler thread when a thread function is supplied 51 * and the interrupt does not nest into another interrupt 52 * thread. 53 */ 54 if (new-\u0026gt;thread_fn \u0026amp;\u0026amp; !nested) { 55 ret = setup_irq_thread(new, irq, false); 56 if (ret) 57 goto out_mput; 58 if (new-\u0026gt;secondary) { 59 ret = setup_irq_thread(new-\u0026gt;secondary, irq, true); 60 if (ret) 61 goto out_thread; 62 } 63 } 64 65 /* 66 * Drivers are often written to work w/o knowledge about the 67 * underlying irq chip implementation, so a request for a 68 * threaded irq without a primary hard irq context handler 69 * requires the ONESHOT flag to be set. Some irq chips like 70 * MSI based interrupts are per se one shot safe. Check the 71 * chip flags, so we can avoid the unmask dance at the end of 72 * the threaded handler for those. 73 */ 74 if (desc-\u0026gt;irq_data.chip-\u0026gt;flags \u0026amp; IRQCHIP_ONESHOT_SAFE) 75 new-\u0026gt;flags \u0026amp;= ~IRQF_ONESHOT; 76 77 /* 78 * Protects against a concurrent __free_irq() call which might wait 79 * for synchronize_hardirq() to complete without holding the optional 80 * chip bus lock and desc-\u0026gt;lock. Also protects against handing out 81 * a recycled oneshot thread_mask bit while it\u0026#39;s still in use by 82 * its previous owner. 83 */ 84 mutex_lock(\u0026amp;desc-\u0026gt;request_mutex); 85 86 /* 87 * Acquire bus lock as the irq_request_resources() callback below 88 * might rely on the serialization or the magic power management 89 * functions which are abusing the irq_bus_lock() callback, 90 */ 91 chip_bus_lock(desc); 92 93 /* First installed action requests resources. */ 94 if (!desc-\u0026gt;action) { 95 ret = irq_request_resources(desc); 96 if (ret) { 97 pr_err(\u0026#34;Failed to request resources for %s (irq %d) on irqchip %s\\n\u0026#34;, 98 new-\u0026gt;name, irq, desc-\u0026gt;irq_data.chip-\u0026gt;name); 99 goto out_bus_unlock; 100 } 101 } 102 103 /* 104 * The following block of code has to be executed atomically 105 * protected against a concurrent interrupt and any of the other 106 * management calls which are not serialized via 107 * desc-\u0026gt;request_mutex or the optional bus lock. 108 */ 109 raw_spin_lock_irqsave(\u0026amp;desc-\u0026gt;lock, flags); 110 old_ptr = \u0026amp;desc-\u0026gt;action; 111 old = *old_ptr; 112 if (old) { 113 /// ... ... 114 115 /* add new interrupt at end of irq queue */ 116 do { 117 /* 118 * Or all existing action-\u0026gt;thread_mask bits, 119 * so we can find the next zero bit for this 120 * new action. 121 */ 122 thread_mask |= old-\u0026gt;thread_mask; 123 old_ptr = \u0026amp;old-\u0026gt;next; 124 old = *old_ptr; 125 } while (old); 126 shared = 1; 127 } 128 129 /* 130 * Setup the thread mask for this irqaction for ONESHOT. For 131 * !ONESHOT irqs the thread mask is 0 so we can avoid a 132 * conditional in irq_wake_thread(). 133 */ 134 if (new-\u0026gt;flags \u0026amp; IRQF_ONESHOT) { 135 /* 136 * Unlikely to have 32 resp 64 irqs sharing one line, 137 * but who knows. 138 */ 139 if (thread_mask == ~0UL) { 140 ret = -EBUSY; 141 goto out_unlock; 142 } 143 /* 144 * The thread_mask for the action is or\u0026#39;ed to 145 * desc-\u0026gt;thread_active to indicate that the 146 * IRQF_ONESHOT thread handler has been woken, but not 147 * yet finished. The bit is cleared when a thread 148 * completes. When all threads of a shared interrupt 149 * line have completed desc-\u0026gt;threads_active becomes 150 * zero and the interrupt line is unmasked. See 151 * handle.c:irq_wake_thread() for further information. 152 * 153 * If no thread is woken by primary (hard irq context) 154 * interrupt handlers, then desc-\u0026gt;threads_active is 155 * also checked for zero to unmask the irq line in the 156 * affected hard irq flow handlers 157 * (handle_[fasteoi|level]_irq). 158 * 159 * The new action gets the first zero bit of 160 * thread_mask assigned. See the loop above which or\u0026#39;s 161 * all existing action-\u0026gt;thread_mask bits. 162 */ 163 new-\u0026gt;thread_mask = 1UL \u0026lt;\u0026lt; ffz(thread_mask); 164 165 } else if (new-\u0026gt;handler == irq_default_primary_handler \u0026amp;\u0026amp; 166 !(desc-\u0026gt;irq_data.chip-\u0026gt;flags \u0026amp; IRQCHIP_ONESHOT_SAFE)) { 167 /* 168 * The interrupt was requested with handler = NULL, so 169 * we use the default primary handler for it. But it 170 * does not have the oneshot flag set. In combination 171 * with level interrupts this is deadly, because the 172 * default primary handler just wakes the thread, then 173 * the irq lines is reenabled, but the device still 174 * has the level irq asserted. Rinse and repeat.... 175 * 176 * While this works for edge type interrupts, we play 177 * it safe and reject unconditionally because we can\u0026#39;t 178 * say for sure which type this interrupt really 179 * has. The type flags are unreliable as the 180 * underlying chip implementation can override them. 181 */ 182 pr_err(\u0026#34;Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\u0026#34;, 183 new-\u0026gt;name, irq); 184 ret = -EINVAL; 185 goto out_unlock; 186 } 187 188 if (!shared) { 189 /* Setup the type (level, edge polarity) if configured: */ 190 if (new-\u0026gt;flags \u0026amp; IRQF_TRIGGER_MASK) { 191 ret = __irq_set_trigger(desc, 192 new-\u0026gt;flags \u0026amp; IRQF_TRIGGER_MASK); 193 194 if (ret) 195 goto out_unlock; 196 } 197 198 /* 199 * Activate the interrupt. That activation must happen 200 * independently of IRQ_NOAUTOEN. request_irq() can fail 201 * and the callers are supposed to handle 202 * that. enable_irq() of an interrupt requested with 203 * IRQ_NOAUTOEN is not supposed to fail. The activation 204 * keeps it in shutdown mode, it merily associates 205 * resources if necessary and if that\u0026#39;s not possible it 206 * fails. Interrupts which are in managed shutdown mode 207 * will simply ignore that activation request. 208 */ 209 ret = irq_activate(desc); 210 if (ret) 211 goto out_unlock; 212 213 desc-\u0026gt;istate \u0026amp;= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\ 214 IRQS_ONESHOT | IRQS_WAITING); 215 irqd_clear(\u0026amp;desc-\u0026gt;irq_data, IRQD_IRQ_INPROGRESS); 216 217 if (new-\u0026gt;flags \u0026amp; IRQF_PERCPU) { 218 irqd_set(\u0026amp;desc-\u0026gt;irq_data, IRQD_PER_CPU); 219 irq_settings_set_per_cpu(desc); 220 if (new-\u0026gt;flags \u0026amp; IRQF_NO_DEBUG) 221 irq_settings_set_no_debug(desc); 222 } 223 224 if (noirqdebug) 225 irq_settings_set_no_debug(desc); 226 227 if (new-\u0026gt;flags \u0026amp; IRQF_ONESHOT) 228 desc-\u0026gt;istate |= IRQS_ONESHOT; 229 230 /* Exclude IRQ from balancing if requested */ 231 if (new-\u0026gt;flags \u0026amp; IRQF_NOBALANCING) { 232 irq_settings_set_no_balancing(desc); 233 irqd_set(\u0026amp;desc-\u0026gt;irq_data, IRQD_NO_BALANCING); 234 } 235 236 if (!(new-\u0026gt;flags \u0026amp; IRQF_NO_AUTOEN) \u0026amp;\u0026amp; 237 irq_settings_can_autoenable(desc)) { 238 irq_startup(desc, IRQ_RESEND, IRQ_START_COND); 239 } else { 240 /* 241 * Shared interrupts do not go well with disabling 242 * auto enable. The sharing interrupt might request 243 * it while it\u0026#39;s still disabled and then wait for 244 * interrupts forever. 245 */ 246 WARN_ON_ONCE(new-\u0026gt;flags \u0026amp; IRQF_SHARED); 247 /* Undo nested disables: */ 248 desc-\u0026gt;depth = 1; 249 } 250 251 } else if (new-\u0026gt;flags \u0026amp; IRQF_TRIGGER_MASK) { 252 unsigned int nmsk = new-\u0026gt;flags \u0026amp; IRQF_TRIGGER_MASK; 253 unsigned int omsk = irqd_get_trigger_type(\u0026amp;desc-\u0026gt;irq_data); 254 255 if (nmsk != omsk) 256 /* hope the handler works with current trigger mode */ 257 pr_warn(\u0026#34;irq %d uses trigger mode %u; requested %u\\n\u0026#34;, 258 irq, omsk, nmsk); 259 } 260 261 *old_ptr = new; 262 263 irq_pm_install_action(desc, new); 264 265 /* Reset broken irq detection when installing new handler */ 266 desc-\u0026gt;irq_count = 0; 267 desc-\u0026gt;irqs_unhandled = 0; 268 269 /* 270 * Check whether we disabled the irq via the spurious handler 271 * before. Reenable it and give it another chance. 272 */ 273 if (shared \u0026amp;\u0026amp; (desc-\u0026gt;istate \u0026amp; IRQS_SPURIOUS_DISABLED)) { 274 desc-\u0026gt;istate \u0026amp;= ~IRQS_SPURIOUS_DISABLED; 275 __enable_irq(desc); 276 } 277 278 raw_spin_unlock_irqrestore(\u0026amp;desc-\u0026gt;lock, flags); 279 chip_bus_sync_unlock(desc); 280 mutex_unlock(\u0026amp;desc-\u0026gt;request_mutex); 281 282 irq_setup_timings(desc, new); 283 284 wake_up_and_wait_for_irq_thread_ready(desc, new); 285 wake_up_and_wait_for_irq_thread_ready(desc, new-\u0026gt;secondary); 286 287 register_irq_proc(irq, desc); 288 new-\u0026gt;dir = NULL; 289 register_handler_proc(irq, new); 290 return 0; 291 292///... ... 293} 2.1. 默认handler 1/// kernel/irq/manage.c 2/* 3 * Default primary interrupt handler for threaded interrupts. Is 4 * assigned as primary handler when request_threaded_irq is called 5 * with handler == NULL. Useful for oneshot interrupts. 6 */ 7/// 用于唤醒默认的中断处理线程 8static irqreturn_t irq_default_primary_handler(int irq, void *dev_id) 9{ 10 return IRQ_WAKE_THREAD; 11} 12 13/* 14 * Primary handler for nested threaded interrupts. Should never be 15 * called. 16 */ 17static irqreturn_t irq_nested_primary_handler(int irq, void *dev_id) 18{ 19 WARN(1, \u0026#34;Primary handler called for nested irq %d\\n\u0026#34;, irq); 20 return IRQ_NONE; 21} 22 23static irqreturn_t irq_forced_secondary_handler(int irq, void *dev_id) 24{ 25 WARN(1, \u0026#34;Secondary action handler called for irq %d\\n\u0026#34;, irq); 26 return IRQ_NONE; 27} 3. 中断线程 在不是中断嵌套的清闲，如果同时指定了handler和thread_fn，或者使能了强制中断线程化，__setup_irq会通过setup_irq_thread来设置中断线程，其代码如下\n1/// kernel/irq/manage.c 2static int 3setup_irq_thread(struct irqaction *new, unsigned int irq, bool secondary) 4{ 5 struct task_struct *t; 6 7 if (!secondary) { 8 t = kthread_create(irq_thread, new, \u0026#34;irq/%d-%s\u0026#34;, irq, 9 new-\u0026gt;name); 10 } else { 11 t = kthread_create(irq_thread, new, \u0026#34;irq/%d-s-%s\u0026#34;, irq, 12 new-\u0026gt;name); 13 } 14 15 if (IS_ERR(t)) 16 return PTR_ERR(t); 17 18 /* 19 * We keep the reference to the task struct even if 20 * the thread dies to avoid that the interrupt code 21 * references an already freed task_struct. 22 */ 23 new-\u0026gt;thread = get_task_struct(t); 24 /* 25 * Tell the thread to set its affinity. This is 26 * important for shared interrupt handlers as we do 27 * not invoke setup_affinity() for the secondary 28 * handlers as everything is already set up. Even for 29 * interrupts marked with IRQF_NO_BALANCE this is 30 * correct as we want the thread to move to the cpu(s) 31 * on which the requesting code placed the interrupt. 32 */ 33 set_bit(IRQTF_AFFINITY, \u0026amp;new-\u0026gt;thread_flags); 34 return 0; 35} 3.1. 强制中断线程化 如果是强制中断线程化，会将irqaction的handler设为irq_default_primary_handler，而将原来的handler赋给thread_fn。 如果原来的handler和thread_fn均被设置，则会申请新的irqaction作为new-\u0026gt;secondary。将thread_fn赋值给new-\u0026gt;secondary-\u0026gt;thread_fn，new-\u0026gt;secondary-\u0026gt;handler设为irq_forced_secondary_handler。\n1/// kernel/irq/manage.c 2static int irq_setup_forced_threading(struct irqaction *new) 3{ 4 if (!force_irqthreads()) 5 return 0; 6 if (new-\u0026gt;flags \u0026amp; (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT)) 7 return 0; 8 9 /* 10 * No further action required for interrupts which are requested as 11 * threaded interrupts already 12 */ 13 if (new-\u0026gt;handler == irq_default_primary_handler) 14 return 0; 15 16 new-\u0026gt;flags |= IRQF_ONESHOT; 17 18 /* 19 * Handle the case where we have a real primary handler and a 20 * thread handler. We force thread them as well by creating a 21 * secondary action. 22 */ 23 if (new-\u0026gt;handler \u0026amp;\u0026amp; new-\u0026gt;thread_fn) { 24 /* Allocate the secondary action */ 25 new-\u0026gt;secondary = kzalloc(sizeof(struct irqaction), GFP_KERNEL); 26 if (!new-\u0026gt;secondary) 27 return -ENOMEM; 28 new-\u0026gt;secondary-\u0026gt;handler = irq_forced_secondary_handler; 29 new-\u0026gt;secondary-\u0026gt;thread_fn = new-\u0026gt;thread_fn; 30 new-\u0026gt;secondary-\u0026gt;dev_id = new-\u0026gt;dev_id; 31 new-\u0026gt;secondary-\u0026gt;irq = new-\u0026gt;irq; 32 new-\u0026gt;secondary-\u0026gt;name = new-\u0026gt;name; 33 } 34 /* Deal with the primary handler */ 35 set_bit(IRQTF_FORCED_THREAD, \u0026amp;new-\u0026gt;thread_flags); 36 new-\u0026gt;thread_fn = new-\u0026gt;handler; 37 new-\u0026gt;handler = irq_default_primary_handler; 38 return 0; 39} 强制中断线程化配置 irq_setup_forced_threading会调用force_irqthreads判断系统是否开启强制中断线程化。\n1#ifdef CONFIG_IRQ_FORCED_THREADING 2# ifdef CONFIG_PREEMPT_RT 3# define force_irqthreads()\t(true) 4# else 5/// static_key支持动态开关，原理见jump label分析 6DECLARE_STATIC_KEY_FALSE(force_irqthreads_key); 7# define force_irqthreads()\t(static_branch_unlikely(\u0026amp;force_irqthreads_key)) 8# endif 9#else 10#define force_irqthreads()\t(false) 11#endif ","date":"July 16, 2024","img":"https://kingdix10.github.io/covers/laptop_backlight_colorful_194324_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/interrupt/request_irq/","series":[{"title":"中断管理","url":"/zh-cn/series/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1721088000,"title":"Linux中断子系统（四）申请中断request_irq"},{"categories":[{"title":"中断管理","url":"/zh-cn/categories/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"content":" 1. 中断入口 要处理中断，必须为handle_arch_irq赋值。\nARM64自己定义handle_arch_irq的实现。\n1/// arch/arm64/kernel/irq.c 2void (*handle_arch_irq)(struct pt_regs *) __ro_after_init = default_handle_irq; 3void (*handle_arch_fiq)(struct pt_regs *) __ro_after_init = default_handle_fiq; 4 5int __init set_handle_irq(void (*handle_irq)(struct pt_regs *)) 6{ 7 if (handle_arch_irq != default_handle_irq) 8 return -EBUSY; 9 10 handle_arch_irq = handle_irq; 11 pr_info(\u0026#34;Root IRQ handler: %ps\\n\u0026#34;, handle_irq); 12 return 0; 13} 14 15int __init set_handle_fiq(void (*handle_fiq)(struct pt_regs *)) 16{ 17 if (handle_arch_fiq != default_handle_fiq) 18 return -EBUSY; 19 20 handle_arch_fiq = handle_fiq; 21 pr_info(\u0026#34;Root FIQ handler: %ps\\n\u0026#34;, handle_fiq); 22 return 0; 23} ARM使能CONFIG_GENERIC_IRQ_MULTI_HANDLER。\n1/// kernel/irq/handle.c 2#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER 3void (*handle_arch_irq)(struct pt_regs *) __ro_after_init; 4#endif 5/// ... ... 6#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER 7int __init set_handle_irq(void (*handle_irq)(struct pt_regs *)) 8{ 9 if (handle_arch_irq) 10 return -EBUSY; 11 12 handle_arch_irq = handle_irq; 13 return 0; 14} 15 16/** 17 * generic_handle_arch_irq - root irq handler for architectures which do no 18 * entry accounting themselves 19 * @regs:\tRegister file coming from the low-level handling code 20 */ 21asmlinkage void noinstr generic_handle_arch_irq(struct pt_regs *regs) 22{ 23 struct pt_regs *old_regs; 24 25 irq_enter(); 26 old_regs = set_irq_regs(regs); 27 handle_arch_irq(regs); 28 set_irq_regs(old_regs); 29 irq_exit(); 30} 31#endif 1.1. arm32 arm32的中断入口分别在__irq_svc和__irq_usr中，其内部会使用irq_handler来调用generic_handle_arch_irq，最终调用到handle_arch_irq。\n1/// arch/arm/kernel/entry-armv.S 2/* 3 * Interrupt handling. 4 */ 5 .macro irq_handler, from_user:req 6 mov r1, sp 7 ldr_this_cpu r2, irq_stack_ptr, r2, r3 8 .if \\from_user == 0 9 @ 10 @ If we took the interrupt while running in the kernel, we may already 11 @ be using the IRQ stack, so revert to the original value in that case. 12 @ 13 subs r3, r2, r1 @ SP above bottom of IRQ stack? 14 rsbscs r3, r3, #THREAD_SIZE @ ... and below the top? 15#ifdef CONFIG_VMAP_STACK 16 ldr_va r3, high_memory, cc @ End of the linear region 17 cmpcc r3, r1 @ Stack pointer was below it? 18#endif 19 bcc 0f @ If not, switch to the IRQ stack 20 mov r0, r1 21 /// 直接调用generic_handle_arch_irq 22 bl generic_handle_arch_irq 23 b 1f 240: 25 .endif 26 27 /// 将generic_handle_arch_irq作为call_with_stack的参数 28 /// 在call_with_stack内调用 29 mov_l r0, generic_handle_arch_irq 30 bl call_with_stack 311: 32 .endm 1.2. arm64 handle_arch_irq作为参数，最终由do_interrupt_handler调用。\n2. gic的中断处理函数 2.1. 实际的处理函数 1# cat /proc/interrupts 2 CPU0 CPU1 3 11: 2598 2172 GICv3 27 Level arch_timer 4 13: 176 0 GICv3 33 Level uart-pl011 5 16: 563 0 GICv3 75 Edge virtio0 6 17: 0 0 GICv3 79 Edge virtio4 7 18: 0 0 GICv3 34 Level rtc-pl031 8 19: 0 0 GICv3 23 Level arm-pmu 9 20: 3 0 GICv3 76 Edge virtio1 10 21: 82 0 GICv3 77 Edge virtio2 11 22: 33 0 GICv3 78 Edge virtio3 12 23: 0 0 9030000.pl061 3 Edge GPIO Key Poweroff 13IPI0: 56 84 Rescheduling interrupts 14IPI1: 503 797 Function call interrupts 15IPI2: 0 0 CPU stop interrupts 16IPI3: 0 0 CPU stop (for crash dump) interrupts 17IPI4: 0 0 Timer broadcast interrupts 18IPI5: 0 0 IRQ work interrupts 19IPI6: 0 0 CPU wake-up interrupts 20Err: 0 21# cd /sys/kernel/debug/irq/irqs 22# grep -w handler * | sort -n 231:handler: handle_percpu_devid_irq 242:handler: handle_percpu_devid_irq 253:handler: handle_percpu_devid_irq 264:handler: handle_percpu_devid_irq 275:handler: handle_percpu_devid_irq 286:handler: handle_percpu_devid_irq 297:handler: handle_percpu_devid_irq 308:handler: handle_percpu_devid_irq 319:handler: handle_percpu_devid_irq 3210:handler: handle_percpu_devid_irq 3311:handler: handle_percpu_devid_irq 3412:handler: handle_percpu_devid_irq 3513:handler: handle_fasteoi_irq 3614:handler: pl061_irq_handler 3715:handler: handle_fasteoi_irq 3816:handler: handle_fasteoi_irq 3917:handler: handle_fasteoi_irq 4018:handler: handle_fasteoi_irq 4119:handler: handle_percpu_devid_irq 4220:handler: handle_fasteoi_irq 4321:handler: handle_fasteoi_irq 4422:handler: handle_fasteoi_irq 4523:handler: handle_edge_irq 这里重点关注handle_fasteoi_irq，其最后会调用__handle_irq_event_percpu。\n在__handle_irq_event_percpu中，如果handler返回IRQ_WAKE_THREAD，则会唤醒中断处理线程。\n1irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc) 2{ 3\tirqreturn_t retval = IRQ_NONE; 4\tunsigned int irq = desc-\u0026gt;irq_data.irq; 5\tstruct irqaction *action; 6 7\trecord_irq_time(desc); 8 9\tfor_each_action_of_desc(desc, action) { 10\tirqreturn_t res; 11 12\t/* 13\t* If this IRQ would be threaded under force_irqthreads, mark it so. 14\t*/ 15\tif (irq_settings_can_thread(desc) \u0026amp;\u0026amp; 16\t!(action-\u0026gt;flags \u0026amp; (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT))) 17\tlockdep_hardirq_threaded(); 18 19\ttrace_irq_handler_entry(irq, action); 20\tres = action-\u0026gt;handler(irq, action-\u0026gt;dev_id); 21\ttrace_irq_handler_exit(irq, action, res); 22 23\tif (WARN_ONCE(!irqs_disabled(),\u0026#34;irq %u handler %pS enabled interrupts\\n\u0026#34;, 24\tirq, action-\u0026gt;handler)) 25\tlocal_irq_disable(); 26 27\tswitch (res) { 28\tcase IRQ_WAKE_THREAD: 29\t/* 30\t* Catch drivers which return WAKE_THREAD but 31\t* did not set up a thread function 32\t*/ 33\tif (unlikely(!action-\u0026gt;thread_fn)) { 34\twarn_no_thread(irq, action); 35\tbreak; 36\t} 37 38\t__irq_wake_thread(desc, action); 39\tbreak; 40 41\tdefault: 42\tbreak; 43\t} 44 45\tretval |= res; 46\t} 47 48\treturn retval; 49} 3. 中断线程化 之前提到，在__setup_irq申请中断时，可以在指定的handler或着通过强制中断线程化来使用irq_default_primary_handler中返回IRQ_WAKE_THREAD来唤醒中断线程。\n中断线程服务函数irq_thread：\n1/// kernel/irq/manage.c 2/* 3 * Interrupt handler thread 4 */ 5static int irq_thread(void *data) 6{ 7 struct callback_head on_exit_work; 8 struct irqaction *action = data; 9 struct irq_desc *desc = irq_to_desc(action-\u0026gt;irq); 10 irqreturn_t (*handler_fn)(struct irq_desc *desc, 11 struct irqaction *action); 12 13 irq_thread_set_ready(desc, action); 14 15 sched_set_fifo(current); 16 17 if (force_irqthreads() \u0026amp;\u0026amp; test_bit(IRQTF_FORCED_THREAD, 18 \u0026amp;action-\u0026gt;thread_flags)) 19 handler_fn = irq_forced_thread_fn; 20 else 21 handler_fn = irq_thread_fn; 22 23 init_task_work(\u0026amp;on_exit_work, irq_thread_dtor); 24 task_work_add(current, \u0026amp;on_exit_work, TWA_NONE); 25 26 irq_thread_check_affinity(desc, action); 27 28 while (!irq_wait_for_interrupt(action)) { 29 irqreturn_t action_ret; 30 31 irq_thread_check_affinity(desc, action); 32 33 action_ret = handler_fn(desc, action); 34 if (action_ret == IRQ_WAKE_THREAD) 35 irq_wake_secondary(desc, action); 36 37 wake_threads_waitq(desc); 38 } 39 40 /* 41 * This is the regular exit path. __free_irq() is stopping the 42 * thread via kthread_stop() after calling 43 * synchronize_hardirq(). So neither IRQTF_RUNTHREAD nor the 44 * oneshot mask bit can be set. 45 */ 46 task_work_cancel(current, irq_thread_dtor); 47 return 0; 48} ","date":"July 16, 2024","img":"https://kingdix10.github.io/covers/vintage_retro_camera_126517_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/interrupt/handler_entry/","series":[{"title":"中断管理","url":"/zh-cn/series/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1721088000,"title":"Linux中断子系统（五）中断处理"},{"categories":[{"title":"中断管理","url":"/zh-cn/categories/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"},{"title":"启动流程","url":"/zh-cn/categories/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"content":" 1. 简介 early_irq_init完成中断子系统软件部分初始化。\nirqchip_init初始化中断控制器，向系统注册struct irq_domain。\n2. 中断软件子系统初始化 early_irq_init初始化数组或树，用于保存virq到struct irq_desc的转换关系。\nirq_to_desc用于将virq转换为struct irq_desc指针。\n2.1. 线性映射 未定义CONFIG_SPARSE_IRQ时使用线性映射，使用数组实现，静态分配，支持的最大virq由NR_IRQS决定。\n1struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = { 2 [0 ... NR_IRQS-1] = { 3 .handle_irq\t= handle_bad_irq, 4 .depth\t= 1, 5 .lock\t= __RAW_SPIN_LOCK_UNLOCKED(irq_desc-\u0026gt;lock), 6 } 7}; 8 9struct irq_desc *irq_to_desc(unsigned int irq) 10{ 11 return (irq \u0026lt; NR_IRQS) ? irq_desc + irq : NULL; 12} 13EXPORT_SYMBOL(irq_to_desc); 2.2. 非线性映射 定义CONFIG_SPARSE_IRQ时使用非线性映射，使用树实现，早期版本使用radix tree，linux-6.6使用maple tree。支持的最大virq由MAX_SPARSE_IRQS\t决定，其值为INT_MAX。struct irq_desc在注册设备中断时动态分配。\n1/// kernel/irq/irqdesc.c 2static DEFINE_MUTEX(sparse_irq_lock); 3static struct maple_tree sparse_irqs = MTREE_INIT_EXT(sparse_irqs, 4 MT_FLAGS_ALLOC_RANGE | 5 MT_FLAGS_LOCK_EXTERN | 6 MT_FLAGS_USE_RCU, 7 sparse_irq_lock); 8/// ... ... 9struct irq_desc *irq_to_desc(unsigned int irq) 10{ 11 return mtree_load(\u0026amp;sparse_irqs, irq); 12} 13#ifdef CONFIG_KVM_BOOK3S_64_HV_MODULE 14EXPORT_SYMBOL_GPL(irq_to_desc); 15#endif 16/// ... ... 17static void irq_insert_desc(unsigned int irq, struct irq_desc *desc) 18{ 19 MA_STATE(mas, \u0026amp;sparse_irqs, irq, irq); 20 WARN_ON(mas_store_gfp(\u0026amp;mas, desc, GFP_KERNEL) != 0); 21} 3. 中断控制器初始化 先进行软件初始化，再进行硬件初始化。核心函数 of_irq_init，遍历 __irqchip_table段，扫描设备树中可以匹配的中断控制器节点，并调用对应的初始化函数。\n1/// drivers/irqchip/irqchip.c 2void __init irqchip_init(void) 3{ 4 of_irq_init(__irqchip_of_table); 5 acpi_probe_device_table(irqchip); 6} irqchip_init使用of或者使用acpi获取中断控制器的设备树节点，并调用 of_irq_init 和 acpi_probe_device_table进行初始化。\n3.1. IRQCHIP_DECLARE 所有的中断控制器初始化函数由IRQCHIP_DECLARE修饰，在链接时放到vmlinux的__irqchip_of_table段中。\n通过搜索IRQCHIP_DECLARE，可以找到所有的中断控制器初始化函数。如下为gic相关的初始化函数。\n1# git grep --heading -Inw IRQCHIP_DECLARE drivers/irqchip/irq-gic* 2drivers/irqchip/irq-gic-realview.c 376:IRQCHIP_DECLARE(armtc11mp_gic, \u0026#34;arm,tc11mp-gic\u0026#34;, realview_gic_of_init); 477:IRQCHIP_DECLARE(armeb11mp_gic, \u0026#34;arm,eb11mp-gic\u0026#34;, realview_gic_of_init); 5drivers/irqchip/irq-gic-v3.c 62328:IRQCHIP_DECLARE(gic_v3, \u0026#34;arm,gic-v3\u0026#34;, gic_of_init); 7drivers/irqchip/irq-gic.c 81516:IRQCHIP_DECLARE(gic_400, \u0026#34;arm,gic-400\u0026#34;, gic_of_init); 91517:IRQCHIP_DECLARE(arm11mp_gic, \u0026#34;arm,arm11mp-gic\u0026#34;, gic_of_init); 101518:IRQCHIP_DECLARE(arm1176jzf_dc_gic, \u0026#34;arm,arm1176jzf-devchip-gic\u0026#34;, gic_of_init); 111519:IRQCHIP_DECLARE(cortex_a15_gic, \u0026#34;arm,cortex-a15-gic\u0026#34;, gic_of_init); 121520:IRQCHIP_DECLARE(cortex_a9_gic, \u0026#34;arm,cortex-a9-gic\u0026#34;, gic_of_init); 131521:IRQCHIP_DECLARE(cortex_a7_gic, \u0026#34;arm,cortex-a7-gic\u0026#34;, gic_of_init); 141522:IRQCHIP_DECLARE(msm_8660_qgic, \u0026#34;qcom,msm-8660-qgic\u0026#34;, gic_of_init); 151523:IRQCHIP_DECLARE(msm_qgic2, \u0026#34;qcom,msm-qgic2\u0026#34;, gic_of_init); 161524:IRQCHIP_DECLARE(pl390, \u0026#34;arm,pl390\u0026#34;, gic_of_init); vmlinux.lds.h控制链接布局。\n1/// include/asm-generic/vmlinux.lds.h 2#define ___OF_TABLE(cfg, name)\t_OF_TABLE_##cfg(name) 3#define __OF_TABLE(cfg, name)\t___OF_TABLE(cfg, name) 4#define OF_TABLE(cfg, name)\t__OF_TABLE(IS_ENABLED(cfg), name) 5#define _OF_TABLE_0(name) 6#define _OF_TABLE_1(name)\t\\ 7 . = ALIGN(8);\t\\ 8 __##name##_of_table = .;\t\\ 9 KEEP(*(__##name##_of_table))\t\\ 10 KEEP(*(__##name##_of_table_end)) 11 12#define TIMER_OF_TABLES()\tOF_TABLE(CONFIG_TIMER_OF, timer) 13/// __irqchip_of_table段 14#define IRQCHIP_OF_MATCH_TABLE() OF_TABLE(CONFIG_IRQCHIP, irqchip) 15#define CLK_OF_TABLES()\tOF_TABLE(CONFIG_COMMON_CLK, clk) 16#define RESERVEDMEM_OF_TABLES()\tOF_TABLE(CONFIG_OF_RESERVED_MEM, reservedmem) 17#define CPU_METHOD_OF_TABLES()\tOF_TABLE(CONFIG_SMP, cpu_method) 18#define CPUIDLE_METHOD_OF_TABLES() OF_TABLE(CONFIG_CPU_IDLE, cpuidle_method) IRQCHIP_DECLARE的实现，细节可以自行分析。\n1/// include/linux/irqchip.h 2/* 3 * This macro must be used by the different irqchip drivers to declare 4 * the association between their DT compatible string and their 5 * initialization function. 6 * 7 * @name: name that must be unique across all IRQCHIP_DECLARE of the 8 * same file. 9 * @compat: compatible string of the irqchip driver 10 * @fn: initialization function 11 */ 12#define IRQCHIP_DECLARE(name, compat, fn)\t\\ 13 OF_DECLARE_2(irqchip, name, compat, typecheck_irq_init_cb(fn)) 3.2. gic-v2 gic-v2的初始化函数是gic_of_init，其主要工作如下：\n设置中断回调函数 irq_domain_create_linear注册irq_domain 初始化硬件 gic_smp_init使用SGI的前8号中断作为IPI，并建立virq和struct irq_data的映射关系 如下内容摘自CoreLink GIC-400 Generic Interrupt Controller Technical Reference Manual\nSGIs are generated by writing to the Software Generated Interrupt Register, GICD_SGIR. Each CPU interface can generate a maximum of 16 SGIs, ID0-ID15, for each target processor.\ngic-v2支持中断级联，级联的中断控制器与普通的中断控制器初始化代码都是gic_of_init，只是加了一个判断。\n1/// drivers/irqchip/irq-gic.c 2int __init 3gic_of_init(struct device_node *node, struct device_node *parent) 4{ 5 /// ... ... 6 7 /// 用于级联中断控制器的初始化 8 if (parent) { 9 irq = irq_of_parse_and_map(node, 0); 10 gic_cascade_irq(gic_cnt, irq); 11 } 12 13 /// ... ... 14 15 gic_cnt++; 16 return 0; 17} 3.3. gic-v3 gic-v3的初始化函数也是gic_of_init，其主要工作如下：\n注册irq_domain irq_domain_create_tree注册irq_domain 设置中断回调函数 初始化硬件 gic_smp_init使用SGI的前8号中断作为IPI，并建立virq和struct irq_data的映射关系 ITS(Interrupt Translation Service)相关初始化 gic_enable_nmi_support使用fiq来实现NMI中断 《IHI0069H_gic_architecture_specification.pdf》中中断号划分如下。\n","date":"July 16, 2024","img":"https://kingdix10.github.io/covers/hologram_scheme_scifi_139294_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/interrupt/init/","series":[{"title":"中断管理","url":"/zh-cn/series/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1721088000,"title":"Linux中断子系统（一）软硬件初始化"},{"categories":[{"title":"C语言","url":"/zh-cn/categories/c%E8%AF%AD%E8%A8%80/"}],"content":" 1. 示例一 先看下如下代码，思考一下，结果是输出a == b还是a != b？\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;string.h\u0026gt; 3 4struct test_type { 5 char name[10]; 6 int i; 7 long l; 8}; 9 10int main(void) 11{ 12 struct test_type a = { 13 \u0026#34;test\u0026#34;, 1, 2 14 }; 15 struct test_type b; 16 17 b.i = a.i; 18 b.l = a.l; 19 strcpy(b.name, a.name); 20 21 if (0 == memcmp(\u0026amp;a, \u0026amp;b, sizeof(struct test_type))) { 22 printf(\u0026#34;a == b\\n\u0026#34;); 23 } else { 24 printf(\u0026#34;a != b\\n\u0026#34;); 25 } 26 27 return 0; 28} 1.1. 结果及分析 实际结果很可能是a != b。\n注意到strcpy(b.name, a.name)，由于a.name是\u0026quot;test\u0026quot;，字符串长度比10要小，strcpy只是复制了a.name的一部分到b.name，所以两者会存在不相等的情况。\n2. 示例二 我们把strcpy(b.name, a.name)改成memcpy(b.name, a.name, sizeof(a.name))，来看一下，代码如下。\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;string.h\u0026gt; 3 4struct test_type { 5 char name[10]; 6 int i; 7 long l; 8}; 9 10int main(void) 11{ 12 struct test_type a = { 13 \u0026#34;test\u0026#34;, 1, 2 14 }; 15 struct test_type b; 16 17 b.i = a.i; 18 b.l = a.l; 19 memcpy(b.name, a.name, sizeof(a.name)); 20 21 if (0 == memcmp(\u0026amp;a, \u0026amp;b, sizeof(struct test_type))) { 22 printf(\u0026#34;a == b\\n\u0026#34;); 23 } else { 24 printf(\u0026#34;a != b\\n\u0026#34;); 25 } 26 27 return 0; 28} 2.1. 结果及分析 然而，实际结果很可能还是a != b。\n这里涉及到编译器对结构体的处理，为了提高访问性能，编译器会对结构体成员地址进行对齐。对于64位系统来说，int型变量的地址通常要4字节对齐，long型变量的地址通常要8字节对齐。而name数组大小是10，为了满足4字节对齐，i前要留出2字节的空洞。而空洞的内容是不确定的，这就导致了对比结果显示a != b。\n不过要注意的是，大多数编译器对long型变量也是4字节对齐，所以l前通常不会有空洞。\n3. 总结 在编码中，如果要使用memcmp来比较结构体，在声明变量时，要保证使用memset来进行初始化，否则就不用直接使用memcmp来进行比较。\n","date":"July 16, 2024","img":"https://kingdix10.github.io/covers/trunk_tree_texture_119590_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/05-program/ccpp/c_struct_cmp/","series":[],"smallImg":"","tags":[{"title":"C语言","url":"/zh-cn/tags/c%E8%AF%AD%E8%A8%80/"},{"title":"结构体","url":"/zh-cn/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"}],"timestamp":1721088000,"title":"用memcmp比较结构体会有什么问题"},{"categories":[{"title":"代码技巧","url":"/zh-cn/categories/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/"}],"content":" 1. Linux内核代码的编写和优化技巧 1.1. 代码编写 使用 __same_type和 typecheck编译时检查类型匹配。 __printf和 __scanf编译时检查代码。 对宏进行undef后重新定义，生成不同的代码，如 __SYSCALL配合 unistd.h生成系统调用，TRACE_EVENT生成ftrace相关的数据结构和各个函数。 使用模板宏，减少重复代码也降低出错率，如 STANDARD_PARAM_DEF生成 module_param用到的set和get函数。 使用内联汇编提升性能。 使用位图优化内存占用。 无锁队列kfifo。 1.2. 控制编译时行为 O2或 O3，编译时优化汇编代码。 __builtin_constant_p优化常量分支。 使用 likely和 unlikely，编译时对代码进程重排序。 __noreturn优化不需要返回的函数。 宏、inline和 __always_inline，内联函数，减少入栈出栈操作。 使用 __randomize_layout，结构体布局随机化，打乱成员排序，提升入侵难度。 使用 __cacheline_aligned对结构体进行cache line对齐，提升访问性能，减少cache颠簸 细化程序分段，如 init、initdata等，释放无用内存。 区分冷热段，热段如 sched、read_mostly，冷段如 tracepoint段，热段更容易常驻cache。 重要部分使用联合减少结构大小，如 struct page，减少内存占用。 1.3. 控制运行时行为 使用percpu变量减少核见竞争。 访问一个变量时，需同时获取两把锁，将锁放到不同的cache line。如struct zone。 使用动态代码修改，如 jump_label、alternative_if，减少分支判断。 栈随机化和地址空间布局随机化（KASLR），提升攻击难度。 零拷贝技术、写时复制 2. Linux内核中的面向对象编程 使用函数回调，抽象通用接口 抽象通用数据结构，使用container获取自定义数据结构 2.1. 使用 __noreturn会有哪些编译优化？ 使用 __noreturn属性可以允许编译器进行一些特定的优化，因为编译器知道带这个属性的函数不会返回。这些优化可能包括：\n省略返回值：如果一个函数被标记为 __noreturn，并且它的返回类型不是 void，编译器可能会省略对返回值的处理，因为它知道这个函数不会返回给调用者。 省略后续代码的生成：在函数调用的后面如果有代码，编译器可能会省略这些代码的生成，因为它们永远不会被执行。 优化调用栈：编译器可能会优化函数调用的栈处理，因为不需要为非 void返回类型的函数保留返回地址。 分支预测：编译器可能会对调用 __noreturn函数的代码进行分支预测优化，因为它知道执行流程将不会回到正常的控制流。 省略函数结束时的清理代码：通常，函数在返回前需要执行一些清理工作，比如释放局部变量的存储空间。对于标记为 __noreturn的函数，这些清理工作可能被省略。 优化错误处理代码：如果一个函数在错误处理分支中调用 __noreturn函数，编译器可能会优化这些错误处理路径，因为它们不会导致函数的正常返回。 消除不必要的检查：例如，如果一个 __noreturn函数的返回值被用来做条件判断，编译器可能会省略这些检查，因为函数不会返回。 需要注意的是，虽然 __noreturn可以带来一些优化，但它也可能导致一些问题，如果使用不当。例如，如果一个函数被错误地标记为 __noreturn但实际上它可以返回，那么编译器可能会省略一些重要的代码路径，导致未定义的行为。因此，使用 __noreturn时必须非常小心，确保函数确实不会返回。 ","date":"June 9, 2024","img":"https://kingdix10.github.io/covers/lines_multicolored_rainbow_125651_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/misc/optimize_tips/","series":[{"title":"代码技巧","url":"/zh-cn/series/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"代码技巧","url":"/zh-cn/tags/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/"}],"timestamp":1717891200,"title":"Linux内核代码的编写和优化技巧"},{"categories":[{"title":"代码技巧","url":"/zh-cn/categories/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/"}],"content":" 1. 背景 引入jump label的背景，参考Linux: Jump label实现简析\n在内核代码中，有很多分支判断条件，它们在绝大多数情形下，都是不成立的。尽管我们已经加上unlikely修饰来进行优化，但是，读取 condition 仍然要访问内存，仍然需要用到cache；另外，也会CPU分支预测失败。虽然少数这样的代码影响不大，但当这样的条件判断代码（如内核中大量的tracepoint）增多的时候，将对cache会造成很大压力，所有这些代码导致的cache miss，以及CPU分支预测失败，所造成的性能损失，就变得可观起来。因此，内核需要一种方案，来解决这样的问题。这个解决方案，就是本文描述的 Jump label。\n2. 原理简介 struct jump_entry的code记录要修改的地址，target记录需要跳转的地址。\n以arch_static_branch为例，code指向的地址默认为nop指令。当修改struct static_key的值时，从entries找到struct jump_entry，构造一条b l_yes指令，然后写入到code指向的地址。arch_static_branch_jump则正好相反，code指向的地址默认为b l_yes。\n数据 存储位置 struct static_key .bss struct jump_entry .rodata code .text 静态分析时，只能通过反汇编得到struct jump_entry，然后得到struct static_key和代码的地址。如果只知道代码的地址或者struct static_key变量名，没有直接的办法来得到struct jump_entry的地址，只能通过遍历jump_table来找到对应的struct jump_entry。\n动态分析时，可以通过struct static_key，找到struct jump_entry。\n3. struct jump_entry ARM64使能了CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE，struct jump_entry中记录的是偏移量。\n1/// include/linux/jump_label.h 2#ifdef CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE 3 4struct jump_entry { 5 s32 code; 6 s32 target; 7 long key;\t// key may be far away from the core kernel under KASLR 8}; 9 10static inline unsigned long jump_entry_code(const struct jump_entry *entry) 11{ 12 return (unsigned long)\u0026amp;entry-\u0026gt;code + entry-\u0026gt;code; 13} 14 15static inline unsigned long jump_entry_target(const struct jump_entry *entry) 16{ 17 return (unsigned long)\u0026amp;entry-\u0026gt;target + entry-\u0026gt;target; 18} 19 20static inline struct static_key *jump_entry_key(const struct jump_entry *entry) 21{ 22 long offset = entry-\u0026gt;key \u0026amp; ~3L; 23 24 return (struct static_key *)((unsigned long)\u0026amp;entry-\u0026gt;key + offset); 25} 26 27#else 28/// struct jump_entry在arch/$ARCH/include/asm/jump_label.h中定义 29static inline unsigned long jump_entry_code(const struct jump_entry *entry) 30{ 31 return entry-\u0026gt;code; 32} 33 34static inline unsigned long jump_entry_target(const struct jump_entry *entry) 35{ 36 return entry-\u0026gt;target; 37} 38 39static inline struct static_key *jump_entry_key(const struct jump_entry *entry) 40{ 41 return (struct static_key *)((unsigned long)entry-\u0026gt;key \u0026amp; ~3UL); 42} 43 44#endif 4. arch_static_branch和arch_static_branch_jump 默认情况下，arch_static_branch总是返回false，arch_static_branch_jump总是返回true。\n1/// arch/arm64/include/asm/jump_label.h 2static __always_inline bool arch_static_branch(struct static_key * const key, 3 const bool branch) 4{ 5 asm_volatile_goto( 6 /// 声明标号1，对应指令为nop，编译时会优化，运行时直接执行后续代码 7 \u0026#34;1: nop \\n\\t\u0026#34; 8 /// 链接时放到__jump_table段 9 \u0026#34; .pushsection __jump_table, \\\u0026#34;aw\\\u0026#34; \\n\\t\u0026#34; 10 /// struct jump_entry地址按8字节对齐，不同处理器架构可能不一样，但地址都是偶数 11 \u0026#34; .align 3 \\n\\t\u0026#34; 12 /// jump_entry.code记录标号1和当前地址的差值，可能为负值 13 /// jump_entry.target记录当前地址和l_yes的差值，可能为负值 14 \u0026#34; .long 1b - ., %l[l_yes] - . \\n\\t\u0026#34; 15 /// jump_entry.target记录struct static_key和当前地址的差值，低位记录branch 16 /// 运行时可以使用jump_entry_key获取struct static_key的地址 17 \u0026#34; .quad %c0 - . \\n\\t\u0026#34; 18 \u0026#34; .popsection \\n\\t\u0026#34; 19 : : \u0026#34;i\u0026#34;(\u0026amp;((char *)key)[branch]) : : l_yes); 20 21 return false; 22l_yes: 23 return true; 24} 25 26static __always_inline bool arch_static_branch_jump(struct static_key * const key, 27 const bool branch) 28{ 29 asm_volatile_goto( 30 /// 编译时会优化，直接跳转到l_yes执行代码 31 \u0026#34;1: b %l[l_yes] \\n\\t\u0026#34; 32 \u0026#34; .pushsection __jump_table, \\\u0026#34;aw\\\u0026#34; \\n\\t\u0026#34; 33 \u0026#34; .align 3 \\n\\t\u0026#34; 34 \u0026#34; .long 1b - ., %l[l_yes] - . \\n\\t\u0026#34; 35 \u0026#34; .quad %c0 - . \\n\\t\u0026#34; 36 \u0026#34; .popsection \\n\\t\u0026#34; 37 : : \u0026#34;i\u0026#34;(\u0026amp;((char *)key)[branch]) : : l_yes); 38 39 return false; 40l_yes: 41 return true; 42} 特别说明下(\u0026amp;((char *)key)[branch])，这个是取key的地址，并强制转为char *类型。\n当branch = false时，%c0 - .就是key的地址与当前位置的差值。 当branch = true时，%c0 - .是key的地址与当前位置的差值再加1（char *偏移量为1）。 这样最低位就记录了branch的值。\n4.1. struct jump_entry存储位置 从vmlinux.lds可以看到__jump_table在.rodata段。这是链接时的布局，在Linux启动时，jump_label_init会重新对jump_table进行排序。\n1/// aarch64-linux-gnu-objdump -d -j .rodata vmlinux | less 2ffff80008137de00 \u0026lt;__start___jump_table\u0026gt;: 3ffff80008137de00: fec96fd4 .word 0xfec96fd4 4ffff80008137de04: fec96fd8 .word 0xfec96fd8 5ffff80008137de08: 00b132a8 .word 0x00b132a8 6ffff80008137de0c: 00000000 .word 0x00000000 7 8ffff80008137de10: fec9707c .word 0xfec9707c 9ffff80008137de14: fec97090 .word 0xfec97090 10ffff80008137de18: 00a56881 .word 0x00a56881 11ffff80008137de1c: 00000000 .word 0x00000000 5. 从struct jump_entry到struct static_key 根据前边的jump_entry_code、jump_entry_target和jump_entry_key的实现，计算如下：\n1python3 2\u0026gt;\u0026gt;\u0026gt; hex(0xffff80008137de00 - 0x100000000 + 0xfec96fd4) 3\u0026#39;0xffff800080014dd4\u0026#39; /// code 4\u0026gt;\u0026gt;\u0026gt; hex(0xffff80008137de04 - 0x100000000 + 0xfec96fd8) 5\u0026#39;0xffff800080014ddc\u0026#39; /// target 6\u0026gt;\u0026gt;\u0026gt; hex(0xffff80008137de08 + 0x00b132a8) 7\u0026#39;0xffff800081e910b0\u0026#39; /// key 可以看到struct static_key在bss段。使用DEFINE_STATIC_KEY_TRUE和DEFINE_STATIC_KEY_FALSE声明的变量都会在bss段。\n1/// readelf -S vmlinux 2[29] .bss NOBITS ffff800081e2a000 01e39a00 3 4/// aarch64-linux-gnu-nm -n vmlinux | grep -w gic_nonsecure_priorities 5ffff800081e910b0 B gic_nonsecure_priorities 根据反汇编和0xffff800080014dd4这个地址，可以找到代码对应的是arch_local_irq_disable函数。\n1grep -C 20 ffff800080014dd4 vmlinux.dis 6. arch_local_irq_disable源码 1/// arch/arm64/include/asm/irqflags.h 2static inline void arch_local_irq_enable(void) 3{ 4 if (__irqflags_uses_pmr()) { 5 __pmr_local_irq_enable(); 6 } else { 7 __daif_local_irq_enable(); 8 } 9} 10 11static __always_inline void __daif_local_irq_disable(void) 12{ 13 barrier(); 14 asm volatile(\u0026#34;msr daifset, #3\u0026#34;); 15 barrier(); 16} 17 18static __always_inline void __pmr_local_irq_disable(void) 19{ 20 if (IS_ENABLED(CONFIG_ARM64_DEBUG_PRIORITY_MASKING)) { 21 u32 pmr = read_sysreg_s(SYS_ICC_PMR_EL1); 22 WARN_ON_ONCE(pmr != GIC_PRIO_IRQON \u0026amp;\u0026amp; pmr != GIC_PRIO_IRQOFF); 23 } 24 25 barrier(); 26 write_sysreg_s(GIC_PRIO_IRQOFF, SYS_ICC_PMR_EL1); 27 barrier(); 28} 29 30static inline void arch_local_irq_disable(void) 31{ 32 if (__irqflags_uses_pmr()) { 33 __pmr_local_irq_disable(); 34 } else { 35 __daif_local_irq_disable(); 36 } 37} 关注write_sysreg_s(GIC_PRIO_IRQOFF, SYS_ICC_PMR_EL1);。\n1/// arch/arm64/include/asm/sysreg.h 2#define write_sysreg_s(v, r) do {\t\\ 3 u64 __val = (u64)(v);\t\\ 4 u32 __maybe_unused __check_r = (u32)(r);\t\\ 5 asm volatile(__msr_s(r, \u0026#34;%x0\u0026#34;) : : \u0026#34;rZ\u0026#34; (__val));\t\\ 6} while (0) GIC_PRIO_IRQOFF用到了static_branch_unlikely，实际走的是branch = arch_static_branch(\u0026amp;(x)-\u0026gt;key, false)。\n1/// arch/arm64/include/asm/ptrace.h 2/* 3 * PMR values used to mask/unmask interrupts. 4 * 5 * GIC priority masking works as follows: if an IRQ\u0026#39;s priority is a higher value 6 * than the value held in PMR, that IRQ is masked. Lowering the value of PMR 7 * means masking more IRQs (or at least that the same IRQs remain masked). 8 * 9 * To mask interrupts, we clear the most significant bit of PMR. 10 * 11 * Some code sections either automatically switch back to PSR.I or explicitly 12 * require to not use priority masking. If bit GIC_PRIO_PSR_I_SET is included 13 * in the priority mask, it indicates that PSR.I should be set and 14 * interrupt disabling temporarily does not rely on IRQ priorities. 15 */ 16#define GIC_PRIO_IRQON\t0xe0 17#define __GIC_PRIO_IRQOFF\t(GIC_PRIO_IRQON \u0026amp; ~0x80) 18#define __GIC_PRIO_IRQOFF_NS\t0xa0 19#define GIC_PRIO_PSR_I_SET\t(1 \u0026lt;\u0026lt; 4) 20 21#define GIC_PRIO_IRQOFF\t\\ 22 ({\t\\ 23 extern struct static_key_false gic_nonsecure_priorities;\\ 24 u8 __prio = __GIC_PRIO_IRQOFF;\t\\ 25 \\ 26 if (static_branch_unlikely(\u0026amp;gic_nonsecure_priorities))\t\\ 27 __prio = __GIC_PRIO_IRQOFF_NS;\t\\ 28 \\ 29 __prio;\t\\ 30 }) 7. static_branch_likely和static_branch_unlikely 内核文档Documentation/staging/static-keys.rst。\n1 DEPRECATED API: 2 3 The use of \u0026#39;struct static_key\u0026#39; directly, is now DEPRECATED. In addition 4 static_key_{true,false}() is also DEPRECATED. IE DO NOT use the following:: 5 6 struct static_key false = STATIC_KEY_INIT_FALSE; 7 struct static_key true = STATIC_KEY_INIT_TRUE; 8 static_key_true() 9 static_key_false() 10 11 The updated API replacements are:: 12 13 DEFINE_STATIC_KEY_TRUE(key); 14 DEFINE_STATIC_KEY_FALSE(key); 15 DEFINE_STATIC_KEY_ARRAY_TRUE(keys, count); 16 DEFINE_STATIC_KEY_ARRAY_FALSE(keys, count); 17 static_branch_likely() 18 static_branch_unlikely() static_branch_likely和static_branch_unlikely实现，以如下示例代码进行分析。\n1if (x) { 2 codeA 3} else { 4 codeB 5} 详见注释。\n1/// include/linux/jump_label.h 2#ifdef CONFIG_JUMP_LABEL 3 4/* 5 * Combine the right initial value (type) with the right branch order 6 * to generate the desired result. 7 * 8 * 9 * type\\branch| likely (1) | unlikely (0) 10 * -----------+-----------------------+------------------ 11 * | | 12 * true (1) | ... | ... 13 * | NOP | JMP L 14 * | \u0026lt;br-stmts\u0026gt; | 1: ... 15 * | L: ... | 16 * | | 17 * | | L: \u0026lt;br-stmts\u0026gt; 18 * | | jmp 1b 19 * | | 20 * -----------+-----------------------+------------------ 21 * | | 22 * false (0) | ... | ... 23 * | JMP L | NOP 24 * | \u0026lt;br-stmts\u0026gt; | 1: ... 25 * | L: ... | 26 * | | 27 * | | L: \u0026lt;br-stmts\u0026gt; 28 * | | jmp 1b 29 * | | 30 * -----------+-----------------------+------------------ 31 * 32 * The initial value is encoded in the LSB of static_key::entries, 33 * type: 0 = false, 1 = true. 34 * 35 * The branch type is encoded in the LSB of jump_entry::key, 36 * branch: 0 = unlikely, 1 = likely. 37 * 38 * This gives the following logic table: 39 * 40 * enabled type branch instuction 41 * -----------------------------+----------- 42 * 0 0 0 | NOP 43 * 0 0 1 | JMP 44 * 0 1 0 | NOP 45 * 0 1 1 | JMP 46 47 * 1 0 0 | JMP 48 * 1 0 1 | NOP 49 * 1 1 0 | JMP 50 * 1 1 1 | NOP 51 * 52 * Which gives the following functions: 53 * 54 * dynamic: instruction = enabled ^ branch 55 * static: instruction = type ^ branch 56 * 57 * See jump_label_type() / jump_label_init_type(). 58 */ 59 60#define static_branch_likely(x)\t\\ 61({\t\\ 62 bool branch;\t\\ 63 if (__builtin_types_compatible_p(typeof(*x), struct static_key_true))\t\\ 64 /// 1\t1\t1\t| NOP 65 /// x为true的可能性大，直接执行codeA 66 branch = !arch_static_branch(\u0026amp;(x)-\u0026gt;key, true);\t\\ 67 else if (__builtin_types_compatible_p(typeof(*x), struct static_key_false)) \\ 68 /// 0\t0\t1\t| JMP 69 /// x为false的可能性大，更可能直接跳转到codeB，可能把codeB放到codeA之前进行编译 70 branch = !arch_static_branch_jump(\u0026amp;(x)-\u0026gt;key, true);\t\\ 71 else\t\\ 72 branch = ____wrong_branch_error();\t\\ 73 likely_notrace(branch);\t\\ 74}) 75 76#define static_branch_unlikely(x)\t\\ 77({\t\\ 78 bool branch;\t\\ 79 if (__builtin_types_compatible_p(typeof(*x), struct static_key_true))\t\\ 80 /// 1\t1\t0\t| JMP 81 /// x为true的可能性小，直接跳转到codeB的可能性大，可能把codeB放到codeA之前进行编译 82 branch = arch_static_branch_jump(\u0026amp;(x)-\u0026gt;key, false);\t\\ 83 else if (__builtin_types_compatible_p(typeof(*x), struct static_key_false)) \\ 84 /// 0\t0\t0\t| NOP 85 /// x为false的可能性小，执行codeB的可能性小 86 branch = arch_static_branch(\u0026amp;(x)-\u0026gt;key, false);\t\\ 87 else\t\\ 88 branch = ____wrong_branch_error();\t\\ 89 unlikely_notrace(branch);\t\\ 90}) 91 92#else /* !CONFIG_JUMP_LABEL */ 8. 反汇编分析 这里额外做一下说明：\n使用grep -C2 -w arch_local_irq_disable vmlinux.dis可以看到反汇编中有很多bl arch_local_irq_disable，并不是每次调用都进行了内联，而是在单个文件中只有一份汇编指令，函数调用时使用bl指令。 static inline会在.c文件中生成一份指令，inline只是建议编译器进行内联，并不保证内联。\n__irqflags_uses_pmr内有alternative_has_cap_unlikely，编译器进行了代码重排，反汇编中__daif_local_irq_disable在__pmr_local_irq_disable之前。alternative_has_cap_unlikely与arch_static_branch类似，优先返回false。ALTERNATIVE宏也是一种动态代码替换的技术，详见Linux ARM64架构 动态替换 altinstructions。\n重点关注__pmr_local_irq_disable部分汇编代码即可。\n1/// grep -C 20 ffff800080014dd4 vmlinux.dis 2ffff800080014dc8 \u0026lt;arch_local_irq_disable\u0026gt;: 3alternative_has_cap_unlikely(): 4/data/eel/source/kernel/linux-6.6/arch/arm64/include/asm/alternative-macros.h:250 5ffff800080014dc8: d503201f nop /// __irqflags_uses_pmr 6__daif_local_irq_disable(): 7/data/eel/source/kernel/linux-6.6/arch/arm64/include/asm/irqflags.h:62 8ffff800080014dcc: d50343df msr daifset, #0x3 /// __daif_local_irq_disable 9/data/eel/source/kernel/linux-6.6/arch/arm64/include/asm/irqflags.h:64 10ffff800080014dd0: 14000008 b ffff800080014df0 \u0026lt;arch_local_irq_disable+0x28\u0026gt; 11/// 以下开始是__pmr_local_irq_disable的指令 12arch_static_branch(): /// 对应GIC_PRIO_IRQOFF宏，由static_branch_unlikely调用 13/data/eel/source/kernel/linux-6.6/arch/arm64/include/asm/jump_label.h:21 14/// gic_nonsecure_priorities为struct static_key_false，默认取__GIC_PRIO_IRQOFF(0x60) 15/// 使能时，ffff800080014dd4处替换为 b ffff800080014ddc，取__GIC_PRIO_IRQOFF_NS(0xa0) 16ffff800080014dd4: d503201f nop 17ffff800080014dd8: 14000003 b ffff800080014de4 \u0026lt;arch_local_irq_disable+0x1c\u0026gt; 18__pmr_local_irq_disable(): 19/data/eel/source/kernel/linux-6.6/arch/arm64/include/asm/irqflags.h:74 20ffff800080014ddc: 52801400 mov w0, #0xa0 // #160 21ffff800080014de0: 14000002 b ffff800080014de8 \u0026lt;arch_local_irq_disable+0x20\u0026gt; 22ffff800080014de4: 52800c00 mov w0, #0x60 // #96 23ffff800080014de8: 92401c00 and x0, x0, #0xff 24ffff800080014dec: d5184600 msr s3_0_c4_c6_0, x0 25arch_local_irq_disable(): 26/data/eel/source/kernel/linux-6.6/arch/arm64/include/asm/irqflags.h:85 27ffff800080014df0: d65f03c0 ret 与示例代码进行对应：\n1if (static_branch_unlikely(x)) { 2ffff800080014dd4: b ffff800080014ddc /// 默认为nop，需要运行时替换 3} else { 4ffff800080014dd8: b ffff800080014de4 5} 8.1. 执行流 1/// 这部分本质上是__pmr_local_irq_enable的指令 2/// gic_nonsecure_priorities为struct static_key_false，默认取__GIC_PRIO_IRQOFF(0x60) 3/// 使能时，ffff800080014dd4处替换为 b ffff800080014ddc，取__GIC_PRIO_IRQOFF_NS(0xa0) 4默认 替换后 5ffff800080014dd4 ffff800080014dd4 6ffff800080014dd8 ffff800080014ddc * 7ffff800080014de4 ffff800080014de0 * 8ffff800080014de8 ffff800080014de8 9ffff800080014dec ffff800080014dec 10写入0x60 写入0xa0 9. jump_label_init 启动过程中，在jump_label_init中，根据jump_table来初始化static_key。\n1/// kernel/jump_label.c 2void __init jump_label_init(void) 3{ 4 struct jump_entry *iter_start = __start___jump_table; 5 struct jump_entry *iter_stop = __stop___jump_table; 6 struct static_key *key = NULL; 7 struct jump_entry *iter; 8 9 /* 10 * Since we are initializing the static_key.enabled field with 11 * with the \u0026#39;raw\u0026#39; int values (to avoid pulling in atomic.h) in 12 * jump_label.h, let\u0026#39;s make sure that is safe. There are only two 13 * cases to check since we initialize to 0 or 1. 14 */ 15 BUILD_BUG_ON((int)ATOMIC_INIT(0) != 0); 16 BUILD_BUG_ON((int)ATOMIC_INIT(1) != 1); 17 18 if (static_key_initialized) 19 return; 20 21 cpus_read_lock(); 22 jump_label_lock(); 23 /// 按jump_entry指向static_key的地址，将jump_entry进行升序排列 24 jump_label_sort_entries(iter_start, iter_stop); 25 26 for (iter = iter_start; iter \u0026lt; iter_stop; iter++) { 27 struct static_key *iterk; 28 bool in_init; 29 30 /* rewrite NOPs */ 31 if (jump_label_type(iter) == JUMP_LABEL_NOP) 32 arch_jump_label_transform_static(iter, JUMP_LABEL_NOP); 33 34 /// 是不是在__init_begin, __init_end之间 35 in_init = init_section_contains((void *)jump_entry_code(iter), 1); 36 /// in_init的static_key只能在初始化阶段update，见jump_label_update和__jump_label_update 37 jump_entry_set_init(iter, in_init); 38 39 iterk = jump_entry_key(iter); 40 /// 排序后，指向同一static_key的jump_entry会连续存放 41 /// static_key只需记录第一个jump_entry 42 if (iterk == key) 43 continue; 44 45 key = iterk; 46 static_key_set_entries(key, iter); 47 } 48 static_key_initialized = true; 49 jump_label_unlock(); 50 cpus_read_unlock(); 51} 9.1. static_key_set_entries 1/// kernel/jump_label.c 2/*** 3 * A \u0026#39;struct static_key\u0026#39; uses a union such that it either points directly 4 * to a table of \u0026#39;struct jump_entry\u0026#39; or to a linked list of modules which in 5 * turn point to \u0026#39;struct jump_entry\u0026#39; tables. 6 * 7 * The two lower bits of the pointer are used to keep track of which pointer 8 * type is in use and to store the initial branch direction, we use an access 9 * function which preserves these bits. 10 */ 11static void static_key_set_entries(struct static_key *key, 12 struct jump_entry *entries) 13{ 14 unsigned long type; 15 16 WARN_ON_ONCE((unsigned long)entries \u0026amp; JUMP_TYPE_MASK); 17 type = key-\u0026gt;type \u0026amp; JUMP_TYPE_MASK; 18 key-\u0026gt;entries = entries; 19 key-\u0026gt;type |= type; 20} entries和type在union中，这里用低位记录type，高位记录entries。取值时使用掩码进行运算。见static_key_entries、static_key_type、static_key_set_entries等函数。\n1/// include/linux/jump_label.h 2struct static_key { 3 atomic_t enabled; 4#ifdef CONFIG_JUMP_LABEL 5/* 6 * Note: 7 * To make anonymous unions work with old compilers, the static 8 * initialization of them requires brackets. This creates a dependency 9 * on the order of the struct with the initializers. If any fields 10 * are added, STATIC_KEY_INIT_TRUE and STATIC_KEY_INIT_FALSE may need 11 * to be modified. 12 * 13 * bit 0 =\u0026gt; 1 if key is initially true 14 *\t0 if initially false 15 * bit 1 =\u0026gt; 1 if points to struct static_key_mod 16 *\t0 if points to struct jump_entry 17 */ 18 union { 19 unsigned long type; 20 struct jump_entry *entries; 21 struct static_key_mod *next; 22 }; 23#endif\t/* CONFIG_JUMP_LABEL */ 24}; 10. 值的更新 1/// include/kernel/jump_label.h 2/* 3 * Advanced usage; refcount, branch is enabled when: count != 0 4 */ 5 6#define static_branch_inc(x)\tstatic_key_slow_inc(\u0026amp;(x)-\u0026gt;key) 7#define static_branch_dec(x)\tstatic_key_slow_dec(\u0026amp;(x)-\u0026gt;key) 8#define static_branch_inc_cpuslocked(x)\tstatic_key_slow_inc_cpuslocked(\u0026amp;(x)-\u0026gt;key) 9#define static_branch_dec_cpuslocked(x)\tstatic_key_slow_dec_cpuslocked(\u0026amp;(x)-\u0026gt;key) 10 11/* 12 * Normal usage; boolean enable/disable. 13 */ 14 15#define static_branch_enable(x)\tstatic_key_enable(\u0026amp;(x)-\u0026gt;key) 16#define static_branch_disable(x)\tstatic_key_disable(\u0026amp;(x)-\u0026gt;key) 17#define static_branch_enable_cpuslocked(x)\tstatic_key_enable_cpuslocked(\u0026amp;(x)-\u0026gt;key) 18#define static_branch_disable_cpuslocked(x)\tstatic_key_disable_cpuslocked(\u0026amp;(x)-\u0026gt;key) 这些函数最终都会调用jump_label_update，jump_label_update会根据struct static_key找到struct jump_entry，然后进行更新，细节就不具体分析了。\n10.1. 更新时机 根据struct static_key的特性，其更新的时机由如下几种：\n启动阶段使用__setup或early_param 驱动probe时使用module_param 运行时，通过sysfs/procfs/debugfs导出的节点配置 11. 参考资料 内核文档Documentation/staging/static-keys.rst Linux: Jump label实现简析 RISC-V jump_label详解，第 1 部分：技术背景 RISC-V jump_label详解，第2部分：指令编码 RISC-V jump_label详解，第3部分：核心实现 RISC-V jump_label详解，第4部分：运行时代码改写 RISC-V jump_label详解，第5部分：优化案例 RISC-V jump_label详解，第6部分：分析RVC支持 ","date":"May 24, 2024","img":"https://kingdix10.github.io/covers/paint_wall_shabby_135205_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/misc/jump_label/","series":[{"title":"代码技巧","url":"/zh-cn/series/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"代码技巧","url":"/zh-cn/tags/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/"}],"timestamp":1716508800,"title":"ARM64 jump label源码分析"},{"categories":[{"title":"DRM","url":"/zh-cn/categories/drm/"}],"content":" 1. 说明 内核模式驱动：linux-6.6/drivers/accel/ivpu/\n用户模式驱动：https://github.com/intel/linux-npu-driver/releases/tag/v1.2.0\n用户模式库：https://github.com/intel/intel-npu-acceleration-library\n14代intel处理器内置了NPU，使用了drm来管理内存。drm内存管理核心部分如下：\ndrm_mm_init buffer_object 2. drm内存管理初始化 ivpu_mmu_context_init调用drm_mm_init将需要管理的内存范围添加到drm内存管理器。\n1/// linux-6.6/drivers/accel/ivpu/ivpu_mmu_context.c 2static int 3ivpu_mmu_context_init(struct ivpu_device *vdev, struct ivpu_mmu_context *ctx, u32 context_id) 4{ 5\tu64 start, end; 6\tint ret; 7 8\tmutex_init(\u0026amp;ctx-\u0026gt;lock); 9\tINIT_LIST_HEAD(\u0026amp;ctx-\u0026gt;bo_list); 10 11\tret = ivpu_mmu_pgtable_init(vdev, \u0026amp;ctx-\u0026gt;pgtable); 12\tif (ret) 13\treturn ret; 14 15\tif (!context_id) { 16\tstart = vdev-\u0026gt;hw-\u0026gt;ranges.global.start; 17\tend = vdev-\u0026gt;hw-\u0026gt;ranges.shave.end; 18\t} else { 19\tstart = vdev-\u0026gt;hw-\u0026gt;ranges.user.start; 20\tend = vdev-\u0026gt;hw-\u0026gt;ranges.dma.end; 21\t} 22 23\tdrm_mm_init(\u0026amp;ctx-\u0026gt;mm, start, end - start); 24\tctx-\u0026gt;id = context_id; 25 26\treturn 0; 27} 设备内存区域初始化。\n1/// drivers/accel/ivpu/ivpu_hw_40xx.c 2static int ivpu_hw_40xx_info_init(struct ivpu_device *vdev) 3{ 4\t/// ... ... 5\tivpu_pll_init_frequency_ratios(vdev); 6 7\tivpu_hw_init_range(\u0026amp;vdev-\u0026gt;hw-\u0026gt;ranges.global, 0x80000000, SZ_512M); 8\tivpu_hw_init_range(\u0026amp;vdev-\u0026gt;hw-\u0026gt;ranges.user, 0x80000000, SZ_256M); 9\tivpu_hw_init_range(\u0026amp;vdev-\u0026gt;hw-\u0026gt;ranges.shave, 0x80000000 + SZ_256M, SZ_2G - SZ_256M); 10\tivpu_hw_init_range(\u0026amp;vdev-\u0026gt;hw-\u0026gt;ranges.dma, 0x200000000, SZ_8G); 11 12\treturn 0; 13} 3. 文件操作 1/// drivers/accel/ivpu/ivpu_drv.c 2static const struct file_operations ivpu_fops = { 3\t.owner\t= THIS_MODULE, 4\tDRM_ACCEL_FOPS, 5}; 6 7static const struct drm_driver driver = { 8\t.driver_features = DRIVER_GEM | DRIVER_COMPUTE_ACCEL, 9 10\t.open = ivpu_open, 11\t.postclose = ivpu_postclose, 12\t.gem_prime_import = ivpu_gem_prime_import, 13 14#if defined(CONFIG_DEBUG_FS) 15\t.debugfs_init = ivpu_debugfs_init, 16#endif 17 18\t.ioctls = ivpu_drm_ioctls, 19\t.num_ioctls = ARRAY_SIZE(ivpu_drm_ioctls), 20\t.fops = \u0026amp;ivpu_fops, 21 22\t.name = DRIVER_NAME, 23\t.desc = DRIVER_DESC, 24\t.date = DRIVER_DATE, 25\t.major = DRM_IVPU_DRIVER_MAJOR, 26\t.minor = DRM_IVPU_DRIVER_MINOR, 27}; 3.1. open ivpu_open会申请新的struct ivpu_file_priv，也就是每次open都会创建新的struct ivpu_mmu_context，且其id从2开始。\n1/// drivers/accel/ivpu/ivpu_drv.h 2#define IVPU_GLOBAL_CONTEXT_MMU_SSID 0 3/* SSID 1 is used by the VPU to represent invalid context */ 4#define IVPU_USER_CONTEXT_MIN_SSID 2 5#define IVPU_USER_CONTEXT_MAX_SSID (IVPU_USER_CONTEXT_MIN_SSID + 63) 6/// ... ... 7/* 8 * file_priv has its own refcount (ref) that allows user space to close the fd 9 * without blocking even if VPU is still processing some jobs. 10 */ 11struct ivpu_file_priv { 12\tstruct kref ref; 13\tstruct ivpu_device *vdev; 14\tstruct mutex lock; /* Protects cmdq */ 15\tstruct ivpu_cmdq *cmdq[IVPU_NUM_ENGINES]; 16\tstruct ivpu_mmu_context ctx; 17\tu32 priority; 18\tbool has_mmu_faults; 19}; struct ivpu_mmu_context有个struct drm_mm，struct drm_mm管理的范围是user.start - dma.end。\n1/// drivers/accel/ivpu/ivpu_mmu_context.h 2struct ivpu_mmu_context { 3\tstruct mutex lock; /* protects: mm, pgtable, bo_list */ 4\tstruct drm_mm mm; 5\tstruct ivpu_mmu_pgtable pgtable; 6\tstruct list_head bo_list; 7\tu32 id; 8}; 3.2. ioctl ivpu常用的关于buffer object的ioctl如下：\n1/// drivers/accel/ivpu/ivpu_drv.c 2static const struct drm_ioctl_desc ivpu_drm_ioctls[] = { 3\tDRM_IOCTL_DEF_DRV(IVPU_GET_PARAM, ivpu_get_param_ioctl, 0), 4\tDRM_IOCTL_DEF_DRV(IVPU_SET_PARAM, ivpu_set_param_ioctl, 0), 5\tDRM_IOCTL_DEF_DRV(IVPU_BO_CREATE, ivpu_bo_create_ioctl, 0), 6\tDRM_IOCTL_DEF_DRV(IVPU_BO_INFO, ivpu_bo_info_ioctl, 0), 7\tDRM_IOCTL_DEF_DRV(IVPU_SUBMIT, ivpu_submit_ioctl, 0), 8\tDRM_IOCTL_DEF_DRV(IVPU_BO_WAIT, ivpu_bo_wait_ioctl, 0), 9}; 4. mmap 默认使用drm_gem_mmap。\n1/// include/drm/drm_accel.h 2/** 3 * DRM_ACCEL_FOPS - Default drm accelerators file operations 4 * 5 * This macro provides a shorthand for setting the accelerator file ops in the 6 * \u0026amp;file_operations structure. If all you need are the default ops, use 7 * DEFINE_DRM_ACCEL_FOPS instead. 8 */ 9#define DRM_ACCEL_FOPS \\ 10\t.open\t= accel_open,\\ 11\t.release\t= drm_release,\\ 12\t.unlocked_ioctl\t= drm_ioctl,\\ 13\t.compat_ioctl\t= drm_compat_ioctl,\\ 14\t.poll\t= drm_poll,\\ 15\t.read\t= drm_read,\\ 16\t.llseek\t= noop_llseek, \\ 17\t.mmap\t= drm_gem_mmap 5. 用户程序 VPUDriverApi主要对各个文件操作进行封装，如ioctl、mmap。\n1/// linux-npu-driver/umd/vpu_driver/source/os_interface/vpu_driver_api.cpp 2int VPUDriverApi::wait(void *args) const { 3 return doIoctl(DRM_IOCTL_IVPU_BO_WAIT, args); 4} 5 6int VPUDriverApi::closeBuffer(uint32_t handle) const { 7 struct drm_gem_close args = {.handle = handle, .pad = 0}; 8 return doIoctl(DRM_IOCTL_GEM_CLOSE, \u0026amp;args); 9} 10 11int VPUDriverApi::createBuffer(size_t size, 12 uint32_t flags, 13 uint32_t \u0026amp;handle, 14 uint64_t \u0026amp;vpuAddr) const { 15 drm_ivpu_bo_create args = {}; 16 args.size = size; 17 args.flags = flags; 18 19 int ret = doIoctl(DRM_IOCTL_IVPU_BO_CREATE, \u0026amp;args); 20 if (ret) { 21 if (errno == ENOSPC) { 22 LOG_E(\u0026#34;Buffer size is too big.\u0026#34;); 23 } 24 25 LOG_E(\u0026#34;Failed to call DRM_IOCTL_IVPU_BO_CREATE\u0026#34;); 26 return ret; 27 } 28 29 handle = args.handle; 30 vpuAddr = args.vpu_addr; 31 return ret; 32} 33 34int VPUDriverApi::getBufferInfo(uint32_t handle, uint64_t \u0026amp;mmap_offset) const { 35 drm_ivpu_bo_info args = {}; 36 args.handle = handle; 37 38 int ret = doIoctl(DRM_IOCTL_IVPU_BO_INFO, \u0026amp;args); 39 if (ret) { 40 LOG_E(\u0026#34;Failed to call DRM_IOCTL_IVPU_BO_INFO\u0026#34;); 41 return ret; 42 } 43 44 mmap_offset = args.mmap_offset; 45 return ret; 46} 47 48int VPUDriverApi::getExtBufferInfo(uint32_t handle, 49 uint32_t \u0026amp;flags, 50 uint64_t \u0026amp;vpu_address, 51 uint64_t \u0026amp;size, 52 uint64_t \u0026amp;mmap_offset) const { 53 drm_ivpu_bo_info args = {}; 54 args.handle = handle; 55 56 int ret = doIoctl(DRM_IOCTL_IVPU_BO_INFO, \u0026amp;args); 57 if (ret) { 58 LOG_E(\u0026#34;Failed to call DRM_IOCTL_IVPU_BO_INFO\u0026#34;); 59 return ret; 60 } 61 62 flags = args.flags; 63 vpu_address = args.vpu_addr; 64 size = args.size; 65 mmap_offset = args.mmap_offset; 66 return ret; 67} 68 69int VPUDriverApi::exportBuffer(uint32_t handle, uint32_t flags, int32_t \u0026amp;fd) const { 70 drm_prime_handle args = {.handle = handle, .flags = flags, .fd = -1}; 71 72 int ret = doIoctl(DRM_IOCTL_PRIME_HANDLE_TO_FD, \u0026amp;args); 73 if (ret) { 74 LOG_E(\u0026#34;Failed to call DRM_IOCTL_PRIME_HANDLE_TO_FD\u0026#34;); 75 return ret; 76 } 77 78 fd = args.fd; 79 return ret; 80} 81 82int VPUDriverApi::importBuffer(int32_t fd, uint32_t flags, uint32_t \u0026amp;handle) const { 83 drm_prime_handle args = {.handle = 0, .flags = flags, .fd = fd}; 84 85 int ret = doIoctl(DRM_IOCTL_PRIME_FD_TO_HANDLE, \u0026amp;args); 86 if (ret) { 87 LOG_E(\u0026#34;Failed to call DRM_IOCTL_PRIME_FD_TO_HANDLE\u0026#34;); 88 return ret; 89 } 90 91 handle = args.handle; 92 return ret; 93} 94 95void *VPUDriverApi::mmap(size_t size, off_t offset) const { 96 void *ptr = osInfc.osiMmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, vpuFd, offset); 97 if (ptr == MAP_FAILED) { 98 LOG_E(\u0026#34;Failed to mmap the memory using offset received from KMD\u0026#34;); 99 return nullptr; 100 } 101 102 return ptr; 103} 104 105int VPUDriverApi::unmap(void *ptr, size_t size) const { 106 return osInfc.osiMunmap(ptr, size); 107} 5.1. buffer_object操作 buffer_object是drm内存管理的核心概念，用户态操作流程如下：\ncreate bo，使内核态创建buffer object info bo，获取bo的信息，如地址等 mmap，映射内核态bo到用户态 read/write bo，用户态读写数据 1/// linux-npu-driver/umd/vpu_driver/source/memory/vpu_buffer_object.cpp 2std::unique_ptr\u0026lt;VPUBufferObject\u0026gt; 3VPUBufferObject::create(const VPUDriverApi \u0026amp;drvApi, Location type, Type range, size_t size) { 4 uint32_t handle = 0; 5 uint64_t vpuAddr = 0; 6 if (drvApi.createBuffer(size, static_cast\u0026lt;uint32_t\u0026gt;(range), handle, vpuAddr)) { 7 LOG_E(\u0026#34;Failed to allocate memory\u0026#34;); 8 return nullptr; 9 } 10 11 void *ptr = nullptr; 12 uint64_t offset = 0; 13 if (drvApi.getBufferInfo(handle, offset)) { 14 LOG_E(\u0026#34;Failed to get info about buffer\u0026#34;); 15 drvApi.closeBuffer(handle); 16 return nullptr; 17 } 18 19 ptr = drvApi.mmap(size, safe_cast\u0026lt;off_t\u0026gt;(offset)); 20 if (ptr == nullptr) { 21 LOG_E(\u0026#34;Failed to mmap the created buffer\u0026#34;); 22 drvApi.closeBuffer(handle); 23 return nullptr; 24 } 25 /// ptr赋值给VPUBufferObject::basePtr，size赋值给VPUBufferObject::allocSize 26 return std::make_unique\u0026lt;VPUBufferObject\u0026gt;(drvApi, type, range, ptr, size, handle, vpuAddr); 27} 28/// ... ... 29bool VPUBufferObject::copyToBuffer(const void *data, size_t size, uint64_t offset) { 30 if (offset \u0026gt; allocSize) { 31 LOG_E(\u0026#34;Invalid offset value\u0026#34;); 32 return false; 33 } 34 35 uint8_t *dstPtr = basePtr + offset; 36 size_t dstMax = allocSize - offset; 37 38 if (data == nullptr || size == 0 || dstMax == 0 || size \u0026gt; dstMax) { 39 LOG_E(\u0026#34;Invalid arguments. data(%p) size(%ld) dstMax(%ld)\u0026#34;, data, size, dstMax); 40 return false; 41 } 42 43 memcpy(dstPtr, data, size); 44 return true; 45} 6. 跨进程访问 假设用户态有A和B两个进程，B需要访问A申请的buffer ojbect，操作步骤如下：\nA使用DRM_IOCTL_PRIME_HANDLE_TO_FD将fd转为handle 使用进程间通信将handle发送给B B使用DRM_IOCTL_PRIME_FD_TO_HANDLE将handle转为fd，之后使用ioctl等访问buffer object 1/// drivers/gpu/drm/drm_ioctl.c 2DRM_IOCTL_DEF(DRM_IOCTL_PRIME_HANDLE_TO_FD, drm_prime_handle_to_fd_ioctl, DRM_RENDER_ALLOW), 3DRM_IOCTL_DEF(DRM_IOCTL_PRIME_FD_TO_HANDLE, drm_prime_fd_to_handle_ioctl, DRM_RENDER_ALLOW), 6.1. 内核实现 目前只有drivers/gpu/drm/vmwgfx/vmwgfx_drv.c会自定义prime_fd_to_handle和prime_handle_to_fd回调函数。\n1/// drivers/gpu/drm/drm_prime.c 2int drm_prime_fd_to_handle_ioctl(struct drm_device *dev, void *data, 3\tstruct drm_file *file_priv) 4{ 5\tstruct drm_prime_handle *args = data; 6 7\tif (dev-\u0026gt;driver-\u0026gt;prime_fd_to_handle) { 8\treturn dev-\u0026gt;driver-\u0026gt;prime_fd_to_handle(dev, file_priv, args-\u0026gt;fd, 9\t\u0026amp;args-\u0026gt;handle); 10\t} 11 12\treturn drm_gem_prime_fd_to_handle(dev, file_priv, args-\u0026gt;fd, \u0026amp;args-\u0026gt;handle); 13} 14/// ... ... 15int drm_prime_handle_to_fd_ioctl(struct drm_device *dev, void *data, 16\tstruct drm_file *file_priv) 17{ 18\tstruct drm_prime_handle *args = data; 19 20\t/* check flags are valid */ 21\tif (args-\u0026gt;flags \u0026amp; ~(DRM_CLOEXEC | DRM_RDWR)) 22\treturn -EINVAL; 23 24\tif (dev-\u0026gt;driver-\u0026gt;prime_handle_to_fd) { 25\treturn dev-\u0026gt;driver-\u0026gt;prime_handle_to_fd(dev, file_priv, 26\targs-\u0026gt;handle, args-\u0026gt;flags, 27\t\u0026amp;args-\u0026gt;fd); 28\t} 29\treturn drm_gem_prime_handle_to_fd(dev, file_priv, args-\u0026gt;handle, 30\targs-\u0026gt;flags, \u0026amp;args-\u0026gt;fd); 31} 6.1.1. fd_to_handle 6.1.2. handle_to_fd ","date":"April 24, 2024","img":"https://kingdix10.github.io/covers/flowers_leaves_pattern_148777_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/drm/ivpu_drm_mm/","series":[{"title":"DRM","url":"/zh-cn/series/drm/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"},{"title":"内存管理","url":"/zh-cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}],"timestamp":1713916800,"title":"Linux drm mm分析(基于intel ivpu驱动)"},{"categories":[{"title":"系统调用","url":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"}],"content":" 1. 简介 Linux操作系统提供多种服务，这些服务由内核提供，用户态程序通过系统调用与内核进行交互。\n通常来说，标准C库中会为每个系统调用设置一个具有相同名字的函数。从应用程序的角度，可以将系统调用视为C函数。\n系统调用的基本流程如下：\nc库中的函数将参数写入通用寄存器 通过软中断陷入到内核 内核保存寄存器和一些其他上下文 内核根据系统调用号，找到对应的系统调用处理函数，并执行。 执行完成后，再将上下文恢复，并记录返回值，最后返回用户态。 2. 用户态的系统调用分析 musl是一个c标准函数库，这里以musl-v1.2.5的ioctl为例来介绍系统调用的原理。\n1/// src/misc/ioctl.c 2int ioctl(int fd, int req, ...) 3{ 4 void *arg; 5 va_list ap; 6 va_start(ap, req); 7 arg = va_arg(ap, void *); 8 va_end(ap); 9 int r = __syscall(SYS_ioctl, fd, req, arg); 10 if (SIOCGSTAMP != SIOCGSTAMP_OLD \u0026amp;\u0026amp; req \u0026amp;\u0026amp; r==-ENOTTY) { 11 for (int i=0; i\u0026lt;sizeof compat_map/sizeof *compat_map; i++) { 12 if (compat_map[i].new_req != req) continue; 13 union { 14 long long align; 15 char buf[256]; 16 } u; 17 convert_ioctl_struct(\u0026amp;compat_map[i], u.buf, arg, W); 18 r = __syscall(SYS_ioctl, fd, compat_map[i].old_req, u.buf); 19 if (r\u0026lt;0) break; 20 convert_ioctl_struct(\u0026amp;compat_map[i], u.buf, arg, R); 21 break; 22 } 23 } 24 return __syscall_ret(r); 25} 2.1. SYS_ioctl从何而来 1/// ./Makefile 2obj/include/bits/syscall.h: $(srcdir)/arch/$(ARCH)/bits/syscall.h.in 3 cp $\u0026lt; $@ 4 sed -n -e s/__NR_/SYS_/p \u0026lt; $\u0026lt; \u0026gt;\u0026gt; $@ 以aarch64为例，ioctl的系统调用号为29，这个值和内核头文件中的定义一致。\n1/// arch/aarch64/bits/syscall.h.in 2#define __NR_ioctl 29 2.2. 宏展开__syscall 下面来一步步展开__syscall\n1__syscall(SYS_ioctl, fd, req, arg) 2 3/// __VA_ARGS__: SYS_ioctl, fd, req, arg 4__SYSCALL_CONCAT(__syscall, __SYSCALL_NARGS(SYS_ioctl, fd, req, arg))(SYS_ioctl, fd, req, arg) 再看__SYSCALL_NARGS，它的作用是返回参数个数\n1__SYSCALL_NARGS(SYS_ioctl, fd, req, arg) 2/// __VA_ARGS__: SYS_ioctl, fd, req, arg，分别对应a/b/c/d 3/// a b c d e f g h n 4__SYSCALL_NARGS_X(SYS_ioctl, fd, req, arg,7,6,5,4,3,2,1,0,) 最后转换__SYSCALL_CONCAT_X，这是将两个符号连接起来。\n1__SYSCALL_CONCAT_X(__syscall, 3)(SYS_ioctl, fd, req, arg) 2__syscall3(SYS_ioctl, fd, req, arg) __syscall3是一个与体系结构相关的函数，具体参考后边内容。\n2.3. 函数__syscall_ret __syscall_ret的声明在src/internal/syscall.h，实现在src/internal/syscall_ret.c。\n其作用就是返回系统调用的返回值，并对范围做了限定。\n1/// src/internal/syscall.h 2#ifndef __scc 3#define __scc(X) ((long) (X)) 4typedef long syscall_arg_t; 5#endif 6 7/// 看不懂是什么写法，但gcc可以识别，可能只是个函数声明吧 8hidden long __syscall_ret(unsigned long), 9 __syscall_cp(syscall_arg_t, syscall_arg_t, syscall_arg_t, syscall_arg_t, 10 syscall_arg_t, syscall_arg_t, syscall_arg_t); 1/// src/internal/syscall_ret.c 2long __syscall_ret(unsigned long r) 3{ 4 if (r \u0026gt; -4096UL) { 5 errno = -r; 6 return -1; 7 } 8 return r; 9} 3. 用户态与内核态界面 用户态通过软中断来陷入到内核态，但是在触发软中断前，还有一些工作要做。\n3.1. 通用宏__syscall 以__syscall1为例，左侧的__syscall1是宏名称，而右侧的是函数名，这里对用__scc对参数做了强制转换。__syscall0没有参数，直接使用各体系结构定义的函数。注意有些体系结构不支持__syscall7。\n1/// src/internal/syscall.h 2#ifndef __scc 3#define __scc(X) ((long) (X)) 4typedef long syscall_arg_t; 5#endif 6/// ... ... 7#define __syscall1(n,a) __syscall1(n,__scc(a)) 8#define __syscall2(n,a,b) __syscall2(n,__scc(a),__scc(b)) 9#define __syscall3(n,a,b,c) __syscall3(n,__scc(a),__scc(b),__scc(c)) 10#define __syscall4(n,a,b,c,d) __syscall4(n,__scc(a),__scc(b),__scc(c),__scc(d)) 11#define __syscall5(n,a,b,c,d,e) __syscall5(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e)) 12#define __syscall6(n,a,b,c,d,e,f) __syscall6(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f)) 13#define __syscall7(n,a,b,c,d,e,f,g) __syscall7(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f),__scc(g)) 14 15#define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n 16#define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,) 17#define __SYSCALL_CONCAT_X(a,b) a##b 18#define __SYSCALL_CONCAT(a,b) __SYSCALL_CONCAT_X(a,b) 19#define __SYSCALL_DISP(b,...) __SYSCALL_CONCAT(b,__SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__) 20 21#define __syscall(...) __SYSCALL_DISP(__syscall,__VA_ARGS__) 22#define syscall(...) __syscall_ret(__syscall(__VA_ARGS__)) 再来分析__syscall3(SYS_ioctl, fd, req, arg)，这个最终调用体系结构的__syscall3函数。\n3.2. aarch64 系统调用本质上就是填寄存器，之后再调用svc。内核约定使用arm64的x8寄存器来传递系统调用号。\n这些代码的本质就是将系统调用号n放到x8，其他参数按顺序放到x0~x5，然后调用svc 0。\n1/// arch/aarch64/syscall_arch.h 2#define __SYSCALL_LL_E(x) (x) 3#define __SYSCALL_LL_O(x) (x) 4 5#define __asm_syscall(...) do { \\ 6 __asm__ __volatile__ ( \u0026#34;svc 0\u0026#34; \\ 7 : \u0026#34;=r\u0026#34;(x0) : __VA_ARGS__ : \u0026#34;memory\u0026#34;, \u0026#34;cc\u0026#34;); \\ 8 return x0; \\ 9 } while (0) 10 11static inline long __syscall0(long n) 12{ 13 register long x8 __asm__(\u0026#34;x8\u0026#34;) = n; 14 register long x0 __asm__(\u0026#34;x0\u0026#34;); 15 __asm_syscall(\u0026#34;r\u0026#34;(x8)); 16} 17 18static inline long __syscall1(long n, long a) 19{ 20 register long x8 __asm__(\u0026#34;x8\u0026#34;) = n; 21 register long x0 __asm__(\u0026#34;x0\u0026#34;) = a; 22 __asm_syscall(\u0026#34;r\u0026#34;(x8), \u0026#34;0\u0026#34;(x0)); 23} 24 25static inline long __syscall2(long n, long a, long b) 26{ 27 register long x8 __asm__(\u0026#34;x8\u0026#34;) = n; 28 register long x0 __asm__(\u0026#34;x0\u0026#34;) = a; 29 register long x1 __asm__(\u0026#34;x1\u0026#34;) = b; 30 __asm_syscall(\u0026#34;r\u0026#34;(x8), \u0026#34;0\u0026#34;(x0), \u0026#34;r\u0026#34;(x1)); 31} 32/// ... ... 33static inline long __syscall6(long n, long a, long b, long c, long d, long e, long f) 34{ 35 register long x8 __asm__(\u0026#34;x8\u0026#34;) = n; 36 register long x0 __asm__(\u0026#34;x0\u0026#34;) = a; 37 register long x1 __asm__(\u0026#34;x1\u0026#34;) = b; 38 register long x2 __asm__(\u0026#34;x2\u0026#34;) = c; 39 register long x3 __asm__(\u0026#34;x3\u0026#34;) = d; 40 register long x4 __asm__(\u0026#34;x4\u0026#34;) = e; 41 register long x5 __asm__(\u0026#34;x5\u0026#34;) = f; 42 __asm_syscall(\u0026#34;r\u0026#34;(x8), \u0026#34;0\u0026#34;(x0), \u0026#34;r\u0026#34;(x1), \u0026#34;r\u0026#34;(x2), \u0026#34;r\u0026#34;(x3), \u0026#34;r\u0026#34;(x4), \u0026#34;r\u0026#34;(x5)); 43} 3.3. arm 早期的arm使用swi指令来触发软中断，现在也改成了svc。\n1/// arch/arm/syscall_arch.h 2#define __SYSCALL_LL_E(x) \\ 3((union { long long ll; long l[2]; }){ .ll = x }).l[0], \\ 4((union { long long ll; long l[2]; }){ .ll = x }).l[1] 5#define __SYSCALL_LL_O(x) 0, __SYSCALL_LL_E((x)) 6 7#ifdef __thumb__ 8 9/* Avoid use of r7 in asm constraints when producing thumb code, 10 * since it\u0026#39;s reserved as frame pointer and might not be supported. */ 11#define __ASM____R7__ 12#define __asm_syscall(...) do { \\ 13 __asm__ __volatile__ ( \u0026#34;mov %1,r7 ; mov r7,%2 ; svc 0 ; mov r7,%1\u0026#34; \\ 14 : \u0026#34;=r\u0026#34;(r0), \u0026#34;=\u0026amp;r\u0026#34;((int){0}) : __VA_ARGS__ : \u0026#34;memory\u0026#34;); \\ 15 return r0; \\ 16 } while (0) 17 18#else 19 20#define __ASM____R7__ __asm__(\u0026#34;r7\u0026#34;) 21#define __asm_syscall(...) do { \\ 22 __asm__ __volatile__ ( \u0026#34;svc 0\u0026#34; \\ 23 : \u0026#34;=r\u0026#34;(r0) : __VA_ARGS__ : \u0026#34;memory\u0026#34;); \\ 24 return r0; \\ 25 } while (0) 26#endif 27 28/* For thumb2, we can allow 8-bit immediate syscall numbers, saving a 29 * register in the above dance around r7. Does not work for thumb1 where 30 * only movs, not mov, supports immediates, and we can\u0026#39;t use movs because 31 * it doesn\u0026#39;t support high regs. */ 32#ifdef __thumb2__ 33#define R7_OPERAND \u0026#34;rI\u0026#34;(r7) 34#else 35#define R7_OPERAND \u0026#34;r\u0026#34;(r7) 36#endif 37 38static inline long __syscall0(long n) 39{ 40 register long r7 __ASM____R7__ = n; 41 register long r0 __asm__(\u0026#34;r0\u0026#34;); 42 __asm_syscall(R7_OPERAND); 43} 44 45static inline long __syscall1(long n, long a) 46{ 47 register long r7 __ASM____R7__ = n; 48 register long r0 __asm__(\u0026#34;r0\u0026#34;) = a; 49 __asm_syscall(R7_OPERAND, \u0026#34;0\u0026#34;(r0)); 50} 51 52static inline long __syscall2(long n, long a, long b) 53{ 54 register long r7 __ASM____R7__ = n; 55 register long r0 __asm__(\u0026#34;r0\u0026#34;) = a; 56 register long r1 __asm__(\u0026#34;r1\u0026#34;) = b; 57 __asm_syscall(R7_OPERAND, \u0026#34;0\u0026#34;(r0), \u0026#34;r\u0026#34;(r1)); 58} 59/// ... ... 60static inline long __syscall6(long n, long a, long b, long c, long d, long e, long f) 61{ 62 register long r7 __ASM____R7__ = n; 63 register long r0 __asm__(\u0026#34;r0\u0026#34;) = a; 64 register long r1 __asm__(\u0026#34;r1\u0026#34;) = b; 65 register long r2 __asm__(\u0026#34;r2\u0026#34;) = c; 66 register long r3 __asm__(\u0026#34;r3\u0026#34;) = d; 67 register long r4 __asm__(\u0026#34;r4\u0026#34;) = e; 68 register long r5 __asm__(\u0026#34;r5\u0026#34;) = f; 69 __asm_syscall(R7_OPERAND, \u0026#34;0\u0026#34;(r0), \u0026#34;r\u0026#34;(r1), \u0026#34;r\u0026#34;(r2), \u0026#34;r\u0026#34;(r3), \u0026#34;r\u0026#34;(r4), \u0026#34;r\u0026#34;(r5)); 70} 4. 内核入口到invoke_syscall 在汇编阶段，内核会将通用寄存器的值保存到栈空间上的struct pt_regs，在c函数中，会使用栈上的值。\n这里注意local_daif_restore(DAIF_PROCCTX)，与外设产生的中断不同，系统调用在处理过程中会取消中断屏蔽，也就是说系统调用的处理函数是可以睡眠的。\n1/// arch/arm64/kernel/entry-common.c 2static void noinstr el0_svc(struct pt_regs *regs) 3{ 4 enter_from_user_mode(regs); 5 cortex_a76_erratum_1463225_svc_handler(); 6 fp_user_discard(); 7 local_daif_restore(DAIF_PROCCTX); /// 取消DAIF屏蔽，允许中断和异常 8 do_el0_svc(regs); 9 exit_to_user_mode(regs); 10} 以arm64为例，最终就是通过系统调用号和syscall_table找到处理函数，然后调用。\n1/// arch/arm64/kernel/syscall.c 2static long __invoke_syscall(struct pt_regs *regs, syscall_fn_t syscall_fn) 3{ 4 return syscall_fn(regs); 5} 6 7static void invoke_syscall(struct pt_regs *regs, unsigned int scno, 8 unsigned int sc_nr, 9 const syscall_fn_t syscall_table[]) 10{ 11 long ret; 12 13 add_random_kstack_offset(); 14 15 if (scno \u0026lt; sc_nr) { 16 syscall_fn_t syscall_fn; 17 syscall_fn = syscall_table[array_index_nospec(scno, sc_nr)]; 18 ret = __invoke_syscall(regs, syscall_fn); 19 } else { 20 ret = do_ni_syscall(regs, scno); 21 } 22 23 syscall_set_return_value(current, regs, 0, ret); 24 25 /* 26 * Ultimately, this value will get limited by KSTACK_OFFSET_MAX(), 27 * but not enough for arm64 stack utilization comfort. To keep 28 * reasonable stack head room, reduce the maximum offset to 9 bits. 29 * 30 * The actual entropy will be further reduced by the compiler when 31 * applying stack alignment constraints: the AAPCS mandates a 32 * 16-byte (i.e. 4-bit) aligned SP at function boundaries. 33 * 34 * The resulting 5 bits of entropy is seen in SP[8:4]. 35 */ 36 choose_random_kstack_offset(get_random_u16() \u0026amp; 0x1FF); 37} 系统调用的返回值记录在regs-\u0026gt;regs[0]中，在返回用户态时，会将其写入到寄存器，这样用户程序就可以拿到返回值了。\n1/// arch/arm64/include/asm/syscall.h 2static inline void syscall_set_return_value(struct task_struct *task, 3 struct pt_regs *regs, 4 int error, long val) 5{ 6 if (error) 7 val = error; 8 9 if (is_compat_thread(task_thread_info(task))) 10 val = lower_32_bits(val); 11 12 regs-\u0026gt;regs[0] = val; 13} 5. 系统调用表 内核约定使用arm64的x8寄存器来传递系统调用号，由用户态负责填充。\n1/// arch/arm64/kernel/syscall.c 2void do_el0_svc(struct pt_regs *regs) 3{ 4 el0_svc_common(regs, regs-\u0026gt;regs[8], __NR_syscalls, sys_call_table); 5} 6 7#ifdef CONFIG_COMPAT 8void do_el0_svc_compat(struct pt_regs *regs) 9{ 10 el0_svc_common(regs, regs-\u0026gt;regs[7], __NR_compat_syscalls, 11 compat_sys_call_table); 12} 13#endif 5.1. sys_call_table 系统调用函数表的实现巧妙的借助了C语言中的宏来实现，通过对同一个宏进行不同的定义，使得编译器在预处理阶段产生不同的代码，使用尽量少的代码来实现不同的功能。\n1/// arch/arm64/kernel/sys.c 2#undef __SYSCALL 3#define __SYSCALL(nr, sym)\tasmlinkage long __arm64_##sym(const struct pt_regs *); 4#include \u0026lt;asm/unistd.h\u0026gt; 5 6#undef __SYSCALL 7#define __SYSCALL(nr, sym)\t[nr] = __arm64_##sym, 8 9const syscall_fn_t sys_call_table[__NR_syscalls] = { 10 [0 ... __NR_syscalls - 1] = __arm64_sys_ni_syscall, 11#include \u0026lt;asm/unistd.h\u0026gt; 12}; 这里__SYSCALL的定义和#include \u0026lt;asm/unistd.h\u0026gt;是关键。\n以ARM64为例，asm/unistd.h涉及3个文件，三个头文件会依次被上一文件include。\narch/arm64/include/asm/unistd.h arch/arm64/include/uapi/asm/unistd.h，被1包含 include/uapi/asm-generic/unistd.h，被2包含 核心的内容在include/uapi/asm-generic/unistd.h，在包含此文件前，如果定义了__SYSCALL，会按定义的格式生成相关代码。如果没有定义，则__SYSCALL不会有任何代码生成。\n1/// include/uapi/asm-generic/unistd.h 2/* 3 * This file contains the system call numbers, based on the 4 * layout of the x86-64 architecture, which embeds the 5 * pointer to the syscall in the table. 6 * 7 * As a basic principle, no duplication of functionality 8 * should be added, e.g. we don\u0026#39;t use lseek when llseek 9 * is present. New architectures should use this file 10 * and implement the less feature-full calls in user space. 11 */ 12 13#ifndef __SYSCALL 14#define __SYSCALL(x, y) 15#endif 16 17#if __BITS_PER_LONG == 32 || defined(__SYSCALL_COMPAT) 18#define __SC_3264(_nr, _32, _64) __SYSCALL(_nr, _32) 19#else 20#define __SC_3264(_nr, _32, _64) __SYSCALL(_nr, _64) 21#endif 22 23#ifdef __SYSCALL_COMPAT 24#define __SC_COMP(_nr, _sys, _comp) __SYSCALL(_nr, _comp) 25#define __SC_COMP_3264(_nr, _32, _64, _comp) __SYSCALL(_nr, _comp) 26#else 27#define __SC_COMP(_nr, _sys, _comp) __SYSCALL(_nr, _sys) 28#define __SC_COMP_3264(_nr, _32, _64, _comp) __SC_3264(_nr, _32, _64) 29#endif 以ioctl为例解释上述代码\n1#define __NR_ioctl 29 2__SC_COMP(__NR_ioctl, sys_ioctl, compat_sys_ioctl) 分别展开两次宏定义。\n1/// #undef __SYSCALL 2/// #define __SYSCALL(nr, sym)\tasmlinkage long __arm64_##sym(const struct pt_regs *); 3/// #include \u0026lt;asm/unistd.h\u0026gt; 4asmlinkage long __arm64_sys_ioctl(const struct pt_regs *); 5 6#undef __SYSCALL 7#define __SYSCALL(nr, sym)\t[nr] = __arm64_##sym, 8 9const syscall_fn_t sys_call_table[__NR_syscalls] = { 10 [0 ... __NR_syscalls - 1] = __arm64_sys_ni_syscall, 11/// #include \u0026lt;asm/unistd.h\u0026gt; 12 [29] = __arm64_sys_ioctl, 13 [30] = ...; 14}; 总结来说，就是通过两次分别做了一次函数声明，和一次函数指针数组中特定索引赋值。函数声明防止编译器警告或报错，数组赋值是可以使invoke_syscall调用到真正的函数。\n6. 系统调用封装 还是以ioctl为例，其实现在fs/ioctl.c。\n1/// fs/ioctl.c 2SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg) 3{ 4 struct fd f = fdget(fd); 5 int error; 6 7 if (!f.file) 8 return -EBADF; 9 10 error = security_file_ioctl(f.file, cmd, arg); 11 if (error) 12 goto out; 13 14 error = do_vfs_ioctl(f.file, fd, cmd, arg); 15 if (error == -ENOIOCTLCMD) 16 error = vfs_ioctl(f.file, cmd, arg); 17 18out: 19 fdput(f); 20 return error; 21} 从__invoke_syscall的代码可以看到，系统调用的入参都是struct pt_regs指针，而我们看到ioctl没有用到这个指针，这里需要从SYSCALL_DEFINE3的实现来找答案了。\n6.1. SYSCALL_DEFINEx SYSCALL_DEFINEx是系统调用的宏定义，其定义在include/linux/syscalls.h中，体系结构体也可以通过定义__SYSCALL_DEFINEx来改变默认的行为。\n1/// include/linux/syscalls.h 2#ifndef SYSCALL_DEFINE0 3#define SYSCALL_DEFINE0(sname)\t\\ 4 SYSCALL_METADATA(_##sname, 0);\t\\ 5 asmlinkage long sys_##sname(void);\t\\ 6 ALLOW_ERROR_INJECTION(sys_##sname, ERRNO);\t\\ 7 asmlinkage long sys_##sname(void) 8#endif /* SYSCALL_DEFINE0 */ 9 10#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__) 11#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__) 12#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__) 13#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__) 14#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__) 15#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__) 16 17#define SYSCALL_DEFINE_MAXARGS\t6 18 19#define SYSCALL_DEFINEx(x, sname, ...)\t\\ 20 SYSCALL_METADATA(sname, x, __VA_ARGS__)\t\\ 21 __SYSCALL_DEFINEx(x, sname, __VA_ARGS__) 以ARM64为例，__SYSCALL_DEFINEx在arch/arm64/include/asm/syscall_wrapper.h中进行了定义。\n1/// arch/arm64/include/asm/syscall_wrapper.h 2#define __SYSCALL_DEFINEx(x, name, ...)\t\\ 3 asmlinkage long __arm64_sys##name(const struct pt_regs *regs);\t\\ 4 ALLOW_ERROR_INJECTION(__arm64_sys##name, ERRNO);\t\\ 5 static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));\t\\ 6 static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\t\\ 7 asmlinkage long __arm64_sys##name(const struct pt_regs *regs);\t\\ 8 asmlinkage long __arm64_sys##name(const struct pt_regs *regs)\t\\ 9 {\t\\ 10 return __se_sys##name(SC_ARM64_REGS_TO_ARGS(x,__VA_ARGS__));\t\\ 11 }\t\\ 12 static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))\t\\ 13 {\t\\ 14 long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\t\\ 15 __MAP(x,__SC_TEST,__VA_ARGS__);\t\\ 16 __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));\t\\ 17 return ret;\t\\ 18 }\t\\ 19 static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__)) 20 21#define SYSCALL_DEFINE0(sname)\t\\ 22 SYSCALL_METADATA(_##sname, 0);\t\\ 23 asmlinkage long __arm64_sys_##sname(const struct pt_regs *__unused);\t\\ 24 ALLOW_ERROR_INJECTION(__arm64_sys_##sname, ERRNO);\t\\ 25 asmlinkage long __arm64_sys_##sname(const struct pt_regs *__unused) 26 27#define COND_SYSCALL(name)\t\\ 28 asmlinkage long __arm64_sys_##name(const struct pt_regs *regs);\t\\ 29 asmlinkage long __weak __arm64_sys_##name(const struct pt_regs *regs)\t\\ 30 {\t\\ 31 return sys_ni_syscall();\t\\ 32 } 33 34asmlinkage long __arm64_sys_ni_syscall(const struct pt_regs *__unused); 35#define SYS_NI(name) SYSCALL_ALIAS(__arm64_sys_##name, sys_ni_posix_timers); 6.2. ioctl的SYSCALL_DEFINE3展开 1/// SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg) 2 3#define __SYSCALL_DEFINEx(3, _ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg) 4 5/// __arm64_sys_ioctl函数声明，sys_call_table记录的就是这个函数指针。 6asmlinkage long __arm64_sys_ioctl(const struct pt_regs *regs); 7/// 定义CONFIG_FUNCTION_ERROR_INJECTION时会声明一个struct error_injection_entry变量， 8/// 对分析系统调用代码没有影响 9ALLOW_ERROR_INJECTION(__arm64_sys##name, ERRNO); 10/// 3个函数声明 11static long __se_sys_ioctl(__MAP(3,__SC_LONG,__VA_ARGS__)); 12static inline long __do_sys_ioctl(__MAP(3,__SC_DECL,__VA_ARGS__)); 13asmlinkage long __arm64_sys_ioctl(const struct pt_regs *regs); 14/// __arm64_sys_ioctl函数实现，这里入参是struct pt_regs 15asmlinkage long __arm64_sys_ioctl(const struct pt_regs *regs) 16{ 17 /// SC_ARM64_REGS_TO_ARGS展开参数，见下边分析 18 return __se_sys_ioctl(SC_ARM64_REGS_TO_ARGS(3,__VA_ARGS__)); 19} 20/// 这个函数的参数列表都是long或者long long型的，这里目的是要转换成实际的函数参数类型 21static long __se_sys_ioctl(__MAP(3,__SC_LONG,__VA_ARGS__)) 22{ 23 /// __SC_CAST将long型的参数转为代码中声明的实际类型的参数 24 /// 统一将函数返回值转为long 25 long ret = __do_sys_ioctl(__MAP(3,__SC_CAST,__VA_ARGS__)); 26 /// 如果参数类型不是ll或者ull，并且sizeof(t) \u0026gt; sizeof(long)，编译报错 27 __MAP(3,__SC_TEST,__VA_ARGS__); 28 /// 默认为空操作 29 __PROTECT(3, ret,__MAP(x,__SC_ARGS,__VA_ARGS__)); 30 return ret; 31} 32/// 实际函数体定义 33static inline long __do_sys_ioctl(__MAP(x,__SC_DECL,__VA_ARGS__)) 注意最后的static inline long __do_sys_ioctl(__MAP(x,__SC_DECL,__VA_ARGS__))，这个后边没有;，在ioctl的源码中，它的下一个字符是{，是函数体的开始。\n6.3. 宏展开__MAP 1/// arch/arm64/include/asm/syscall_wrapper.h 2/* 3 * __MAP - apply a macro to syscall arguments 4 * __MAP(n, m, t1, a1, t2, a2, ..., tn, an) will expand to 5 * m(t1, a1), m(t2, a2), ..., m(tn, an) 6 * The first argument must be equal to the amount of type/name 7 * pairs given. Note that this list of pairs (i.e. the arguments 8 * of __MAP starting at the third one) is in the same format as 9 * for SYSCALL_DEFINE\u0026lt;n\u0026gt;/COMPAT_SYSCALL_DEFINE\u0026lt;n\u0026gt; 10 */ 11#define __MAP0(m,...) 12#define __MAP1(m,t,a,...) m(t,a) 13#define __MAP2(m,t,a,...) m(t,a), __MAP1(m,__VA_ARGS__) 14#define __MAP3(m,t,a,...) m(t,a), __MAP2(m,__VA_ARGS__) 15#define __MAP4(m,t,a,...) m(t,a), __MAP3(m,__VA_ARGS__) 16#define __MAP5(m,t,a,...) m(t,a), __MAP4(m,__VA_ARGS__) 17#define __MAP6(m,t,a,...) m(t,a), __MAP5(m,__VA_ARGS__) 18#define __MAP(n,...) __MAP##n(__VA_ARGS__) 19 20#define __SC_DECL(t, a)\tt a 21#define __TYPE_AS(t, v)\t__same_type((__force t)0, v) 22#define __TYPE_IS_L(t)\t(__TYPE_AS(t, 0L)) 23#define __TYPE_IS_UL(t)\t(__TYPE_AS(t, 0UL)) 24#define __TYPE_IS_LL(t) (__TYPE_AS(t, 0LL) || __TYPE_AS(t, 0ULL)) 25#define __SC_LONG(t, a) __typeof(__builtin_choose_expr(__TYPE_IS_LL(t), 0LL, 0L)) a 26#define __SC_CAST(t, a)\t(__force t) a 27#define __SC_ARGS(t, a)\ta 28#define __SC_TEST(t, a) (void)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(t) \u0026amp;\u0026amp; sizeof(t) \u0026gt; sizeof(long)) 以ioctl使用的__MAP(3,__SC_DECL,__VA_ARGS__)来解释__MAP宏的作用。\n1/// __MAP(n, m, ...) 2/// __MAP(3,__SC_DECL,__VA_ARGS__) 3__MAP(3,__SC_DECL, unsigned int, fd, unsigned int, cmd, unsigned long, arg) 4__MAP3(__SC_DECL, unsigned int, fd, unsigned int, cmd, unsigned long, arg) 5__SC_DECL(unsigned int, fd), __MAP2(unsigned int, cmd, unsigned long, arg) 6__SC_DECL(unsigned int, fd), __SC_DECL(unsigned int, cmd), __MAP1(unsigned long, arg) 7__SC_DECL(unsigned int, fd), __SC_DECL(unsigned int, cmd), __SC_DECL(unsigned long, arg) 8/// 最终结果 9unsigned int fd, unsigned int cmd, unsigned long arg 6.4. 宏展开SC_ARM64_REGS_TO_ARGS 1/// arch/arm64/include/asm/syscall_wrapper.h 2#define SC_ARM64_REGS_TO_ARGS(x, ...)\t\\ 3\t__MAP(x,__SC_ARGS\t\\ 4\t,,regs-\u0026gt;regs[0],,regs-\u0026gt;regs[1],,regs-\u0026gt;regs[2]\t\\ 5\t,,regs-\u0026gt;regs[3],,regs-\u0026gt;regs[4],,regs-\u0026gt;regs[5]) 这里把参数类型设为空，使用__SC_ARGS来获取变量名，而变量名使用regs-\u0026gt;regs[n]，-\u0026gt;左侧的regs来自__arm64_sys_ioctl的参数，这样就可以把值一个个传递给被调用的函数。\n1__se_sys_ioctl(regs-\u0026gt;regs[0], regs-\u0026gt;regs[1], regs-\u0026gt;regs[2]); ","date":"April 21, 2024","img":"https://kingdix10.github.io/covers/leaves_patterns_autumn_129305_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/syscall/syscall/","series":[{"title":"系统调用","url":"/zh-cn/series/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1713657600,"title":"【Linux内核|系统调用】深度分析系统调用从用户程序到内核的流程"},{"categories":[{"title":"中断管理","url":"/zh-cn/categories/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"content":" 1. 简介 ARM64中断入口相关的代码主要在arch/arm64/kernel/entry.S，启动过程中，会将中断向量表vectors的起始虚拟地址写入到VBAR_EL1。\n当发生中断或者异常时，硬件会保存一些寄存器，然后就是软件的工作：\n进入中断后，根据中断原因，跳转到对应的中断处理函数，这部分是汇编实现。 在中断处理函数中，先通过kernel_entry将寄存器压栈，然后将栈空间记录的struct pt_regs传递给C语言的对应中断处理函数。 完成中断处理后，根据中断发生的异常等级，决定是调用ret_to_user还是ret_to_kernel退出中断，这两个hasn\u0026rsquo;t都是对汇编代码kernel_exit的封装。 1.1. 中断向量基地址寄存器配置 在kernel启动的一开始，会将中断向量表的起始虚拟地址写入到VBAR_EL1。\n1/// arch/arm64/kernel/head.S 2 adr_l\tx8, vectors\t// load VBAR_EL1 with virtual 3 msr\tvbar_el1, x8\t// vector table address 4 isb 2. 中断向量表 根据DEN0024A_v8_architecture_PG描述，后缀t和h表示使用不同的sp指针。意思是捕获异常时所在的异常等级使用的sp寄存器。\nArm Architecture Reference Manual for A-profile architecture\n中断向量一共有四组表，每组有四个异常入口，分别对应同步异常、IRQ、FIQ、SError。\n入口 异常等级切换 运行状态 异常前使用的sp 1 N AArch64 SP_EL0 2 N AArch64 SP_EL1/2/3 3 Y AArch64 SP_EL0 4 Y AArch32 SP_EL0 对于第一组入口，Linux在内核态下不可能使用SP_EL0作为栈指针，所以内核将其handler设置为UNHANDLED。\n3. Linux内核的中断入口 内核的vectors定义如下，通过捕获异常的等级、使用的sp寄存器、异常类型、处理器指令集(AArch32/AArch64)，可以唯一确定要跳转的中断入口。\n1/// arch/arm64/kernel/entry.S 2/* 3 * Exception vectors. 4 */ 5 .pushsection \u0026#34;.entry.text\u0026#34;, \u0026#34;ax\u0026#34; 6 7 .align\t11 8SYM_CODE_START(vectors) 9 /// UNHANDLED 10 kernel_ventry\t1, t, 64, sync\t// Synchronous EL1t 11 kernel_ventry\t1, t, 64, irq\t// IRQ EL1t 12 kernel_ventry\t1, t, 64, fiq\t// FIQ EL1t 13 kernel_ventry\t1, t, 64, error\t// Error EL1t 14 15 /// 中断或异常发送在EL1 16 kernel_ventry\t1, h, 64, sync\t// Synchronous EL1h 17 kernel_ventry\t1, h, 64, irq\t// IRQ EL1h 18 kernel_ventry\t1, h, 64, fiq\t// FIQ EL1h 19 kernel_ventry\t1, h, 64, error\t// Error EL1h 20 21 /// 中断或异常发送在EL0 22 kernel_ventry\t0, t, 64, sync\t// Synchronous 64-bit EL0 23 kernel_ventry\t0, t, 64, irq\t// IRQ 64-bit EL0 24 kernel_ventry\t0, t, 64, fiq\t// FIQ 64-bit EL0 25 kernel_ventry\t0, t, 64, error\t// Error 64-bit EL0 26 27 /// UNHANDLED或中断或异常发送在EL0(AArch32) 28 kernel_ventry\t0, t, 32, sync\t// Synchronous 32-bit EL0 29 kernel_ventry\t0, t, 32, irq\t// IRQ 32-bit EL0 30 kernel_ventry\t0, t, 32, fiq 根据DEN0024A_v8_architecture_PG描述，不同的异常等级，使用的寄存器有所不同。\n3.1. 硬件的工作 进入和退出中断时，硬件完成的工作。\n进入时主要工作如下：\n将处理器状态PSTATE寄存器保存到SPSR_ELx中，其中是捕获异常级别。 将异常返回地址保存到ELR_ELx，其中是捕获异常级别。 设置PSTATE的DAIF为1，关闭调试异常、SError、IRQ和FIQ。 如果是同步异常或SError，将异常信息写入ESR_ELx。 如果是地址访问相关的异常，将导致异常的虚拟地址写入FAR_ELx。 切换到指定异常等级的sp。 将处理器设置到对应的异常等级，然后跳转到异常向量表执行。 软件调用eret退出时： 使用ELR_ELx和SPSR_ELx恢复处理器状态，然后返回到异常发生的位置。\nLearn the architecture - AArch64 Exception Model\n1When an exception is taken, the current state must be preserved so that it can be returned to. The 2PE will automatically preserve the exception return address and the current PSTATE. 3The state stored in the general-purpose registers must be preserved by software. The PE will then 4update the current PSTATE to the one defined in the architecture for that exception type, and 5branch to the exception handler in the vector table. 6The PSTATE the exception was taken from is stored in the System register SPSR_ELx, where \u0026lt;x\u0026gt; is 7the number of the Exception level that the exception was taken to. The exception return address is 8stored in ELR_ELx, where \u0026lt;x\u0026gt; is the Exception level that the exception was taken to. Arm Architecture Reference Manual for A-profile architecture\n4. 中断入口定义：kernel_ventry 1/// arch/arm64/kernel/entry.S 2 .macro kernel_ventry, el:req, ht:req, regsize:req, label:req 3 .align 7 /// 128(2^7)字节对齐 4.Lventry_start\\@: 5 .if\t\\el == 0 6 /* 7 * This must be the first instruction of the EL0 vector entries. It is 8 * skipped by the trampoline vectors, to trigger the cleanup. 9 */ 10 b\t.Lskip_tramp_vectors_cleanup\\@ /// 是跳过清理跳板中断向量表 11 /// 还不清楚跳板中断向量表如何起作用，但是如下指令实际不会走到 12 .if\t\\regsize == 64 13 /// Thread ID registers，TPIDRRO_EL0包含当前处理器的 CPU 编号 14 mrs\tx30, tpidrro_el0 /// 备份tpidrro_el0到x30 15 msr\ttpidrro_el0, xzr /// 清零tpidrro_el0 16 .else 17 mov\tx30, xzr /// 清零x30(w30)，对应AArch32 fiq下的r14(lr) 18 .endif 19.Lskip_tramp_vectors_cleanup\\@: 20 .endif 21 22 sub\tsp, sp, #PT_REGS_SIZE /// 在栈中为struct pt_regs留出空间 23#ifdef CONFIG_VMAP_STACK 24 /// 一些栈溢出相关操作和sp的设置，不影响中断处理流程分析 25#endif 26 b\tel\\el\\ht\\()_\\regsize\\()_\\label /// 跳转到真正的处理函数 27.org .Lventry_start\\@ + 128\t// Did we overflow the ventry slot? kernel_ventry是一个汇编宏，其主要作用如下：\n在栈中为struct pt_regs留出空间 跳转到真正的处理函数，比如代码中b\tel\\el\\ht\\()_\\regsize\\()_\\label 以kernel_ventry\t1, t, 64, sync\t// Synchronous EL1t为例来看一下效果，最后会调用el1t_64_sync\n4.1. entry_handler 中断处理函数使用汇编宏entry_handler进行定义，其代码如下：\n1/// arch/arm64/kernel/entry.S 2 .macro entry_handler el:req, ht:req, regsize:req, label:req 3 /// 定义符号 4SYM_CODE_START_LOCAL(el\\el\\ht\\()_\\regsize\\()_\\label) 5 /// 上下文保存 6 kernel_entry \\el, \\regsize 7 /// 此时sp指向struct pt_regs基地址，将其作为参数传给C语言handler 8 mov\tx0, sp 9 /// 调用C语言handler 10 bl\tel\\el\\ht\\()_\\regsize\\()_\\label\\()_handler 11 .if \\el == 0 12 b\tret_to_user /// 退出中断，返回用户模式 13 .else 14 b\tret_to_kernel /// 退出中断，返回kernel模式 15 .endif 16SYM_CODE_END(el\\el\\ht\\()_\\regsize\\()_\\label) 17 .endm entry_handler宏的主要工作如下：\n调用kernel_entry，其主要工作是上下文保存 调用C语言的handler handler返回后，如果是在EL0发生的中断，调用ret_to_user，否则调用ret_to_kernel。软件处理完成。 以entry_handler\t1, t, 64, sync为例，这一行声明了el1t_64_sync符号，其内部会调用el1t_64_sync_handler。\n1/// arch/arm64/kernel/entry.S 2/* 3 * Early exception handlers 4 */ 5 entry_handler\t1, t, 64, sync 6/// SYM_CODE_START_LOCAL(el1t_64_sync) 7/// ... ... 8/// bl el1t_64_sync_handler 9/// ... ... 10/// SYM_CODE_END(el1t_64_sync) 11 entry_handler\t1, t, 64, irq 12 entry_handler\t1, t, 64, fiq 13 entry_handler\t1, t, 64, error 14 15 entry_handler\t1, h, 64, sync 16 entry_handler\t1, h, 64, irq 17 entry_handler\t1, h, 64, fiq 18 entry_handler\t1, h, 64, error 19 20 entry_handler\t0, t, 64, sync 21 entry_handler\t0, t, 64, irq 22 entry_handler\t0, t, 64, fiq 23 entry_handler\t0, t, 64, error 24 25 entry_handler\t0, t, 32, sync 26 entry_handler\t0, t, 32, irq 27 entry_handler\t0, t, 32, fiq 28 entry_handler\t0, t, 32, error 4.2. 调用C函数前的准备kernel_entry 前边提到，栈顶要存储的是struct pt_regs，这里先看一下其定义。\n1/// arch/arm64/include/asm/ptrace.h 2/* 3 * User structures for general purpose, floating point and debug registers. 4 */ 5struct user_pt_regs { 6 __u64\tregs[31]; 7 __u64\tsp; 8 __u64\tpc; 9 __u64\tpstate; 10}; 11 12/* 13 * This struct defines the way the registers are stored on the stack during an 14 * exception. Note that sizeof(struct pt_regs) has to be a multiple of 16 (for 15 * stack alignment). struct user_pt_regs must form a prefix of struct pt_regs. 16 */ 17struct pt_regs { 18 union { 19 struct user_pt_regs user_regs; 20 struct { 21 u64 regs[31]; 22 u64 sp; 23 u64 pc; 24 u64 pstate; 25 }; 26 }; 27 u64 orig_x0; 28#ifdef __AARCH64EB__ 29 u32 unused2; 30 s32 syscallno; 31#else 32 s32 syscallno; 33 u32 unused2; 34#endif 35 u64 sdei_ttbr1; 36 /* Only valid when ARM64_HAS_GIC_PRIO_MASKING is enabled. */ 37 u64 pmr_save; 38 u64 stackframe[2]; 39 40 /* Only valid for some EL1 exceptions. */ 41 u64 lockdep_hardirqs; 42 u64 exit_rcu; 43}; 继续向下分析之前，先记住tsk，这个代表x28寄存器，用了记录当前进程的struct thread_info。\n1/// arch/arm64/kernel/entry.S 2/* GPRs used by entry code */ 3tsk\t.req\tx28\t// current thread_info 4.2.1. 寄存器压栈 1/// arch/arm64/kernel/entry.S 2 .macro\tkernel_entry, el, regsize = 64 3 .if\t\\el == 0 4 /// 用户模式中断，根据需要，修改PSTATE寄存器 5 alternative_insn nop, SET_PSTATE_DIT(1), ARM64_HAS_DIT 6 .endif 7 .if\t\\regsize == 32 8 mov\tw0, w0\t// zero upper 32 bits of x0 9 .endif 10 /// 下边这些是将寄存器x0~x29压栈，后续可以使用struct pt_regs指针访问 11 stp\tx0, x1, [sp, #16 * 0] 12 stp\tx2, x3, [sp, #16 * 1] 13 stp\tx4, x5, [sp, #16 * 2] 14 stp\tx6, x7, [sp, #16 * 3] 15 stp\tx8, x9, [sp, #16 * 4] 16 stp\tx10, x11, [sp, #16 * 5] 17 stp\tx12, x13, [sp, #16 * 6] 18 stp\tx14, x15, [sp, #16 * 7] 19 stp\tx16, x17, [sp, #16 * 8] 20 stp\tx18, x19, [sp, #16 * 9] 21 stp\tx20, x21, [sp, #16 * 10] 22 stp\tx22, x23, [sp, #16 * 11] 23 stp\tx24, x25, [sp, #16 * 12] 24 stp\tx26, x27, [sp, #16 * 13] 25 stp\tx28, x29, [sp, #16 * 14] 4.2.2. el0和el1的处理 4.2.2.1. EL0 1 .if\t\\el == 0 /// 用户模式中断或异常 2 clear_gp_regs /// 清零x0~x29 3 mrs\tx21, sp_el0 /// x21记录用户模式sp_el0，后续会保存到pt_regs.sp 4 /// __entry_task是一个percpu变量，记录当前cpu的task_struct 5 /// x20作为临时变量 6 /// ldr_this_cpu是将当前cpu的当前task_struct读到tsk(x28) 7 ldr_this_cpu\ttsk, __entry_task, x20 8 msr\tsp_el0, tsk /// sp_el0记录当前进程 9 /* 10 * Ensure MDSCR_EL1.SS is clear, since we can unmask debug exceptions 11 * when scheduling. 12 */ 13 ldr\tx19, [tsk, #TSK_TI_FLAGS] /// 加载thread_info.flags到x19 14 /// 如果进程允许单步调试，关闭MDSCR_EL1的软件单步控制 15 disable_step_tsk x19, x20 16 17 /* Check for asynchronous tag check faults in user space */ 18 ldr\tx0, [tsk, THREAD_SCTLR_USER] /// 加载thread.sctlr_user到x0 19 check_mte_async_tcf x22, x23, x0 /// Check for MTE asynchronous tag check faults 20 21#ifdef CONFIG_ARM64_PTR_AUTH 22 /// ... ... 23#endif 24 25 apply_ssbd 1, x22, x23 26 27 mte_set_kernel_gcr x22, x23 28 29 /* 30 * Any non-self-synchronizing system register updates required for 31 * kernel entry should be placed before this point. 32 */ 33alternative_if ARM64_MTE 34 isb 35 b\t1f 36alternative_else_nop_endif 37alternative_if ARM64_HAS_ADDRESS_AUTH 38 isb 39alternative_else_nop_endif 401: 41 42 scs_load_current __entry_task是一个percpu变量。用于记录当前CPU当前进程的struct task_struct。\n1/// arch/arm64/kernel/process.c 2/* 3 * We store our current task in sp_el0, which is clobbered by userspace. Keep a 4 * shadow copy so that we can restore this upon entry from userspace. 5 * 6 * This is *only* for exception entry from EL0, and is not valid until we 7 * __switch_to() a user task. 8 */ 9DEFINE_PER_CPU(struct task_struct *, __entry_task); 4.2.2.2. EL1 1 .else 2 /// sp + sizeof(struct pt_regs)，x21记录出现异常时的sp，后续会保存到pt_regs.sp 3 add\tx21, sp, #PT_REGS_SIZE 4 /// 将sp_el0读到tsk，后边汇编代码可以用tsk来访问当前task_struct 5 get_current_task tsk 6 .endif /* \\el == 0 */ 4.2.3. 寄存和栈配置 1 mrs\tx22, elr_el1 /// 保存elr_el1 2 mrs\tx23, spsr_el1 /// 保存spsr_el1 3 stp\tlr, x21, [sp, #S_LR] /// lr和sp保存到pt_regs.regs[30](lr)和pt_regs.sp 4 5 /* 6 * For exceptions from EL0, create a final frame record. 7 * For exceptions from EL1, create a synthetic frame record so the 8 * interrupted code shows up in the backtrace. 9 */ 10 .if \\el == 0 11 stp\txzr, xzr, [sp, #S_STACKFRAME] /// 清零pt_regs.stackframe[2]，用于终止栈回溯 12 .else 13 stp\tx29, x22, [sp, #S_STACKFRAME] /// 保存x29和x22(elr_el1)到pt_regs.stackframe[2] 14 .endif 15 add\tx29, sp, #S_STACKFRAME /// x29指向pt_regs.stackframe[2] 16 17#ifdef CONFIG_ARM64_SW_TTBR0_PAN 18 /// ... ... 19#endif 20 21 stp\tx22, x23, [sp, #S_PC] /// 保存elr_el1和spsr_el1到pt_regs.pc和pt_regs.pstate 22 23 /* Not in a syscall by default (el0_svc overwrites for real syscall) */ 24 .if\t\\el == 0 25 mov\tw21, #NO_SYSCALL 26 str\tw21, [sp, #S_SYSCALLNO] 27 .endif 28 29#ifdef CONFIG_ARM64_PSEUDO_NMI 30 /// ... ... 31#endif 32 33 /* 34 * Registers that may be useful after this macro is invoked: 35 * 36 * x20 - ICC_PMR_EL1 37 * x21 - aborted SP 38 * x22 - aborted PC 39 * x23 - aborted PSTATE 40 */ 41 .endm pt_regs.x reg(el1) reg(el0) regs[0] x0 x0 regs[1] x1 x1 \u0026hellip; \u0026hellip; \u0026hellip; regs[29] x29(fp) x29(fp) regs[30] x30(lr) x30(lr) sp sp + PT_REGS_SIZE sp_el0 pc elr_el1 elr_el1 pstate spsr_el1 spsr_el1 orig_x0 unused2 - - syscallno - NO_SYSCALL sdei_ttbr1 - - pmr_save - - stackframe[0] x29 0 stackframe[1] elr_el1 0 lockdep_hardirqs - - exit_rcu - - 做完这些之后，就可以调用C语言的处理函数了。\n5. 中断处理C语言函数 arch/arm64/kernel/entry.S中的汇编代码最终会调用到C语言的handler，这些函数在arch/arm64/kernel/entry-common.c中的定义，对应声明在arch/arm64/include/asm/exception.h中。\n1/// arch/arm64/include/asm/exception.h 2asmlinkage void el1t_64_sync_handler(struct pt_regs *regs); 3asmlinkage void el1t_64_irq_handler(struct pt_regs *regs); 4asmlinkage void el1t_64_fiq_handler(struct pt_regs *regs); 5asmlinkage void el1t_64_error_handler(struct pt_regs *regs); 6 7asmlinkage void el1h_64_sync_handler(struct pt_regs *regs); 8asmlinkage void el1h_64_irq_handler(struct pt_regs *regs); 9asmlinkage void el1h_64_fiq_handler(struct pt_regs *regs); 10asmlinkage void el1h_64_error_handler(struct pt_regs *regs); 11 12asmlinkage void el0t_64_sync_handler(struct pt_regs *regs); 13asmlinkage void el0t_64_irq_handler(struct pt_regs *regs); 14asmlinkage void el0t_64_fiq_handler(struct pt_regs *regs); 15asmlinkage void el0t_64_error_handler(struct pt_regs *regs); 16 17asmlinkage void el0t_32_sync_handler(struct pt_regs *regs); 18asmlinkage void el0t_32_irq_handler(struct pt_regs *regs); 19asmlinkage void el0t_32_fiq_handler(struct pt_regs *regs); 20asmlinkage void el0t_32_error_handler(struct pt_regs *regs); 5.1. UNHANDLED 早期的Linux内核，在vectors直接调用不支持的的handler，比如ventry\tel1_sync_invalid。在linux-6.6中，汇编部分做了通用化，而将差异放到了C语言代码中。\n1/// arch/arm64/kernel/entry-common.c 2#define UNHANDLED(el, regsize, vector)\t\\ 3asmlinkage void noinstr el##_##regsize##_##vector##_handler(struct pt_regs *regs)\t\\ 4{\t\\ 5 const char *desc = #regsize \u0026#34;-bit \u0026#34; #el \u0026#34; \u0026#34; #vector;\t\\ 6 __panic_unhandled(regs, desc, read_sysreg(esr_el1));\t\\ 7} 1UNHANDLED(el1t, 64, sync) /// el1t_64_sync_handler 2UNHANDLED(el1t, 64, irq) /// el1t_64_irq_handler 3UNHANDLED(el1t, 64, fiq) /// el1t_64_fiq_handler 4UNHANDLED(el1t, 64, error) /// el1t_64_error_handler 在未使能CONFIG_COMPAT的情况下，32位中断也是UNHANDLED。\n1#ifdef CONFIG_COMPAT 2 /// ... ... 3#else /* CONFIG_COMPAT */ 4UNHANDLED(el0t, 32, sync) /// el0t_32_sync_handler 5UNHANDLED(el0t, 32, irq) /// el0t_32_irq_handler 6UNHANDLED(el0t, 32, fiq) /// el0t_32_fiq_handler 7UNHANDLED(el0t, 32, error) /// el0t_32_error_handler 8#endif /* CONFIG_COMPAT */ 6. 中断返回 进行一些中断处理的收尾工作，ret_to_kernel和ret_to_user都是直接使用kernel_exit实现的。\n6.1. ret_to_kernel 1SYM_CODE_START_LOCAL(ret_to_kernel) 2 kernel_exit 1 3SYM_CODE_END(ret_to_kernel) 6.2. ret_to_user 1SYM_CODE_START_LOCAL(ret_to_user) 2 /// 加载thread_info.flags到x19 3 ldr\tx19, [tsk, #TSK_TI_FLAGS]\t// re-check for single-step 4 /// call with daif masked 5 /// 如果进程允许单步调试(TIF_SINGLESTEP)，开启MDSCR_EL1的软件单步控制(DBG_MDSCR_SS) 6 enable_step_tsk x19, x2 7#ifdef CONFIG_GCC_PLUGIN_STACKLEAK 8 bl\tstackleak_erase_on_task_stack 9#endif 10 kernel_exit 0 11SYM_CODE_END(ret_to_user) 7. kernel_exit 7.1. el0关闭daif 1/// arch/arm64/kernel/entry.S 2 .macro\tkernel_exit, el 3 .if\t\\el != 0 4 disable_daif /// 屏蔽中断 5 .endif 7.2. 从ELR和SPSR恢复 1#ifdef CONFIG_ARM64_PSEUDO_NMI 2 /// ... ... 3#endif 4 5 ldp\tx21, x22, [sp, #S_PC]\t// load ELR, SPSR 6 7#ifdef CONFIG_ARM64_SW_TTBR0_PAN 8 /// ... ... 9#endif 7.3. el0栈空间处理 1 .if\t\\el == 0 2 ldr\tx23, [sp, #S_SP]\t// load return stack pointer 3 msr\tsp_el0, x23 /// 从栈中恢复sp_el0 4 tst\tx22, #PSR_MODE32_BIT\t// native task? 5 b.eq\t3f 6 7#ifdef CONFIG_ARM64_ERRATUM_845719 8/// ... ... 9#endif 103: 11 scs_save tsk 12 13 /* Ignore asynchronous tag check faults in the uaccess routines */ 14 ldr\tx0, [tsk, THREAD_SCTLR_USER] 15 clear_mte_async_tcf x0 16 17#ifdef CONFIG_ARM64_PTR_AUTH 18/// ... ... 19#endif 20 21 mte_set_user_gcr tsk, x0, x1 22 23 apply_ssbd 0, x0, x1 24 .endif 7.4. 寄存器出栈 1 /// 前边从栈中恢复了ELR和SPSR到x21和x22 2 msr\telr_el1, x21\t// set up the return data 3 msr\tspsr_el1, x22 4 /// 恢复通用寄存器x0~x29 5 ldp\tx0, x1, [sp, #16 * 0] 6 ldp\tx2, x3, [sp, #16 * 1] 7 ldp\tx4, x5, [sp, #16 * 2] 8 ldp\tx6, x7, [sp, #16 * 3] 9 ldp\tx8, x9, [sp, #16 * 4] 10 ldp\tx10, x11, [sp, #16 * 5] 11 ldp\tx12, x13, [sp, #16 * 6] 12 ldp\tx14, x15, [sp, #16 * 7] 13 ldp\tx16, x17, [sp, #16 * 8] 14 ldp\tx18, x19, [sp, #16 * 9] 15 ldp\tx20, x21, [sp, #16 * 10] 16 ldp\tx22, x23, [sp, #16 * 11] 17 ldp\tx24, x25, [sp, #16 * 12] 18 ldp\tx26, x27, [sp, #16 * 13] 19 ldp\tx28, x29, [sp, #16 * 14] 7.5. el0和el1恢复 7.5.1. el0 1 .if\t\\el == 0 2alternative_if ARM64_WORKAROUND_2966298 3 tlbi\tvale1, xzr 4 dsb\tnsh 5alternative_else_nop_endif 6alternative_if_not ARM64_UNMAP_KERNEL_AT_EL0 7 /// 不使能KPTI(Kernel page table isolation) patch 8 ldr\tlr, [sp, #S_LR] /// 中断处理过程中修改了lr，这时恢复用户态lr 9 add\tsp, sp, #PT_REGS_SIZE\t// restore sp 10 eret /// 从异常返回，继续从中断处执行 11alternative_else_nop_endif 12#ifdef CONFIG_UNMAP_KERNEL_AT_EL0 13 msr\tfar_el1, x29 14 15 ldr_this_cpu\tx30, this_cpu_vector, x29 16 tramp_alias\tx29, tramp_exit 17 msr\tvbar_el1, x30\t// install vector table 18 ldr\tlr, [sp, #S_LR]\t// restore x30 19 add\tsp, sp, #PT_REGS_SIZE\t// restore sp 20 br\tx29 21#endif 7.5.2. el1 1 .else 2 ldr\tlr, [sp, #S_LR] /// 中断处理过程中修改了lr，从栈中恢复lr 3 add\tsp, sp, #PT_REGS_SIZE\t// restore sp 4 5 /* Ensure any device/NC reads complete */ 6 alternative_insn nop, \u0026#34;dmb sy\u0026#34;, ARM64_WORKAROUND_1508412 7 8 eret /// 从异常返回 9 .endif 7.6. Speculation barrier 1 sb 2 .endm 1/// arch/arm64/include/asm/assembler.h 2/* 3 * Speculation barrier 4 */ 5 .macro\tsb 6alternative_if_not ARM64_HAS_SB 7 dsb\tnsh 8 isb 9alternative_else 10 SB_BARRIER_INSN 11 nop 12alternative_endif 13 .endm 8. 总结 8.1. daif状态切换 发生异常时，硬件将pstate.daif保存到spsr_el1，屏蔽daif。 中断C函数中，关闭或部分/全部打开。 在kernel_exit中，如果是返回用户态中断，将daif关闭。 硬件从SPSR中恢复原daif状态。 8.2. SP和current Linux内核运行在EL1，sp_el0压栈后，就可以用sp_el0来存放当前task_struct。\n对于el0t_64和el0t_32，是用户态中断，在陷入内核时，通过msr sp_el0, tsk将sp_el0指向了当前task_struct 。 对于el1t_64和el1h_64，是内核态中断，在发生中断前，要么是初始化阶段经设置sp_el0指向init_task，要么是从用户态陷入内核态，sp_el0也指向了当前task_struct 。 ARM上中断栈和内核栈是共享的。每个进程/线程都有自己的内核栈，除init_task外，其他进程/线程在fork时会申请内存作为内核栈，并将sp_el1指向该内核栈，见copy_thread。而在进程第一次运行或被调度后，栈会向下增长。在发生中断时，就会使当前进程/线程的栈向下增长，在中断处理完成后，又逐步将栈还原。\nel1t_64 el1h_64 el0t_64 el0t_32 异常前使用的sp sp_el0 sp_el1 sp_el0 sp_el0 kernel_ventry sp_el1 -= PT_REGS_SIZE sp_el1 -= PT_REGS_SIZE sp_el1 -= PT_REGS_SIZE sp_el1 -= PT_REGS_SIZE kernel_entry add\tx21, sp, #PT_REGS_SIZE add\tx21, sp, #PT_REGS_SIZE mrs\tx21, sp_el0 mrs\tx21, sp_el0 kernel_entry get_current_task tsk get_current_task tsk msr sp_el0, tsk msr sp_el0, tsk kernel_entry stp\tlr, x21, [sp, #S_LR] stp\tlr, x21, [sp, #S_LR] stp\tlr, x21, [sp, #S_LR] stp\tlr, x21, [sp, #S_LR] C语言handler current current current kernel_exit ldr\tx23, [sp, #S_SP] ldr\tx23, [sp, #S_SP] kernel_exit msr\tsp_el0, x23 msr\tsp_el0, x23 kernel_exit sp_el1 += PT_REGS_SIZE sp_el1 += PT_REGS_SIZE sp_el1 += PT_REGS_SIZE sp_el1 += PT_REGS_SIZE 9. 反汇编 这里给出ARM64 vmlinux的反汇编，方便对比源码和最终的指令。\n9.1. vectors 1ffff800080011000 \u0026lt;vectors\u0026gt;: 2vectors(): 3linux-6.6/arch/arm64/kernel/entry.S:517 4/// 由kernel_ventry宏生成 5ffff800080011000: d10543ff sub sp, sp, #0x150 6ffff800080011004: 8b2063ff add sp, sp, x0 7ffff800080011008: cb2063e0 sub x0, sp, x0 8ffff80008001100c: 37700080 tbnz w0, #14, ffff80008001101c \u0026lt;vectors+0x1c\u0026gt; 9ffff800080011010: cb2063e0 sub x0, sp, x0 10ffff800080011014: cb2063ff sub sp, sp, x0 11/// el1t_64_sync由entry_handler声明 12ffff800080011018: 1400021e b ffff800080011890 \u0026lt;el1t_64_sync\u0026gt; 13ffff80008001101c: d51bd040 msr tpidr_el0, x0 14ffff800080011020: cb2063e0 sub x0, sp, x0 15ffff800080011024: d51bd060 msr tpidrro_el0, x0 16ffff800080011028: f000aec0 adrp x0, ffff8000815ec000 \u0026lt;overflow_stack+0xcf0\u0026gt; 17ffff80008001102c: 910c401f add sp, x0, #0x310 18ffff800080011030: d538d080 mrs x0, tpidr_el1 19ffff800080011034: 8b2063ff add sp, sp, x0 20ffff800080011038: d53bd040 mrs x0, tpidr_el0 21ffff80008001103c: cb2063e0 sub x0, sp, x0 22ffff800080011040: f274cc1f tst x0, #0xfffffffffffff000 23ffff800080011044: 54003de1 b.ne ffff800080011800 \u0026lt;__bad_stack\u0026gt; // b.any 24ffff800080011048: cb2063ff sub sp, sp, x0 25ffff80008001104c: d53bd060 mrs x0, tpidrro_el0 26ffff800080011050: 14000210 b ffff800080011890 \u0026lt;el1t_64_sync\u0026gt; 27 ... 28linux-6.6/arch/arm64/kernel/entry.S:518 29ffff800080011080: d10543ff sub sp, sp, #0x150 30ffff800080011084: 8b2063ff add sp, sp, x0 31ffff800080011088: cb2063e0 sub x0, sp, x0 32ffff80008001108c: 37700080 tbnz w0, #14, ffff80008001109c \u0026lt;vectors+0x9c\u0026gt; 33ffff800080011090: cb2063e0 sub x0, sp, x0 34ffff800080011094: cb2063ff sub sp, sp, x0 35ffff800080011098: 1400021e b ffff800080011910 \u0026lt;el1t_64_irq\u0026gt; 36ffff80008001109c: d51bd040 msr tpidr_el0, x0 37ffff8000800110a0: cb2063e0 sub x0, sp, x0 38ffff8000800110a4: d51bd060 msr tpidrro_el0, x0 39ffff8000800110a8: f000aec0 adrp x0, ffff8000815ec000 \u0026lt;overflow_stack+0xcf0\u0026gt; 40ffff8000800110ac: 910c401f add sp, x0, #0x310 41ffff8000800110b0: d538d080 mrs x0, tpidr_el1 42ffff8000800110b4: 8b2063ff add sp, sp, x0 43ffff8000800110b8: d53bd040 mrs x0, tpidr_el0 44ffff8000800110bc: cb2063e0 sub x0, sp, x0 45ffff8000800110c0: f274cc1f tst x0, #0xfffffffffffff000 46ffff8000800110c4: 540039e1 b.ne ffff800080011800 \u0026lt;__bad_stack\u0026gt; // b.any 47ffff8000800110c8: cb2063ff sub sp, sp, x0 48ffff8000800110cc: d53bd060 mrs x0, tpidrro_el0 49ffff8000800110d0: 14000210 b ffff800080011910 \u0026lt;el1t_64_irq\u0026gt; 50 51/// ... ... 52/data/eel/source/kernel/linux-6.6/arch/arm64/kernel/entry.S:527 53ffff800080011400: 14000003 b ffff80008001140c \u0026lt;vectors+0x40c\u0026gt; 54ffff800080011404: d53bd07e mrs x30, tpidrro_el0 55ffff800080011408: d51bd07f msr tpidrro_el0, xzr 56ffff80008001140c: d10543ff sub sp, sp, #0x150 57ffff800080011410: 8b2063ff add sp, sp, x0 58ffff800080011414: cb2063e0 sub x0, sp, x0 59ffff800080011418: 37700080 tbnz w0, #14, ffff800080011428 \u0026lt;vectors+0x428\u0026gt; 60ffff80008001141c: cb2063e0 sub x0, sp, x0 61ffff800080011420: cb2063ff sub sp, sp, x0 62ffff800080011424: 1400021b b ffff800080011c90 \u0026lt;el0t_64_sync\u0026gt; 63ffff800080011428: d51bd040 msr tpidr_el0, x0 64ffff80008001142c: cb2063e0 sub x0, sp, x0 65ffff800080011430: d51bd060 msr tpidrro_el0, x0 66ffff800080011434: f000aec0 adrp x0, ffff8000815ec000 \u0026lt;overflow_stack+0xcf0\u0026gt; 67ffff800080011438: 910c401f add sp, x0, #0x310 68ffff80008001143c: d538d080 mrs x0, tpidr_el1 69ffff800080011440: 8b2063ff add sp, sp, x0 70ffff800080011444: d53bd040 mrs x0, tpidr_el0 71ffff800080011448: cb2063e0 sub x0, sp, x0 72ffff80008001144c: f274cc1f tst x0, #0xfffffffffffff000 73ffff800080011450: 54001d81 b.ne ffff800080011800 \u0026lt;__bad_stack\u0026gt; // b.any 74ffff800080011454: cb2063ff sub sp, sp, x0 75ffff800080011458: d53bd060 mrs x0, tpidrro_el0 76ffff80008001145c: 1400020d b ffff800080011c90 \u0026lt;el0t_64_sync\u0026gt; 77 ... 9.2. el1t_64_sync和el1t_64_irq 1/// el1t_64_sync由entry_handler声明 2ffff800080011890 \u0026lt;el1t_64_sync\u0026gt;: 3el1t_64_sync(): 4linux-6.6/arch/arm64/kernel/entry.S:585 5/// kernel_entry生成 6ffff800080011890: a90007e0 stp x0, x1, [sp] 7ffff800080011894: a9010fe2 stp x2, x3, [sp, #16] 8ffff800080011898: a90217e4 stp x4, x5, [sp, #32] 9ffff80008001189c: a9031fe6 stp x6, x7, [sp, #48] 10ffff8000800118a0: a90427e8 stp x8, x9, [sp, #64] 11ffff8000800118a4: a9052fea stp x10, x11, [sp, #80] 12ffff8000800118a8: a90637ec stp x12, x13, [sp, #96] 13ffff8000800118ac: a9073fee stp x14, x15, [sp, #112] 14ffff8000800118b0: a90847f0 stp x16, x17, [sp, #128] 15ffff8000800118b4: a9094ff2 stp x18, x19, [sp, #144] 16ffff8000800118b8: a90a57f4 stp x20, x21, [sp, #160] 17ffff8000800118bc: a90b5ff6 stp x22, x23, [sp, #176] 18ffff8000800118c0: a90c67f8 stp x24, x25, [sp, #192] 19ffff8000800118c4: a90d6ffa stp x26, x27, [sp, #208] 20ffff8000800118c8: a90e77fc stp x28, x29, [sp, #224] 21ffff8000800118cc: 910543f5 add x21, sp, #0x150 22ffff8000800118d0: d538411c mrs x28, sp_el0 23ffff8000800118d4: d5384036 mrs x22, elr_el1 24ffff8000800118d8: d5384017 mrs x23, spsr_el1 25ffff8000800118dc: a90f57fe stp x30, x21, [sp, #240] 26ffff8000800118e0: a9135bfd stp x29, x22, [sp, #304] 27ffff8000800118e4: 9104c3fd add x29, sp, #0x130 28ffff8000800118e8: a9105ff6 stp x22, x23, [sp, #256] 29ffff8000800118ec: 14000005 b ffff800080011900 \u0026lt;el1t_64_sync+0x70\u0026gt; 30ffff8000800118f0: d5384614 mrs x20, s3_0_c4_c6_0 31ffff8000800118f4: f90097f4 str x20, [sp, #296] 32ffff8000800118f8: d2801e14 mov x20, #0xf0 // #240 33ffff8000800118fc: d5184614 msr s3_0_c4_c6_0, x20 34ffff800080011900: 910003e0 mov x0, sp 35/// 调用C语言处理函数 36ffff800080011904: 94364225 bl ffff800080da2198 \u0026lt;el1t_64_sync_handler\u0026gt; 37/// 中断返回 38ffff800080011908: 1400043a b ffff8000800129f0 \u0026lt;ret_to_kernel\u0026gt; 39ffff80008001190c: d503201f nop 40 41ffff800080011910 \u0026lt;el1t_64_irq\u0026gt;: 42el1t_64_irq(): 43linux-6.6/arch/arm64/kernel/entry.S:586 44ffff800080011910: a90007e0 stp x0, x1, [sp] 45ffff800080011914: a9010fe2 stp x2, x3, [sp, #16] 46ffff800080011918: a90217e4 stp x4, x5, [sp, #32] 47ffff80008001191c: a9031fe6 stp x6, x7, [sp, #48] 48ffff800080011920: a90427e8 stp x8, x9, [sp, #64] 49ffff800080011924: a9052fea stp x10, x11, [sp, #80] 50ffff800080011928: a90637ec stp x12, x13, [sp, #96] 51ffff80008001192c: a9073fee stp x14, x15, [sp, #112] 52ffff800080011930: a90847f0 stp x16, x17, [sp, #128] 53ffff800080011934: a9094ff2 stp x18, x19, [sp, #144] 54ffff800080011938: a90a57f4 stp x20, x21, [sp, #160] 55ffff80008001193c: a90b5ff6 stp x22, x23, [sp, #176] 56ffff800080011940: a90c67f8 stp x24, x25, [sp, #192] 57ffff800080011944: a90d6ffa stp x26, x27, [sp, #208] 58ffff800080011948: a90e77fc stp x28, x29, [sp, #224] 59ffff80008001194c: 910543f5 add x21, sp, #0x150 60ffff800080011950: d538411c mrs x28, sp_el0 61ffff800080011954: d5384036 mrs x22, elr_el1 62ffff800080011958: d5384017 mrs x23, spsr_el1 63ffff80008001195c: a90f57fe stp x30, x21, [sp, #240] 64ffff800080011960: a9135bfd stp x29, x22, [sp, #304] 65ffff800080011964: 9104c3fd add x29, sp, #0x130 66ffff800080011968: a9105ff6 stp x22, x23, [sp, #256] 67ffff80008001196c: 14000005 b ffff800080011980 \u0026lt;el1t_64_irq+0x70\u0026gt; 68ffff800080011970: d5384614 mrs x20, s3_0_c4_c6_0 69ffff800080011974: f90097f4 str x20, [sp, #296] 70ffff800080011978: d2801e14 mov x20, #0xf0 // #240 71ffff80008001197c: d5184614 msr s3_0_c4_c6_0, x20 72ffff800080011980: 910003e0 mov x0, sp 73/// 调用C语言处理函数 74ffff800080011984: 9436420d bl ffff800080da21b8 \u0026lt;el1t_64_irq_handler\u0026gt; 75/// 中断返回 76ffff800080011988: 1400041a b ffff8000800129f0 \u0026lt;ret_to_kernel\u0026gt; 77ffff80008001198c: d503201f nop 9.3. el0t_64_sync 1ffff800080011c90 \u0026lt;el0t_64_sync\u0026gt;: 2el0t_64_sync(): 3linux-6.6/arch/arm64/kernel/entry.S:595 4ffff800080011c90: d503201f nop 5ffff800080011c94: a90007e0 stp x0, x1, [sp] 6ffff800080011c98: a9010fe2 stp x2, x3, [sp, #16] 7ffff800080011c9c: a90217e4 stp x4, x5, [sp, #32] 8ffff800080011ca0: a9031fe6 stp x6, x7, [sp, #48] 9ffff800080011ca4: a90427e8 stp x8, x9, [sp, #64] 10ffff800080011ca8: a9052fea stp x10, x11, [sp, #80] 11ffff800080011cac: a90637ec stp x12, x13, [sp, #96] 12ffff800080011cb0: a9073fee stp x14, x15, [sp, #112] 13ffff800080011cb4: a90847f0 stp x16, x17, [sp, #128] 14ffff800080011cb8: a9094ff2 stp x18, x19, [sp, #144] 15ffff800080011cbc: a90a57f4 stp x20, x21, [sp, #160] 16ffff800080011cc0: a90b5ff6 stp x22, x23, [sp, #176] 17ffff800080011cc4: a90c67f8 stp x24, x25, [sp, #192] 18ffff800080011cc8: a90d6ffa stp x26, x27, [sp, #208] 19ffff800080011ccc: a90e77fc stp x28, x29, [sp, #224] 20/// 用户态中断，重置部分通用寄存器 21ffff800080011cd0: aa1f03e0 mov x0, xzr 22ffff800080011cd4: aa1f03e1 mov x1, xzr 23ffff800080011cd8: aa1f03e2 mov x2, xzr 24ffff800080011cdc: aa1f03e3 mov x3, xzr 25ffff800080011ce0: aa1f03e4 mov x4, xzr 26ffff800080011ce4: aa1f03e5 mov x5, xzr 27ffff800080011ce8: aa1f03e6 mov x6, xzr 28ffff800080011cec: aa1f03e7 mov x7, xzr 29ffff800080011cf0: aa1f03e8 mov x8, xzr 30ffff800080011cf4: aa1f03e9 mov x9, xzr 31ffff800080011cf8: aa1f03ea mov x10, xzr 32ffff800080011cfc: aa1f03eb mov x11, xzr 33ffff800080011d00: aa1f03ec mov x12, xzr 34ffff800080011d04: aa1f03ed mov x13, xzr 35ffff800080011d08: aa1f03ee mov x14, xzr 36ffff800080011d0c: aa1f03ef mov x15, xzr 37ffff800080011d10: aa1f03f0 mov x16, xzr 38ffff800080011d14: aa1f03f1 mov x17, xzr 39ffff800080011d18: aa1f03f2 mov x18, xzr 40ffff800080011d1c: aa1f03f3 mov x19, xzr 41ffff800080011d20: aa1f03f4 mov x20, xzr 42ffff800080011d24: aa1f03f5 mov x21, xzr 43ffff800080011d28: aa1f03f6 mov x22, xzr 44ffff800080011d2c: aa1f03f7 mov x23, xzr 45ffff800080011d30: aa1f03f8 mov x24, xzr 46ffff800080011d34: aa1f03f9 mov x25, xzr 47ffff800080011d38: aa1f03fa mov x26, xzr 48ffff800080011d3c: aa1f03fb mov x27, xzr 49ffff800080011d40: aa1f03fc mov x28, xzr 50ffff800080011d44: aa1f03fd mov x29, xzr 51ffff800080011d48: d5384115 mrs x21, sp_el0 52ffff800080011d4c: d000aedc adrp x28, ffff8000815eb000 \u0026lt;this_cpu_vector\u0026gt; 53ffff800080011d50: 910c239c add x28, x28, #0x308 54ffff800080011d54: d538d094 mrs x20, tpidr_el1 55ffff800080011d58: f8746b9c ldr x28, [x28, x20] 56ffff800080011d5c: d518411c msr sp_el0, x28 57ffff800080011d60: f9400393 ldr x19, [x28] 58ffff800080011d64: 36a800b3 tbz w19, #21, ffff800080011d78 \u0026lt;el0t_64_sync+0xe8\u0026gt; 59ffff800080011d68: d5300254 mrs x20, mdscr_el1 60ffff800080011d6c: 927ffa94 and x20, x20, #0xfffffffffffffffe 61ffff800080011d70: d5100254 msr mdscr_el1, x20 62ffff800080011d74: d5033fdf isb 63ffff800080011d78: f9476b80 ldr x0, [x28, #3792] 64ffff800080011d7c: 14000007 b ffff800080011d98 \u0026lt;el0t_64_sync+0x108\u0026gt; 65ffff800080011d80: b63800c0 tbz x0, #39, ffff800080011d98 \u0026lt;el0t_64_sync+0x108\u0026gt; 66ffff800080011d84: d5385636 mrs x22, tfsre0_el1 67ffff800080011d88: 36000096 tbz w22, #0, ffff800080011d98 \u0026lt;el0t_64_sync+0x108\u0026gt; 68ffff800080011d8c: d2800416 mov x22, #0x20 // #32 69ffff800080011d90: 91000397 add x23, x28, #0x0 70ffff800080011d94: f83632ff stset x22, [x23] 71ffff800080011d98: d503201f nop 72ffff800080011d9c: d503201f nop 73ffff800080011da0: d503201f nop 74ffff800080011da4: d503201f nop 75ffff800080011da8: d503201f nop 76ffff800080011dac: d503201f nop 77ffff800080011db0: d503201f nop 78ffff800080011db4: d503201f nop 79ffff800080011db8: d503201f nop 80ffff800080011dbc: d503201f nop 81ffff800080011dc0: 1400000b b ffff800080011dec \u0026lt;el0t_64_sync+0x15c\u0026gt; 82ffff800080011dc4: d000aed7 adrp x23, ffff8000815eb000 \u0026lt;this_cpu_vector\u0026gt; 83ffff800080011dc8: 9100a2f7 add x23, x23, #0x28 84ffff800080011dcc: d538d096 mrs x22, tpidr_el1 85ffff800080011dd0: f8766af7 ldr x23, [x23, x22] 86ffff800080011dd4: b40000d7 cbz x23, ffff800080011dec \u0026lt;el0t_64_sync+0x15c\u0026gt; 87ffff800080011dd8: f9400397 ldr x23, [x28] 88ffff800080011ddc: 37c80097 tbnz w23, #25, ffff800080011dec \u0026lt;el0t_64_sync+0x15c\u0026gt; 89ffff800080011de0: 32013fe0 mov w0, #0x80007fff // #-2147450881 90ffff800080011de4: 52800021 mov w1, #0x1 // #1 91ffff800080011de8: d503201f nop 92ffff800080011dec: d503201f nop 93ffff800080011df0: d503201f nop 94ffff800080011df4: d503201f nop 95ffff800080011df8: d5384036 mrs x22, elr_el1 96ffff800080011dfc: d5384017 mrs x23, spsr_el1 97ffff800080011e00: a90f57fe stp x30, x21, [sp, #240] 98ffff800080011e04: a9137fff stp xzr, xzr, [sp, #304] 99ffff800080011e08: 9104c3fd add x29, sp, #0x130 100ffff800080011e0c: a9105ff6 stp x22, x23, [sp, #256] 101ffff800080011e10: 12800015 mov w21, #0xffffffff // #-1 102ffff800080011e14: b9011bf5 str w21, [sp, #280] 103ffff800080011e18: 14000005 b ffff800080011e2c \u0026lt;el0t_64_sync+0x19c\u0026gt; 104ffff800080011e1c: d5384614 mrs x20, s3_0_c4_c6_0 105ffff800080011e20: f90097f4 str x20, [sp, #296] 106ffff800080011e24: d2801e14 mov x20, #0xf0 // #240 107ffff800080011e28: d5184614 msr s3_0_c4_c6_0, x20 108ffff800080011e2c: 910003e0 mov x0, sp 109/// 调用C语言处理函数 110ffff800080011e30: 94364160 bl ffff800080da23b0 \u0026lt;el0t_64_sync_handler\u0026gt; 111/// 中断返回 112ffff800080011e34: 1400030d b ffff800080012a68 \u0026lt;ret_to_user\u0026gt; 9.4. ret_to_kernel 1ffff8000800129f0 \u0026lt;ret_to_kernel\u0026gt;: 2ret_to_kernel(): 3linux-6.6/arch/arm64/kernel/entry.S:606 4ffff8000800129f0: d5034fdf msr daifset, #0xf 5ffff8000800129f4: 14000004 b ffff800080012a04 \u0026lt;ret_to_kernel+0x14\u0026gt; 6ffff8000800129f8: f94097f4 ldr x20, [sp, #296] 7ffff8000800129fc: d5184614 msr s3_0_c4_c6_0, x20 8ffff800080012a00: d5033f9f dsb sy 9ffff800080012a04: a9505bf5 ldp x21, x22, [sp, #256] 10ffff800080012a08: d5184035 msr elr_el1, x21 11ffff800080012a0c: d5184016 msr spsr_el1, x22 12ffff800080012a10: a94007e0 ldp x0, x1, [sp] 13ffff800080012a14: a9410fe2 ldp x2, x3, [sp, #16] 14ffff800080012a18: a94217e4 ldp x4, x5, [sp, #32] 15ffff800080012a1c: a9431fe6 ldp x6, x7, [sp, #48] 16ffff800080012a20: a94427e8 ldp x8, x9, [sp, #64] 17ffff800080012a24: a9452fea ldp x10, x11, [sp, #80] 18ffff800080012a28: a94637ec ldp x12, x13, [sp, #96] 19ffff800080012a2c: a9473fee ldp x14, x15, [sp, #112] 20ffff800080012a30: a94847f0 ldp x16, x17, [sp, #128] 21ffff800080012a34: a9494ff2 ldp x18, x19, [sp, #144] 22ffff800080012a38: a94a57f4 ldp x20, x21, [sp, #160] 23ffff800080012a3c: a94b5ff6 ldp x22, x23, [sp, #176] 24ffff800080012a40: a94c67f8 ldp x24, x25, [sp, #192] 25ffff800080012a44: a94d6ffa ldp x26, x27, [sp, #208] 26ffff800080012a48: a94e77fc ldp x28, x29, [sp, #224] 27ffff800080012a4c: f9407bfe ldr x30, [sp, #240] 28ffff800080012a50: 910543ff add sp, sp, #0x150 29ffff800080012a54: d503201f nop 30/// 从异常返回 31ffff800080012a58: d69f03e0 eret 32ffff800080012a5c: d503379f dsb nsh 33ffff800080012a60: d5033fdf isb 34ffff800080012a64: d503201f nop 9.5. ret_to_user 1ffff800080012a68 \u0026lt;ret_to_user\u0026gt;: 2ret_to_user(): 3linux-6.6/arch/arm64/kernel/entry.S:610 4ffff800080012a68: f9400393 ldr x19, [x28] 5linux-6.6/arch/arm64/kernel/entry.S:611 6ffff800080012a6c: 36a80093 tbz w19, #21, ffff800080012a7c \u0026lt;ret_to_user+0x14\u0026gt; 7ffff800080012a70: d5300242 mrs x2, mdscr_el1 8ffff800080012a74: b2400042 orr x2, x2, #0x1 9ffff800080012a78: d5100242 msr mdscr_el1, x2 10linux-6.6/arch/arm64/kernel/entry.S:615 11ffff800080012a7c: 14000004 b ffff800080012a8c \u0026lt;ret_to_user+0x24\u0026gt; 12ffff800080012a80: f94097f4 ldr x20, [sp, #296] 13ffff800080012a84: d5184614 msr s3_0_c4_c6_0, x20 14ffff800080012a88: d5033f9f dsb sy 15ffff800080012a8c: a9505bf5 ldp x21, x22, [sp, #256] 16ffff800080012a90: f9407ff7 ldr x23, [sp, #248] 17ffff800080012a94: d5184117 msr sp_el0, x23 18ffff800080012a98: f27c02df tst x22, #0x10 19ffff800080012a9c: 54000020 b.eq ffff800080012aa0 \u0026lt;ret_to_user+0x38\u0026gt; // b.none 20ffff800080012aa0: f9476b80 ldr x0, [x28, #3792] 21ffff800080012aa4: d503201f nop 22ffff800080012aa8: d503201f nop 23ffff800080012aac: d503201f nop 24ffff800080012ab0: d503201f nop 25ffff800080012ab4: d503201f nop 26ffff800080012ab8: d503201f nop 27ffff800080012abc: d503201f nop 28ffff800080012ac0: d503201f nop 29ffff800080012ac4: d503201f nop 30ffff800080012ac8: d503201f nop 31ffff800080012acc: d503201f nop 32ffff800080012ad0: d503201f nop 33ffff800080012ad4: d503201f nop 34ffff800080012ad8: 1400000b b ffff800080012b04 \u0026lt;ret_to_user+0x9c\u0026gt; 35ffff800080012adc: b000aec1 adrp x1, ffff8000815eb000 \u0026lt;this_cpu_vector\u0026gt; 36ffff800080012ae0: 9100a021 add x1, x1, #0x28 37ffff800080012ae4: d538d080 mrs x0, tpidr_el1 38ffff800080012ae8: f8606821 ldr x1, [x1, x0] 39ffff800080012aec: b40000c1 cbz x1, ffff800080012b04 \u0026lt;ret_to_user+0x9c\u0026gt; 40ffff800080012af0: f9400381 ldr x1, [x28] 41ffff800080012af4: 37c80081 tbnz w1, #25, ffff800080012b04 \u0026lt;ret_to_user+0x9c\u0026gt; 42ffff800080012af8: 32013fe0 mov w0, #0x80007fff // #-2147450881 43ffff800080012afc: 52800001 mov w1, #0x0 // #0 44ffff800080012b00: d503201f nop 45ffff800080012b04: d5184035 msr elr_el1, x21 46ffff800080012b08: d5184016 msr spsr_el1, x22 47ffff800080012b0c: a94007e0 ldp x0, x1, [sp] 48ffff800080012b10: a9410fe2 ldp x2, x3, [sp, #16] 49ffff800080012b14: a94217e4 ldp x4, x5, [sp, #32] 50ffff800080012b18: a9431fe6 ldp x6, x7, [sp, #48] 51ffff800080012b1c: a94427e8 ldp x8, x9, [sp, #64] 52ffff800080012b20: a9452fea ldp x10, x11, [sp, #80] 53ffff800080012b24: a94637ec ldp x12, x13, [sp, #96] 54ffff800080012b28: a9473fee ldp x14, x15, [sp, #112] 55ffff800080012b2c: a94847f0 ldp x16, x17, [sp, #128] 56ffff800080012b30: a9494ff2 ldp x18, x19, [sp, #144] 57ffff800080012b34: a94a57f4 ldp x20, x21, [sp, #160] 58ffff800080012b38: a94b5ff6 ldp x22, x23, [sp, #176] 59ffff800080012b3c: a94c67f8 ldp x24, x25, [sp, #192] 60ffff800080012b40: a94d6ffa ldp x26, x27, [sp, #208] 61ffff800080012b44: a94e77fc ldp x28, x29, [sp, #224] 62ffff800080012b48: d503201f nop 63ffff800080012b4c: d503201f nop 64ffff800080012b50: f9407bfe ldr x30, [sp, #240] 65ffff800080012b54: 910543ff add sp, sp, #0x150 66/// 从异常返回 67ffff800080012b58: d69f03e0 eret 68#ifdef CONFIG_UNMAP_KERNEL_AT_EL0 69ffff800080012b5c: d518601d msr far_el1, x29 70ffff800080012b60: b000aede adrp x30, ffff8000815eb000 \u0026lt;this_cpu_vector\u0026gt; 71ffff800080012b64: 910003de add x30, x30, #0x0 72ffff800080012b68: d538d09d mrs x29, tpidr_el1 73ffff800080012b6c: f87d6bde ldr x30, [x30, x29] 74ffff800080012b70: 92c0801d mov x29, #0xfffffbffffffffff // #-4398046511105 75ffff800080012b74: f2bfbbfd movk x29, #0xfddf, lsl #16 76ffff800080012b78: f290001d movk x29, #0x8000 77ffff800080012b7c: d518c01e msr vbar_el1, x30 78ffff800080012b80: f9407bfe ldr x30, [sp, #240] 79ffff800080012b84: 910543ff add sp, sp, #0x150 80ffff800080012b88: d61f03a0 br x29 81#endif 82ffff800080012b8c: d503379f dsb nsh 83ffff800080012b90: d5033fdf isb 84ffff800080012b94: d503201f nop 85ffff800080012b98: d503201f nop 10. 参考资料 Arm Architecture Reference Manual for A-profile architecture Learn the architecture - AArch64 Exception Model Linux Kernel 5.14 arm64异常向量表解读-中断处理解读 ARM架构学习（1）——Exception level ","date":"April 21, 2024","img":"https://kingdix10.github.io/covers/wavy_curvy_lines_146044_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/interrupt/cpu_interrupt_entry/","series":[{"title":"中断管理","url":"/zh-cn/series/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1713657600,"title":"ARM64 Linux中断入口"},{"categories":[{"title":"C语言","url":"/zh-cn/categories/c%E8%AF%AD%E8%A8%80/"}],"content":"测试的时候，发现内核驱动里用crc32_le计算出的值和u-boot里用crc32计算出的值不一样。\n又用python的zlib.crc32和把内容写到文件用linuxcrc32命令计算，发现与u-bootcrc32函数计算结果一致。\n对比u-boot和linux内核用的crc32table，两者是一致的，后来查看代码，发现u-boot的crc32有个与0xffffffffL进行异或的操作。 实际linux的crc32_le函数与u-boot的crc32_no_comp函数是一致的。\n1uint32_t __efi_runtime crc32(uint32_t crc, const Bytef *p, uInt len) 2{ 3 return crc32_no_comp(crc ^ 0xffffffffL, p, len) ^ 0xffffffffL; 4} ","date":"April 21, 2024","img":"https://kingdix10.github.io/covers/laptop_keyboard_glow_170138_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/03-boot/u-boot/crc32_func/","series":[{"title":"C语言","url":"/zh-cn/series/c%E8%AF%AD%E8%A8%80/"}],"smallImg":"","tags":[{"title":"u-boot","url":"/zh-cn/tags/u-boot/"}],"timestamp":1713657600,"title":"U-Boot和Linux内核的CRC函数"},{"categories":[{"title":"linux命令","url":"/zh-cn/categories/linux%E5%91%BD%E4%BB%A4/"},{"title":"系统管理","url":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"}],"content":" 1. pstree查看进程树 1$ pstree -ptA 2systemd(1)-+-VGAuthService(546) 3 |-cron(625) 4 |-dbus-daemon(626) 5 |-dhclient(1587) 6 |-dhclient(1831) 7 |-rinetd(707) 8 |-rsyslogd(629)-+-{in:imklog}(632) 9 | |-{in:imuxsock}(631) 10 | `-{rs:main Q:Reg}(633) 2. ps 1# 查看命名空间，需要用root权限，可以使用sudo 2ps -eo pid,pidns,user,group,cmd 3# ps查看进程间的关系。 4ps -Teo ppid,sid,pgid,pid,tgid,tid,comm 5 6ps -eL -o pid,tid,stat,comm 7ps -eL -o psr,pid,tid,stat,comm 3. mount 3.1. 使用mount替代软链接 1# vi /etc/fstab 2/data/docker\t/var/lib/docker none bind 0 0 3 4# 重新mount所有文件系统 5sudo mount -a 3.2. 挂载samba共享目录 1MP=/mnt/smb_share 2 3mkdir -p ${MP} 4 5mount -t cifs //${IPADDR}/share ${MP} -o rw,noatime,nodiratime,file_mode=0644,dir_mode=0755,gid=1000,uid=1000,,username=${USERNAME},pass=${PASSWORD} 3.3. 挂载U盘，并指定默认用户等 格式为exfat，如果不指定gid和uid，默认只有root可以写入。 fmask和dmask参考Linux umask命令。\n1mount -o rw,noatime,nodiratime,fmask=133,dmask=022,gid=1000,uid=1000 /dev/sda1 /mnt/usb ","date":"March 9, 2024","img":"https://kingdix10.github.io/covers/water_waves_ripples_143522_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/linux/shell/cmd_sys/","series":[{"title":"linux命令","url":"/zh-cn/series/linux%E5%91%BD%E4%BB%A4/"}],"smallImg":"","tags":[{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"},{"title":"linux命令","url":"/zh-cn/tags/linux%E5%91%BD%E4%BB%A4/"},{"title":"系统管理","url":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"}],"timestamp":1709942400,"title":"linux常用命令-系统管理"},{"categories":[{"title":"C语言","url":"/zh-cn/categories/c%E8%AF%AD%E8%A8%80/"}],"content":" 1. 简介 c++17标准引入了static_assert。\n1static_assert(bool-constexpr, message ) /// since C++11 2static_assert(bool-constexpr) /// since C++17 gnu c编译器也实现了_Static_assert，见Static Assertions。\n2. 自定义 在没有static_assert的c语言中，可以自己实现类似的功能，如下：\n2.1. 方法一 1#ifndef STATIC_ASSERT 2#define STATIC_ASSERT(exp) ((void)sizeof(struct{int:-!(exp);})) 3#endif 2.2. 方法二 1#ifndef STATIC_ASSERT 2#define STATIC_ASSERT(exp) ((void)sizeof(char[(exp)?1:-1])) 3#endif 2.3. 方法三 1#ifndef STATIC_ASSERT 2#define STATIC_ASSERT(exp) switch(0) { case 0: case (exp):; } 3#endif 2.4. 方法四 推荐：可以在函数内，也可以在函数外。\n1#ifndef STATIC_ASSERT 2#define STATIC_ASSERT(exp) extern void _static_assert(int arg[(exp) ? 1 : -1]) 3#endif 注意：exp必须是常量表达式，编译期可计算的。方法四可以用于代码块以外。\n3. 参考 无警告C语言编译断言\n","date":"February 25, 2024","img":"https://kingdix10.github.io/covers/wood_texture_logs_159793_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/05-program/ccpp/c_assert/","series":[{"title":"C语言","url":"/zh-cn/series/c%E8%AF%AD%E8%A8%80/"}],"smallImg":"","tags":[{"title":"C语言","url":"/zh-cn/tags/c%E8%AF%AD%E8%A8%80/"}],"timestamp":1708819200,"title":"C语言编译断言"},{"categories":[{"title":"linux命令","url":"/zh-cn/categories/linux%E5%91%BD%E4%BB%A4/"}],"content":" 1. shell语法 shell核心基础知识 进阶版\n2. 忽略大小写 重新进入bash后生效。\n1echo \u0026#39;set completion-ignore-case on\u0026#39; \u0026gt; ~/.inputrc 3. 临时使用alias前的命令 参考LINUX下使用命令行获取公网IP地址转载\n\u0026ldquo;\u0026quot;在命令前表示使用最原始的命令 比如 rm 和 \\rm 如果环境alias过，那rm就是alias后的rm 如: rm -i \\rm 指没有alias过最原始的rm。\n4. jobs/fg/bg/Ctrl+Z/kill 在Linux系统中，可以使用jobs命令来管理在后台运行的进程。下面是一些使用jobs命令的常用操作：\n查看后台进程列表：运行jobs命令可以列出当前在后台运行的所有进程及其对应的作业号。 暂停后台进程：可以使用fg %作业号或者bg %作业号命令将某个后台进程移动到前台运行或者继续在后台运行。 终止后台进程：可以使用kill %作业号命令来终止某个后台进程。 切换前后台进程：可以使用ctrl+z命令将正在前台运行的进程暂停并移动到后台运行，然后使用fg或者bg命令将其切换到前台或者后台运行。 后台运行进程：在运行一个命令时，可以在命令末尾添加\u0026amp;符号，使其在后台运行。例如，运行命令nohup command \u0026amp;来使命令在后台运行，并且即使退出终端也不会停止。 通过以上操作，可以方便地管理Linux系统中的后台进程。\n5. 修改默认编辑器 Linux上crontab的默认编辑器是vi编辑器。然而，在运行crontab命令之前，可以通过将VISUAL或EDITOR环境变量设置为所需的编辑器来改变。例如，要使用nano作为crontab的编辑器，命令是：\n1export VISUAL=nano; crontab -e 或者，\n1export EDITOR=nano; crontab -e 这将在nano中打开crontab文件供编辑。\n1$ select-editor 2 3Select an editor. To change later, run \u0026#39;select-editor\u0026#39;. 4 1. /bin/nano \u0026lt;---- easiest 5 2. /usr/bin/vim.basic 6 3. /usr/bin/vim.tiny 7 8Choose 1-3 [1]: 2 5. bash快捷键 Bash终端快捷键 - Little Garden - CSDN博客 Bash 快捷键大全 | 菜鸟教程 快捷键 如何使用jobs命令管理Linux后台进程 ","date":"February 25, 2024","img":"https://kingdix10.github.io/covers/leaves_patterns_autumn_129305_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/linux/shell/bash_tips/","series":[{"title":"linux命令","url":"/zh-cn/series/linux%E5%91%BD%E4%BB%A4/"}],"smallImg":"","tags":[{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"},{"title":"Bash","url":"/zh-cn/tags/bash/"}],"timestamp":1708819200,"title":"Linux Bash技巧"},{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1. kernel_clone kernel_clone是内核创建进程/线程的核心函数，如下功能都是通过调用kernel_clone实现的。\nkernel_thread：创建内核进程 user_mode_thread：创建1号进程，1号进程的回调函数先是内核态的kernel_init，之后通过execve切换到用户进程 fork和clone系统调用：创建用户进程/线程 kernel_clone主要流程是copy_process函数实现task_struct结构的创建和初始化，而后通过wake_up_new_task将新进程/线程加入运行队列，并唤醒。详细流程见源码注释。\n1/// kernel/sched/core.c 2/* 3 * Ok, this is the main fork-routine. 4 * 5 * It copies the process, and if successful kick-starts 6 * it and waits for it to finish using the VM if required. 7 * 8 * args-\u0026gt;exit_signal is expected to be checked for sanity by the caller. 9 */ 10pid_t kernel_clone(struct kernel_clone_args *args) 11{ 12 u64 clone_flags = args-\u0026gt;flags; 13 struct completion vfork; 14 struct pid *pid; 15 struct task_struct *p; 16 int trace = 0; 17 pid_t nr; 18 19 /// ... .. 20 21 /// 创建进程的主要流程 22 p = copy_process(NULL, trace, NUMA_NO_NODE, args); 23 add_latent_entropy(); 24 25 if (IS_ERR(p)) 26 return PTR_ERR(p); 27 28 /* 29 * Do this prior waking up the new thread - the thread pointer 30 * might get invalid after that point, if the thread exits quickly. 31 */ 32 trace_sched_process_fork(current, p); 33 34 /// 读取当前struct pid，并增加引用计数，防止被销毁 35 pid = get_task_pid(p, PIDTYPE_PID); 36 /// 获取虚拟的pid，是父进程所在最后一级pid namespace的id 37 nr = pid_vnr(pid); 38 39 if (clone_flags \u0026amp; CLONE_PARENT_SETTID) 40 put_user(nr, args-\u0026gt;parent_tid); 41 42 /// 如果是vfork，让父进程阻塞，直到子进程调用exit或者execve 43 if (clone_flags \u0026amp; CLONE_VFORK) { 44 p-\u0026gt;vfork_done = \u0026amp;vfork; 45 init_completion(\u0026amp;vfork); 46 get_task_struct(p); 47 } 48 49 if (IS_ENABLED(CONFIG_LRU_GEN) \u0026amp;\u0026amp; !(clone_flags \u0026amp; CLONE_VM)) { 50 /* lock the task to synchronize with memcg migration */ 51 task_lock(p); 52 lru_gen_add_mm(p-\u0026gt;mm); 53 task_unlock(p); 54 } 55 56 /// 唤醒新进程 57 wake_up_new_task(p); 58 59 /* forking complete and child started to run, tell ptracer */ 60 if (unlikely(trace)) 61 ptrace_event_pid(trace, pid); 62 63 if (clone_flags \u0026amp; CLONE_VFORK) { 64 /// 等待子进程完成，如果是正常等待完成，使用ptrace报告事件 65 if (!wait_for_vfork_done(p, \u0026amp;vfork)) 66 ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid); 67 } 68 69 put_pid(pid); 70 return nr; 71} 1.1. fork的返回值 fork的返回值是子进程的pid，父进程的pid是调用fork的进程的pid。如果fork失败，则返回一个负值。\n从代码中可以看到，进程的pid是通过pid_vnr获取的，这里获取的是current，也就父进程所在的最后一级命名空间里分配的id。 在clone_flags包含CLONE_NEWPID是会为子进程创建新的命名空间，由于父进程需要知道子进程的id，所以这里取的是父进程的pid namespace内的id。\n1/// kernel/pid.c 2pid_t pid_vnr(struct pid *pid) 3{ 4\treturn pid_nr_ns(pid, task_active_pid_ns(current)); 5} 6EXPORT_SYMBOL_GPL(pid_vnr); 这里看到父进程正确拿到了子进程的pid，那子进程的fork返回值又是在哪里处理的呢？\n这个问题涉及到子进程的第一次运行，需要看copy_thread函数，这是一个与体系结构体相关的函数，其基本工作是将子进程内核空间内记录的cpu context进程初始化，以ARM64为例，会将x0设为0，而pc设为ret_form_fork，新进程第一次运行时，是从ret_from_fork开始的，返回到用户空间时，将内核栈记录的寄存器恢复到寄存器。子进程的fork函数调用结束，从x0拿到的返回值就是0，\n2. copy_process copy_process主要流程如下：\n对传入的clone_flags进行一些检查，如果是不合法的组合，直接返回失败。 在进行实际的fork之前，将收到的信号强制分发出去。使用delayed收集在fork过程中发送给进程的信号，以便进行延迟处理。在新进程准备好后，将其记录到新进程的p-\u0026gt;signal-\u0026gt;shared_pending.signal，再进行处理。之后清除pending的信号。完成之后，继续检查是否收到信号，如果收到信号，则fork失败，直接退出。 基于current创建新的task_struct，并设置一些基本信息。 设置进程/线程名 共享或复制证书 将新创建的进程状态设置为TASK_NEW，设置调度策略和优先级，初始化负载 共享或创建新的files_struct和fs_struct 共享或创建新的sighand_struct和signal_struct 共享或创建新的mm_struct 共享或创建新的除user namespace之外的namespace 共享或创建新的io_context 初始化新进程的内核栈，设置fork返回时要执行的函数和栈 如果不是fork_idle，在新进程所属的每一级pid namespace中申请pid 共享或创建新的pidfd 设置新进程/线程的group_leader、tgid、real_parent 将新进程/线程关联到线程、进程、进程组、会话 根据情况增加nr_threads和total_forks计数 如果clone_flags包含CLONE_PIDFD，将pidfd加入到父进程的文件列表 一些收尾工作和OOM参数配置后，返回新创建的task_struct 1+-- copy_process 2| +-- dup_task_struct 3| | +-- alloc_task_struct_node 4| | +-- arch_dup_task_struct 5| | +-- alloc_thread_stack_node 6| | +-- setup_thread_stack 7| | +-- set_task_stack_end_magic 8| +-- rt_mutex_init_task 9| +-- copy_creds 10| +-- rcu_copy_process 11| +-- init_sigpending 12| +-- posix_cputimers_init 13| +-- cgroup_fork 14| +-- set_kthread_struct 15| +-- sched_fork 16| | +-- __sched_fork 17| +-- shm_init_task 18| +-- copy_semundo 19| +-- copy_files 20| | +-- dup_fd 21| +-- copy_fs 22| | +-- copy_fs_struct 23| +-- copy_sighand 24| +-- copy_signal 25| +-- copy_mm 26| | +-- vmacache_flush 27| | +-- mmget 28| | +-- dup_mm 29| +-- copy_namespaces 30| | +-- get_nsproxy 31| | +-- create_new_namespaces 32| | +-- timens_on_fork 33| +-- copy_io 34| +-- copy_thread 35| +-- stackleak_task_init // arch/arm64/kernel/process.c 36| +-- alloc_pid // pid != \u0026amp;init_struct_pid 37| +-- futex_init_task 38| +-- clear_posix_cputimers_work 39| +-- cgroup_can_fork 40| +-- sched_cgroup_fork 41| +-- sched_core_fork 42| | +-- sched_core_clone_cookie 43| +-- copy_seccomp 44| +-- rv_task_fork 45| +-- rseq_fork 46| +-- init_task_pid_links 47| +-- init_task_pid 48| +-- attach_pid // likely(p-\u0026gt;pid) 49| +-- fd_install // if (pidfile) 50| +-- sched_post_fork 51| +-- cgroup_post_fork 52| +-- perf_event_fork 53| +-- uprobe_copy_process 54| +-- copy_oom_score_adj ","date":"February 3, 2024","img":"https://kingdix10.github.io/covers/walls_floor_light_50837_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/sched/a-fork/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"进程管理","url":"/zh-cn/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1706918400,"title":"Linux fork进程/线程简介"},{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1. shm_init_task 在使能SYSVIPC的情况下，初始化task-\u0026gt;sysvshm.shm_clist。\n1 /* copy all the process information */ 2 shm_init_task(p); 2. security_task_alloc 1 retval = security_task_alloc(p, clone_flags); /// Allocate a task\u0026#39;s LSM blob 2 if (retval) 3 goto bad_fork_cleanup_audit; 3. copy_semundo 在不使能CONFIG_SYSVIPC的情况下，copy_semundo为空。如果clone_flags包含CLONE_SYSVSEM，则共享父进程的sysvsem.undo_list，或者申请新的undo_list。\n1 retval = copy_semundo(clone_flags, p); 2 if (retval) 3 goto bad_fork_cleanup_security; 3.1. copy_semundo源码 1/// ipc/sem.c 2/* If CLONE_SYSVSEM is set, establish sharing of SEM_UNDO state between 3 * parent and child tasks. 4 */ 5 6int copy_semundo(unsigned long clone_flags, struct task_struct *tsk) 7{ 8 struct sem_undo_list *undo_list; 9 int error; 10 11 if (clone_flags \u0026amp; CLONE_SYSVSEM) { 12 /// 如果当前进程sysvsem.undo_list不为空，则共享 13 /// 否则为新进程分配新的undo_list 14 error = get_undo_list(\u0026amp;undo_list); 15 if (error) 16 return error; 17 refcount_inc(\u0026amp;undo_list-\u0026gt;refcnt); 18 tsk-\u0026gt;sysvsem.undo_list = undo_list; 19 } else 20 tsk-\u0026gt;sysvsem.undo_list = NULL; 21 22 return 0; 23} 4. copy_files 如果clone_flags包含CLONE_FILES，则与父进程共享files_struct，否则调用dup_fd创建新的files_struct。files_struct包含进程打开文件列表。\n1 retval = copy_files(clone_flags, p, args-\u0026gt;no_files); 2 if (retval) 3 goto bad_fork_cleanup_semundo; 4.1. copy_files源码 1/// kernel/fork.c 2static int copy_files(unsigned long clone_flags, struct task_struct *tsk, 3 int no_files) 4{ 5 struct files_struct *oldf, *newf; 6 int error = 0; 7 8 /* 9 * A background process may not have any files ... 10 */ 11 oldf = current-\u0026gt;files; 12 if (!oldf) 13 goto out; 14 15 if (no_files) { 16 tsk-\u0026gt;files = NULL; 17 goto out; 18 } 19 20 if (clone_flags \u0026amp; CLONE_FILES) { 21 atomic_inc(\u0026amp;oldf-\u0026gt;count); 22 goto out; 23 } 24 25 newf = dup_fd(oldf, NR_OPEN_MAX, \u0026amp;error); 26 if (!newf) 27 goto out; 28 29 tsk-\u0026gt;files = newf; 30 error = 0; 31out: 32 return error; 33} 4.2. dup_fd原型 1/// fs/file.c 2/* 3 * Allocate a new files structure and copy contents from the 4 * passed in files structure. 5 * errorp will be valid only when the returned files_struct is NULL. 6 */ 7struct files_struct *dup_fd(struct files_struct *oldf, unsigned int max_fds, int *errorp) 8{ 9 /// ... ... 5. copy_fs 如果clone_flags包含CLONE_FS，则与父进程共享fs_struct，否则调用copy_fs_struct创建新的fs_struct。 fs_struct包含进程的根目录、当前目录等信息。\n1 retval = copy_fs(clone_flags, p); 2 if (retval) 3 goto bad_fork_cleanup_files; 5.1. copy_fs源码 1/// kernel/fork.c 2static int copy_fs(unsigned long clone_flags, struct task_struct *tsk) 3{ 4 struct fs_struct *fs = current-\u0026gt;fs; 5 if (clone_flags \u0026amp; CLONE_FS) { 6 /* tsk-\u0026gt;fs is already what we want */ 7 spin_lock(\u0026amp;fs-\u0026gt;lock); 8 if (fs-\u0026gt;in_exec) { /// 正在执行execve系统调用？ 9 spin_unlock(\u0026amp;fs-\u0026gt;lock); 10 return -EAGAIN; 11 } 12 fs-\u0026gt;users++; 13 spin_unlock(\u0026amp;fs-\u0026gt;lock); 14 return 0; 15 } 16 tsk-\u0026gt;fs = copy_fs_struct(fs); 17 if (!tsk-\u0026gt;fs) 18 return -ENOMEM; 19 return 0; 20} 5.2. copy_fs_struct源码 新创建的fs_struct继承父进程fs_struct的一些数据。\n1/// fs/fs_struct.c 2struct fs_struct *copy_fs_struct(struct fs_struct *old) 3{ 4 struct fs_struct *fs = kmem_cache_alloc(fs_cachep, GFP_KERNEL); 5 /* We don\u0026#39;t need to lock fs - think why ;-) */ 6 if (fs) { 7 fs-\u0026gt;users = 1; 8 fs-\u0026gt;in_exec = 0; 9 spin_lock_init(\u0026amp;fs-\u0026gt;lock); 10 seqcount_spinlock_init(\u0026amp;fs-\u0026gt;seq, \u0026amp;fs-\u0026gt;lock); 11 fs-\u0026gt;umask = old-\u0026gt;umask; 12 13 spin_lock(\u0026amp;old-\u0026gt;lock); 14 fs-\u0026gt;root = old-\u0026gt;root; 15 path_get(\u0026amp;fs-\u0026gt;root); 16 fs-\u0026gt;pwd = old-\u0026gt;pwd; 17 path_get(\u0026amp;fs-\u0026gt;pwd); 18 spin_unlock(\u0026amp;old-\u0026gt;lock); 19 } 20 return fs; 21} 6. copy_sighand 如果clone_flags包含CLONE_SIGHAND，则共享父进程sighand。否则，创建一个新的sighand，并从父进程复制sighand-\u0026gt;action。如果clone_flags包含CLONE_CLEAR_SIGHAND，还会将signal handler重置为默认值。\n1 retval = copy_sighand(clone_flags, p); 2 if (retval) 3 goto bad_fork_cleanup_fs; 6.1. copy_sighand源码 1/// kernel/fork.c 2static int copy_sighand(unsigned long clone_flags, struct task_struct *tsk) 3{ 4 struct sighand_struct *sig; 5 6 if (clone_flags \u0026amp; CLONE_SIGHAND) { 7 refcount_inc(\u0026amp;current-\u0026gt;sighand-\u0026gt;count); 8 return 0; 9 } 10 sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL); 11 RCU_INIT_POINTER(tsk-\u0026gt;sighand, sig); 12 if (!sig) 13 return -ENOMEM; 14 15 refcount_set(\u0026amp;sig-\u0026gt;count, 1); 16 spin_lock_irq(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); 17 memcpy(sig-\u0026gt;action, current-\u0026gt;sighand-\u0026gt;action, sizeof(sig-\u0026gt;action)); 18 spin_unlock_irq(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); 19 20 /* Reset all signal handler not set to SIG_IGN to SIG_DFL. */ 21 if (clone_flags \u0026amp; CLONE_CLEAR_SIGHAND) 22 flush_signal_handlers(tsk, 0); 23 24 return 0; 25} 7. copy_signal 如果clone_flags包含CLONE_THREAD，也就是创建线程，不做任何操作。否则，创建新的signal，并初始化各个变量。\n1 retval = copy_signal(clone_flags, p); 2 if (retval) 3 goto bad_fork_cleanup_sighand; 7.1. copy_signal源码 1/// kernel/fork.c 2static int copy_signal(unsigned long clone_flags, struct task_struct *tsk) 3{ 4 struct signal_struct *sig; 5 6 /// 如果是创建线程，则不做任何操作 7 if (clone_flags \u0026amp; CLONE_THREAD) 8 return 0; 9 10 sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL); 11 tsk-\u0026gt;signal = sig; 12 if (!sig) 13 return -ENOMEM; 14 15 /// 新进程默认计数为1 16 sig-\u0026gt;nr_threads = 1; 17 sig-\u0026gt;quick_threads = 1; 18 atomic_set(\u0026amp;sig-\u0026gt;live, 1); 19 refcount_set(\u0026amp;sig-\u0026gt;sigcnt, 1); 20 21 /// 快速将tsk和sig的list关联起来 22 /* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */ 23 sig-\u0026gt;thread_head = (struct list_head)LIST_HEAD_INIT(tsk-\u0026gt;thread_node); 24 tsk-\u0026gt;thread_node = (struct list_head)LIST_HEAD_INIT(sig-\u0026gt;thread_head); 25 26 init_waitqueue_head(\u0026amp;sig-\u0026gt;wait_chldexit); 27 sig-\u0026gt;curr_target = tsk; 28 init_sigpending(\u0026amp;sig-\u0026gt;shared_pending); /// 清空signal 29 INIT_HLIST_HEAD(\u0026amp;sig-\u0026gt;multiprocess); 30 seqlock_init(\u0026amp;sig-\u0026gt;stats_lock); 31 prev_cputime_init(\u0026amp;sig-\u0026gt;prev_cputime); 32 33#ifdef CONFIG_POSIX_TIMERS 34 INIT_LIST_HEAD(\u0026amp;sig-\u0026gt;posix_timers); 35 hrtimer_init(\u0026amp;sig-\u0026gt;real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); 36 sig-\u0026gt;real_timer.function = it_real_fn; 37#endif 38 39 /// 复制父进程的rlim，fork可能是父进程的子线程调用的，这里用group_leader找到主线程 40 task_lock(current-\u0026gt;group_leader); 41 memcpy(sig-\u0026gt;rlim, current-\u0026gt;signal-\u0026gt;rlim, sizeof sig-\u0026gt;rlim); 42 task_unlock(current-\u0026gt;group_leader); 43 44 posix_cpu_timers_init_group(sig); 45 46 tty_audit_fork(sig); /// 审计日志 47 sched_autogroup_fork(sig); /// 增加当前调度组引用计数 48 49 /// 复制oom信息 50 sig-\u0026gt;oom_score_adj = current-\u0026gt;signal-\u0026gt;oom_score_adj; 51 sig-\u0026gt;oom_score_adj_min = current-\u0026gt;signal-\u0026gt;oom_score_adj_min; 52 53 mutex_init(\u0026amp;sig-\u0026gt;cred_guard_mutex); 54 init_rwsem(\u0026amp;sig-\u0026gt;exec_update_lock); 55 56 return 0; 57} 8. copy_mm 如果父进程是用户程序，且clone_flags包含CLONE_VM，则共享父进程mm_struct。否则调用dup_mm复制父进程的mm_struct。\n1 retval = copy_mm(clone_flags, p); 2 if (retval) 3 goto bad_fork_cleanup_signal; 8.1. copy_mm源码 1/// kernel/fork.c 2static int copy_mm(unsigned long clone_flags, struct task_struct *tsk) 3{ 4 struct mm_struct *mm, *oldmm; 5 6 tsk-\u0026gt;min_flt = tsk-\u0026gt;maj_flt = 0; 7 tsk-\u0026gt;nvcsw = tsk-\u0026gt;nivcsw = 0; 8#ifdef CONFIG_DETECT_HUNG_TASK 9 tsk-\u0026gt;last_switch_count = tsk-\u0026gt;nvcsw + tsk-\u0026gt;nivcsw; 10 tsk-\u0026gt;last_switch_time = 0; 11#endif 12 13 tsk-\u0026gt;mm = NULL; 14 tsk-\u0026gt;active_mm = NULL; 15 16 /* 17 * Are we cloning a kernel thread? 18 * 19 * We need to steal a active VM for that.. 20 */ 21 oldmm = current-\u0026gt;mm; 22 if (!oldmm) 23 return 0; 24 25 if (clone_flags \u0026amp; CLONE_VM) { 26 mmget(oldmm); 27 mm = oldmm; 28 } else { 29 mm = dup_mm(tsk, current-\u0026gt;mm); 30 if (!mm) 31 return -ENOMEM; 32 } 33 34 tsk-\u0026gt;mm = mm; 35 tsk-\u0026gt;active_mm = mm; 36 sched_mm_cid_fork(tsk); 37 return 0; 38} 9. copy_namespaces copy_namespaces共享或创建新的除user namespace之外的namespace。 检查是否需要创建新的命名空间，如果不需要，增加父进程命名空间的引用计数。如果需要创建新的命名空间，还需要检查是否有管理员权限。之后就是调用create_new_namespaces来完成新的命名空间创建。\n1 retval = copy_namespaces(clone_flags, p); 2 if (retval) 3 goto bad_fork_cleanup_mm; 9.1. copy_namespaces源码 1/// kernel/nsproxy.c 2/* 3 * called from clone. This now handles copy for nsproxy and all 4 * namespaces therein. 5 */ 6int copy_namespaces(unsigned long flags, struct task_struct *tsk) 7{ 8 struct nsproxy *old_ns = tsk-\u0026gt;nsproxy; 9 struct user_namespace *user_ns = task_cred_xxx(tsk, user_ns); 10 struct nsproxy *new_ns; 11 12 if (likely(!(flags \u0026amp; (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC | 13 CLONE_NEWPID | CLONE_NEWNET | 14 CLONE_NEWCGROUP | CLONE_NEWTIME)))) { 15 if ((flags \u0026amp; CLONE_VM) || 16 likely(old_ns-\u0026gt;time_ns_for_children == old_ns-\u0026gt;time_ns)) { 17 get_nsproxy(old_ns); 18 return 0; 19 } 20 } else if (!ns_capable(user_ns, CAP_SYS_ADMIN)) 21 return -EPERM; 22 23 /* 24 * CLONE_NEWIPC must detach from the undolist: after switching 25 * to a new ipc namespace, the semaphore arrays from the old 26 * namespace are unreachable. In clone parlance, CLONE_SYSVSEM 27 * means share undolist with parent, so we must forbid using 28 * it along with CLONE_NEWIPC. 29 */ 30 if ((flags \u0026amp; (CLONE_NEWIPC | CLONE_SYSVSEM)) == 31 (CLONE_NEWIPC | CLONE_SYSVSEM)) 32 return -EINVAL; 33 34 new_ns = create_new_namespaces(flags, tsk, user_ns, tsk-\u0026gt;fs); 35 if (IS_ERR(new_ns)) 36 return PTR_ERR(new_ns); 37 38 if ((flags \u0026amp; CLONE_VM) == 0) 39 timens_on_fork(new_ns, tsk); 40 41 tsk-\u0026gt;nsproxy = new_ns; 42 return 0; 43} 9.2. create_new_namespaces源码 1/// kernel/nsproxy.c 2/* 3 * Create new nsproxy and all of its the associated namespaces. 4 * Return the newly created nsproxy. Do not attach this to the task, 5 * leave it to the caller to do proper locking and attach it to task. 6 */ 7static struct nsproxy *create_new_namespaces(unsigned long flags, 8 struct task_struct *tsk, struct user_namespace *user_ns, 9 struct fs_struct *new_fs) 10{ 11 struct nsproxy *new_nsp; 12 int err; 13 14 new_nsp = create_nsproxy(); 15 if (!new_nsp) 16 return ERR_PTR(-ENOMEM); 17 18 new_nsp-\u0026gt;mnt_ns = copy_mnt_ns(flags, tsk-\u0026gt;nsproxy-\u0026gt;mnt_ns, user_ns, new_fs); 19 if (IS_ERR(new_nsp-\u0026gt;mnt_ns)) { 20 err = PTR_ERR(new_nsp-\u0026gt;mnt_ns); 21 goto out_ns; 22 } 23 24 new_nsp-\u0026gt;uts_ns = copy_utsname(flags, user_ns, tsk-\u0026gt;nsproxy-\u0026gt;uts_ns); 25 if (IS_ERR(new_nsp-\u0026gt;uts_ns)) { 26 err = PTR_ERR(new_nsp-\u0026gt;uts_ns); 27 goto out_uts; 28 } 29 30 new_nsp-\u0026gt;ipc_ns = copy_ipcs(flags, user_ns, tsk-\u0026gt;nsproxy-\u0026gt;ipc_ns); 31 if (IS_ERR(new_nsp-\u0026gt;ipc_ns)) { 32 err = PTR_ERR(new_nsp-\u0026gt;ipc_ns); 33 goto out_ipc; 34 } 35 36 new_nsp-\u0026gt;pid_ns_for_children = 37 copy_pid_ns(flags, user_ns, tsk-\u0026gt;nsproxy-\u0026gt;pid_ns_for_children); 38 if (IS_ERR(new_nsp-\u0026gt;pid_ns_for_children)) { 39 err = PTR_ERR(new_nsp-\u0026gt;pid_ns_for_children); 40 goto out_pid; 41 } 42 43 new_nsp-\u0026gt;cgroup_ns = copy_cgroup_ns(flags, user_ns, 44 tsk-\u0026gt;nsproxy-\u0026gt;cgroup_ns); 45 if (IS_ERR(new_nsp-\u0026gt;cgroup_ns)) { 46 err = PTR_ERR(new_nsp-\u0026gt;cgroup_ns); 47 goto out_cgroup; 48 } 49 50 new_nsp-\u0026gt;net_ns = copy_net_ns(flags, user_ns, tsk-\u0026gt;nsproxy-\u0026gt;net_ns); 51 if (IS_ERR(new_nsp-\u0026gt;net_ns)) { 52 err = PTR_ERR(new_nsp-\u0026gt;net_ns); 53 goto out_net; 54 } 55 56 new_nsp-\u0026gt;time_ns_for_children = copy_time_ns(flags, user_ns, 57 tsk-\u0026gt;nsproxy-\u0026gt;time_ns_for_children); 58 if (IS_ERR(new_nsp-\u0026gt;time_ns_for_children)) { 59 err = PTR_ERR(new_nsp-\u0026gt;time_ns_for_children); 60 goto out_time; 61 } 62 new_nsp-\u0026gt;time_ns = get_time_ns(tsk-\u0026gt;nsproxy-\u0026gt;time_ns); 63 64 return new_nsp; 65 /// ... ... 66} 9.3. timens_on_fork 在新进程不与父进程共享vm的情况下调用，这个时候新进程也不共享父进程的命名空间（time_ns成员）。\n1/// kernel/time/namespace.c 2void timens_on_fork(struct nsproxy *nsproxy, struct task_struct *tsk) 3{ 4 struct ns_common *nsc = \u0026amp;nsproxy-\u0026gt;time_ns_for_children-\u0026gt;ns; 5 struct time_namespace *ns = to_time_ns(nsc); 6 7 /// init_task的time_ns和time_ns_for_children是同一个 8 /// fork时如果创建了新的timens，这里time_ns_for_children是新的 9 /// 而time_ns还与父进程的time_ns保持一致 10 /* create_new_namespaces() already incremented the ref counter */ 11 if (nsproxy-\u0026gt;time_ns == nsproxy-\u0026gt;time_ns_for_children) 12 return; 13 14 get_time_ns(ns); 15 put_time_ns(nsproxy-\u0026gt;time_ns); 16 /// 使新进程的time_ns和time_ns_for_children相同 17 nsproxy-\u0026gt;time_ns = ns; 18 19 timens_commit(tsk, ns); 20} 10. copy_io 在使能CONFIG_BLOCK的情况下才有效。如果clone_flags包含CLONE_VM，则共享父进程的io上下文，否则创建新的io_context，其中主要是一些io调度的上下文。\n1 retval = copy_io(clone_flags, p); 2 if (retval) 3 goto bad_fork_cleanup_namespaces; 10.1. copy_io源码 1/// include/linux/iocontext.h 2static inline int copy_io(unsigned long clone_flags, struct task_struct *tsk) 3{ 4 if (!current-\u0026gt;io_context) 5 return 0; 6 return __copy_io(clone_flags, tsk); 7} 10.2. __copy_io源码 1/// block/blk-io.c 2int __copy_io(unsigned long clone_flags, struct task_struct *tsk) 3{ 4 struct io_context *ioc = current-\u0026gt;io_context; 5 6 /* 7 * Share io context with parent, if CLONE_IO is set 8 */ 9 if (clone_flags \u0026amp; CLONE_IO) { 10 atomic_inc(\u0026amp;ioc-\u0026gt;active_ref); 11 tsk-\u0026gt;io_context = ioc; 12 } else if (ioprio_valid(ioc-\u0026gt;ioprio)) { 13 tsk-\u0026gt;io_context = alloc_io_context(GFP_KERNEL, NUMA_NO_NODE); 14 if (!tsk-\u0026gt;io_context) 15 return -ENOMEM; 16 tsk-\u0026gt;io_context-\u0026gt;ioprio = ioc-\u0026gt;ioprio; 17 } 18 19 return 0; 20} 11. copy_thread 1 retval = copy_thread(p, args); 2 if (retval) 3 goto bad_fork_cleanup_io; 11.1. ARM64 copy_thread源码 1/// arch/arm64/kernel/process.c 2int copy_thread(struct task_struct *p, const struct kernel_clone_args *args) 3{ 4 unsigned long clone_flags = args-\u0026gt;flags; 5 unsigned long stack_start = args-\u0026gt;stack; 6 unsigned long tls = args-\u0026gt;tls; 7 struct pt_regs *childregs = task_pt_regs(p); 8 9 memset(\u0026amp;p-\u0026gt;thread.cpu_context, 0, sizeof(struct cpu_context)); 10 11 /* 12 * In case p was allocated the same task_struct pointer as some 13 * other recently-exited task, make sure p is disassociated from 14 * any cpu that may have run that now-exited task recently. 15 * Otherwise we could erroneously skip reloading the FPSIMD 16 * registers for p. 17 */ 18 fpsimd_flush_task_state(p); 19 20 ptrauth_thread_init_kernel(p); 21 22 if (likely(!args-\u0026gt;fn)) { 23 *childregs = *current_pt_regs(); 24 childregs-\u0026gt;regs[0] = 0; 25 26 /* 27 * Read the current TLS pointer from tpidr_el0 as it may be 28 * out-of-sync with the saved value. 29 */ 30 *task_user_tls(p) = read_sysreg(tpidr_el0); 31 if (system_supports_tpidr2()) 32 p-\u0026gt;thread.tpidr2_el0 = read_sysreg_s(SYS_TPIDR2_EL0); 33 34 if (stack_start) { 35 if (is_compat_thread(task_thread_info(p))) 36 childregs-\u0026gt;compat_sp = stack_start; 37 else 38 childregs-\u0026gt;sp = stack_start; 39 } 40 41 /* 42 * If a TLS pointer was passed to clone, use it for the new 43 * thread. We also reset TPIDR2 if it\u0026#39;s in use. 44 */ 45 if (clone_flags \u0026amp; CLONE_SETTLS) { 46 p-\u0026gt;thread.uw.tp_value = tls; 47 p-\u0026gt;thread.tpidr2_el0 = 0; 48 } 49 } else { 50 /* 51 * A kthread has no context to ERET to, so ensure any buggy 52 * ERET is treated as an illegal exception return. 53 * 54 * When a user task is created from a kthread, childregs will 55 * be initialized by start_thread() or start_compat_thread(). 56 */ 57 memset(childregs, 0, sizeof(struct pt_regs)); 58 childregs-\u0026gt;pstate = PSR_MODE_EL1h | PSR_IL_BIT; 59 60 p-\u0026gt;thread.cpu_context.x19 = (unsigned long)args-\u0026gt;fn; 61 p-\u0026gt;thread.cpu_context.x20 = (unsigned long)args-\u0026gt;fn_arg; 62 } 63 p-\u0026gt;thread.cpu_context.pc = (unsigned long)ret_from_fork; 64 p-\u0026gt;thread.cpu_context.sp = (unsigned long)childregs; 65 /* 66 * For the benefit of the unwinder, set up childregs-\u0026gt;stackframe 67 * as the final frame for the new task. 68 */ 69 p-\u0026gt;thread.cpu_context.fp = (unsigned long)childregs-\u0026gt;stackframe; 70 71 ptrace_hw_copy_thread(p); 72 73 return 0; 74} 对于用户态，childregs复制current_pt_regs，childregs-\u0026gt;sp指向用户栈，x0设为0作为fork返回值，这样用户态可以识别到这是子进程。 对于内核态调用的fork，childregs清零，x19和x20分别记录args-\u0026gt;fn和args-\u0026gt;fn_arg。\n其他值是相同的\np-\u0026gt;thread.cpu_context.sp指向childregs，指向内核栈task-\u0026gt;stack的栈底+sizeof(struct pt_regs)的位置。 cpu_context.pc为ret_from_fork。 调度时，首先使用内核栈，找到cpu_context.sp和pc，跳转到ret_from_fork； 如果是内核线程，将x20赋值到x0，跳转x19指向的函数，继续使用内核栈。 如果是用户程序，返回用户态时，从childregs取出用户栈地址，恢复用户上下文。\n","date":"February 3, 2024","img":"https://kingdix10.github.io/covers/blinds_lines_shade_143653_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/sched/b-copy_process_2/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"Linux","url":"/zh-cn/tags/linux/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1706918400,"title":"Linux内核copy_process分析（二）"},{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1. stackleak_task_init 需要编译器和体系结构支持，见CONFIG_GCC_PLUGIN_STACKLEAK，ARM64默认未使能。 如果使能，会设置lowest_stack。在ret_to_user时调用stackleak_erase_on_task_stack为栈空间内的一段区间写为特定值。\n2. stackleak_task_init 1 stackleak_task_init(p); 3. alloc_pid 在新进程所属的每一级pid namespace中申请pid。\n1 /// 判断是否是fork_idle调用，idle线程不需要新的pid 2 /// 创建用户进程和内核线程时，传入的pid为NULL 3 if (pid != \u0026amp;init_struct_pid) { 4 pid = alloc_pid(p-\u0026gt;nsproxy-\u0026gt;pid_ns_for_children, args-\u0026gt;set_tid, 5 args-\u0026gt;set_tid_size); 6 if (IS_ERR(pid)) { 7 retval = PTR_ERR(pid); 8 goto bad_fork_cleanup_thread; 9 } 10 } 3.1. alloc_pid源码 1/// kernel/pid.c 2struct pid *alloc_pid(struct pid_namespace *ns, pid_t *set_tid, 3 size_t set_tid_size) 4{ 5 struct pid *pid; 6 enum pid_type type; 7 int i, nr; 8 struct pid_namespace *tmp; 9 struct upid *upid; 10 int retval = -ENOMEM; 11 12 /* 13 * set_tid_size contains the size of the set_tid array. Starting at 14 * the most nested currently active PID namespace it tells alloc_pid() 15 * which PID to set for a process in that most nested PID namespace 16 * up to set_tid_size PID namespaces. It does not have to set the PID 17 * for a process in all nested PID namespaces but set_tid_size must 18 * never be greater than the current ns-\u0026gt;level + 1. 19 */ 20 if (set_tid_size \u0026gt; ns-\u0026gt;level + 1) 21 return ERR_PTR(-EINVAL); 22 23 pid = kmem_cache_alloc(ns-\u0026gt;pid_cachep, GFP_KERNEL); 24 if (!pid) 25 return ERR_PTR(retval); 26 27 tmp = ns; 28 pid-\u0026gt;level = ns-\u0026gt;level; 29 30 /// 下面的循环在新进程所属的每一级pid namespace中申请pid 31 for (i = ns-\u0026gt;level; i \u0026gt;= 0; i--) { 32 int tid = 0; 33 /// 处理手动设置tid的情况，set_tid数组给出的是pid的最小值 34 if (set_tid_size) { 35 tid = set_tid[ns-\u0026gt;level - i]; 36 37 retval = -EINVAL; 38 if (tid \u0026lt; 1 || tid \u0026gt;= pid_max) 39 goto out_free; 40 /// 如果是新创建的pid namespace，新的命名空间没有1号进程，set_tid的pid需要从1开始 41 /* 42 * Also fail if a PID != 1 is requested and 43 * no PID 1 exists. 44 */ 45 if (tid != 1 \u0026amp;\u0026amp; !tmp-\u0026gt;child_reaper) 46 goto out_free; 47 retval = -EPERM; 48 if (!checkpoint_restore_ns_capable(tmp-\u0026gt;user_ns)) 49 goto out_free; 50 set_tid_size--; 51 } 52 53 idr_preload(GFP_KERNEL); 54 spin_lock_irq(\u0026amp;pidmap_lock); 55 56 if (tid) { /// 手动设置tid的情况 57 nr = idr_alloc(\u0026amp;tmp-\u0026gt;idr, NULL, tid, 58 tid + 1, GFP_ATOMIC); 59 /* 60 * If ENOSPC is returned it means that the PID is 61 * alreay in use. Return EEXIST in that case. 62 */ 63 if (nr == -ENOSPC) 64 nr = -EEXIST; 65 } else { 66 int pid_min = 1; 67 /* 68 * init really needs pid 1, but after reaching the 69 * maximum wrap back to RESERVED_PIDS 70 */ 71 if (idr_get_cursor(\u0026amp;tmp-\u0026gt;idr) \u0026gt; RESERVED_PIDS) 72 pid_min = RESERVED_PIDS; 73 74 /* 75 * Store a null pointer so find_pid_ns does not find 76 * a partially initialized PID (see below). 77 */ 78 nr = idr_alloc_cyclic(\u0026amp;tmp-\u0026gt;idr, NULL, pid_min, 79 pid_max, GFP_ATOMIC); 80 } 81 spin_unlock_irq(\u0026amp;pidmap_lock); 82 idr_preload_end(); 83 84 if (nr \u0026lt; 0) { 85 retval = (nr == -ENOSPC) ? -EAGAIN : nr; 86 goto out_free; 87 } 88 89 /// 进程在这一级pid namespace中的pid号 90 pid-\u0026gt;numbers[i].nr = nr; 91 pid-\u0026gt;numbers[i].ns = tmp; 92 tmp = tmp-\u0026gt;parent; 93 } 94 95 /* 96 * ENOMEM is not the most obvious choice especially for the case 97 * where the child subreaper has already exited and the pid 98 * namespace denies the creation of any new processes. But ENOMEM 99 * is what we have exposed to userspace for a long time and it is 100 * documented behavior for pid namespaces. So we can\u0026#39;t easily 101 * change it even if there were an error code better suited. 102 */ 103 retval = -ENOMEM; 104 105 get_pid_ns(ns); 106 refcount_set(\u0026amp;pid-\u0026gt;count, 1); 107 spin_lock_init(\u0026amp;pid-\u0026gt;lock); 108 for (type = 0; type \u0026lt; PIDTYPE_MAX; ++type) 109 INIT_HLIST_HEAD(\u0026amp;pid-\u0026gt;tasks[type]); 110 111 init_waitqueue_head(\u0026amp;pid-\u0026gt;wait_pidfd); 112 INIT_HLIST_HEAD(\u0026amp;pid-\u0026gt;inodes); 113 114 upid = pid-\u0026gt;numbers + ns-\u0026gt;level; 115 spin_lock_irq(\u0026amp;pidmap_lock); 116 if (!(ns-\u0026gt;pid_allocated \u0026amp; PIDNS_ADDING)) 117 goto out_unlock; 118 for ( ; upid \u0026gt;= pid-\u0026gt;numbers; --upid) { 119 /* Make the PID visible to find_pid_ns. */ 120 idr_replace(\u0026amp;upid-\u0026gt;ns-\u0026gt;idr, pid, upid-\u0026gt;nr); 121 upid-\u0026gt;ns-\u0026gt;pid_allocated++; 122 } 123 spin_unlock_irq(\u0026amp;pidmap_lock); 124 125 return pid; 126 /// ... ... 127} 4. pidfd pidfd用于在进程间通信、父进程等待子进程退出等情况下，通知用户态。\n1 /// 此操作必须在可能取消共享文件描述符表之后进行 2 ///（以确保如果文件描述符表未共享，子进程不会泄漏pidfd） 3 /* 4 * This has to happen after we\u0026#39;ve potentially unshared the file 5 * descriptor table (so that the pidfd doesn\u0026#39;t leak into the child 6 * if the fd table isn\u0026#39;t shared). 7 */ 8 if (clone_flags \u0026amp; CLONE_PIDFD) { 9 /* Note that no task has been attached to @pid yet. */ 10 retval = __pidfd_prepare(pid, O_RDWR | O_CLOEXEC, \u0026amp;pidfile); 11 if (retval \u0026lt; 0) 12 goto bad_fork_free_pid; 13 pidfd = retval; 14 15 retval = put_user(pidfd, args-\u0026gt;pidfd); 16 if (retval) 17 goto bad_fork_put_pidfd; 18 } 5. futex和tracing等数据初始化 1#ifdef CONFIG_BLOCK 2 p-\u0026gt;plug = NULL; 3#endif 4 /// 依赖CONFIG_FUTEXT，futex相关成员初始化 5 futex_init_task(p); 6 7 /* 8 * sigaltstack should be cleared when sharing the same VM 9 */ 10 if ((clone_flags \u0026amp; (CLONE_VM|CLONE_VFORK)) == CLONE_VM) 11 sas_ss_reset(p); 12 13 /* 14 * Syscall tracing and stepping should be turned off in the 15 * child regardless of CLONE_PTRACE. 16 */ 17 user_disable_single_step(p); 18 clear_task_syscall_work(p, SYSCALL_TRACE); 19#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU) 20 clear_task_syscall_work(p, SYSCALL_EMU); 21#endif 22 clear_tsk_latency_tracing(p); 6. pid 1 /* ok, now we should be set up.. */ 2 p-\u0026gt;pid = pid_nr(pid); /// 获取进程在init namespace中的id 3 if (clone_flags \u0026amp; CLONE_THREAD) { 4 p-\u0026gt;group_leader = current-\u0026gt;group_leader; 5 p-\u0026gt;tgid = current-\u0026gt;tgid; /// 线程的tgid是主线程id 6 } else { 7 p-\u0026gt;group_leader = p; 8 p-\u0026gt;tgid = p-\u0026gt;pid; /// 单线程进程的tgid和pid相同 9 } 10 11 p-\u0026gt;nr_dirtied = 0; 12 p-\u0026gt;nr_dirtied_pause = 128 \u0026gt;\u0026gt; (PAGE_SHIFT - 10); 13 p-\u0026gt;dirty_paused_when = 0; 14 15 p-\u0026gt;pdeath_signal = 0; 16 INIT_LIST_HEAD(\u0026amp;p-\u0026gt;thread_group); /// 这里先初始化一下，后续再赋值 17 p-\u0026gt;task_works = NULL; 18 clear_posix_cputimers_work(p); 19 20#ifdef CONFIG_KRETPROBES 21 p-\u0026gt;kretprobe_instances.first = NULL; 22#endif 23#ifdef CONFIG_RETHOOK 24 p-\u0026gt;rethooks.first = NULL; 25#endif 7. sched_cgroup_fork 检查在cgroup的管理下是否可以创建新进程。\n1 /* 2 * Ensure that the cgroup subsystem policies allow the new process to be 3 * forked. It should be noted that the new process\u0026#39;s css_set can be changed 4 * between here and cgroup_post_fork() if an organisation operation is in 5 * progress. 6 */ 7 retval = cgroup_can_fork(p, args); 8 if (retval) 9 goto bad_fork_put_pidfd; 8. sched_cgroup_fork 现在已经将cgroups固定了，重新克隆父cgroup并将新任务放在正确的运行队列上。所有这些都在任务变得可见之前完成。 这不是can_fork的一部分，因为虽然重新克隆是cgroup特定的，但它需要将任务无条件的放在一个运行队列上。\n1 /* 2 * Now that the cgroups are pinned, re-clone the parent cgroup and put 3 * the new task on the correct runqueue. All this *before* the task 4 * becomes visible. 5 * 6 * This isn\u0026#39;t part of -\u0026gt;can_fork() because while the re-cloning is 7 * cgroup specific, it unconditionally needs to place the task on a 8 * runqueue. 9 */ 10 sched_cgroup_fork(p, args); 9. start_time/start_boottime 1 /* 2 * From this point on we must avoid any synchronous user-space 3 * communication until we take the tasklist-lock. In particular, we do 4 * not want user-space to be able to predict the process start-time by 5 * stalling fork(2) after we recorded the start_time but before it is 6 * visible to the system. 7 */ 8 9 p-\u0026gt;start_time = ktime_get_ns(); 10 p-\u0026gt;start_boottime = ktime_get_boottime_ns(); 10. real_parent和exit_signal 主线程的exit_signal大于等于0，其他子线程的exit_signal为-1。\n1 /* 2 * Make it visible to the rest of the system, but dont wake it up yet. 3 * Need tasklist lock for parent etc handling! 4 */ 5 write_lock_irq(\u0026amp;tasklist_lock); 6 7 /* CLONE_PARENT re-uses the old parent */ 8 if (clone_flags \u0026amp; (CLONE_PARENT|CLONE_THREAD)) { 9 p-\u0026gt;real_parent = current-\u0026gt;real_parent; 10 p-\u0026gt;parent_exec_id = current-\u0026gt;parent_exec_id; 11 if (clone_flags \u0026amp; CLONE_THREAD) 12 p-\u0026gt;exit_signal = -1; 13 else 14 p-\u0026gt;exit_signal = current-\u0026gt;group_leader-\u0026gt;exit_signal; 15 } else { 16 p-\u0026gt;real_parent = current; 17 p-\u0026gt;parent_exec_id = current-\u0026gt;self_exec_id; 18 p-\u0026gt;exit_signal = args-\u0026gt;exit_signal; 19 } 11. klp_copy_process livepatch处理。\n1 klp_copy_process(p); 12. sched_core_fork sched_core相关成员初始化。\n1 sched_core_fork(p); 12.1. sched_core_fork源码 1/// kernel/sched/core_sched.c 2void sched_core_fork(struct task_struct *p) 3{ 4 RB_CLEAR_NODE(\u0026amp;p-\u0026gt;core_node); 5 p-\u0026gt;core_cookie = sched_core_clone_cookie(current); 6} 13. copy_xxx前的准备工作 1 spin_lock(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); 2 3 rv_task_fork(p); 4 5 rseq_fork(p, clone_flags); 6 7 /* Don\u0026#39;t start children in a dying pid namespace */ 8 if (unlikely(!(ns_of_pid(pid)-\u0026gt;pid_allocated \u0026amp; PIDNS_ADDING))) { 9 retval = -ENOMEM; 10 goto bad_fork_cancel_cgroup; 11 } 12 /// fork过程中收到致命信号，直接退出 13 /* Let kill terminate clone/fork in the middle */ 14 if (fatal_signal_pending(current)) { 15 retval = -EINTR; 16 goto bad_fork_cancel_cgroup; 17 } 14. copy_seccomp secure compute相关变量初始化。\n1 /* No more failure paths after this point. */ 2 3 /* 4 * Copy seccomp details explicitly here, in case they were changed 5 * before holding sighand lock. 6 */ 7 copy_seccomp(p); 15. process or thread 这段代码是理解线程、进程、进程组、会话的关键。\n1 init_task_pid_links(p); /// pid_links数组初始化 2 if (likely(p-\u0026gt;pid)) { /// 非idle线程 3 /// ptrace相关成员初始化 4 ptrace_init_task(p, (clone_flags \u0026amp; CLONE_PTRACE) || trace); 5 6 init_task_pid(p, PIDTYPE_PID, pid); /// task-\u0026gt;thread_pid = pid 7 if (thread_group_leader(p)) { /// 用户进程主线程或内核线程 8 init_task_pid(p, PIDTYPE_TGID, pid); /// task-\u0026gt;signal-\u0026gt;pids[type] = pid 9 init_task_pid(p, PIDTYPE_PGID, task_pgrp(current)); 10 init_task_pid(p, PIDTYPE_SID, task_session(current)); 11 12 /// 本pid namespace的1号进程，新建pid namespace时满足 13 if (is_child_reaper(pid)) { 14 ns_of_pid(pid)-\u0026gt;child_reaper = p; 15 p-\u0026gt;signal-\u0026gt;flags |= SIGNAL_UNKILLABLE; 16 } 17 /// 在fork期间收到的信号被记录到父进程的multiprocess，现在从父进程的multiprocess复制回来 18 p-\u0026gt;signal-\u0026gt;shared_pending.signal = delayed.signal; 19 p-\u0026gt;signal-\u0026gt;tty = tty_kref_get(current-\u0026gt;signal-\u0026gt;tty); 20 /* 21 * Inherit has_child_subreaper flag under the same 22 * tasklist_lock with adding child to the process tree 23 * for propagate_has_child_subreaper optimization. 24 */ 25 p-\u0026gt;signal-\u0026gt;has_child_subreaper = p-\u0026gt;real_parent-\u0026gt;signal-\u0026gt;has_child_subreaper || 26 p-\u0026gt;real_parent-\u0026gt;signal-\u0026gt;is_child_subreaper; 27 list_add_tail(\u0026amp;p-\u0026gt;sibling, \u0026amp;p-\u0026gt;real_parent-\u0026gt;children); /// 加入父进程的子进程链表 28 list_add_tail_rcu(\u0026amp;p-\u0026gt;tasks, \u0026amp;init_task.tasks); /// 加入全局（init_task）的子进程链表 29 /// attach_pid: hlist_add_head_rcu(\u0026amp;task-\u0026gt;pid_links[type], \u0026amp;pid-\u0026gt;tasks[type]); 30 attach_pid(p, PIDTYPE_TGID); /// 加入到线程组列表 31 attach_pid(p, PIDTYPE_PGID); /// 加入到进程组列表 32 attach_pid(p, PIDTYPE_SID); /// 加入到会话列表 33 __this_cpu_inc(process_counts); /// 增加当前cpu的process_counts 34 } else { /// 用户线程子线程 35 current-\u0026gt;signal-\u0026gt;nr_threads++; /// 多线程进程的signal是共享的，增加计数 36 current-\u0026gt;signal-\u0026gt;quick_threads++; 37 atomic_inc(\u0026amp;current-\u0026gt;signal-\u0026gt;live); 38 refcount_inc(\u0026amp;current-\u0026gt;signal-\u0026gt;sigcnt); 39 task_join_group_stop(p); /// 处理jobctl和signal 40 list_add_tail_rcu(\u0026amp;p-\u0026gt;thread_group, 41 \u0026amp;p-\u0026gt;group_leader-\u0026gt;thread_group); /// 添加到进程的线程链表 42 list_add_tail_rcu(\u0026amp;p-\u0026gt;thread_node, 43 \u0026amp;p-\u0026gt;signal-\u0026gt;thread_head); /// 添加到进程信号的线程链表 44 } 45 attach_pid(p, PIDTYPE_PID); /// 加入到线程列表 46 nr_threads++; 47 } 48 total_forks++; 49 hlist_del_init(\u0026amp;delayed.node); /// 从父进程的multiprocess删除临时列表变量 50 spin_unlock(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); 51 syscall_tracepoint_update(p); 52 write_unlock_irq(\u0026amp;tasklist_lock); 关于thread_group和thread_node，如果没有tasklist/siglock，list_for_each_entry_rcu只在g非exit/exec的情况下才是rcu-safe的，否则在list_del_rcu(g)之后，next_thread(t)永远无法访问到g。\n1/// include/linux/sched/signal.h 2/* 3 * Without tasklist/siglock it is only rcu-safe if g can\u0026#39;t exit/exec, 4 * otherwise next_thread(t) will never reach g after list_del_rcu(g). 5 */ 6#define while_each_thread(g, t) \\ 7 while ((t = next_thread(t)) != g) 8 9#define __for_each_thread(signal, t)\t\\ 10 list_for_each_entry_rcu(t, \u0026amp;(signal)-\u0026gt;thread_head, thread_node) 11 12#define for_each_thread(p, t)\t\\ 13 __for_each_thread((p)-\u0026gt;signal, t) 14 15/* Careful: this is a double loop, \u0026#39;break\u0026#39; won\u0026#39;t work as expected. */ 16#define for_each_process_thread(p, t)\t\\ 17 for_each_process(p) for_each_thread(p, t) 18 19/// include/linux/sched/signal.h 20static inline struct task_struct *next_thread(const struct task_struct *p) 21{ 22 return list_entry_rcu(p-\u0026gt;thread_group.next, 23 struct task_struct, thread_group); 24} 16. pidfile 如果clone_flags包含CLONE_PIDFD，将pidfd加入到父进程的文件列表。\n1 if (pidfile) 2 fd_install(pidfd, pidfile); 17. 收尾工作 1 proc_fork_connector(p); /// 依赖CONFIG_PROC_EVENTS 2 sched_post_fork(p); /// 正对rt任务，配置默认最小的cpu利用率限制 3 cgroup_post_fork(p, args); 4 perf_event_fork(p); 5 6 trace_task_newtask(p, clone_flags); 7 uprobe_copy_process(p, clone_flags); 8 /// 如果clone_flags包含CLONE_VM，共享父进程user_event_mm 9 user_events_fork(p, clone_flags); 10 11 copy_oom_score_adj(clone_flags, p); 12 13 return p; 17.1. copy_oom_score_adj源码 为用户进程（非线程）配置oom相关参数。\n1/// kernel/fork.c 2static void copy_oom_score_adj(u64 clone_flags, struct task_struct *tsk) 3{ 4 /* Skip if kernel thread */ 5 if (!tsk-\u0026gt;mm) 6 return; 7 8 /* Skip if spawning a thread or using vfork */ 9 if ((clone_flags \u0026amp; (CLONE_VM | CLONE_THREAD | CLONE_VFORK)) != CLONE_VM) 10 return; 11 12 /* We need to synchronize with __set_oom_adj */ 13 mutex_lock(\u0026amp;oom_adj_mutex); 14 set_bit(MMF_MULTIPROCESS, \u0026amp;tsk-\u0026gt;mm-\u0026gt;flags); 15 /* Update the values in case they were changed after copy_signal */ 16 tsk-\u0026gt;signal-\u0026gt;oom_score_adj = current-\u0026gt;signal-\u0026gt;oom_score_adj; 17 tsk-\u0026gt;signal-\u0026gt;oom_score_adj_min = current-\u0026gt;signal-\u0026gt;oom_score_adj_min; 18 mutex_unlock(\u0026amp;oom_adj_mutex); 19} ","date":"February 3, 2024","img":"https://kingdix10.github.io/covers/pink_color_background_153889_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/sched/b-copy_process_3/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"Linux","url":"/zh-cn/tags/linux/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1706918400,"title":"Linux内核copy_process分析（三）"},{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1. copy_process原型 1/// kernel/fork.c 2/* 3 * This creates a new process as a copy of the old one, 4 * but does not actually start it yet. 5 * 6 * It copies the registers, and all the appropriate 7 * parts of the process environment (as per the clone 8 * flags). The actual kick-off is left to the caller. 9 */ 10__latent_entropy struct task_struct *copy_process( 11 struct pid *pid, 12 int trace, 13 int node, 14 struct kernel_clone_args *args) pid主要是为fork_init准备的，其值为\u0026amp;init_struct_pid，其他情况为NULL。\n2. 局部变量声明 1 int pidfd = -1, retval; 2 struct task_struct *p; 3 struct multiprocess_signals delayed; 4 struct file *pidfile = NULL; 5 const u64 clone_flags = args-\u0026gt;flags; 6 struct nsproxy *nsp = current-\u0026gt;nsproxy; 3. 参数检查 1 /* 2 * Don\u0026#39;t allow sharing the root directory with processes in a different 3 * namespace 4 */ 5 if ((clone_flags \u0026amp; (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS)) 6 return ERR_PTR(-EINVAL); 7 8 if ((clone_flags \u0026amp; (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS)) 9 return ERR_PTR(-EINVAL); 10 11 /* 12 * Thread groups must share signals as well, and detached threads 13 * can only be started up within the thread group. 14 */ 15 if ((clone_flags \u0026amp; CLONE_THREAD) \u0026amp;\u0026amp; !(clone_flags \u0026amp; CLONE_SIGHAND)) 16 return ERR_PTR(-EINVAL); 17 18 /* 19 * Shared signal handlers imply shared VM. By way of the above, 20 * thread groups also imply shared VM. Blocking this case allows 21 * for various simplifications in other code. 22 */ 23 if ((clone_flags \u0026amp; CLONE_SIGHAND) \u0026amp;\u0026amp; !(clone_flags \u0026amp; CLONE_VM)) 24 return ERR_PTR(-EINVAL); 25 26 /* 27 * Siblings of global init remain as zombies on exit since they are 28 * not reaped by their parent (swapper). To solve this and to avoid 29 * multi-rooted process trees, prevent global and container-inits 30 * from creating siblings. 31 */ 32 if ((clone_flags \u0026amp; CLONE_PARENT) \u0026amp;\u0026amp; 33 current-\u0026gt;signal-\u0026gt;flags \u0026amp; SIGNAL_UNKILLABLE) 34 return ERR_PTR(-EINVAL); 35 36 /* 37 * If the new process will be in a different pid or user namespace 38 * do not allow it to share a thread group with the forking task. 39 */ 40 if (clone_flags \u0026amp; CLONE_THREAD) { 41 if ((clone_flags \u0026amp; (CLONE_NEWUSER | CLONE_NEWPID)) || 42 (task_active_pid_ns(current) != nsp-\u0026gt;pid_ns_for_children)) 43 return ERR_PTR(-EINVAL); 44 } 45 46 if (clone_flags \u0026amp; CLONE_PIDFD) { 47 /* 48 * - CLONE_DETACHED is blocked so that we can potentially 49 * reuse it later for CLONE_PIDFD. 50 * - CLONE_THREAD is blocked until someone really needs it. 51 */ 52 if (clone_flags \u0026amp; (CLONE_DETACHED | CLONE_THREAD)) 53 return ERR_PTR(-EINVAL); 54 } 4. 当前进程signal处理 将收到的信号强制分发出去。使用delayed收集在fork过程中发送给进程的信号，以便进行延迟处理。在新进程准备好后，将其记录到新进程的p-\u0026gt;signal-\u0026gt;shared_pending.signal，再进行处理。之后清除pending的信号。完成之后，继续检查是否收到信号，如果收到信号，则fork失败，直接退出。\n1 /* 2 * Force any signals received before this point to be delivered 3 * before the fork happens. Collect up signals sent to multiple 4 * processes that happen during the fork and delay them so that 5 * they appear to happen after the fork. 6 */ 7 sigemptyset(\u0026amp;delayed.signal); 8 INIT_HLIST_NODE(\u0026amp;delayed.node); 9 10 spin_lock_irq(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); 11 /// delayed记录到父进程的multiprocess，用于收集在新进程fork期间收到的信号 12 if (!(clone_flags \u0026amp; CLONE_THREAD)) 13 hlist_add_head(\u0026amp;delayed.node, \u0026amp;current-\u0026gt;signal-\u0026gt;multiprocess); 14 recalc_sigpending(); 15 spin_unlock_irq(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); 16 retval = -ERESTARTNOINTR; 17 if (task_sigpending(current)) /// 继续检查是否收到信号 18 goto fork_out; 5. dup_task_struct dup_task_struct基于current创建新的task_struct，和一些其他信息，申请内核栈，初始化新进程的一些变量。\n1 retval = -ENOMEM; 2 p = dup_task_struct(current, node); 3 if (!p) 4 goto fork_out; 5.1. dup_task_struct源码 1static struct task_struct *dup_task_struct(struct task_struct *orig, int node) 2{ 3 struct task_struct *tsk; 4 int err; 5 6 if (node == NUMA_NO_NODE) 7 node = tsk_fork_get_node(orig); 8 tsk = alloc_task_struct_node(node); 9 if (!tsk) 10 return NULL; 11 12 err = arch_dup_task_struct(tsk, orig); /// 复制task_struct，和一些其他信息 13 if (err) 14 goto free_tsk; 15 16 err = alloc_thread_stack_node(tsk, node); /// 申请内核栈，记录到tsk-\u0026gt;stack 17 if (err) 18 goto free_tsk; 19 20#ifdef CONFIG_THREAD_INFO_IN_TASK 21 refcount_set(\u0026amp;tsk-\u0026gt;stack_refcount, 1); 22#endif 23 account_kernel_stack(tsk, 1); 24 25 err = scs_prepare(tsk, node); 26 if (err) 27 goto free_stack; 28 29#ifdef CONFIG_SECCOMP 30 /* 31 * We must handle setting up seccomp filters once we\u0026#39;re under 32 * the sighand lock in case orig has changed between now and 33 * then. Until then, filter must be NULL to avoid messing up 34 * the usage counts on the error path calling free_task. 35 */ 36 tsk-\u0026gt;seccomp.filter = NULL; 37#endif 38 39 /// 在thread_info独立与task_struct时，将tsk记录到栈，以便使用current获取当前进程 40 setup_thread_stack(tsk, orig); 41 clear_user_return_notifier(tsk); 42 clear_tsk_need_resched(tsk); /// 新建的进程不需要调度 43 set_task_stack_end_magic(tsk); /// 设置栈底魔数 44 clear_syscall_work_syscall_user_dispatch(tsk); 45 46#ifdef CONFIG_STACKPROTECTOR 47 /// Canary value for the -fstack-protector GCC feature 48 tsk-\u0026gt;stack_canary = get_random_canary(); 49#endif 50 if (orig-\u0026gt;cpus_ptr == \u0026amp;orig-\u0026gt;cpus_mask) 51 tsk-\u0026gt;cpus_ptr = \u0026amp;tsk-\u0026gt;cpus_mask; 52 dup_user_cpus_ptr(tsk, orig, node); 53 54 /* 55 * One for the user space visible state that goes away when reaped. 56 * One for the scheduler. 57 */ 58 refcount_set(\u0026amp;tsk-\u0026gt;rcu_users, 2); /// 进程退出和回收task_struct时使用 59 /* One for the rcu users */ 60 refcount_set(\u0026amp;tsk-\u0026gt;usage, 1); /// 回收task_struct时使用 61#ifdef CONFIG_BLK_DEV_IO_TRACE 62 tsk-\u0026gt;btrace_seq = 0; 63#endif 64 tsk-\u0026gt;splice_pipe = NULL; 65 tsk-\u0026gt;task_frag.page = NULL; 66 tsk-\u0026gt;wake_q.next = NULL; 67 tsk-\u0026gt;worker_private = NULL; 68 69 kcov_task_init(tsk); 70 kmsan_task_create(tsk); 71 kmap_local_fork(tsk); 72 73#ifdef CONFIG_FAULT_INJECTION 74 tsk-\u0026gt;fail_nth = 0; 75#endif 76 77#ifdef CONFIG_BLK_CGROUP 78 tsk-\u0026gt;throttle_disk = NULL; 79 tsk-\u0026gt;use_memdelay = 0; 80#endif 81 82#ifdef CONFIG_IOMMU_SVA 83 tsk-\u0026gt;pasid_activated = 0; 84#endif 85 86#ifdef CONFIG_MEMCG 87 tsk-\u0026gt;active_memcg = NULL; 88#endif 89 90#ifdef CONFIG_CPU_SUP_INTEL 91 tsk-\u0026gt;reported_split_lock = 0; 92#endif 93 94#ifdef CONFIG_SCHED_MM_CID 95 tsk-\u0026gt;mm_cid = -1; 96 tsk-\u0026gt;last_mm_cid = -1; 97 tsk-\u0026gt;mm_cid_active = 0; 98 tsk-\u0026gt;migrate_from_cpu = -1; 99#endif 100 return tsk; 101 102free_stack: 103 exit_task_stack_account(tsk); 104 free_thread_stack(tsk); 105free_tsk: 106 free_task_struct(tsk); 107 return NULL; 108} 6. flags、进程名等设置 1 p-\u0026gt;flags \u0026amp;= ~PF_KTHREAD; /// 默认不是内核线程 2 if (args-\u0026gt;kthread) 3 p-\u0026gt;flags |= PF_KTHREAD; /// 如果是内核线程，设置PF_KTHREAD 4 if (args-\u0026gt;user_worker) { /// 如果是user worker，阻止非致命信号和STOP 5 /* 6 * Mark us a user worker, and block any signal that isn\u0026#39;t 7 * fatal or STOP 8 */ 9 p-\u0026gt;flags |= PF_USER_WORKER; 10 siginitsetinv(\u0026amp;p-\u0026gt;blocked, sigmask(SIGKILL)|sigmask(SIGSTOP)); 11 } 12 if (args-\u0026gt;io_thread) /// io线程 13 p-\u0026gt;flags |= PF_IO_WORKER; 14 15 if (args-\u0026gt;name) /// 设置进程名 16 strscpy_pad(p-\u0026gt;comm, args-\u0026gt;name, sizeof(p-\u0026gt;comm)); 17 18 /// 父设置子进程的pid 19 p-\u0026gt;set_child_tid = (clone_flags \u0026amp; CLONE_CHILD_SETTID) ? args-\u0026gt;child_tid : NULL; 20 /* 21 * Clear TID on mm_release()? 22 */ 23 p-\u0026gt;clear_child_tid = (clone_flags \u0026amp; CLONE_CHILD_CLEARTID) ? args-\u0026gt;child_tid : NULL; 24 25 ftrace_graph_init_task(p); 26 27 rt_mutex_init_task(p); 28 29 lockdep_assert_irqs_enabled(); 30#ifdef CONFIG_PROVE_LOCKING 31 DEBUG_LOCKS_WARN_ON(!p-\u0026gt;softirqs_enabled); 32#endif 7. copy_creds 如果clone_flags包含CLONE_THREAD，与父进程共享凭证，否则创建新的凭证。包含进程的UID和GID等信息。\n1 retval = copy_creds(p, clone_flags); 2 if (retval \u0026lt; 0) 3 goto bad_fork_free; 7.1. copy_creds源码 1/// kernel/cred.c 2/* 3 * Copy credentials for the new process created by fork() 4 * 5 * We share if we can, but under some circumstances we have to generate a new 6 * set. 7 * 8 * The new process gets the current process\u0026#39;s subjective credentials as its 9 * objective and subjective credentials 10 */ 11int copy_creds(struct task_struct *p, unsigned long clone_flags) 12{ 13 struct cred *new; 14 int ret; 15 16#ifdef CONFIG_KEYS_REQUEST_CACHE 17 p-\u0026gt;cached_requested_key = NULL; 18#endif 19 20 if ( 21#ifdef CONFIG_KEYS 22 !p-\u0026gt;cred-\u0026gt;thread_keyring \u0026amp;\u0026amp; 23#endif 24 clone_flags \u0026amp; CLONE_THREAD 25 ) { 26 p-\u0026gt;real_cred = get_cred(p-\u0026gt;cred); 27 get_cred(p-\u0026gt;cred); 28 alter_cred_subscribers(p-\u0026gt;cred, 2); 29 kdebug(\u0026#34;share_creds(%p{%d,%d})\u0026#34;, 30 p-\u0026gt;cred, atomic_read(\u0026amp;p-\u0026gt;cred-\u0026gt;usage), 31 read_cred_subscribers(p-\u0026gt;cred)); 32 inc_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1); 33 return 0; 34 } 35 36 new = prepare_creds(); 37 if (!new) 38 return -ENOMEM; 39 40 if (clone_flags \u0026amp; CLONE_NEWUSER) { 41 ret = create_user_ns(new); 42 if (ret \u0026lt; 0) 43 goto error_put; 44 ret = set_cred_ucounts(new); 45 if (ret \u0026lt; 0) 46 goto error_put; 47 } 48 49#ifdef CONFIG_KEYS 50 /* new threads get their own thread keyrings if their parent already 51 * had one */ 52 if (new-\u0026gt;thread_keyring) { 53 key_put(new-\u0026gt;thread_keyring); 54 new-\u0026gt;thread_keyring = NULL; 55 if (clone_flags \u0026amp; CLONE_THREAD) 56 install_thread_keyring_to_cred(new); 57 } 58 59 /* The process keyring is only shared between the threads in a process; 60 * anything outside of those threads doesn\u0026#39;t inherit. 61 */ 62 if (!(clone_flags \u0026amp; CLONE_THREAD)) { 63 key_put(new-\u0026gt;process_keyring); 64 new-\u0026gt;process_keyring = NULL; 65 } 66#endif 67 68 p-\u0026gt;cred = p-\u0026gt;real_cred = get_cred(new); 69 inc_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1); 70 alter_cred_subscribers(new, 2); 71 validate_creds(new); 72 return 0; 73 74error_put: 75 put_cred(new); 76 return ret; 77} 8. 检查是否超过限制和一些其他变量初始化 1 retval = -EAGAIN; 2 /// 检查NPROC是否超过限制 3 if (is_rlimit_overlimit(task_ucounts(p), UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC))) { 4 /// 检查是否有管理权限 5 if (p-\u0026gt;real_cred-\u0026gt;user != INIT_USER \u0026amp;\u0026amp; 6 !capable(CAP_SYS_RESOURCE) \u0026amp;\u0026amp; !capable(CAP_SYS_ADMIN)) 7 goto bad_fork_cleanup_count; 8 } 9 current-\u0026gt;flags \u0026amp;= ~PF_NPROC_EXCEEDED; 10 11 /* 12 * If multiple threads are within copy_process(), then this check 13 * triggers too late. This doesn\u0026#39;t hurt, the check is only there 14 * to stop root fork bombs. 15 */ 16 retval = -EAGAIN; 17 /// 线程数是否超过限制，超过限制会返回-EAGAIN 18 if (data_race(nr_threads \u0026gt;= max_threads)) 19 goto bad_fork_cleanup_count; 20 21 delayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */ 22 p-\u0026gt;flags \u0026amp;= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE | PF_NO_SETAFFINITY); 23 p-\u0026gt;flags |= PF_FORKNOEXEC; /// Forked but didn\u0026#39;t exec 24 INIT_LIST_HEAD(\u0026amp;p-\u0026gt;children); /// 新创建的进程，子进程和兄弟进程列表都为空 25 INIT_LIST_HEAD(\u0026amp;p-\u0026gt;sibling); 26 rcu_copy_process(p); /// 初始化rcu相关成员 27 p-\u0026gt;vfork_done = NULL; /// 清空父进程的vfork信息 28 spin_lock_init(\u0026amp;p-\u0026gt;alloc_lock); 29 30 init_sigpending(\u0026amp;p-\u0026gt;pending); /// 清空signal 31 32 p-\u0026gt;utime = p-\u0026gt;stime = p-\u0026gt;gtime = 0; 33#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME 34 p-\u0026gt;utimescaled = p-\u0026gt;stimescaled = 0; 35#endif 36 prev_cputime_init(\u0026amp;p-\u0026gt;prev_cputime); 37 38#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN 39 seqcount_init(\u0026amp;p-\u0026gt;vtime.seqcount); 40 p-\u0026gt;vtime.starttime = 0; 41 p-\u0026gt;vtime.state = VTIME_INACTIVE; 42#endif 43 44#ifdef CONFIG_IO_URING 45 p-\u0026gt;io_uring = NULL; 46#endif 47 48#if defined(SPLIT_RSS_COUNTING) 49 memset(\u0026amp;p-\u0026gt;rss_stat, 0, sizeof(p-\u0026gt;rss_stat)); 50#endif 51 52 p-\u0026gt;default_timer_slack_ns = current-\u0026gt;timer_slack_ns; 53 54#ifdef CONFIG_PSI 55 p-\u0026gt;psi_flags = 0; 56#endif 9. 统计相关 1 task_io_accounting_init(\u0026amp;p-\u0026gt;ioac); 2 /// acct_clear_integrals - clear the mm integral fields in task_struct 3 acct_clear_integrals(p); 10. 一些变量初始化 1 posix_cputimers_init(\u0026amp;p-\u0026gt;posix_cputimers); 2 3 p-\u0026gt;io_context = NULL; 4 audit_set_context(p, NULL); 5 cgroup_fork(p); /// 设置cgroups为init_css_set，清空cg_list 6 if (args-\u0026gt;kthread) { 7 if (!set_kthread_struct(p)) /// 申请kthread数据并赋值给worker_private，同时设置vfork_done 8 goto bad_fork_cleanup_delayacct; 9 } 10#ifdef CONFIG_NUMA 11 p-\u0026gt;mempolicy = mpol_dup(p-\u0026gt;mempolicy); 12 if (IS_ERR(p-\u0026gt;mempolicy)) { 13 retval = PTR_ERR(p-\u0026gt;mempolicy); 14 p-\u0026gt;mempolicy = NULL; 15 goto bad_fork_cleanup_delayacct; 16 } 17#endif 18#ifdef CONFIG_CPUSETS 19 p-\u0026gt;cpuset_mem_spread_rotor = NUMA_NO_NODE; 20 p-\u0026gt;cpuset_slab_spread_rotor = NUMA_NO_NODE; 21 seqcount_spinlock_init(\u0026amp;p-\u0026gt;mems_allowed_seq, \u0026amp;p-\u0026gt;alloc_lock); 22#endif 23#ifdef CONFIG_TRACE_IRQFLAGS 24 memset(\u0026amp;p-\u0026gt;irqtrace, 0, sizeof(p-\u0026gt;irqtrace)); 25 p-\u0026gt;irqtrace.hardirq_disable_ip\t= _THIS_IP_; 26 p-\u0026gt;irqtrace.softirq_enable_ip\t= _THIS_IP_; 27 p-\u0026gt;softirqs_enabled\t= 1; 28 p-\u0026gt;softirq_context\t= 0; 29#endif 30 31 p-\u0026gt;pagefault_disabled = 0; 32 33#ifdef CONFIG_LOCKDEP 34 lockdep_init_task(p); 35#endif 36 37#ifdef CONFIG_DEBUG_MUTEXES 38 p-\u0026gt;blocked_on = NULL; /* not blocked yet */ 39#endif 40#ifdef CONFIG_BCACHE 41 p-\u0026gt;sequential_io\t= 0; 42 p-\u0026gt;sequential_io_avg\t= 0; 43#endif 44#ifdef CONFIG_BPF_SYSCALL 45 RCU_INIT_POINTER(p-\u0026gt;bpf_storage, NULL); 46 p-\u0026gt;bpf_ctx = NULL; 47#endif 11. sched_fork 将新创建的进程状态设置为TASK_NEW，设置调度策略和优先级，初始化负载。\n1 /* Perform scheduler related setup. Assign this task to a CPU. */ 2 retval = sched_fork(clone_flags, p); 3 if (retval) 4 goto bad_fork_cleanup_policy; 1/// kernel/sched/core.c 2/* 3 * fork()/clone()-time setup: 4 */ 5int sched_fork(unsigned long clone_flags, struct task_struct *p) 6{ 7 __sched_fork(clone_flags, p); /// 调度相关成员初始化 8 /* 9 * We mark the process as NEW here. This guarantees that 10 * nobody will actually run it, and a signal or other external 11 * event cannot wake it up and insert it on the runqueue either. 12 */ 13 p-\u0026gt;__state = TASK_NEW; 14 15 /* 16 * Make sure we do not leak PI boosting priority to the child. 17 */ 18 p-\u0026gt;prio = current-\u0026gt;normal_prio; 19 20 uclamp_fork(p); 21 22 /// 重置调度策略和优先级 23 /* 24 * Revert to default priority/policy on fork if requested. 25 */ 26 if (unlikely(p-\u0026gt;sched_reset_on_fork)) { 27 if (task_has_dl_policy(p) || task_has_rt_policy(p)) { 28 p-\u0026gt;policy = SCHED_NORMAL; 29 p-\u0026gt;static_prio = NICE_TO_PRIO(0); 30 p-\u0026gt;rt_priority = 0; 31 } else if (PRIO_TO_NICE(p-\u0026gt;static_prio) \u0026lt; 0) 32 p-\u0026gt;static_prio = NICE_TO_PRIO(0); 33 34 p-\u0026gt;prio = p-\u0026gt;normal_prio = p-\u0026gt;static_prio; 35 set_load_weight(p, false); 36 37 /* 38 * We don\u0026#39;t need the reset flag anymore after the fork. It has 39 * fulfilled its duty: 40 */ 41 p-\u0026gt;sched_reset_on_fork = 0; 42 } 43 44 /// 根据优先级设置调度策略 45 if (dl_prio(p-\u0026gt;prio)) 46 return -EAGAIN; 47 else if (rt_prio(p-\u0026gt;prio)) 48 p-\u0026gt;sched_class = \u0026amp;rt_sched_class; 49 else 50 p-\u0026gt;sched_class = \u0026amp;fair_sched_class; 51 52 /// 初始化sched_entity负载 53 init_entity_runnable_average(\u0026amp;p-\u0026gt;se); 54 55 56#ifdef CONFIG_SCHED_INFO 57 if (likely(sched_info_on())) 58 memset(\u0026amp;p-\u0026gt;sched_info, 0, sizeof(p-\u0026gt;sched_info)); 59#endif 60#if defined(CONFIG_SMP) 61 p-\u0026gt;on_cpu = 0; 62#endif 63 init_task_preempt_count(p); 64#ifdef CONFIG_SMP 65 plist_node_init(\u0026amp;p-\u0026gt;pushable_tasks, MAX_PRIO); 66 RB_CLEAR_NODE(\u0026amp;p-\u0026gt;pushable_dl_tasks); 67#endif 68 return 0; 69} 12. perf_event_init_task 初始化perf event上下文\n1 retval = perf_event_init_task(p, clone_flags); 2 if (retval) 3 goto bad_fork_cleanup_policy; 13. audit_alloc 申请audit上下文。\n1 retval = audit_alloc(p); 2 if (retval) 3 goto bad_fork_cleanup_perf; ","date":"February 3, 2024","img":"https://kingdix10.github.io/covers/iridescent_colorful_lines_130978_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/sched/b-copy_process_1/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"Linux","url":"/zh-cn/tags/linux/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1706918400,"title":"Linux内核copy_process分析（一）"},{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1. 动态链接和静态链接 1.1. 编译命令 1aarch64-linux-gnu-gcc -o dummy_arm64 dummy.c 2aarch64-linux-gnu-gcc -static -o dummy_arm64_static dummy.c 1.2. 查看文件格式信息 1$ file dummy_arm64* 2dummy_arm64: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID[sha1]=3fa0f1369e1b3181f059174b078dd893e813abb2, for GNU/Linux 3.7.0, with debug_info, not stripped 3dummy_arm64_static: ELF 64-bit LSB executable, ARM aarch64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=5475ac20b174d94d96e666e170fb2d6ce69cdf76, for GNU/Linux 3.7.0, with debug_info, not stripped 1.3. 读取elf文件信息 可以看到动态链接的程序需要有解释器/lib64/ld-linux-x86-64.so.2，与file目录看到的是一样的。静态链接的程序没有解释器段。\n1$ readelf -l dummy_arm64 2 3Elf file type is EXEC (Executable file) 4Entry point 0x4004c0 5There are 9 program headers, starting at offset 64 6 7Program Headers: 8 Type Offset VirtAddr PhysAddr 9 FileSiz MemSiz Flags Align 10 PHDR 0x0000000000000040 0x0000000000400040 0x0000000000400040 11 0x00000000000001f8 0x00000000000001f8 R 0x8 12 INTERP 0x0000000000000238 0x0000000000400238 0x0000000000400238 13 0x000000000000001b 0x000000000000001b R 0x1 14 [Requesting program interpreter: /lib/ld-linux-aarch64.so.1] 15 LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 16 0x00000000000006c8 0x00000000000006c8 R E 0x10000 17 18$ readelf -l dummy_arm64_static 19 20Elf file type is EXEC (Executable file) 21Entry point 0x400540 22There are 6 program headers, starting at offset 64 23 24Program Headers: 25 Type Offset VirtAddr PhysAddr 26 FileSiz MemSiz Flags Align 27 LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 28 0x000000000007aa71 0x000000000007aa71 R E 0x10000 29 LOAD 0x000000000007b3b8 0x000000000048b3b8 0x000000000048b3b8 30 0x0000000000002560 0x0000000000007ba8 RW 0x10000 1.4. 符号信息 aarch64-linux-gnu-nm -u dummy_arm64可以看到动态链接的程序由未定义的符号（用U标示），而静态链接的程序没有未定义的符号。\n1$ aarch64-linux-gnu-nm -u dummy_arm64 2 w __gmon_start__ 3 U __libc_start_main@GLIBC_2.34 4 U abort@GLIBC_2.17 用aarch64-linux-gnu-nm -n dummy_arm64看到的符号要比静态链接的程序少很多。\n1$ aarch64-linux-gnu-nm -n dummy_arm64 | wc 2 32 93 1069 3 4$ aarch64-linux-gnu-nm -n dummy_arm64_static | wc 5 1664 4992 59232 2. exec的内核实现 exec系统调用、1号进程的演化和内核调用用户态程序的umh最终都会调用到exec_binprm。 exec是一系列系统调用，对应的内核代码在fs/exec.c，其核心函数是exec_binprm。\n2.1. exec_binprm exec过程中，主要涉及两个结构体：struct linux_binprm和struct linux_binfmt。\nstruct linux_binprm包含了exec过程中需要用到的配置信息，其中也包括一些从用户态传递的信息。\nstruct linux_binfmt是exec过程中用来表示不同可执行文件格式的结构体，它包含了如何解析和加载不同可执行文件格式的函数指针。\n注意在alloc_bprm时，就已经通过bprm_mm_init为进程申请并初始化了struct mm_struct。\n2.2. search_binary_handler search_binary_handler会通过prepare_binprm读取可执行文件的头部的BINPRM_BUF_SIZE(256)字节记录到struct linux_bprm的buf。\nsearch_binary_handler通过遍历formats链表中的struct linux_binfmt并尝试执行load_binary，load_binary会对buf进行检查，如果不匹配，则直接返回失败。search_binary_handler继续遍历，直到load_binary执行成功。\n1/// fs/exec.c 2/* binfmt handlers will call back into begin_new_exec() on success. */ 3static int exec_binprm(struct linux_binprm *bprm) 4{ 5\tpid_t old_pid, old_vpid; 6\tint ret, depth; 7 8\t/* Need to fetch pid before load_binary changes it */ 9\told_pid = current-\u0026gt;pid; 10\trcu_read_lock(); 11\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current-\u0026gt;parent)); 12\trcu_read_unlock(); 13 14\t/* This allows 4 levels of binfmt rewrites before failing hard. */ 15\tfor (depth = 0;; depth++) { 16\tstruct file *exec; 17\tif (depth \u0026gt; 5) 18\treturn -ELOOP; 19 20\tret = search_binary_handler(bprm); 21\tif (ret \u0026lt; 0) 22\treturn ret; 23\tif (!bprm-\u0026gt;interpreter) 24\tbreak; 25 26\texec = bprm-\u0026gt;file; 27\tbprm-\u0026gt;file = bprm-\u0026gt;interpreter; 28\tbprm-\u0026gt;interpreter = NULL; 29 30\tallow_write_access(exec); 31\tif (unlikely(bprm-\u0026gt;have_execfd)) { 32\tif (bprm-\u0026gt;executable) { 33\tfput(exec); 34\treturn -ENOEXEC; 35\t} 36\tbprm-\u0026gt;executable = exec; 37\t} else 38\tfput(exec); 39\t} 40 41\taudit_bprm(bprm); 42\ttrace_sched_process_exec(current, old_pid, bprm); 43\tptrace_event(PTRACE_EVENT_EXEC, old_vpid); 44\tproc_exec_connector(current); 45\treturn 0; 46} 对于elf文件来说，exec_binprm会调用load_elf_binary来加载可执行文件。elf文件格式解析代码在fs/binfmt_elf.c。\n1/// fs/binfmt_elf.c 2static struct linux_binfmt elf_format = { 3\t.module\t= THIS_MODULE, 4\t.load_binary\t= load_elf_binary, 5\t.load_shlib\t= load_elf_library, 6#ifdef CONFIG_COREDUMP 7\t.core_dump\t= elf_core_dump, 8\t.min_coredump\t= ELF_EXEC_PAGESIZE, 9#endif 10}; 2.3. load_elf_binary load_elf_binary比较长，其主要完成的工作如下：\n对文件做一些检查，如magic、arch等。 解析elf文件头信息，查看是否有解释器段，如果有，打开解释器并记录到struct file *interpreter，并加载解释器的elf信息。 用户态可能是在多线程的一个子线程中调用了exec，需要清理其他线程，同时也要清理进程的一些其他资源，如文件、信号处理程序等 设置进程名 映射可执行文件一些必要的段。 设置进程的页表，包括加载程序段，加载解释器段等。 设置进程的栈，包括设置栈顶，设置栈保护等。 清空bss段。 修改当前进程的pt_regs 设置pstate为EL0。这样函数返回后，会切换至用户态。 配置进程的入口点，如果是动态链接程序，入口点是解释器elf文件的入口，如果是静态链接程序，入口点是可执行文件的入口。 1+-- load_elf_binary 2| +-- load_elf_phdrs 3| +-- for (i = 0; i \u0026lt; elf_ex-\u0026gt;e_phnum; i++, elf_ppnt++) 4| | +-- elf_read 5| | +-- interpreter = open_exec(elf_interpreter) 6| +-- load_elf_phdrs /// if (interpreter) 7| +-- parse_elf_properties(interpreter ?: bprm-\u0026gt;file, ...) 8| +-- begin_new_exec 9| +-- SET_PERSONALITY2 10| +-- setup_new_exec 11| +-- setup_arg_pages 12| +-- randomize_stack_top 13| +-- set_brk 14| +-- elf_map 15| +-- load_elf_interp 16| +-- set_binfmt 17| +-- create_elf_tables 18| +-- arch_randomize_brk 19| +-- vm_mmap\t/// if (current-\u0026gt;personality \u0026amp; MMAP_PAGE_ZERO) 20| +-- current_pt_regs 21| +-- finalize_exec 22| +-- START_THREAD(elf_ex, regs, elf_entry, bprm-\u0026gt;p) ","date":"January 3, 2024","img":"https://kingdix10.github.io/covers/camera_lens_strap_145518_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/sched/execve/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"Linux","url":"/zh-cn/tags/linux/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1704240000,"title":"exec系统调用简介"},{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1. namespace简介 namespace是Linux提供的一种内核级别环境隔离的方法，很多编程语言也有namespace这样的功能，例如C++，Java等。编程语言的namespace是为了解决项目中能够在不同的命名空间里使用相同的函数名或者类名。而Linux的namespace也是为了实现资源能够在不同的命名空间里有相同的名称，比如在A命名空间有个pid为1的进程，而在B命名空间中也可以有一个pid为1的进程。\n有了namespace就可以实现基本的容器功能，著名的Docker就是使用了namespace来实现资源隔离。\nLinux支持多种资源的namespace：\nType Parameter Linux Version Mount namespaces CLONE_NEWNS 2.4.19 UTS namespaces CLONE_NEWUTS 2.6.19 IPC namespaces CLONE_NEWIPC 2.6.19 PID namespaces CLONE_NEWPID 2.6.24 Network namespaces CLONE_NEWNET 2.6.24 User namespaces CLONE_NEWUSER 2.6.23 Cgroup namespaces CLONE_NEWCGROUP 4.6 Time namespaces CLONE_NEWTIME 4.11 在执行clone()系统调用时，传入以上的不同类型的参数就可以实现复制不同类型的namespace。比如传入CLONE_NEWPID参数时，就是复制pid命名空间。在新的pid命名空间里可以使用与其他pid命名空间相同的pid。\n2. PID namespace Linux内核使用struct nsproxy来对除user namespace之外的命名空间进行管理，struct task_struct.nsproxy指向当前进程使用的命名空间。如果两个进程共享除user namespace外的其他命名空间，那么他们共享一个nsproxy。\npid namespace按层次关系形成树状结构，初始pid命名空间为init_pid_ns。默认情况下，新创建的进程/线程都属于这个命名空间。子pid namespace的级别不是无限的，当前MAX_PID_NS_LEVEL被定义为32。\n每个命名空间的1号进程，是这个命名空间的child_reaper，用来作为托管进程，回收当前命名空间中的孤儿进程。上图中，user_init是init_pid_ns的child_reaper，subA_init是pidnsA的child_reaper，subB_init是pidnsB的child_reaper。\n上图对应内核的结构体如下，图中展示的是没有创建新的user namespace的情况。所有pid namespace的ops都指向pid_ns_ops。\npid namespace用来隔离进程号，每个pid namespace内独立分配进程号。上图中，pidnsB是pidnsA的子命名空间，pidnsA是init_pid_ns的子命名空间。对于pidnsB内的task1，其在pidnsB的进程号是2，在pidnsA的进程号是4，在init_pid_ns的进程号是6。\n创建进程时，内核会在当前命名空间逐级向上查找父命名空间，直到找到init_pid_ns，在进程所属的所有pid namespace内分配唯一的进程号。在Linux内核中，这一过程是通过alloc_pid函数实现的。一个进程在不同的pid namespace中的pid，是通过struct pid的numbers数组来描述的。\n1/// include/linux/pid.h 2struct upid { 3 int nr; /// 当前level的pid namespace中的进程id 4 struct pid_namespace *ns; /// 所属的pid namespace 5}; 6 7struct pid 8{ 9 refcount_t count; 10 unsigned int level; 11 spinlock_t lock; 12 /* lists of tasks that use this pid */ 13 struct hlist_head tasks[PIDTYPE_MAX]; 14 struct hlist_head inodes; 15 /* wait queue for pidfd notifications */ 16 wait_queue_head_t wait_pidfd; 17 struct rcu_head rcu; 18 /// 在create_pid_cachep中创建kmem_cache时，根据pid namespace的level确定数组大小 19 struct upid numbers[]; 20}; 3. 查看命名空间 3.1. 使用ps查看 1# 需要用root权限，可以使用sudo 2ps -eo pid,pidns,user,group,cmd 输出结果如下：\n1 PID PIDNS USER GROUP CMD 2 1 4026531836 root root /sbin/init 3 2 4026531836 root root [kthreadd] 4 3 4026531836 root root [rcu_gp] 5 4 4026531836 root root [rcu_par_gp] 3.2. /proc//ns文件 1ls -l /proc/1/ns/ 输出结果如下：\n1lrwxrwxrwx 1 root root 0 Jan 17 23:01 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; 2lrwxrwxrwx 1 root root 0 Jan 17 23:01 ipc -\u0026gt; \u0026#39;ipc:[4026531839]\u0026#39; 3lrwxrwxrwx 1 root root 0 Jan 17 23:01 mnt -\u0026gt; \u0026#39;mnt:[4026531841]\u0026#39; 4lrwxrwxrwx 1 root root 0 Jan 17 23:01 net -\u0026gt; \u0026#39;net:[4026531840]\u0026#39; 5lrwxrwxrwx 1 root root 0 Jan 17 23:01 pid -\u0026gt; \u0026#39;pid:[4026531836]\u0026#39; 6lrwxrwxrwx 1 root root 0 Jan 17 00:25 pid_for_children -\u0026gt; \u0026#39;pid:[4026531836]\u0026#39; 7lrwxrwxrwx 1 root root 0 Jan 17 23:01 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; 8lrwxrwxrwx 1 root root 0 Jan 17 00:25 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; 9lrwxrwxrwx 1 root root 0 Jan 17 23:01 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; 10lrwxrwxrwx 1 root root 0 Jan 17 23:01 uts -\u0026gt; \u0026#39;uts:[4026531838]\u0026#39; 4. 参考资料 Namespaces in operation, part 1: namespaces overview 内核文档Documentation/admin-guide/namespaces/compatibility-list.rst 内核文档Documentation/admin-guide/namespaces/resource-control.rst ","date":"December 31, 2023","img":"https://kingdix10.github.io/covers/cockpit_panel_display_169481_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/sched/pid_namespace/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"Linux","url":"/zh-cn/tags/linux/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1703980800,"title":"Linux进程命名空间（pid namespace）"},{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1. 基本概念 Linux内核中没有使用单独的数据结构来描述进程和线程，而是将它们统一起来，使用task_struct结构体来描述，这就是“Linux不区分进程和线程”的来源。\n内核态： 所有线程都由kthreadd创建，运行在内核态，由独立的task_sturct描述。内核中不区分进程和线程，为了方便区分，这里统称为内核线程\n用户态：\n单线程进程：仅有一个线程，也就是主线程，内核中由一个task_struct描述,进程id就是task_struct.pid。 多线程进程：包含多个线程，每个线程都有自己的task_struct，有几个线程（包含主线程）就会有几个task_struct，所有task_struct的group_leader指向主线程的task_struct，进程id就是主线程task_struct.pid，所有线程的tgid都指向进程id。 1.1. 进程 进程是Linux系统中最基本的概念，它是资源分配的最小单位。\n进程的创建、运行、结束都在内核态进行，进程的描述在内核态中由task_struct描述。\n1.2. 线程 线程是进程的一个执行单元，它是操作系统调度和执行的最小单位。\n与进程一样，线程的创建、运行、结束都在用户态进行，线程的描述在用户态中由thread_struct描述。\n1.3. 进程组、会话 进程组：进程组是一组相关进程，它们共享一个进程组ID，进程组ID默认是进程组内第一个进程的task_struct.pid。\n会话：会话是一组相关进程组，它们共享一个会话ID，会话ID是会话内第一个进程的 task_struct.pid。\n2. 进程关系 可以通过ps命令来查看进程间的关系。\n1ps -Teo ppid,sid,pgid,pid,tgid,tid,comm 注意ps显示的pid和tgid，在内核中含义是相同的。\n2.1. 父子、兄弟 以内核最开始创建的swapper、user_init、kthreadd三个进程（线程）为例，\nswapper是user_init和ktheread的父进程。 user_init和ktheread的task_struct.parent和task_struct.real_parent指向swapper的task_struct。 user_init和ktheread的task_struct.sibling挂到swapper的task_struct.children链表。 user_init和ktheread的task_struct.tasks挂到swapper的task_struct.tasks链表。 user_init和kthreadd是兄弟进程。 进程可以遍历自己的task_struct.sibling链表，找到兄弟进程和父进程。 2.2. 进程、线程、线程组 以user_multi_thread为例，\nuser_multi_thread_leader是进程的主线程，主线程的task_struct.pid就是进程id，task_struct.tgid与task_struct.pid相同，task_struct.group_leader指向自身。 只有主线程user_multi_thread_leader的task_struct.tasks会挂到init_task.tasks链表。 只有主线程user_multi_thread_leader的task_struct.sibling会挂到父进程的task_struct.children链表。 user_multi_thread包含两个线程，分别是user_multi_thread1和user_multi_thread2，每个线程都有自己的task_struct，线程id为task_struct.pid，task_struct.tgid为进程id。 user_multi_thread1和user_multi_thread2的task_struct.real_parent与user_multi_thread_leader的task_struct.real_parent相同。 2.3. 进程组、会话 进程的进程组和会话关系是靠 struct signal_struct的 pids数组来建立的，通过 enum pid_type进行索引。除了 init_signals.pids[PIDTYPE_PID]会指向init_struct_pid外，其他task_stuct的 pids[PIDTYPE_PID]都没有使用，而是使用了 task_struct.thread_pid，具体可以看 task_pid_type、init_task_pid、task_pid_ptr等函数。\n1/// inlcude/linux/pid.h 2enum pid_type 3{ 4\tPIDTYPE_PID, /// 线程id，这里是内核态PID的概念 5\tPIDTYPE_TGID, /// 线程组id，对应用户态PID，也就是用户进程id 6\tPIDTYPE_PGID, /// 进程组id 7\tPIDTYPE_SID, /// 会话id 8\tPIDTYPE_MAX, 9}; 进程在创建时，默认都是继承了父进程的sid、pgid，之后再通过系统调用，来创建或加入新的会话或者进程组。进程组是属于会话的，当进程改变所属的会话时，进程组id自动改为新的会话id。\n2.3.1. 内核线程的会话和进程组 swapper线程和所有内核线程的会话和进程组都指向 init_struct_pid。\n1 PPID SID PGID PID TGID TID COMMAND 2 0 1 1 1 1 1 systemd 3 0 0 0 2 2 2 kthreadd 4 2 0 0 3 3 3 rcu_gp 5 2 0 0 4 4 4 rcu_par_gp 2.3.2. 用户进程的会话和进程组 用户init进程（1号进程）在创建时，继承 init_struct_pid，但是通常来说，init进程会创建新的会话和进程组。其他用户线程大多也会创建自己的会话和进程组。而自己用C语言写的程序，通常不会改变会话id，此时进程和执行程序的shell属于同一会话。\n2.3.3. 用户多线程示例 multi_thread是用pthread_create创建的线程，所有线程的sid、pgid和pid是相同的。\n1 PPID SID PGID PID TGID TID COMMAND 2 3607 3608 3608 3608 3608 3608 bash /// bash会话 3 3608 3608 218513 218513 218513 218513 multi_thread /// 主进程（主线程） 4 3608 3608 218513 218513 218513 218514 multi_thread /// 子线程 5 3608 3608 218513 218513 218513 218515 multi_thread 6 3608 3608 218513 218513 218513 218516 multi_thread 2.3.4. 用户进程组示例 比较典型的是sid为135990，pgid为215368的python进程，这是通过python的multiporces库实现的多进程。所有子进程的sid和pgid是相同的。\n1 PPID SID PGID PID TGID TID COMMAND 2 16502 135990 135990 135990 135990 135990 bash /// bash会话 3 135990 135990 215368 215368 215368 215368 python3 /// 进程组 4 215368 135990 215368 215369 215369 215369 python3 /// 子进程 5 215368 135990 215368 215372 215372 215372 python3 /// 子进程 6 215368 135990 215368 215375 215375 215375 python3 7 215368 135990 215368 215378 215378 215378 python3 8 215368 135990 215368 215381 215381 215381 python3 9 215368 135990 215368 215384 215384 215384 python3 10 215368 135990 215368 215393 215393 215393 python3 11 215368 135990 215368 215398 215398 215398 python3 12 215368 135990 215368 215400 215400 215400 python3 13 215368 135990 215368 215407 215407 215407 python3 14 215368 135990 215368 215414 215414 215414 python3 15 215368 135990 215368 215418 215418 215418 python3 16 215368 135990 215368 215423 215423 215423 python3 17 215368 135990 215368 215427 215427 215427 python3 18 215368 135990 215368 215437 215437 215437 python3 19 215368 135990 215368 215446 215446 215446 python3 再有就是make，make实际执行的是使用qemu启动一个虚拟机。这里sid对应的是执行make的bash，pgid对应的是make的进程组。sh和qemu的pid不同，但sid和pgid是相同的。\n1 PPID SID PGID PID TGID TID COMMAND 2 3588 3589 3589 3589 3589 3589 bash 3 3589 3589 216041 216041 216041 216041 make 4 216041 3589 216041 216965 216965 216965 sh 5 216965 3589 216041 216966 216966 216966 qemu-system-aar 6 216965 3589 216041 216966 216966 216967 qemu-system-aar 7 216965 3589 216041 216966 216966 216968 qemu-system-aar 8 216965 3589 216041 216966 216966 216969 qemu-system-aar 3. 系统调用 1pid_t gettid(void); /// 获取线程id，对应内核态pid 2 3pid_t getpid(void); /// 获取进程id，对应内核态tgid 4pid_t getppid(void); /// 获取父进程id 5 6/// 修改进程所属的进程组 7int setpgid(pid_t pid, pid_t pgid); 8pid_t getpgid(pid_t pid); 9 10pid_t getpgrp(void); /* POSIX.1 version */ 11[[deprecated]] pid_t getpgrp(pid_t pid); /* BSD version */ 12 13/// 基于当前进程创建一个新的进程组 14int setpgrp(void); /* System V version */ 15[[deprecated]] int setpgrp(pid_t pid, pid_t pgid); /* BSD version */ 16 17pid_t getsid(pid_t pid); 18/// 基于当前进程创建一个新的会话，会话id是当前进程主线程的task_struct.pid，同时创建进程组 19pid_t setsid(void); 4. 内核源码中的解释 4.1. struct pid是什么 1/// inlcude/linux/pid.h 2/* 3 * What is struct pid? 4 * 5 * A struct pid is the kernel\u0026#39;s internal notion of a process identifier. 6 * It refers to individual tasks, process groups, and sessions. While 7 * there are processes attached to it the struct pid lives in a hash 8 * table, so it and then the processes that it refers to can be found 9 * quickly from the numeric pid value. The attached processes may be 10 * quickly accessed by following pointers from struct pid. 11 * 12 * Storing pid_t values in the kernel and referring to them later has a 13 * problem. The process originally with that pid may have exited and the 14 * pid allocator wrapped, and another process could have come along 15 * and been assigned that pid. 16 * 17 * Referring to user space processes by holding a reference to struct 18 * task_struct has a problem. When the user space process exits 19 * the now useless task_struct is still kept. A task_struct plus a 20 * stack consumes around 10K of low kernel memory. More precisely 21 * this is THREAD_SIZE + sizeof(struct task_struct). By comparison 22 * a struct pid is about 64 bytes. 23 * 24 * Holding a reference to struct pid solves both of these problems. 25 * It is small so holding a reference does not consume a lot of 26 * resources, and since a new struct pid is allocated when the numeric pid 27 * value is reused (when pids wrap around) we don\u0026#39;t mistakenly refer to new 28 * processes. 29 */ struct pid是内核对进程标识符的内部概念。它指的是单个任务、流程组和会话。虽然有进程附加到它，但 struct pid位于哈希表中，因此可以从数字pid值中快速找到它以及它所引用的进程。可以通过以下来自 struct pid的指针快速访问附加的进程。\n在内核中存储pid_t值并在以后引用这些值是有问题的。最初具有该pid的进程可能已经退出并包装了pid分配器，而另一个进程可能已经出现并被分配了该pid。\n通过持有对 struct task_struct的引用来引用用户空间进程存在问题。当用户空间进程退出时，现在无用的 task_struct仍然保留。task_struct加上一个堆栈会消耗大约10K的低内核内存。更确切地说，这是 THREAD_SIZE + sizeof(struct task_struct)。相比之下，struct pid大约为64个字节。\n持有对 struct pid的引用可以解决这两个问题。它很小，因此持有引用不会消耗大量资源，而且由于在重复使用数字pid值时（当pid换行时）会分配新的 struct pid，所以我们不会错误地引用新的进程。\n1/// inlcude/linux/pid.h 2/* 3 * struct upid is used to get the id of the struct pid, as it is 4 * seen in particular namespace. Later the struct pid is found with 5 * find_pid_ns() using the int nr and struct pid_namespace *ns. 6 */ struct upid用于获取在特定命名空间中 struct pid的id，find_pid_ns使用 int nr和 struct pid_namespace *ns找到 struct pid。\n","date":"December 27, 2023","img":"https://kingdix10.github.io/covers/stars_figure_pattern_178502_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/sched/relationship/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"进程管理","url":"/zh-cn/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1703635200,"title":"Linux进程和线程关系"},{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1. 总览 这里以ARM64为例。\n在内核的起始阶段，还没有进程和线程的概念，在开启MMU之后，__primary_switched的第一步就是将init_task的地址写到sp_el0，这个时候就可以用get_current()或者curent获取到0号线程的task_struct了。在0号线程的上下文，完成调度器的相关初始化之后，创建1号和2号线程，然后开启调度器，init_task自此进入idle状态。\n这里看几个概念：\n0号线程：对应init_task结构体，名字为swapper，在多处理器中，名称为swapper/\u0026lt;id\u0026gt;，负责内核的一些基础的初始化工作。 1号线程：由0号线程创建，最初的函数为kernel_init，运行在内核态，kernel_init完成一些初始化工作后，通过kernel_execve进入用户态。具体的名字由用户态程序决定。 2号线程：由0号线程创建，回调函数为kthreadd，名字也是kthreadd，所有内核线程的创建都通过2号线程完成。也就是说，所有内核线程的父线程，都是kthreadd。 在kernel_init中，smp_init会为每个处理器核心创建一个的swapper线程，其task_struct结构体，并将其绑定到对应的处理器上。 在kernel_init调用的一些初始化函数中，有些会通过kthread或kworker的接口来创建内核线程，这些都内核线程的创建都由kthreadd接管。 在kernel_init最后，通过kernel_execve进入用户态，用户态的init程序，如busybox或systemd等，再通过fork或者clone等系统调用创建新的进程或者线程。\n关于0号线程，在init_task中，设置的名字为swapper，在sched_init时，才会通过init_idle将其设置为swapper/\u0026lt;id\u0026gt;，而这个id时bootcpu的id，大多数情况下，bootcpu的id是0，图中展示的就是这种情况。\n2. 汇编阶段的初始化 使能MMU后，__primary_switched的第一步就是初始化init_task。\n1/// arch/arm64/kernel/head.S 2SYM_FUNC_START_LOCAL(__primary_switched) 3 adr_l\tx4, init_task 4 init_cpu_task x4, x5, x6 在ARM64中，内核使用sp_el0来记录当前的task_struct。init_cpu_task负责将init_task的地址写入到sp_el0中，设置sp和fp，这个sp是sp_el1或者sp_el2，由内核运行的异常等级决定。\n1/// arch/arm64/kernel/head.S 2 /* 3 * Initialize CPU registers with task-specific and cpu-specific context. 4 * 5 * Create a final frame record at task_pt_regs(current)-\u0026gt;stackframe, so 6 * that the unwinder can identify the final frame record of any task by 7 * its location in the task stack. We reserve the entire pt_regs space 8 * for consistency with user tasks and kthreads. 9 */ 10 .macro init_cpu_task tsk, tmp1, tmp2 11 msr sp_el0, \\tsk /// 将init_task的地址写入sp_el0，内核运行于EL2或EL1，内核中会使用sp_el0来作为current 12 13 ldr \\tmp1, [\\tsk, #TSK_STACK] /// 获取init_task的栈地址，offsetof(struct task_struct, stack) 14 add sp, \\tmp1, #THREAD_SIZE /// 栈是由高地址向下生长的，所以SP_ELx要加上THREAD_SIZE，init_task的栈是静态分配的，它指向init_stack这是一个数组。 15 sub sp, sp, #PT_REGS_SIZE /// 为struct pt_regs留出空间 16 17 stp xzr, xzr, [sp, #S_STACKFRAME] /// 将struct pt_regs的u64 stackframe[2]清零 18 add x29, sp, #S_STACKFRAME /// x29(FP)指向栈中pt_regs的stackframe 19 20 scs_load \\tsk /// 此处为空操作，详细信息可以参考arch/Kconfig中的SHADOW_CALL_STACK 21 22 adr_l \\tmp1, __per_cpu_offset /// 读取__per_cpu_offset[NR_CPUS]数组基地址 23 ldr w\\tmp2, [\\tsk, #TSK_TI_CPU] /// offsetof(struct task_struct, thread_info.cpu) 24 ldr \\tmp1, [\\tmp1, \\tmp2, lsl #3] /// tmp1 = __per_cpu_offset[init_task.cpu \u0026lt;\u0026lt; 3]，通常来说，bootcpu为0 25 set_this_cpu_offset \\tmp1 /// 将当前cpu的per_cpu变量的offset值写入TPIDR_ELx 26 .endm 3. init_task结构体 内核规定，所有的线程必须由已存在的线程创建出来，也就是所有的task_struct都是在已有的task_struct基础上复制出来的。\n内核的初始阶段，内存分配器还没有初始化，无法实现task_struct的动态创建，init_task结构体是在代码中静态声明的。下面展示的是静态声明时，init_task的和其他结构体的关系。\n从这里可以看出来，init_mm指定代码段和数据段指向的就是vmlinux的代码段和数据段。\n4. bootcpu 0号线程的工作 4.1. start_kernel 汇编结束后，就会进入著名的start_kernel。 这里主要实现调度器和定时器的初始化，以及一些相关变量和kmem_cache的初始化。\n1/// init/main.c 2 /// ... ... 3 local_irq_disable(); /// 禁用当前cpu（bootcpu）的中断 4 early_boot_irqs_disabled = true; 5 /// ... ... 6 7 /* 8 * Set up the scheduler prior starting any interrupts (such as the 9 * timer interrupt). Full topology setup happens at smp_init() 10 * time - but meanwhile we still have a functioning scheduler. 11 */ 12 sched_init(); /// 调度器初始化 13 /// ... ... 14 time_init(); /// 定时器初始化，注册clockevent等 15 /// ... ... 16 early_boot_irqs_disabled = false; 17 local_irq_enable(); /// 使能当前cpu（bootcpu）的中断 18 /// ... ... 19 sched_clock_init(); /// 与CONFIG_HAVE_UNSTABLE_SCHED_CLOCK和CONFIG_GENERIC_SCHED_CLOCK相关 20 calibrate_delay(); /// 计算lpj 21 pid_idr_init(); /// 初始化pid_max和init_pid_ns等 22 /// ... ... 23 thread_stack_cache_init(); /// 创建thread_stack_cache kmem_cache 24 cred_init(); /// 创建cred_jar kmem_cache 25 fork_init(); /// task_struct_cachep、rlimit和一些其他初始化 26 proc_caches_init(); /// 一些kmem_cache的初始化 27 /// ... ... 28 /* Do the rest non-__init\u0026#39;ed, we\u0026#39;re now alive */ 29 arch_call_rest_init(); /// 调用rest_init 30 31 prevent_tail_call_optimization(); /// 实际为mb()，下边是内核给出的注释 32/* 33 * This is needed in functions which generate the stack canary, see 34 * arch/x86/kernel/smpboot.c::start_secondary() for an example. 35 */ 4.2. 其他cpu的0号线程创建 在bootcpu使用的静态声明的init_task结构体中，comm为swapper，在shced_init时，调用init_idle将其设置为swapper/\u0026lt;id\u0026gt;。 在1号线程开始运行后，smp_init调用idle_threads_init创建非bootcpu的0号线程，并将其设置为swapper/\u0026lt;id\u0026gt;。 percpu变量idle_threads记录每个cpu的0号线程对应的task_struct。\n4.3. 创建1号和2号线程 0号线程的最后，会创建1号和2号线程，开启完整的调度。\n1/// init/main.c 2static __initdata DECLARE_COMPLETION(kthreadd_done); 3 4noinline void __ref rest_init(void) 5{ 6 struct task_struct *tsk; 7 int pid; 8 9 rcu_scheduler_starting(); /// 启动RCU（Read-Copy-Update）机制 10 /* 11 * We need to spawn init first so that it obtains pid 1, however 12 * the init task will end up wanting to create kthreads, which, if 13 * we schedule it before we create kthreadd, will OOPS. 14 */ 15 pid = user_mode_thread(kernel_init, NULL, CLONE_FS); 16 /* 17 * Pin init on the boot CPU. Task migration is not properly working 18 * until sched_init_smp() has been run. It will set the allowed 19 * CPUs for init to the non isolated CPUs. 20 */ 21 rcu_read_lock(); 22 tsk = find_task_by_pid_ns(pid, \u0026amp;init_pid_ns); 23 tsk-\u0026gt;flags |= PF_NO_SETAFFINITY; /// 不允许用户程序操作cpus_mask 24 set_cpus_allowed_ptr(tsk, cpumask_of(smp_processor_id())); 25 rcu_read_unlock(); 26 27 numa_default_policy(); 28 pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES); 29 rcu_read_lock(); 30 kthreadd_task = find_task_by_pid_ns(pid, \u0026amp;init_pid_ns); 31 rcu_read_unlock(); 32 33 /* 34 * Enable might_sleep() and smp_processor_id() checks. 35 * They cannot be enabled earlier because with CONFIG_PREEMPTION=y 36 * kernel_thread() would trigger might_sleep() splats. With 37 * CONFIG_PREEMPT_VOLUNTARY=y the init task might have scheduled 38 * already, but it\u0026#39;s stuck on the kthreadd_done completion. 39 */ 40 system_state = SYSTEM_SCHEDULING; 41 42 /// kernel_init可能会创建内核线程，kernel_init最开始会等待kthreadd线程创建完成 43 complete(\u0026amp;kthreadd_done); 44 45 /* 46 * The boot idle thread must execute schedule() 47 * at least once to get things moving: 48 */ 49 /// bootcpu的idle程序需要调用schedule来使能调度，这样1号和2号线程才可以运行。 50 schedule_preempt_disabled(); 51 /* Call into cpu_idle with preempt disabled */ 52 cpu_startup_entry(CPUHP_ONLINE); 53} 4.4. schedule_preempt_disabled init_task的thread_info的preempt_count初始化为INIT_PREEMPT_COUNT。\n1/// include/linux/preempt.h 2/* 3 * Disable preemption until the scheduler is running -- use an unconditional 4 * value so that it also works on !PREEMPT_COUNT kernels. 5 * 6 * Reset by start_kernel()-\u0026gt;sched_init()-\u0026gt;init_idle()-\u0026gt;init_idle_preempt_count(). 7 */ 8#define INIT_PREEMPT_COUNT\tPREEMPT_OFFSET 这里在关闭抢占的情况下打开调度。\n1/// kernel/sched/core.c 2/* 3 * schedule_preempt_disabled - called with preemption disabled 4 * 5 * Returns with preemption disabled. Note: preempt_count must be 1 6 */ 7void __sched schedule_preempt_disabled(void) 8{ 9 sched_preempt_enable_no_resched(); /// 打开抢占，但是不进行调度 10 schedule(); /// 主动调度，使1号和2号线程可以运行 11 preempt_disable(); /// 重新关闭抢占，swapper是最后被选择的进程，不会有其他进程抢占 12} 4.5. cpu_startup_entry 1/// kernel/sched/core.c 2void cpu_startup_entry(enum cpuhp_state state) 3{ 4 arch_cpu_idle_prepare(); /// 默认为空 5 cpuhp_online_idle(state); /// cpu hotplug相关 6 while (1) 7 do_idle(); 8} 4.6. do_idle do_idle的主要工作就是检查swapper是否需要重新调度，如果不需要，则一直循环，如果处理器支持，进入低功耗状态，等待处理器被唤醒。否则通过schedule_idle调度其他进程运行。\n1/// kernel/sched/idle.c 2/* 3 * Generic idle loop implementation 4 * 5 * Called with polling cleared. 6 */ 7static void do_idle(void) 8{ 9 int cpu = smp_processor_id(); 10 11 /* 12 * Check if we need to update blocked load 13 */ 14 nohz_run_idle_balance(cpu); 15 16 /* 17 * If the arch has a polling bit, we maintain an invariant: 18 * 19 * Our polling bit is clear if we\u0026#39;re not scheduled (i.e. if rq-\u0026gt;curr != 20 * rq-\u0026gt;idle). This means that, if rq-\u0026gt;idle has the polling bit set, 21 * then setting need_resched is guaranteed to cause the CPU to 22 * reschedule. 23 */ 24 25 __current_set_polling(); 26 tick_nohz_idle_enter(); 27 28 /// 如果不需要重新调度，一直循环，如果处理器支持，进入低功耗状态，等待处理器被唤醒 29 while (!need_resched()) { 30 rmb(); 31 32 local_irq_disable(); /// 在cpu_idle_poll或cpuidle_idle_call会重新使能中断 33 34 if (cpu_is_offline(cpu)) { 35 tick_nohz_idle_stop_tick(); 36 cpuhp_report_idle_dead(); 37 arch_cpu_idle_dead(); 38 } 39 40 arch_cpu_idle_enter(); 41 rcu_nocb_flush_deferred_wakeup(); 42 43 /* 44 * In poll mode we reenable interrupts and spin. Also if we 45 * detected in the wakeup from idle path that the tick 46 * broadcast device expired for us, we don\u0026#39;t want to go deep 47 * idle as we know that the IPI is going to arrive right away. 48 */ 49 if (cpu_idle_force_poll || tick_check_broadcast_expired()) { 50 tick_nohz_idle_restart_tick(); 51 cpu_idle_poll(); 52 } else { 53 cpuidle_idle_call(); 54 } 55 arch_cpu_idle_exit(); 56 } 57 58 /// 如果需要重新调度，则运行其他进程 59 60 /* 61 * Since we fell out of the loop above, we know TIF_NEED_RESCHED must 62 * be set, propagate it into PREEMPT_NEED_RESCHED. 63 * 64 * This is required because for polling idle loops we will not have had 65 * an IPI to fold the state for us. 66 */ 67 preempt_set_need_resched(); 68 tick_nohz_idle_exit(); 69 __current_clr_polling(); 70 71 /* 72 * We promise to call sched_ttwu_pending() and reschedule if 73 * need_resched() is set while polling is set. That means that clearing 74 * polling needs to be visible before doing these things. 75 */ 76 smp_mb__after_atomic(); 77 78 /* 79 * RCU relies on this call to be done outside of an RCU read-side 80 * critical section. 81 */ 82 flush_smp_call_function_queue(); 83 schedule_idle(); 84 85 /// 重新进入idll进程时，检查是否有kernel livepatch 86 if (unlikely(klp_patch_pending(current))) 87 klp_update_patch_state(current); 88} ","date":"December 13, 2023","img":"https://kingdix10.github.io/covers/scheme_glow_blue_140190_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.1/sched/task_0/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"进程管理","url":"/zh-cn/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"title":"linux-6.1","url":"/zh-cn/tags/linux-6.1/"}],"timestamp":1702425600,"title":"Linux 0号线程swapper简介"},{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1. 1号进程的内核态 1号进程首先运行在内核态，其函数是kernel_init，这里简单介绍一下其工作：\n非bootcpu相关初始化 页分配器初始化的收尾工作 驱动子系统和设备树初始化 调用__initcall指定的初始化函数 挂载根文件系统 是否__init指定的内存 执行用户态init程序 2. 1号进程内核态到用户态的切换 kernel_init最后通过kernel_execve函数执行用户程序，完成内核态到用户态的切换。\n这里以elf格式的init程序为例简单说明一下kernel_execve的工作流程：kernel_execve会申请新的mm_struct，记录init程序的代码段和数据段，将当前进程内核栈中记录的pc改为elf的入口地址，并将内核栈中记录的pstate改为EL0，并将内核栈记录的sp指向用户栈。在从内核态函数返回时，从栈中恢复pstate、pc、sp，实现内核态到用户态的转换，并跳转init程序的入口。\n","date":"December 13, 2023","img":"https://kingdix10.github.io/covers/gradient_blur_blending_130648_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.1/sched/task_1/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"进程管理","url":"/zh-cn/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"title":"linux-6.1","url":"/zh-cn/tags/linux-6.1/"}],"timestamp":1702425600,"title":"Linux 1号线程init简介"},{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1. 2号线程kthreadd Linux内核规定，所有的线程必须由已存在的线程创建出来，也就是要求所有的task_struct都需要在已有的task_struct上复制出来。Linux可以通过kernel_thread来创建内核线程，这个函数会复制当前线程的task_struct。如果任由各个子系统或驱动自己调用kernel_thread来创建线程，那在创建内核线程时current所指向的task_struct是不确定的。为了解决这一问题，Linux内核将所有内核线程的创建交给固定的线程来做，这个线程就是2号线程kthreadd。\n2. 内核线程创建的接口 内核为开发者提供了两个创建内核线程的宏kthread_create和kthread_run，kthread_create用于创建内核线程，而kthread_run则是将创建并唤醒内核线程。\n1/// include/linux/kthread.h 2/** 3 * kthread_create - create a kthread on the current node 4 * @threadfn: the function to run in the thread 5 * @data: data pointer for @threadfn() 6 * @namefmt: printf-style format string for the thread name 7 * @arg: arguments for @namefmt. 8 * 9 * This macro will create a kthread on the current node, leaving it in 10 * the stopped state. This is just a helper for kthread_create_on_node(); 11 * see the documentation there for more details. 12 */ 13#define kthread_create(threadfn, data, namefmt, arg...) \\ 14 kthread_create_on_node(threadfn, data, NUMA_NO_NODE, namefmt, ##arg) 15 16/** 17 * kthread_run - create and wake a thread. 18 * @threadfn: the function to run until signal_pending(current). 19 * @data: data ptr for @threadfn. 20 * @namefmt: printf-style name for the thread. 21 * 22 * Description: Convenient wrapper for kthread_create() followed by 23 * wake_up_process(). Returns the kthread or ERR_PTR(-ENOMEM). 24 */ 25#define kthread_run(threadfn, data, namefmt, ...)\t\\ 26({\t\\ 27 struct task_struct *__k\t\\ 28 = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \\ 29 if (!IS_ERR(__k))\t\\ 30 wake_up_process(__k);\t\\ 31 __k;\t\\ 32}) 创建内核线程的核心函数是__kthread_create_on_node，其主要工作就是将需要创建的线程数据挂载到kthread_create_list链表，然后唤醒kthreadd，等待线程创建完成，最后为线程设置名字。\n1/// kernel/kthread.c 2static __printf(4, 0) 3struct task_struct *__kthread_create_on_node(int (*threadfn)(void *data), 4 void *data, int node, 5 const char namefmt[], 6 va_list args) 7{ 8 /// ... ... 9 create-\u0026gt;threadfn = threadfn; 10 create-\u0026gt;data = data; 11 create-\u0026gt;node = node; 12 create-\u0026gt;done = \u0026amp;done; 13 14 spin_lock(\u0026amp;kthread_create_lock); 15 list_add_tail(\u0026amp;create-\u0026gt;list, \u0026amp;kthread_create_list); 16 spin_unlock(\u0026amp;kthread_create_lock); 17 18 wake_up_process(kthreadd_task); 19 /// ... ... 20} 3. kthreadd线程的工作 kthreadd线程被唤醒后，从kthread_create_list取出创建线程所需要的数据，将创建线程的工作委托给create_kthread。\n1/// kernel/kthread.c 2int kthreadd(void *unused) 3{ 4 struct task_struct *tsk = current; 5 6 /// 重置上下文，其他内核线程会继承这些特性 7 /* Setup a clean context for our children to inherit. */ 8 set_task_comm(tsk, \u0026#34;kthreadd\u0026#34;); 9 ignore_signals(tsk); 10 set_cpus_allowed_ptr(tsk, housekeeping_cpumask(HK_TYPE_KTHREAD)); 11 set_mems_allowed(node_states[N_MEMORY]); 12 13 current-\u0026gt;flags |= PF_NOFREEZE; 14 cgroup_init_kthreadd(); 15 16 for (;;) { 17 set_current_state(TASK_INTERRUPTIBLE); 18 if (list_empty(\u0026amp;kthread_create_list)) 19 schedule(); 20 __set_current_state(TASK_RUNNING); 21 22 spin_lock(\u0026amp;kthread_create_lock); 23 while (!list_empty(\u0026amp;kthread_create_list)) { 24 struct kthread_create_info *create; 25 26 create = list_entry(kthread_create_list.next, 27 struct kthread_create_info, list); 28 list_del_init(\u0026amp;create-\u0026gt;list); 29 spin_unlock(\u0026amp;kthread_create_lock); 30 31 create_kthread(create); 32 33 spin_lock(\u0026amp;kthread_create_lock); 34 } 35 spin_unlock(\u0026amp;kthread_create_lock); 36 } 37 38 return 0; 39} 3.1. create_kthread create_kthread使用kernel_thread来创建一个新的内核线程，新的内核线程通过kthread来间接调用在创建线程时指定的函数。如果失败，则检查是否是因为收到一个致命的信号导致的，如果是，则释放创建线程所需要的数据，否则通知kthread_create的调用者创建失败。\n1/// kernel/kthread.c 2static void create_kthread(struct kthread_create_info *create) 3{ 4 int pid; 5 6#ifdef CONFIG_NUMA 7 current-\u0026gt;pref_node_fork = create-\u0026gt;node; 8#endif 9 /* We want our own signal handler (we take no signals by default). */ 10 pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD); 11 if (pid \u0026lt; 0) { 12 /* Release the structure when caller killed by a fatal signal. */ 13 struct completion *done = xchg(\u0026amp;create-\u0026gt;done, NULL); 14 15 if (!done) { 16 kfree(create); 17 return; 18 } 19 create-\u0026gt;result = ERR_PTR(pid); 20 complete(done); 21 } 22} 3.2. kthread kthread运行在新线程的上下文，主要流程见代码注释。 注意新创建的kthread需要被唤醒才能运行。\n1/// kernel/kthread.c 2static int kthread(void *_create) 3{ 4 static const struct sched_param param = { .sched_priority = 0 }; 5 /* Copy data: it\u0026#39;s on kthread\u0026#39;s stack */ 6 struct kthread_create_info *create = _create; 7 int (*threadfn)(void *data) = create-\u0026gt;threadfn; 8 void *data = create-\u0026gt;data; 9 struct completion *done; 10 struct kthread *self; 11 int ret; 12 13 self = to_kthread(current); 14 15 /* Release the structure when caller killed by a fatal signal. */ 16 done = xchg(\u0026amp;create-\u0026gt;done, NULL); /// 再次检查是否有致命信号 17 if (!done) { 18 kfree(create); 19 kthread_exit(-EINTR); 20 } 21 22 self-\u0026gt;threadfn = threadfn; 23 self-\u0026gt;data = data; 24 25 /// 重置新进程的调度策略和cpu亲和性 26 /* 27 * The new thread inherited kthreadd\u0026#39;s priority and CPU mask. Reset 28 * back to default in case they have been changed. 29 */ 30 sched_setscheduler_nocheck(current, SCHED_NORMAL, \u0026amp;param); 31 set_cpus_allowed_ptr(current, housekeeping_cpumask(HK_TYPE_KTHREAD)); 32 33 /* OK, tell user we\u0026#39;re spawned, wait for stop or wakeup */ 34 __set_current_state(TASK_UNINTERRUPTIBLE); /// 新创建的进程需要被唤醒才能运行 35 create-\u0026gt;result = current; 36 /* 37 * Thread is going to call schedule(), do not preempt it, 38 * or the creator may spend more time in wait_task_inactive(). 39 */ 40 preempt_disable(); /// 禁用抢占 41 complete(done); /// 创建成功，通知kthread_create的调用者 42 schedule_preempt_disabled(); /// 在禁用抢占的情况下调度，防止kthread_create的调用者等待时间过长 43 preempt_enable(); /// 重新调度 44 45 ret = -EINTR; 46 if (!test_bit(KTHREAD_SHOULD_STOP, \u0026amp;self-\u0026gt;flags)) { 47 /// 内核中cgroup_kthread_ready的注释 48 /* 49 * This kthread finished initialization. The creator should have 50 * set PF_NO_SETAFFINITY if this kthread should stay in the root. 51 */ 52 cgroup_kthread_ready(); 53 __kthread_parkme(self); /// 检查是否设置KTHREAD_SHOULD_PARK标志，如果没有，继续执行 54 ret = threadfn(data); /// 真正的回调函数 55 } 56 kthread_exit(ret); /// 线程退出，回收资源 57} ","date":"December 13, 2023","img":"https://kingdix10.github.io/covers/metal_plates_lattice_199631_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.1/sched/task_2/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"进程管理","url":"/zh-cn/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"title":"linux-6.1","url":"/zh-cn/tags/linux-6.1/"}],"timestamp":1702425600,"title":"Linux 2号线程kthreadd简介"},{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1. 进程状态切换 state value desc TASK_NEW 0x00000800 新建 TASK_RUNNING 0x00000000 就绪或占有cpu运行 TASK_INTERRUPTIBLE 0x00000001 可中断睡眠 TASK_UNINTERRUPTIBLE 0x00000002 不可中断睡眠 TASK_WAKEKILL 0x00000100 可以在stopped/traced/killable的情况下唤醒 TASK_WAKING 0x00000200 正在被唤醒 __TASK_STOPPED 0x00000004 和其他状态组合，用于唤醒包含此状态标记的进程 TASK_STOPPED 0x00000104 TASK_WAKEKILL和__TASK_STOPPED的组合 TASK_IDLE 0x00000402 TASK_UNINTERRUPTIBLE和TASK_NOLOAD的组合 TASK_DEAD 0x00000080 进程消亡，即将回收task_struct EXIT_DEAD 0x00000010 来自EXIT_ZOMBIE，即将回收task_struct EXIT_ZOMBIE 0x00000020 僵尸态，进程已经结束，但task_struct还没有回收 EXIT前缀的状态，是由struct task_struct.exit_state使用的。\n1/// include/linux/sched.h 2/* 3 * Task state bitmask. NOTE! These bits are also 4 * encoded in fs/proc/array.c: get_task_state(). 5 * 6 * We have two separate sets of flags: task-\u0026gt;__state 7 * is about runnability, while task-\u0026gt;exit_state are 8 * about the task exiting. Confusing, but this way 9 * modifying one set can\u0026#39;t modify the other one by 10 * mistake. 11 */ 2. 进程状态 2.1. 创建 使用kernel_clone新创建的任务为TASK_NEW状态，在copy_process将新进程的信息填充后，使用wake_up_new_task将进程设为TASK_RUNNING。\n2.2. 睡眠 在程序的运行时中，可能会因为资源不满足比如等待IO、信号量等，或者主动让出cpu而进入睡眠状态，睡眠状态包括TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE。TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE统称为TASK_NORMAL状态。常见进入可中断睡眠的接口：msleep_interruptible、schedule_timeout_interruptible、wait_event_interruptible，常见进入不可中断睡眠的接口：msleep、schedule_timeout、wait_event。\n与睡眠状态类似的还有TASK_IDLE，这个状态是TASK_UNINTERRUPTIBLE和TASK_NOLOAD的组合，影响的是rq-\u0026gt;nr_uninterruptible。\n2.3. 唤醒 当进程从睡眠状态被唤醒时，try_to_wake_up会将状态设为TASK_WAKING，之后通过ttwu_do_activate将进程状态设为TASK_RUNNING。然后进程会被加入到运行队列，被调度器调度运行。\n2.4. 停止 在程序的运行过程中，进程被跟踪或者收到SIGSTOP（19）信号后，会被置为包含__TASK_STOPPED的状态，比如TASK_STOPPED。此时进程仍然可以接收信号，但是不能被调度器调度运行。进程收到SIGCONT（18）信号后，会唤醒__TASK_STOPPED的进程。\n2.5. 退出 Linux实现了exit和exit_group系统调用，需要注意的是，为了支持POSIX，进程退出用到的exit、_exit都是调用的exit_group，而不是exit。\n对于单线程的进程，程序可以选择退出时是否通知父进程。如果不需要通知父进程，do_exit会逐步将task-\u0026gt;exit_state设为EXIT_ZOMBIE，然后在设为EXIT_DEAD，最后将task-\u0026gt;__state设为TASK_DEAD，然后主动调度，在调度时释放task_struct。如果需要通知父进程，do_exit会将task-\u0026gt;exit_state设为EXIT_ZOMBIE，然后将task-\u0026gt;__state设为TASK_DEAD，在父进程调用wait时，将 task-\u0026gt;exit_state设为TASK_DEAD，并最后回收task_struct。\n对于多线程进程，只有父进程只关心主线程的突出状态。任一线程调用exit_group时会通过zap_other_threads向其他线程发送SIGKILL信号，并唤醒线程，然后进行清理工作。非主线程的子线程的退出不需要通知父进程，可以直接释放task_sturct。退出流程也与单线程进程不需要通知父进程的过程类似，task-\u0026gt;exit_state和task-\u0026gt;__state值的变化顺序与单线程进程一致。主线程的情况比较复杂，但task-\u0026gt;exit_state和task-\u0026gt;__state值的变化顺序与单线程进程一致，只是在一些细节上存在差异。\n","date":"December 13, 2023","img":"https://kingdix10.github.io/covers/canvas_picture_abstraction_138874_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/sched/task_state/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"Linux","url":"/zh-cn/tags/linux/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1702425600,"title":"Linux进程状态与生命周期"},{"categories":[{"title":"内核调试","url":"/zh-cn/categories/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"},{"title":"kdump crash","url":"/zh-cn/categories/kdump-crash/"}],"content":" 1. ARM64 Crash调试环境搭建 主要参考资料：\n内核源码 Documentation/admin-guide/kdump/kdump.rst或者Documentation for Kdump - The kexec-based Crash Dumping Solution Crash白皮书：https://crash-utility.github.io/crash_whitepaper.html Crash github：https://github.com/crash-utility/crash Oracle: Using the crash Debugger 1.1. x86_64主机编译ARM64 Crash工具 在x86机器上安装的Crash工具不能直接调试ARM64的coredump文件。可以通过重新编译Crash源码来生成调试ARM64 coredump文件的Crash。参考https://github.com/crash-utility/crash/tree/8.0.3的README中提供的编译方法，解压代码后，执行 make target=ARM64即可。\n1 To build the crash utility: 2 3 $ tar -xf crash-8.0.3.tar.gz 4 $ cd crash-8.0.3 5 $ make 6 7 The initial build will take several minutes because the embedded gdb module 8 must be configured and built. Alternatively, the crash source RPM file 9 may be installed and built, and the resultant crash binary RPM file installed. 10 11 The crash binary can only be used on systems of the same architecture as 12 the host build system. There are a few optional manners of building the 13 crash binary: 14 15 o On an x86_64 host, a 32-bit x86 binary that can be used to analyze 16 32-bit x86 dumpfiles may be built by typing \u0026#34;make target=X86\u0026#34;. 17 o On an x86 or x86_64 host, a 32-bit x86 binary that can be used to analyze 18 32-bit arm dumpfiles may be built by typing \u0026#34;make target=ARM\u0026#34;. 19 o On an x86 or x86_64 host, a 32-bit x86 binary that can be used to analyze 20 32-bit mips dumpfiles may be built by typing \u0026#34;make target=MIPS\u0026#34;. 21 o On an ppc64 host, a 32-bit ppc binary that can be used to analyze 22 32-bit ppc dumpfiles may be built by typing \u0026#34;make target=PPC\u0026#34;. 23 o On an x86_64 host, an x86_64 binary that can be used to analyze 24 arm64 dumpfiles may be built by typing \u0026#34;make target=ARM64\u0026#34;. 25 o On an x86_64 host, an x86_64 binary that can be used to analyze 26 ppc64le dumpfiles may be built by typing \u0026#34;make target=PPC64\u0026#34;. 27 o On an x86_64 host, an x86_64 binary that can be used to analyze 28 riscv64 dumpfiles may be built by typing \u0026#34;make target=RISCV64\u0026#34;. 1.2. x86_64主机使用Docker安装ARM64 Crash工具 编译安装的方法需要自己解决依赖，编译也相对耗时，这里使用Docker来解决。后续也使用这种方式来介绍。\nDocker的安装可以参考清华大学开源软件镜像站Docker CE 软件仓库镜像使用帮助，之后可以直接使用，也可以参考其他资料配置国内加速源。安装Docker后按如下步骤执行。\n1# 安装ARM64的运行支持 2sudo apt-get install qemu-user-static binfmt-support 3# 拉取arm64v8的debian镜像 4docker pull arm64v8/debian:bookworm-20230814 5# 启动docker容器，并挂载宿主机目录，Crash调试时需要vmlinux文件 6docker run -it --privileged -v /storage/data:/data arm64v8/debian:bookworm-20230814 bash 启动docker容器，可以安装Crash工具和辅助工具。\n1apt install crash vim less 安装完成后，可以在宿主机使用 docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]将容器保存为镜像，之后可以在宿主机上使用镜像启动容器。\ndocker容器内使用 crash --buildinfo可以查看Crash工具支持的架构，这里提示 build_target是ARM64。\n1crash --buildinfo 2 build_command: crash 3 build_data: reproducible build 4 build_target: ARM64 5 build_version: 8.0.2 6compiler version: gcc (Debian 12.2.0-9) 12.2.0 2. 编译配置 这里不过多介绍编译的细节，只介绍编译所需要的配置。\n2.1. 内核配置和编译 ARM64的内核编译需要打开如下宏，文档中没有提到 CONFIG_RANDOMIZE_BASE和 CONFIG_PROC_KCORE，但也是需要的，而且传递到内核的cmdline不能有nokaslr。\n1CONFIG_KEXEC=y 2CONFIG_SYSFS=y 3CONFIG_DEBUG_INFO=y 4CONFIG_RELOCATABLE=y 5CONFIG_RANDOMIZE_BASE=y 6CONFIG_CRASH_DUMP=y 7CONFIG_PROC_KCORE=y 8CONFIG_PROC_VMCORE=y 为了可以使用sysrq触发panic，还需要开启如下几个选项。\n1CONFIG_MAGIC_SYSRQ=y 2CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1 3CONFIG_MAGIC_SYSRQ_SERIAL=y 2.2. buildroot配置和编译 使能kexec工具。\n1BR2_PACKAGE_KEXEC=y 2BR2_PACKAGE_KEXEC_ZLIB=y 3. 运行 3.1. qemu启动kernel qemu启动内核的命令如下，可以根据自己需要修改。\n1qemu-system-aarch64 -nographic -cpu cortex-a57 -M type=virt,mte=off,virtualization=false,gic-version=3 -semihosting -semihosting-config enable=on,target=native -smp 2 -m 1024 -netdev user,id=net0 -device virtio-net-device,netdev=net0 -object rng-random,filename=/dev/urandom,id=rng0 -device virtio-rng-pci,rng=rng0,max-bytes=1024,period=1000 \\ 2\t-kernel /data/eel/images/arm64/kernel/linux-6.6/arm64_debug_defconfig/arch/arm64/boot/Image -drive if=none,format=raw,file=/data/eel/images/arm64/rootfs/buildroot-2023.02/mine_arm64_defconfig/images/rootfs.ext4,id=hd0 -device virtio-blk-device,drive=hd0 \\ 3\t-append \u0026#34;console=ttyAMA0 crashkernel=512M-1G:64M,1G-:128M loglevel=6 initcall_debug no_console_suspend root=/dev/vda rw init=/linuxrc\u0026#34; \\ 4\t-fsdev local,id=share_comm,path=/data/eel/share,security_model=none -device virtio-9p-device,fsdev=share_comm,mount_tag=mnt_comm -fsdev local,id=share_arch,path=/data/eel/images/arm64,security_model=none -device virtio-9p-device,fsdev=share_arch,mount_tag=mnt_arch -fsdev local,id=share_eel,path=/data/eel,security_model=passthrough,readonly=on -device virtio-9p-device,fsdev=share_eel,mount_tag=mnt_eel 这里要注意cmdline参数不能带有nokaslr。cmdline要添加crashkernel，表示为crashkernel预留的内存。\ncrashkernel=64M：为crashkernel预留64M内存。 crashkernel=512M-1G:64M,1G-:128M：当系统总内存在512M-1G，预留64M，当系统总内存大于1G，预留128M。 另外需要将宿主机的目录映射到qemu内，以便qemu内可以读取编译生成的kernel Image文件，也可以把产生的vmcore文件导出到host。这里映射了3个目录，其中第一个是 -fsdev local,id=share_comm,path=/data/eel/share,security_model=none -device virtio-9p-device,fsdev=share_comm,mount_tag=mnt_comm。qemu内，可以通 过mount -t 9p share_comm /mnt来挂载。\n3.2. kexec加载内核 qemu启动linux后，需要用kexec加载crashkernel，注意 maxcpus=1 reset_devices是必须的。\n1kexec \\ 2 --append=\u0026#34;console=ttyAMA0 rootfstype=ext4 rootwait root=/dev/vda rw maxcpus=1 reset_devices\u0026#34; \\ 3 -p /data/eel/images/arm64/kernel/linux-6.6/arm64_debug_defconfig/arch/arm64/boot/Image 上述命令如果没有输出，则表示执行成功。想要看到详细的信息，可以加上 -d选项。\n3.3. 触发panic 1echo c \u0026gt; /proc/sysrq-trigger 重启时的日志，可以看到panic后，自动启动新的内核。\n1# echo c \u0026gt; /proc/sysrq-trigger 2[ 374.873622][ T160] sysrq: Trigger a crash 3[ 374.874185][ T160] Kernel panic - not syncing: sysrq triggered crash 4[ 374.874602][ T160] CPU: 0 PID: 160 Comm: sh Kdump: loaded Not tainted 6.6.0-g3149bc21d316-dirty #2 1c048aede95eceae4e303b1d563e246e55cb9a9d 5[ 374.875175][ T160] Hardware name: linux,dummy-virt (DT) 6[ 374.875392][ T160] Call trace: 7[ 374.875474][ T160] dump_backtrace+0x104/0x130 8[ 374.875674][ T160] show_stack+0x20/0x50 9[ 374.875723][ T160] dump_stack_lvl+0x90/0xbc 10[ 374.875847][ T160] dump_stack+0x18/0x34 11[ 374.875972][ T160] panic+0x1a0/0x38c 12[ 374.876039][ T160] sysrq_handle_crash+0x24/0x2c 13[ 374.876173][ T160] __handle_sysrq+0xdc/0x1a4 14[ 374.876231][ T160] write_sysrq_trigger+0x78/0xa0 15[ 374.876418][ T160] proc_reg_write+0xc8/0x100 16[ 374.876546][ T160] vfs_write+0x168/0x330 17[ 374.876724][ T160] ksys_write+0x70/0xfc 18[ 374.876906][ T160] __arm64_sys_write+0x24/0x30 19[ 374.877146][ T160] el0_svc_common.constprop.0+0xfc/0x1f4 20[ 374.877254][ T160] do_el0_svc+0xb4/0xc0 21[ 374.877339][ T160] el0_svc+0x48/0xa0 22[ 374.877420][ T160] el0t_64_sync_handler+0xc8/0x14c 23[ 374.877642][ T160] el0t_64_sync+0x19c/0x1a0 24[ 374.878124][ T160] SMP: stopping secondary CPUs 25[ 374.878981][ T160] Starting crashdump kernel... 26[ 374.879230][ T160] Bye! 27[ 0.000000][ T0] Booting Linux on physical CPU 0x0000000000 [0x411fd070] 28[ 0.000000][ T0] Linux version 6.6.0-g3149bc21d316-dirty (dix@EEL) (aarch64-linux-gnu-gcc (GCC) 11.3.1 20220604 [releases/gcc-11 revision 591c0f4b92548e3ae2e8173f4f93984b1c7f62bb], GNU ld (Linaro_Binutils-2022.06) 2.37.20220122) #2 SMP PREEMPT Tue Sep 19 01:09:13 CST 2023 29[ 0.000000][ T0] Machine model: linux,dummy-virt 30[ 0.000000][ T0] efi: UEFI not found. 31[ 0.000000][ T0] OF: fdt: Reserving 1 KiB of memory at 0x7ebff000 for elfcorehdr 新的内核是用kexec加载好的内核，如果用cat /proc/cpuinfo查看的话，会显示只有一个核。\n3.4. 保存vmcore panic重启后生成的文件在 /proc/vmcore，正常启动则没有这个文件。将vmcore保存到与宿主机共享的目录\n1cat /proc/vmcore \u0026gt; /mnt/vmcore_arm64_6.6 4. Crash调试 进入ARM64 Docker使用Crash工具分析\n1crash vmcore_arm64_6.6 /data/eel/output/arm64/kernel/linux-6.6/arm64_debug_defconfig/vmlinux 加载需要一点时间，完成后会显示如下信息。\n1 KERNEL: /data/eel/output/arm64/kernel/linux-6.6/arm64_debug_defconfig/vmlinux 2 DUMPFILE: vmcore_arm64_6.6 3 CPUS: 2 4 DATE: Sat Sep 23 09:47:30 CST 2023 5 UPTIME: 00:06:14 6LOAD AVERAGE: 0.00, 0.00, 0.00 7 TASKS: 60 8 NODENAME: buildroot 9 RELEASE: 6.6.0-g3149bc21d316-dirty 10 VERSION: #2 SMP PREEMPT Tue Sep 19 01:09:13 CST 2023 11 MACHINE: aarch64 (unknown Mhz) 12 MEMORY: 1 GB 13 PANIC: \u0026#34;Kernel panic - not syncing: sysrq triggered crash\u0026#34; 14 PID: 160 15 COMMAND: \u0026#34;sh\u0026#34; 16 TASK: ffff65a602b68ec0 [THREAD_INFO: ffff65a602b68ec0] 17 CPU: 0 18 STATE: TASK_RUNNING (PANIC) 这里先简单使用 bt来看一下panic时的调用栈，可以看到是sysrq触发了panic。\n1crash\u0026gt; bt 2PID: 160 TASK: ffff65a602b68ec0 CPU: 0 COMMAND: \u0026#34;sh\u0026#34; 3 #0 [ffff800008413a10] machine_kexec at ffffd6678e834e98 4 #1 [ffff800008413a40] __crash_kexec at ffffd6678e9148bc 5 #2 [ffff800008413bd0] panic at ffffd6678f4f6a34 6 #3 [ffff800008413cb0] sysrq_handle_crash at ffffd6678eee25f4 7 #4 [ffff800008413cc0] __handle_sysrq at ffffd6678eee2e58 8 #5 [ffff800008413d10] write_sysrq_trigger at ffffd6678eee34b4 9 #6 [ffff800008413d30] proc_reg_write at ffffd6678eb88714 10 #7 [ffff800008413d50] vfs_write at ffffd6678eaf3c24 11 #8 [ffff800008413df0] ksys_write at ffffd6678eaf3f80 12 #9 [ffff800008413e30] __arm64_sys_write at ffffd6678eaf4030 13#10 [ffff800008413e40] el0_svc_common.constprop.0 at ffffd6678e829528 14#11 [ffff800008413e70] do_el0_svc at ffffd6678e8296d4 15#12 [ffff800008413e80] el0_svc at ffffd6678f5085c4 16#13 [ffff800008413ea0] el0t_64_sync_handler at ffffd6678f509948 17#14 [ffff800008413fe0] el0t_64_sync at ffffd6678e811de4 18 PC: 0000ffffb540c450 LR: 0000aaaad6f36968 SP: 0000fffff1d1fe50 19 X29: 0000fffff1d1fe50 X28: 0000aaaaf5de4700 X27: 0000000000000000 20 X26: 0000aaaaf5de46e0 X25: 0000000000000020 X24: 0000fffff1d1ff20 21 X23: 0000000000000001 X22: 0000ffffb55527a0 X21: 0000000000000002 22 X20: 0000aaaaf5deb100 X19: 0000000000000001 X18: 0000000000000001 23 X17: 0000ffffb540c420 X16: 0000aaaad6ff1948 X15: 65645f34366d7261 24 X14: 0000000000000001 X13: 0072656767697274 X12: 2d71727379732f63 25 X11: 2f686372612f6769 X10: 0000000000000000 X9: 0000000000000020 26 X8: 0000000000000040 X7: 7f7f7f7f7f7f7f7f X6: 0000000000000063 27 X5: fffffffffffffffe X4: 0000000000000001 X3: 0000ffffb5552010 28 X2: 0000000000000002 X1: 0000aaaaf5deb100 X0: 0000000000000001 29 ORIG_X0: 0000000000000001 SYSCALLNO: 40 PSTATE: 80000000 ","date":"December 3, 2023","img":"https://kingdix10.github.io/covers/pixels_cubes_shapes_127558_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/debug/kdump_crash/arm64_setup/","series":[{"title":"内核调试","url":"/zh-cn/series/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"内核调试","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"},{"title":"kdump crash","url":"/zh-cn/tags/kdump-crash/"},{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"}],"timestamp":1701561600,"title":"ARM64 Crash调试环境搭建"},{"categories":[{"title":"kdump crash","url":"/en/categories/kdump-crash/"}],"content":" 1. * - pointer-to short-cut 1.1. SYNOPSIS 1* (struct or union command arguments) 1.2. DESCRIPTION 1 This command is a short-cut command that replaces the requirement to enter 2 \u0026#34;struct\u0026#34; or \u0026#34;union\u0026#34; command names. For details on the arguments to 3 those commands, enter \u0026#34;help struct\u0026#34; or \u0026#34;help union\u0026#34;. 1.3. EXAMPLES 1 Dump the page structure at address c02943c0: 2 3 crash\u0026gt; *page c02943c0 4 struct page { 5 next = 0xc0fae740, 6 prev = 0xc0018fb0, 7 inode = 0x0, 8 offset = 0x3f000, 9 next_hash = 0xc02d6310, 10 count = { 11 counter = 0x1 12 }, 13 flags = 0x310, 14 wait = 0xc02943d8, 15 pprev_hash = 0x0, 16 buffers = 0x0 17 } 2. alias - command aliases 2.1. SYNOPSIS 1alias [alias] [command string] 2.2. DESCRIPTION 1 This command creates an alias for a given command string. If no arguments 2 are entered, the current list of aliases are displayed. If one argument is 3 entered, the command string for that alias, if any, is displayed. 4 5 alias the single word to be used as an alias 6 command string the word(s) that will be substituted for the alias 7 8 Aliases may be created in four manners: 9 10 1. entering the alias in $HOME/.crashrc. 11 2. entering the alias in .crashrc in the current directory. 12 3. executing an input file containing the alias command. 13 4. during runtime with this command. 14 15 During initialization, $HOME/.crashrc is read first, followed by the 16 .crashrc file in the current directory. Aliases in the .crashrc file 17 in the current directory override those in $HOME/.crashrc. Aliases 18 entered with this command or by runtime input file override those 19 defined in either .crashrc file. Aliases may be deleted by entering an 20 empty string for the second argument. If redirection characters are to 21 be part of the command string, the command string must be enclosed by 22 quotation marks. 23 24 Note that there are a number of helpful built-in aliases -- see the 25 first example below. 2.3. EXAMPLES 1 Display the currently-defined aliases, which in this example, only 2 consist of the built-in aliases: 3 4 crash\u0026gt; alias 5 ORIGIN ALIAS COMMAND 6 builtin man help 7 builtin ? help 8 builtin quit q 9 builtin sf set scroll off 10 builtin sn set scroll on 11 builtin hex set radix 16 12 builtin dec set radix 10 13 builtin g gdb 14 builtin px p -x 15 builtin pd p -d 16 builtin for foreach 17 builtin size * 18 builtin dmesg log 19 builtin lsmod mod 20 builtin last ps -l 21 22 Create a new alias to be added to the list: 23 24 crash\u0026gt; alias kp kmem -p 25 ORIGIN ALIAS COMMAND 26 runtime kp kmem -p 27 28 Create an alias with redirection characters: 29 30 crash\u0026gt; alias ksd \u0026#34;kmem -p | grep slab | grep DMA\u0026#34; 31 ORIGIN ALIAS COMMAND 32 runtime ksd kmem -p | grep slab | grep DMA 33 34 Remove an alias: 35 36 crash\u0026gt; alias kp \u0026#34;\u0026#34; 37 alias deleted: kp 3. ascii - translate a hexadecimal string to ASCII 3.1. SYNOPSIS 1ascii value ... 3.2. DESCRIPTION 1 Translates 32-bit or 64-bit hexadecimal values to ASCII. If no argument 2 is entered, an ASCII chart is displayed. 3.3. EXAMPLES 1 Translate the hexadecimal value of 0x62696c2f7273752f to ASCII: 2 3 crash\u0026gt; ascii 62696c2f7273752f 4 62696c2f7273752f: /usr/lib 5 6 Display an ASCII chart: 7 8 crash\u0026gt; ascii 9 10 0 1 2 3 4 5 6 7 11 +------------------------------- 12 0 | NUL DLE SP 0 @ P \u0026#39; p 13 1 | SOH DC1 ! 1 A Q a q 14 2 | STX DC2 \u0026#34; 2 B R b r 15 3 | ETX DC3 # 3 C S c s 16 4 | EOT DC4 $ 4 D T d t 17 5 | ENQ NAK % 5 E U e u 18 6 | ACK SYN \u0026amp; 6 F V f v 19 7 | BEL ETB ` 7 G W g w 20 8 | BS CAN ( 8 H X h x 21 9 | HT EM ) 9 I Y i y 22 A | LF SUB * : J Z j z 23 B | VT ESC + ; K [ k { 24 C | FF FS , \u0026lt; L \\ l | 25 D | CR GS _ = M ] m } 26 E | SO RS . \u0026gt; N ^ n ~ 27 F | SI US / ? O - o DEL 4. bpf - extended Berkeley Packet Filter (eBPF) 4.1. SYNOPSIS 1bpf [[-p ID | -P] [-tTj]] [[-m ID] | -M] [-s] [-xd] 4.2. DESCRIPTION 1 2 This command provides information on currently-loaded eBPF programs and maps. 3 With no arguments, basic information about each loaded eBPF program and map 4 is displayed. For each eBPF program, its ID number, the addresses of its 5 bpf_prog and bpf_prog_aux data structures, its type, tag, and the IDs of the 6 eBPF maps that it uses are displayed. For each eBPF map, its ID number, the 7 address of its bpf_map data structure, its type, and the hexadecimal value of 8 its map_flags are displayed. 9 10 -p ID displays the basic information specific to the program ID, plus the 11 size in bytes of its translated bytecode, the size in bytes of its 12 jited code, the number of bytes locked into memory, the time that 13 the program was loaded, whether it is GPL compatible, and its UID. 14 -P same as -p, but displays the basic and extra data for all programs. 15 -m ID displays the basic information specific to the map ID, plus the 16 size in bytes of its key and value, the maximum number of key-value 17 pairs that can be stored within the map, the number of bytes locked 18 into memory, its name string, and its UID. 19 -M same as -m, but displays the basic and extra data for all maps. 20 -t translate the bytecode of the specified program ID. 21 -T same as -t, but also dump the bytecode of each instruction. 22 -j disassemble the jited code of the specified program ID. 23 -s with -p or -P, dump the bpf_prog and bpf_prog_aux data structures. 24 with -m or -M, dump the bpf_map structure. 25 -x with -s, override default output format with hexadecimal format. 26 -d with -s, override default output format with decimal format. 4.3. EXAMPLES 1 Display all loaded eBPF programs and maps: 2 3 crash\u0026gt; bpf 4 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 5 13 ffffbc00c06d1000 ffff9ff260f0c400 CGROUP_SKB 7be49e3934a125ba 13,14 6 14 ffffbc00c0761000 ffff9ff260f0f600 CGROUP_SKB 2a142ef67aaad174 13,14 7 15 ffffbc00c001d000 ffff9ff2618f9e00 CGROUP_SKB 7be49e3934a125ba 15,16 8 16 ffffbc00c06c9000 ffff9ff2618f9400 CGROUP_SKB 2a142ef67aaad174 15,16 9 19 ffffbc00c0d39000 ffff9ff2610fa000 CGROUP_SKB 7be49e3934a125ba 19,20 10 20 ffffbc00c0d41000 ffff9ff2610f8e00 CGROUP_SKB 2a142ef67aaad174 19,20 11 30 ffffbc00c065f000 ffff9ff1b64de200 KPROBE 69fed6de18629d7a 32 12 31 ffffbc00c065b000 ffff9ff1b64df200 KPROBE 69fed6de18629d7a 37 13 32 ffffbc00c0733000 ffff9ff1b64dc600 KPROBE 69fed6de18629d7a 38 14 33 ffffbc00c0735000 ffff9ff1b64dca00 KPROBE 69fed6de18629d7a 39 15 34 ffffbc00c0737000 ffff9ff1b64dfc00 KPROBE 4abbddae72a6ee17 33,36,34 16 36 ffffbc00c0839000 ffff9ff1b64dd000 KPROBE da4fc6a3f41761a2 32 17 41 ffffbc00c07ec000 ffff9ff207b70400 TRACEPOINT e2094f9f46284bf6 55,54 18 44 ffffbc00c07ee000 ffff9ff1b64dc800 PERF_EVENT 19578a12836c4115 62 19 46 ffffbc00c07f0000 ffff9ff207b70400 SOCKET_FILTER 1fcfc04afd689133 64 20 21 ID BPF_MAP BPF_MAP_TYPE MAP_FLAGS 22 13 ffff9ff260f0ec00 LPM_TRIE 00000001 23 14 ffff9ff260f0de00 LPM_TRIE 00000001 24 15 ffff9ff2618fbe00 LPM_TRIE 00000001 25 16 ffff9ff2618fb800 LPM_TRIE 00000001 26 19 ffff9ff2610faa00 LPM_TRIE 00000001 27 20 ffff9ff2610fb800 LPM_TRIE 00000001 28 32 ffff9ff260d74000 HASH 00000000 29 33 ffff9ff260d76400 LRU_HASH 00000000 30 34 ffff9ff260d70000 LRU_HASH 00000002 31 35 ffff9ff260d73800 LRU_HASH 00000004 32 36 ffff9ff1b4f44000 ARRAY_OF_MAPS 00000000 33 37 ffff9ff260d77c00 PERCPU_HASH 00000000 34 38 ffff9ff260d70800 HASH 00000001 35 39 ffff9ff260d76c00 PERCPU_HASH 00000001 36 54 ffff9ff260dd2c00 HASH 00000000 37 55 ffff9ff260dd1400 HASH 00000000 38 62 ffff9ff1ae784000 HASH 00000000 39 64 ffff9ff1aea15000 ARRAY 00000000 40 41 Display additional data about program ID 20: 42 43 crash\u0026gt; bpf -p 20 44 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 45 20 ffffbc00c0d41000 ffff9ff2610f8e00 CGROUP_SKB 2a142ef67aaad174 19,20 46 XLATED: 296 JITED: 229 MEMLOCK: 4096 47 LOAD_TIME: Fri Apr 20 19:39:21 2018 48 GPL_COMPATIBLE: yes UID: 0 49 50 Display additional data about map ID 34: 51 52 crash\u0026gt; bpf -m 34 53 ID BPF_MAP BPF_MAP_TYPE MAP_FLAGS 54 34 ffff9ff260d70000 LRU_HASH 00000000 55 KEY_SIZE: 4 VALUE_SIZE: 8 MAX_ENTRIES: 10000 MEMLOCK: 1953792 56 NAME: \u0026#34;lru_hash_map\u0026#34; UID: 0 57 58 Disassemble the jited program of program ID 20: 59 60 crash\u0026gt; bpf -p 20 -j 61 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 62 20 ffffbc00c0d41000 ffff9ff2610f8e00 CGROUP_SKB 2a142ef67aaad174 19,20 63 XLATED: 296 JITED: 229 MEMLOCK: 4096 64 LOAD_TIME: Fri Apr 20 19:39:21 2018 65 GPL_COMPATIBLE: yes UID: 0 66 67 0xffffffffc06887a2: push %rbp 68 0xffffffffc06887a3: mov %rsp,%rbp 69 0xffffffffc06887a6: sub $0x40,%rsp 70 0xffffffffc06887ad: sub $0x28,%rbp 71 0xffffffffc06887b1: mov %rbx,0x0(%rbp) 72 0xffffffffc06887b5: mov %r13,0x8(%rbp) 73 0xffffffffc06887b9: mov %r14,0x10(%rbp) 74 0xffffffffc06887bd: mov %r15,0x18(%rbp) 75 0xffffffffc06887c1: xor %eax,%eax 76 0xffffffffc06887c3: mov %rax,0x20(%rbp) 77 0xffffffffc06887c7: mov %rdi,%rbx 78 0xffffffffc06887ca: movzwq 0xc0(%rbx),%r13 79 0xffffffffc06887d2: xor %r14d,%r14d 80 0xffffffffc06887d5: cmp $0x8,%r13 81 0xffffffffc06887d9: jne 0xffffffffc068881b 82 0xffffffffc06887db: mov %rbx,%rdi 83 0xffffffffc06887de: mov $0xc,%esi 84 0xffffffffc06887e3: mov %rbp,%rdx 85 0xffffffffc06887e6: add $0xfffffffffffffffc,%rdx 86 0xffffffffc06887ea: mov $0x4,%ecx 87 0xffffffffc06887ef: callq 0xffffffffb0865340 \u0026lt;bpf_skb_load_bytes\u0026gt; 88 0xffffffffc06887f4: movabs $0xffff9ff2610faa00,%rdi 89 0xffffffffc06887fe: mov %rbp,%rsi 90 0xffffffffc0688801: add $0xfffffffffffffff8,%rsi 91 0xffffffffc0688805: movl $0x20,0x0(%rsi) 92 0xffffffffc068880c: callq 0xffffffffb01fcba0 \u0026lt;bpf_map_lookup_elem\u0026gt; 93 0xffffffffc0688811: cmp $0x0,%rax 94 0xffffffffc0688815: je 0xffffffffc068881b 95 0xffffffffc0688817: or $0x2,%r14d 96 0xffffffffc068881b: cmp $0xdd86,%r13 97 0xffffffffc0688822: jne 0xffffffffc0688864 98 0xffffffffc0688824: mov %rbx,%rdi 99 0xffffffffc0688827: mov $0x8,%esi 100 0xffffffffc068882c: mov %rbp,%rdx 101 0xffffffffc068882f: add $0xfffffffffffffff0,%rdx 102 0xffffffffc0688833: mov $0x10,%ecx 103 0xffffffffc0688838: callq 0xffffffffb0865340 \u0026lt;bpf_skb_load_bytes\u0026gt; 104 0xffffffffc068883d: movabs $0xffff9ff2610fb800,%rdi 105 0xffffffffc0688847: mov %rbp,%rsi 106 0xffffffffc068884a: add $0xffffffffffffffec,%rsi 107 0xffffffffc068884e: movl $0x80,0x0(%rsi) 108 0xffffffffc0688855: callq 0xffffffffb01fcba0 \u0026lt;bpf_map_lookup_elem\u0026gt; 109 0xffffffffc068885a: cmp $0x0,%rax 110 0xffffffffc068885e: je 0xffffffffc0688864 111 0xffffffffc0688860: or $0x2,%r14d 112 0xffffffffc0688864: mov $0x1,%eax 113 0xffffffffc0688869: cmp $0x2,%r14 114 0xffffffffc068886d: jne 0xffffffffc0688871 115 0xffffffffc068886f: xor %eax,%eax 116 0xffffffffc0688871: mov 0x0(%rbp),%rbx 117 0xffffffffc0688875: mov 0x8(%rbp),%r13 118 0xffffffffc0688879: mov 0x10(%rbp),%r14 119 0xffffffffc068887d: mov 0x18(%rbp),%r15 120 0xffffffffc0688881: add $0x28,%rbp 121 0xffffffffc0688885: leaveq 122 0xffffffffc0688886: retq 123 124 Translate each bytecode instruction of program ID 13: 125 126 crash\u0026gt; bpf -p 13 -t 127 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 128 13 ffffbc00c06d1000 ffff9ff260f0c400 CGROUP_SKB 7be49e3934a125ba 13,14 129 XLATED: 296 JITED: 229 MEMLOCK: 4096 130 LOAD_TIME: Fri Apr 20 19:39:11 2018 131 GPL_COMPATIBLE: yes UID: 0 132 133 0: (bf) r6 = r1 134 1: (69) r7 = *(u16 *)(r6 +192) 135 2: (b4) (u32) r8 = (u32) 0 136 3: (55) if r7 != 0x8 goto pc+14 137 4: (bf) r1 = r6 138 5: (b4) (u32) r2 = (u32) 16 139 6: (bf) r3 = r10 140 7: (07) r3 += -4 141 8: (b4) (u32) r4 = (u32) 4 142 9: (85) call bpf_skb_load_bytes#6793152 143 10: (18) r1 = map[id:13] 144 12: (bf) r2 = r10 145 13: (07) r2 += -8 146 14: (62) *(u32 *)(r2 +0) = 32 147 15: (85) call bpf_map_lookup_elem#73760 148 16: (15) if r0 == 0x0 goto pc+1 149 17: (44) (u32) r8 |= (u32) 2 150 18: (55) if r7 != 0xdd86 goto pc+14 151 19: (bf) r1 = r6 152 20: (b4) (u32) r2 = (u32) 24 153 21: (bf) r3 = r10 154 22: (07) r3 += -16 155 23: (b4) (u32) r4 = (u32) 16 156 24: (85) call bpf_skb_load_bytes#6793152 157 25: (18) r1 = map[id:14] 158 27: (bf) r2 = r10 159 28: (07) r2 += -20 160 29: (62) *(u32 *)(r2 +0) = 128 161 30: (85) call bpf_map_lookup_elem#73760 162 31: (15) if r0 == 0x0 goto pc+1 163 32: (44) (u32) r8 |= (u32) 2 164 33: (b7) r0 = 1 165 34: (55) if r8 != 0x2 goto pc+1 166 35: (b7) r0 = 0 167 36: (95) exit 168 169 Translate, and then dump each bytecode instruction of program ID 13: 170 171 crash\u0026gt; bpf -p 13 -T 172 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 173 13 ffffbc00c06d1000 ffff9ff260f0c400 CGROUP_SKB 7be49e3934a125ba 13,14 174 XLATED: 296 JITED: 229 MEMLOCK: 4096 175 LOAD_TIME: Fri Apr 20 19:39:11 2018 176 GPL_COMPATIBLE: yes UID: 0 177 178 0: (bf) r6 = r1 179 bf 16 00 00 00 00 00 00 180 1: (69) r7 = *(u16 *)(r6 +192) 181 69 67 c0 00 00 00 00 00 182 2: (b4) (u32) r8 = (u32) 0 183 b4 08 00 00 00 00 00 00 184 3: (55) if r7 != 0x8 goto pc+14 185 55 07 0e 00 08 00 00 00 186 4: (bf) r1 = r6 187 bf 61 00 00 00 00 00 00 188 5: (b4) (u32) r2 = (u32) 16 189 b4 02 00 00 10 00 00 00 190 6: (bf) r3 = r10 191 bf a3 00 00 00 00 00 00 192 7: (07) r3 += -4 193 07 03 00 00 fc ff ff ff 194 8: (b4) (u32) r4 = (u32) 4 195 b4 04 00 00 04 00 00 00 196 9: (85) call bpf_skb_load_bytes#6793152 197 85 00 00 00 c0 a7 67 00 198 10: (18) r1 = map[id:13] 199 18 01 00 00 00 7a 96 61 00 00 00 00 b2 9d ff ff 200 12: (bf) r2 = r10 201 bf a2 00 00 00 00 00 00 202 13: (07) r2 += -8 203 07 02 00 00 f8 ff ff ff 204 14: (62) *(u32 *)(r2 +0) = 32 205 62 02 00 00 20 00 00 00 206 15: (85) call bpf_map_lookup_elem#73760 207 85 00 00 00 20 20 01 00 208 16: (15) if r0 == 0x0 goto pc+1 209 15 00 01 00 00 00 00 00 210 17: (44) (u32) r8 |= (u32) 2 211 44 08 00 00 02 00 00 00 212 18: (55) if r7 != 0xdd86 goto pc+14 213 55 07 0e 00 86 dd 00 00 214 19: (bf) r1 = r6 215 bf 61 00 00 00 00 00 00 216 20: (b4) (u32) r2 = (u32) 24 217 b4 02 00 00 18 00 00 00 218 21: (bf) r3 = r10 219 bf a3 00 00 00 00 00 00 220 22: (07) r3 += -16 221 07 03 00 00 f0 ff ff ff 222 23: (b4) (u32) r4 = (u32) 16 223 b4 04 00 00 10 00 00 00 224 24: (85) call bpf_skb_load_bytes#6793152 225 85 00 00 00 c0 a7 67 00 226 25: (18) r1 = map[id:14] 227 18 01 00 00 00 68 96 61 00 00 00 00 b2 9d ff ff 228 27: (bf) r2 = r10 229 bf a2 00 00 00 00 00 00 230 28: (07) r2 += -20 231 07 02 00 00 ec ff ff ff 232 29: (62) *(u32 *)(r2 +0) = 128 233 62 02 00 00 80 00 00 00 234 30: (85) call bpf_map_lookup_elem#73760 235 85 00 00 00 20 20 01 00 236 31: (15) if r0 == 0x0 goto pc+1 237 15 00 01 00 00 00 00 00 238 32: (44) (u32) r8 |= (u32) 2 239 44 08 00 00 02 00 00 00 240 33: (b7) r0 = 1 241 b7 00 00 00 01 00 00 00 242 34: (55) if r8 != 0x2 goto pc+1 243 55 08 01 00 02 00 00 00 244 35: (b7) r0 = 0 245 b7 00 00 00 00 00 00 00 246 36: (95) exit 247 95 00 00 00 00 00 00 00 248 249 Display the bpf_map data structure for map ID 13: 250 251 crash\u0026gt; bpf -m 13 -s 252 ID BPF_MAP BPF_MAP_TYPE MAP_FLAGS 253 13 ffff9ff260f0ec00 LPM_TRIE 00000001 254 KEY_SIZE: 8 VALUE_SIZE: 8 MAX_ENTRIES: 1 MEMLOCK: 4096 255 NAME: (unused) UID: 0 256 257 struct bpf_map { 258 ops = 0xffffffffb0e36720, 259 inner_map_meta = 0x0, 260 security = 0xffff9ff26873a158, 261 map_type = BPF_MAP_TYPE_LPM_TRIE, 262 key_size = 8, 263 value_size = 8, 264 max_entries = 1, 265 map_flags = 1, 266 pages = 1, 267 id = 13, 268 numa_node = -1, 269 unpriv_array = false, 270 user = 0xffffffffb14578a0, 271 refcnt = { 272 counter = 3 273 }, 274 usercnt = { 275 counter = 1 276 }, 277 work = { 278 data = { 279 counter = 0 280 }, 281 entry = { 282 next = 0x0, 283 prev = 0x0 284 }, 285 func = 0x0, 286 lockdep_map = { 287 key = 0x0, 288 class_cache = {0x0, 0x0}, 289 name = 0x0, 290 cpu = 0, 291 ip = 0 292 } 293 }, 294 name = \u0026#34; 295 } 296 297 Display the bpf_prog and bpf_prog_aux structures for program ID 13: 298 299 crash\u0026gt; bpf -p 13 -s 300 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 301 13 ffffbc00c06d1000 ffff9ff260f0c400 CGROUP_SKB 7be49e3934a125ba 13,14 302 XLATED: 296 JITED: 229 MEMLOCK: 4096 303 LOAD_TIME: Fri Apr 20 19:39:10 2018 304 GPL_COMPATIBLE: yes UID: 0 305 306 struct bpf_prog { 307 pages = 1, 308 jited = 1, 309 jit_requested = 1, 310 locked = 1, 311 gpl_compatible = 1, 312 cb_access = 0, 313 dst_needed = 0, 314 blinded = 0, 315 is_func = 0, 316 kprobe_override = 0, 317 type = BPF_PROG_TYPE_CGROUP_SKB, 318 len = 37, 319 jited_len = 229, 320 tag = \u0026#34;{\\344\\236\\071\\064\\241%\\272\u0026#34;, 321 aux = ffff9ff260f0c400, 322 orig_prog = 0x0, 323 bpf_func = 0xffffffffc0218a59, 324 { 325 insns = 0xffffb0cf406d1030, 326 insnsi = 0xffffb0cf406d1030 327 } 328 } 329 330 struct bpf_prog_aux { 331 refcnt = { 332 counter = 2 333 }, 334 used_map_cnt = 2, 335 max_ctx_offset = 20, 336 stack_depth = 20, 337 id = 13, 338 func_cnt = 0, 339 offload_requested = false, 340 func = 0x0, 341 jit_data = 0x0, 342 ksym_tnode = { 343 node = {{ 344 __rb_parent_color = 18446635988194065457, 345 rb_right = 0x0, 346 rb_left = 0x0 347 }, { 348 __rb_parent_color = 18446635988194065481, 349 rb_right = 0x0, 350 rb_left = 0x0 351 }} 352 }, 353 ksym_lnode = { 354 next = 0xffff9db261966460, 355 prev = 0xffffffffb85d1150 356 }, 357 ops = 0xffffffffb7f09060, 358 used_maps = 0xffff9db261e03600, 359 prog = 0xffffb0cf406d1000, 360 user = 0xffffffffb84578a0, 361 load_time = 23962237943, 362 name = \u0026#34; 363 security = 0xffff9db266f9cf50, 364 offload = 0x0, 365 { 366 work = { 367 data = { 368 counter = 0 369 }, 370 entry = { 371 next = 0x0, 372 prev = 0x0 373 }, 374 func = 0x0, 375 lockdep_map = { 376 key = 0x0, 377 class_cache = {0x0, 0x0}, 378 name = 0x0, 379 cpu = 0, 380 ip = 0 381 } 382 }, 383 rcu = { 384 next = 0x0, 385 func = 0x0 386 } 387 } 388 } 389 390 Display the extra data about all programs: 391 392 crash\u0026gt; bpf -P 393 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 394 13 ffffbc00c06d1000 ffff9ff260f0c400 CGROUP_SKB 7be49e3934a125ba 13,14 395 XLATED: 296 JITED: 229 MEMLOCK: 4096 396 LOAD_TIME: Fri Apr 20 19:39:10 2018 397 GPL_COMPATIBLE: yes UID: 0 398 399 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 400 14 ffffbc00c0761000 ffff9ff260f0f600 CGROUP_SKB 2a142ef67aaad174 13,14 401 XLATED: 296 JITED: 229 MEMLOCK: 4096 402 LOAD_TIME: Fri Apr 20 19:39:10 2018 403 GPL_COMPATIBLE: yes UID: 0 404 405 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 406 15 ffffbc00c001d000 ffff9ff2618f9e00 CGROUP_SKB 7be49e3934a125ba 15,16 407 XLATED: 296 JITED: 229 MEMLOCK: 4096 408 LOAD_TIME: Fri Apr 20 19:39:11 2018 409 GPL_COMPATIBLE: yes UID: 0 410 411 ... 412 413 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 414 75 ffffbc00c0ed1000 ffff9ff2429c6400 KPROBE da4fc6a3f41761a2 107 415 XLATED: 5168 JITED: 2828 MEMLOCK: 8192 416 LOAD_TIME: Fri Apr 27 14:54:40 2018 417 GPL_COMPATIBLE: yes UID: 0 418 419 Display the extra data for all maps: 420 421 crash\u0026gt; bpf -M 422 ID BPF_MAP BPF_MAP_TYPE MAP_FLAGS 423 13 ffff9ff260f0ec00 LPM_TRIE 00000001 424 KEY_SIZE: 8 VALUE_SIZE: 8 MAX_ENTRIES: 1 MEMLOCK: 4096 425 NAME: (unused) UID: 0 426 427 ID BPF_MAP BPF_MAP_TYPE MAP_FLAGS 428 14 ffff9ff260f0de00 LPM_TRIE 00000001 429 KEY_SIZE: 20 VALUE_SIZE: 8 MAX_ENTRIES: 1 MEMLOCK: 4096 430 NAME: (unused) UID: 0 431 432 ... 433 434 ID BPF_MAP BPF_MAP_TYPE MAP_FLAGS 435 108 ffff9ff1aeab9400 LRU_HASH 00000000 436 KEY_SIZE: 4 VALUE_SIZE: 8 MAX_ENTRIES: 1000 MEMLOCK: 147456 437 NAME: \u0026#34;lru_hash_lookup\u0026#34; UID: 0 438 439 To display all possible information that this command offers about 440 all programs and maps, enter: 441 442 crash\u0026gt; bpf -PM -jTs 5. bt - backtrace 5.1. SYNOPSIS 1bt [-a|-c cpu(s)|-g|-r|-t|-T|-l|-e|-E|-f|-F|-o|-O|-v|-p] [-R ref] [-s [-x|d]] 2 [-I ip] [-S sp] [pid | task] 5.2. DESCRIPTION 1 Display a kernel stack backtrace. If no arguments are given, the stack 2 trace of the current context will be displayed. 3 4 -a displays the stack traces of the active task on each CPU. 5 (only applicable to crash dumps) 6 -A same as -a, but also displays vector registers (S390X only). 7 -p display the stack trace of the panic task only. 8 (only applicable to crash dumps) 9 -c cpu display the stack trace of the active task on one or more CPUs, 10 which can be specified using the format \u0026#34;3\u0026#34;, \u0026#34;1,8,9\u0026#34;, \u0026#34;1-23\u0026#34;, 11 or \u0026#34;1,8,9-14\u0026#34;. (only applicable to crash dumps) 12 -g displays the stack traces of all threads in the thread group of 13 the target task; the thread group leader will be displayed first. 14 -r display raw stack data, consisting of a memory dump of the two 15 pages of memory containing the task_union structure. 16 -t display all text symbols found from the last known stack location 17 to the top of the stack. (helpful if the back trace fails) 18 -T display all text symbols found from just above the task_struct or 19 thread_info to the top of the stack. (helpful if the back trace 20 fails or the -t option starts too high in the process stack). 21 -l show file and line number of each stack trace text location. 22 -e search the stack for possible kernel and user mode exception frames. 23 -E search the IRQ stacks (x86, x86_64, arm64, and ppc64), and the 24 exception stacks (x86_64) for possible exception frames; all other 25 arguments except for -c will be ignored since this is not a context- 26 sensitive operation. 27 -f display all stack data contained in a frame; this option can be 28 used to determine the arguments passed to each function; on ia64, 29 the argument register contents are dumped. 30 -F[F] similar to -f, except that the stack data is displayed symbolically 31 when appropriate; if the stack data references a slab cache object, 32 the name of the slab cache will be displayed in brackets; on ia64, 33 the substitution is done to the argument register contents. If -F 34 is entered twice, and the stack data references a slab cache object, 35 both the address and the name of the slab cache will be displayed 36 in brackets. 37 -v check the kernel stack of all tasks for evidence of stack overflows. 38 It does so by verifying the thread_info.task pointer, ensuring that 39 the thread_info.cpu is a valid cpu number, and checking the end of 40 the stack for the STACK_END_MAGIC value. 41 -o arm64: use optional backtrace method; not supported on Linux 4.14 or 42 later kernels. 43 x86: use old backtrace method, permissible only on kernels that were 44 compiled without the -fomit-frame_pointer. 45 x86_64: use old backtrace method, which dumps potentially stale 46 kernel text return addresses found on the stack. 47 -O arm64: use optional backtrace method by default; subsequent usage 48 of this option toggles the backtrace method. 49 x86: use old backtrace method by default, permissible only on kernels 50 that were compiled without the -fomit-frame_pointer; subsequent usage 51 of this option toggles the backtrace method. 52 x86_64: use old backtrace method by default; subsequent usage of this 53 option toggles the backtrace method. 54 -R ref display stack trace only if there is a reference to this symbol 55 or text address. 56 -s display the symbol name plus its offset. 57 -x when displaying a symbol offset with the -s option, override the 58 default output format with hexadecimal format. 59 -d when displaying a symbol offset with the -s option, override the 60 default output format with decimal format. 61 -I ip use ip as the starting text location. 62 -S sp use sp as the starting stack frame address. 63 pid displays the stack trace(s) of this pid. 64 taskp displays the stack trace the the task referenced by this hexadecimal 65 task_struct pointer. 66 67 Multiple pid and taskp arguments may be specified. 68 69 Note that all examples below are for x86 only. The output format will differ 70 for other architectures. x86 backtraces from kernels that were compiled 71 with the --fomit-frame-pointer CFLAG occasionally will drop stack frames, 72 or display a stale frame reference. When in doubt as to the accuracy of a 73 backtrace, the -t or -T options may help fill in the blanks. 5.3. EXAMPLES 1 Display the stack trace of the active task(s) when the kernel panicked: 2 3 crash\u0026gt; bt -a 4 PID: 286 TASK: c0b3a000 CPU: 0 COMMAND: \u0026#34;in.rlogind\u0026#34; 5 #0 [c0b3be90] crash_save_current_state at c011aed0 6 #1 [c0b3bea4] panic at c011367c 7 #2 [c0b3bee8] tulip_interrupt at c01bc820 8 #3 [c0b3bf08] handle_IRQ_event at c010a551 9 #4 [c0b3bf2c] do_8259A_IRQ at c010a319 10 #5 [c0b3bf3c] do_IRQ at c010a653 11 #6 [c0b3bfbc] ret_from_intr at c0109634 12 EAX: 00000000 EBX: c0e68280 ECX: 00000000 EDX: 00000004 EBP: c0b3bfbc 13 DS: 0018 ESI: 00000004 ES: 0018 EDI: c0e68284 14 CS: 0010 EIP: c012f803 ERR: ffffff09 EFLAGS: 00000246 15 #7 [c0b3bfbc] sys_select at c012f803 16 #8 [c0b3bfc0] system_call at c0109598 17 EAX: 0000008e EBX: 00000004 ECX: bfffc9a0 EDX: 00000000 18 DS: 002b ESI: bfffc8a0 ES: 002b EDI: 00000000 19 SS: 002b ESP: bfffc82c EBP: bfffd224 20 CS: 0023 EIP: 400d032e ERR: 0000008e EFLAGS: 00000246 21 22 Display the stack trace of the active task on CPU 0 and 1: 23 24 crash\u0026gt; bt -c 0,1 25 PID: 0 TASK: ffffffff81a8d020 CPU: 0 COMMAND: \u0026#34;swapper\u0026#34; 26 #0 [ffff880002207e90] crash_nmi_callback at ffffffff8102fee6 27 #1 [ffff880002207ea0] notifier_call_chain at ffffffff8152d525 28 #2 [ffff880002207ee0] atomic_notifier_call_chain at ffffffff8152d58a 29 #3 [ffff880002207ef0] notify_die at ffffffff810a155e 30 #4 [ffff880002207f20] do_nmi at ffffffff8152b1eb 31 #5 [ffff880002207f50] nmi at ffffffff8152aab0 32 [exception RIP: native_safe_halt+0xb] 33 RIP: ffffffff8103eacb RSP: ffffffff81a01ea8 RFLAGS: 00000296 34 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000 35 RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffffffff81de5228 36 RBP: ffffffff81a01ea8 R8: 0000000000000000 R9: 0000000000000000 37 R10: 0012099429a6bea3 R11: 0000000000000000 R12: ffffffff81c066c0 38 R13: 0000000000000000 R14: ffffffffffffffff R15: ffffffff81de1000 39 ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018 40 --- \u0026lt;NMI exception stack\u0026gt; --- 41 #6 [ffffffff81a01ea8] native_safe_halt at ffffffff8103eacb 42 #7 [ffffffff81a01eb0] default_idle at ffffffff810167bd 43 #8 [ffffffff81a01ed0] cpu_idle at ffffffff81009fc6 44 45 PID: 38 TASK: ffff88003eaae040 CPU: 1 COMMAND: \u0026#34;khungtaskd\u0026#34; 46 #0 [ffff88003ad97ce8] machine_kexec at ffffffff81038f3b 47 #1 [ffff88003ad97d48] crash_kexec at ffffffff810c5da2 48 #2 [ffff88003ad97e18] panic at ffffffff8152721a 49 #3 [ffff88003ad97e98] watchdog at ffffffff810e6346 50 #4 [ffff88003ad97ee8] kthread at ffffffff8109af06 51 #5 [ffff88003ad97f48] kernel_thread at ffffffff8100c20a 52 53 Display the stack traces of task f2814000 and PID 1592: 54 55 crash\u0026gt; bt f2814000 1592 56 PID: 1018 TASK: f2814000 CPU: 1 COMMAND: \u0026#34;java\u0026#34; 57 #0 [f2815db4] schedule at c011af85 58 #1 [f2815de4] __down at c010600f 59 #2 [f2815e14] __down_failed at c01061b3 60 #3 [f2815e24] stext_lock (via drain_cpu_caches) at c025fa55 61 #4 [f2815ec8] kmem_cache_shrink_nr at c013a53e 62 #5 [f2815ed8] do_try_to_free_pages at c013f402 63 #6 [f2815f04] try_to_free_pages at c013f8d2 64 #7 [f2815f1c] _wrapped_alloc_pages at c01406bd 65 #8 [f2815f40] __alloc_pages at c014079d 66 #9 [f2815f60] __get_free_pages at c014083e 67 #10 [f2815f68] do_fork at c011cebb 68 #11 [f2815fa4] sys_clone at c0105ceb 69 #12 [f2815fc0] system_call at c010740c 70 EAX: 00000078 EBX: 00000f21 ECX: bc1ffbd8 EDX: bc1ffbe0 71 DS: 002b ESI: 00000000 ES: 002b EDI: bc1ffd04 72 SS: 002b ESP: 0807316c EBP: 080731bc 73 CS: 0023 EIP: 4012881e ERR: 00000078 EFLAGS: 00000296 74 75 PID: 1592 TASK: c0cec000 CPU: 3 COMMAND: \u0026#34;httpd\u0026#34; 76 #0 [c0ceded4] schedule at c011af85 77 #1 [c0cedf04] pipe_wait at c0153083 78 #2 [c0cedf58] pipe_read at c015317f 79 #3 [c0cedf7c] sys_read at c0148be6 80 #4 [c0cedfc0] system_call at c010740c 81 EAX: 00000003 EBX: 00000004 ECX: bffed4a3 EDX: 00000001 82 DS: 002b ESI: 00000001 ES: 002b EDI: bffed4a3 83 SS: 002b ESP: bffed458 EBP: bffed488 84 CS: 0023 EIP: 4024f1d4 ERR: 00000003 EFLAGS: 00000286 85 86 In order to examine each stack frame\u0026#39;s contents use the bt -f option. 87 From the extra frame data that is displayed, the arguments passed to each 88 function can be determined. Re-examining the PID 1592 trace above: 89 90 crash\u0026gt; bt -f 1592 91 PID: 1592 TASK: c0cec000 CPU: 3 COMMAND: \u0026#34;httpd\u0026#34; 92 #0 [c0ceded4] schedule at c011af85 93 [RA: c0153088 SP: c0ceded4 FP: c0cedf04 SIZE: 52] 94 c0ceded4: c0cedf00 c0cec000 ce1a6000 00000003 95 c0cedee4: c0cec000 f26152c0 cfafc8c0 c0cec000 96 c0cedef4: ef70a0a0 c0cec000 c0cedf28 c0cedf54 97 c0cedf04: c0153088 98 #1 [c0cedf04] pipe_wait at c0153083 99 [RA: c0153184 SP: c0cedf08 FP: c0cedf58 SIZE: 84] 100 c0cedf08: 00000000 c0cec000 00000000 00000000 101 c0cedf18: 00000000 c0a41fa0 c011d38b c0394120 102 c0cedf28: 00000000 c0cec000 ceeebf30 ce4adf30 103 c0cedf38: 00000000 d4b60ce0 00000000 c0cedf58 104 c0cedf48: e204f820 ef70a040 00000001 c0cedf78 105 c0cedf58: c0153184 106 #2 [c0cedf58] pipe_read at c015317f 107 [RA: c0148be8 SP: c0cedf5c FP: c0cedf7c SIZE: 36] 108 c0cedf5c: ef70a040 c0cec000 00000000 00000000 109 c0cedf6c: 00000001 f27ae680 ffffffea c0cedfbc 110 c0cedf7c: c0148be8 111 #3 [c0cedf7c] sys_read at c0148be6 112 [RA: c0107413 SP: c0cedf80 FP: c0cedfc0 SIZE: 68] 113 c0cedf80: f27ae680 bffed4a3 00000001 f27ae6a0 114 c0cedf90: 40160370 24000000 4019ba28 00000000 115 c0cedfa0: 00000000 fffffffe bffba207 fffffffe 116 c0cedfb0: c0cec000 00000001 bffed4a3 bffed488 117 c0cedfc0: c0107413 118 #4 [c0cedfc0] system_call at c010740c 119 EAX: 00000003 EBX: 00000004 ECX: bffed4a3 EDX: 00000001 120 DS: 002b ESI: 00000001 ES: 002b EDI: bffed4a3 121 SS: 002b ESP: bffed458 EBP: bffed488 122 CS: 0023 EIP: 4024f1d4 ERR: 00000003 EFLAGS: 00000286 123 [RA: 4024f1d4 SP: c0cedfc4 FP: c0cedffc SIZE: 60] 124 c0cedfc4: 00000004 bffed4a3 00000001 00000001 125 c0cedfd4: bffed4a3 bffed488 00000003 0000002b 126 c0cedfe4: 0000002b 00000003 4024f1d4 00000023 127 c0cedff4: 00000286 bffed458 0000002b 128 129 Typically the arguments passed to a function will be the last values 130 that were pushed onto the stack by the next higher-numbered function, i.e., 131 the lowest stack addresses in the frame above the called function\u0026#39;s 132 stack frame. That can be verified by disassembling the calling function. 133 For example, the arguments passed from sys_read() to pipe_read() above 134 are the file pointer, the user buffer address, the count, and a pointer 135 to the file structure\u0026#39;s f_pos field. Looking at the frame #3 data for 136 sys_read(), the last four items pushed onto the stack (lowest addresses) 137 are f27ae680, bffed4a3, 00000001, and f27ae6a0 -- which are the 4 arguments 138 above, in that order. Note that the first (highest address) stack content 139 in frame #2 data for pipe_read() is c0148be8, which is the return address 140 back to sys_read(). 141 142 Dump the text symbols found in the current context\u0026#39;s stack: 143 144 crash\u0026gt; bt -t 145 PID: 1357 TASK: c1aa0000 CPU: 0 COMMAND: \u0026#34;lockd\u0026#34; 146 START: schedule at c01190e0 147 [c1aa1f28] dput at c0157dbc 148 [c1aa1f4c] schedule_timeout at c0124cd4 149 [c1aa1f78] svc_recv at cb22c4d8 [sunrpc] 150 [c1aa1f98] put_files_struct at c011eb21 151 [c1aa1fcc] nlmclnt_proc at cb237bef [lockd] 152 [c1aa1ff0] kernel_thread at c0105826 153 [c1aa1ff8] nlmclnt_proc at cb237a60 [lockd] 154 155 Search the current stack for possible exception frames: 156 157 crash\u0026gt; bt -e 158 PID: 286 TASK: c0b3a000 CPU: 0 COMMAND: \u0026#34;in.rlogind\u0026#34; 159 160 KERNEL-MODE EXCEPTION FRAME AT c0b3bf44: 161 EAX: 00000000 EBX: c0e68280 ECX: 00000000 EDX: 00000004 EBP: c0b3bfbc 162 DS: 0018 ESI: 00000004 ES: 0018 EDI: c0e68284 163 CS: 0010 EIP: c012f803 ERR: ffffff09 EFLAGS: 00000246 164 165 USER-MODE EXCEPTION FRAME AT c0b3bfc4: 166 EAX: 0000008e EBX: 00000004 ECX: bfffc9a0 EDX: 00000000 167 DS: 002b ESI: bfffc8a0 ES: 002b EDI: 00000000 168 SS: 002b ESP: bfffc82c EBP: bfffd224 169 CS: 0023 EIP: 400d032e ERR: 0000008e EFLAGS: 00000246 170 171 Display the back trace from a dumpfile that resulted from the execution 172 of the crash utility\u0026#39;s \u0026#34;sys -panic\u0026#34; command: 173 174 crash\u0026gt; bt 175 PID: 12523 TASK: c610c000 CPU: 0 COMMAND: \u0026#34;crash\u0026#34; 176 #0 [c610de64] die at c01076ec 177 #1 [c610de74] do_invalid_op at c01079bc 178 #2 [c610df2c] error_code (via invalid_op) at c0107256 179 EAX: 0000001d EBX: c024a4c0 ECX: c02f13c4 EDX: 000026f6 EBP: c610c000 180 DS: 0018 ESI: 401de2e0 ES: 0018 EDI: c610c000 181 CS: 0010 EIP: c011bbb4 ERR: ffffffff EFLAGS: 00010296 182 #3 [c610df68] panic at c011bbb4 183 #4 [c610df78] do_exit at c011f1fe 184 #5 [c610dfc0] system_call at c0107154 185 EAX: 00000001 EBX: 00000000 ECX: 00001000 EDX: 401df154 186 DS: 002b ESI: 401de2e0 ES: 002b EDI: 00000000 187 SS: 002b ESP: bffebf0c EBP: bffebf38 188 CS: 0023 EIP: 40163afd ERR: 00000001 EFLAGS: 00000246 189 190 Display the back trace from a dumpfile that resulted from an attempt to 191 insmod the sample \u0026#34;crash.c\u0026#34; kernel module that comes as part of the 192 Red Hat netdump package: 193 194 crash\u0026gt; bt 195 PID: 1696 TASK: c74de000 CPU: 0 COMMAND: \u0026#34;insmod\u0026#34; 196 #0 [c74dfdcc] die at c01076ec 197 #1 [c74dfddc] do_page_fault at c0117bbc 198 #2 [c74dfee0] error_code (via page_fault) at c0107256 199 EAX: 00000013 EBX: cb297000 ECX: 00000000 EDX: c5962000 EBP: c74dff28 200 DS: 0018 ESI: 00000000 ES: 0018 EDI: 00000000 201 CS: 0010 EIP: cb297076 ERR: ffffffff EFLAGS: 00010282 202 #3 [c74dff1c] crash_init at cb297076 [crash] 203 #4 [c74dff2c] sys_init_module at c011d233 204 #5 [c74dffc0] system_call at c0107154 205 EAX: 00000080 EBX: 08060528 ECX: 08076450 EDX: 0000000a 206 DS: 002b ESI: 0804b305 ES: 002b EDI: 08074ed0 207 SS: 002b ESP: bffe9a90 EBP: bffe9ac8 208 CS: 0023 EIP: 4012066e ERR: 00000080 EFLAGS: 00000246 209 210 Display the symbol name plus its offset in each frame, overriding 211 the current output format with hexadecimal: 212 213 crash\u0026gt; bt -sx 214 PID: 1499 TASK: ffff88006af43cc0 CPU: 2 COMMAND: \u0026#34;su\u0026#34; 215 #0 [ffff8800664a1c90] machine_kexec+0x167 at ffffffff810327b7 216 #1 [ffff8800664a1ce0] crash_kexec+0x60 at ffffffff810a9ec0 217 #2 [ffff8800664a1db0] oops_end+0xb0 at ffffffff81504160 218 #3 [ffff8800664a1dd0] general_protection+0x25 at ffffffff81503435 219 [exception RIP: kmem_cache_alloc+120] 220 RIP: ffffffff8113cf88 RSP: ffff8800664a1e88 RFLAGS: 00010086 221 RAX: 0000000000000000 RBX: ff88006ef56840ff RCX: ffffffff8114e9e4 222 RDX: 0000000000000000 RSI: 00000000000080d0 RDI: ffffffff81796020 223 RBP: ffffffff81796020 R8: ffff88000a3137a0 R9: 0000000000000000 224 R10: ffff88007ac97300 R11: 0000000000000400 R12: 00000000000080d0 225 R13: 0000000000000292 R14: 00000000000080d0 R15: 00000000000000c0 226 ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018 227 #4 [ffff8800664a1ed0] get_empty_filp+0x74 at ffffffff8114e9e4 228 #5 [ffff8800664a1ef0] sock_alloc_fd+0x23 at ffffffff8142f553 229 #6 [ffff8800664a1f10] sock_map_fd+0x23 at ffffffff8142f693 230 #7 [ffff8800664a1f50] sys_socket+0x43 at ffffffff814302a3 231 #8 [ffff8800664a1f80] system_call_fastpath+0x16 at ffffffff81013042 232 RIP: 00007f5720b368e7 RSP: 00007fff52b629a8 RFLAGS: 00010206 233 RAX: 0000000000000029 RBX: ffffffff81013042 RCX: 0000000000000000 234 RDX: 0000000000000009 RSI: 0000000000000003 RDI: 0000000000000010 235 RBP: 000000000066f320 R8: 0000000000000001 R9: 0000000000000000 236 R10: 0000000000000000 R11: 0000000000000202 R12: ffff88007ac97300 237 R13: 0000000000000000 R14: 00007f571e104a80 R15: 00007f571e305048 238 ORIG_RAX: 0000000000000029 CS: 0033 SS: 002b 239 240 The following three examples show the difference in the display of 241 the same stack frame\u0026#39;s contents using -f, -F, and -FF: 242 243 crash\u0026gt; bt -f 244 ... 245 #4 [ffff810072b47f10] vfs_write at ffffffff800789d8 246 ffff810072b47f18: ffff81007e020380 ffff81007e2c2880 247 ffff810072b47f28: 0000000000000002 fffffffffffffff7 248 ffff810072b47f38: 00002b141825d000 ffffffff80078f75 249 #5 [ffff810072b47f40] sys_write at ffffffff80078f75 250 ... 251 crash\u0026gt; bt -F 252 ... 253 #4 [ffff810072b47f10] vfs_write at ffffffff800789d8 254 ffff810072b47f18: [files_cache] [filp] 255 ffff810072b47f28: 0000000000000002 fffffffffffffff7 256 ffff810072b47f38: 00002b141825d000 sys_write+69 257 #5 [ffff810072b47f40] sys_write at ffffffff80078f75 258 ... 259 crash\u0026gt; bt -FF 260 ... 261 #4 [ffff810072b47f10] vfs_write at ffffffff800789d8 262 ffff810072b47f18: [ffff81007e020380:files_cache] [ffff81007e2c2880:filp] 263 ffff810072b47f28: 0000000000000002 fffffffffffffff7 264 ffff810072b47f38: 00002b141825d000 sys_write+69 265 #5 [ffff810072b47f40] sys_write at ffffffff80078f75 266 ... 267 268 Check the kernel stack of all tasks for evidence of a stack overflow: 269 270 crash\u0026gt; bt -v 271 PID: 5823 TASK: ffff88102aae0040 CPU: 1 COMMAND: \u0026#34;flush-253:0\u0026#34; 272 possible stack overflow: thread_info.task: 102efb5adc0 != ffff88102aae0040 273 possible stack overflow: 40ffffffff != STACK_END_MAGIC 6. btop - bytes to page 6.1. SYNOPSIS 1btop address ... 6.2. DESCRIPTION 1 This command translates a hexadecimal address to its page number. 6.3. EXAMPLES 1 crash\u0026gt; btop 512a000 2 512a000: 512a 7. dev - device data 7.1. SYNOPSIS 1dev [-i | -p | -d | -D ] [-V | -v index [file]] 7.2. DESCRIPTION 1 If no argument is entered, this command dumps character and block 2 device data. 3 4 -i display I/O port usage; on 2.4 kernels, also display I/O memory usage. 5 -p display PCI device data. 6 -d display disk I/O statistics: 7 TOTAL: total number of allocated in-progress I/O requests 8 SYNC: I/O requests that are synchronous 9 ASYNC: I/O requests that are asynchronous 10 READ: I/O requests that are reads (older kernels) 11 WRITE: I/O requests that are writes (older kernels) 12 DRV: I/O requests that are in-flight in the device driver. 13 If the device driver uses blk-mq interface, this field 14 shows N/A(MQ). If not available, this column is not shown. 15 -D same as -d, but filter out disks with no in-progress I/O requests. 16 17 If the dumpfile contains device dumps: 18 -V display an indexed list of all device dumps present in the vmcore, 19 showing their file offset, size and name. 20 -v index select and display one device dump based upon an index value 21 shown by the -V option, shown in a default human-readable format; 22 alternatively, the \u0026#34;rd -f\u0026#34; option along with its various format 23 options may be used to further tailor the output. 24 file only used with -v, copy the device dump data to a file. 7.3. EXAMPLES 1 Display character and block device data: 2 3 crash\u0026gt; dev 4 CHRDEV NAME CDEV OPERATIONS 5 1 mem f79b83c0 memory_fops 6 4 /dev/vc/0 c07bc560 console_fops 7 4 tty f7af5004 tty_fops 8 4 ttyS f7b02204 tty_fops 9 5 /dev/tty c07bc440 tty_fops 10 5 /dev/console c07bc4a0 console_fops 11 5 /dev/ptmx c07bc500 ptmx_fops 12 6 lp c5797e40 lp_fops 13 7 vcs f7b03d40 vcs_fops 14 10 misc f7f68640 misc_fops 15 13 input f79b8840 input_fops 16 21 sg f7f12840 sg_fops 17 29 fb f7f8c640 fb_fops 18 128 ptm f7b02604 tty_fops 19 136 pts f7b02404 tty_fops 20 162 raw c0693e40 raw_fops 21 180 usb f79b8bc0 usb_fops 22 189 usb_device c06a0300 usbfs_device_file_operations 23 216 rfcomm f5961a04 tty_fops 24 254 pcmcia f79b82c0 ds_fops 25 26 BLKDEV NAME GENDISK OPERATIONS 27 1 ramdisk f7b23480 rd_bd_op 28 8 sd f7cab280 sd_fops 29 9 md f7829b80 md_fops 30 11 sr f75c24c0 sr_bdops 31 65 sd (none) 32 66 sd (none) 33 67 sd (none) 34 68 sd (none) 35 69 sd (none) 36 70 sd (none) 37 71 sd (none) 38 128 sd (none) 39 129 sd (none) 40 130 sd (none) 41 131 sd (none) 42 132 sd (none) 43 133 sd (none) 44 134 sd (none) 45 135 sd (none) 46 253 device-mapper c57a0ac0 dm_blk_dops 47 254 mdp (none) 48 49 Display PCI data: 50 51 crash\u0026gt; dev -p 52 PCI_DEV BU:SL.FN CLASS: VENDOR-DEVICE 53 c00051c0 00:00.0 Host bridge: Intel 440BX - 82443BX Host 54 c0005250 00:01.0 PCI bridge: Intel 440BX - 82443BX AGP 55 c00052e0 00:07.0 ISA bridge: Intel 82371AB PIIX4 ISA 56 c0005370 00:07.1 IDE interface: Intel 82371AB PIIX4 IDE 57 c0005400 00:07.2 USB Controller: Intel 82371AB PIIX4 USB 58 c0005490 00:07.3 Bridge: Intel 82371AB PIIX4 ACPI 59 c0005520 00:11.0 Ethernet controller: 3Com 3C905B 100bTX 60 c00055b0 00:13.0 PCI bridge: DEC DC21152 61 c0005640 01:00.0 VGA compatible controller: NVidia [PCI_DEVICE 28] 62 c00056d0 02:0a.0 SCSI storage controller: Adaptec AIC-7890/1 63 c0005760 02:0e.0 SCSI storage controller: Adaptec AIC-7880U 64 65 Display I/O port and I/O memory usage: 66 67 crash\u0026gt; dev -i 68 RESOURCE RANGE NAME 69 c03036d4 0000-ffff PCI IO 70 c0302594 0000-001f dma1 71 c03025b0 0020-003f pic1 72 c03025cc 0040-005f timer 73 c03025e8 0060-006f keyboard 74 c0302604 0080-008f dma page reg 75 c0302620 00a0-00bf pic2 76 c030263c 00c0-00df dma2 77 c0302658 00f0-00ff fpu 78 c122ff20 0170-0177 ide1 79 c122f240 0213-0213 isapnp read 80 c122ff40 02f8-02ff serial(auto) 81 c122ff00 0376-0376 ide1 82 c03186e8 03c0-03df vga+ 83 c122ff60 03f8-03ff serial(auto) 84 c123851c 0800-083f Intel Corporation 82371AB PIIX4 ACPI 85 c1238538 0840-085f Intel Corporation 82371AB PIIX4 ACPI 86 c122f220 0a79-0a79 isapnp write 87 c122f200 0cf8-0cff PCI conf1 88 c1238858 dc00-dc7f 3Com Corporation 3c905B 100BaseTX [Cyclone] 89 c122fc00 dc00-dc7f 00:11.0 90 c12380c8 dce0-dcff Intel Corporation 82371AB PIIX4 USB 91 c1238d1c e000-efff PCI Bus #02 92 c1237858 e800-e8ff Adaptec AIC-7880U 93 c1237458 ec00-ecff Adaptec AHA-2940U2/W / 7890 94 c1239cc8 ffa0-ffaf Intel Corporation 82371AB PIIX4 IDE 95 96 RESOURCE RANGE NAME 97 c03036f0 00000000-ffffffff PCI mem 98 c0004000 00000000-0009ffff System RAM 99 c03026ac 000a0000-000bffff Video RAM area 100 c03026fc 000c0000-000c7fff Video ROM 101 c0302718 000c9800-000cdfff Extension ROM 102 c0302734 000ce000-000ce7ff Extension ROM 103 c0302750 000ce800-000cffff Extension ROM 104 c03026e0 000f0000-000fffff System ROM 105 c0004040 00100000-07ffdfff System RAM 106 c0302674 00100000-0028682b Kernel code 107 c0302690 0028682c-0031c63f Kernel data 108 c0004060 07ffe000-07ffffff reserved 109 c1239058 ec000000-efffffff Intel Corporation 440BX/ZX - 82443BX/ZX Host 110 bridge 111 c1238d54 f1000000-f1ffffff PCI Bus #02 112 c1239554 f2000000-f5ffffff PCI Bus #01 113 c1237074 f4000000-f5ffffff nVidia Corporation Riva TnT2 [NV5] 114 c1238d38 fa000000-fbffffff PCI Bus #02 115 c1237874 faffe000-faffefff Adaptec AIC-7880U 116 c127ec40 faffe000-faffefff aic7xxx 117 c1237474 fafff000-faffffff Adaptec AHA-2940U2/W / 7890 118 c127eec0 fafff000-faffffff aic7xxx 119 c1239538 fc000000-fdffffff PCI Bus #01 120 c1237058 fc000000-fcffffff nVidia Corporation Riva TnT2 [NV5] 121 c1238874 fe000000-fe00007f 3Com Corporation 3c905B 100BaseTX [Cyclone] 122 c0004080 fec00000-fec0ffff reserved 123 c00040a0 fee00000-fee0ffff reserved 124 c00040c0 ffe00000-ffffffff reserved 125 126 Display disk I/O statistics: 127 128 crash\u0026gt; dev -d 129 MAJOR GENDISK NAME REQUEST_QUEUE TOTAL READ WRITE DRV 130 2 ffff81012d8a5000 fd0 ffff81012dc053c0 12 0 12 0 131 22 ffff81012dc6b000 hdc ffff81012d8ae340 2 2 0 0 132 8 ffff81012dd71000 sda ffff81012d8af040 6 0 6 6 133 8 ffff81012dc77000 sdb ffff81012d8b5740 0 0 0 0 134 8 ffff81012d8d0c00 sdc ffff81012d8ae9c0 0 0 0 0 135 136 Display the available device dumps: 137 138 crash\u0026gt; dev -V 139 INDEX OFFSET SIZE NAME 140 0 0x240 33558464 cxgb4_0000:02:00.4 141 1 0x2001240 33558464 cxgb4_0000:03:00.4 142 143 Extract a specified device dump to file: 144 145 crash\u0026gt; dev -v 0 device_dump_0.bin 146 DEVICE: cxgb4_0000:02:00.4 147 33558464 bytes copied from 0x240 to device_dump_0.bin 148 149 Format and display a device\u0026#39;s dump data to the screen using the \u0026#34;rd\u0026#34; command: 150 151 crash\u0026gt; rd -f 0x240 -32 8 152 240: 040b69e2 00000038 000e0001 00675fd4 .i..8........_g. 153 250: 00000000 21600047 00000000 00000000 ....G.`!........ 154 155 Display a device\u0026#39;s dump data to the screen using the default format: 156 157 crash\u0026gt; dev -v 1 158 DEVICE: cxgb4_0000:03:00.4 159 2001240: 00000038040b69e2 00af985c000e0001 .i..8.......\\... 160 2001250: 2150004700000000 0000000000000000 ....G.P!........ 161 2001260: 0000000000000000 0000000000000000 ................ 162 2001270: 0000000000000000 0002fccc00000001 ................ 163 2001280: 00000000000027b0 0000000000000000 .\u0026#39;.............. 164 ... 8. dis - disassemble 8.1. SYNOPSIS 1dis [-rfludxs][-b [num]] [address | symbol | (expression)] [count] 8.2. DESCRIPTION 1 This command disassembles source code instructions starting (or ending) at 2 a text address that may be expressed by value, symbol or expression: 3 4 -r (reverse) displays all instructions from the start of the 5 routine up to and including the designated address. 6 -f (forward) displays all instructions from the given address 7 to the end of the routine. 8 -l displays source code line number data in addition to the 9 disassembly output. 10 -u address is a user virtual address in the current context; 11 otherwise the address is assumed to be a kernel virtual address. 12 If this option is used, then -r and -l are ignored. 13 -x override default output format with hexadecimal format. 14 -d override default output format with decimal format. 15 -s displays the filename and line number of the source code that 16 is associated with the specified text location, followed by a 17 source code listing if it is available on the host machine. 18 The line associated with the text location will be marked with 19 an asterisk; depending upon gdb\u0026#39;s internal \u0026#34;listsize\u0026#34; variable, 20 several lines will precede the marked location. If a \u0026#34;count\u0026#34; 21 argument is entered, it specifies the number of source code 22 lines to be displayed after the marked location; otherwise 23 the remaining source code of the containing function will be 24 displayed. 25 -b [num] modify the pre-calculated number of encoded bytes to skip after 26 a kernel BUG (\u0026#34;ud2a\u0026#34;) instruction; with no argument, displays 27 the current number of bytes being skipped. (x86 and x86_64 only) 28 address starting hexadecimal text address. 29 symbol symbol of starting text address. On ppc64, the symbol 30 preceded by \u0026#39;.\u0026#39; is used. 31 (expression) expression evaluating to a starting text address. 32 count the number of instructions to be disassembled (default is 1). 33 If no count argument is entered, and the starting address 34 is entered as a text symbol, then the whole routine will be 35 disassembled. The count argument is supported when used with 36 the -r and -f options. 8.3. EXAMPLES 1 Disassemble the sys_signal() routine without, and then with, line numbers: 2 3 crash\u0026gt; dis sys_signal 4 0xc0112c88 \u0026lt;sys_signal\u0026gt;: push %ebp 5 0xc0112c89 \u0026lt;sys_signal+1\u0026gt;: mov %esp,%ebp 6 0xc0112c8b \u0026lt;sys_signal+3\u0026gt;: sub $0x28,%esp 7 0xc0112c8e \u0026lt;sys_signal+6\u0026gt;: mov 0xc(%ebp),%eax 8 0xc0112c91 \u0026lt;sys_signal+9\u0026gt;: mov %eax,0xffffffec(%ebp) 9 0xc0112c94 \u0026lt;sys_signal+12\u0026gt;: movl $0xc0000000,0xfffffff0(%ebp) 10 0xc0112c9b \u0026lt;sys_signal+19\u0026gt;: lea 0xffffffd8(%ebp),%eax 11 0xc0112c9e \u0026lt;sys_signal+22\u0026gt;: push %eax 12 0xc0112c9f \u0026lt;sys_signal+23\u0026gt;: lea 0xffffffec(%ebp),%eax 13 0xc0112ca2 \u0026lt;sys_signal+26\u0026gt;: push %eax 14 0xc0112ca3 \u0026lt;sys_signal+27\u0026gt;: pushl 0x8(%ebp) 15 0xc0112ca6 \u0026lt;sys_signal+30\u0026gt;: call 0xc01124b8 \u0026lt;do_sigaction\u0026gt; 16 0xc0112cab \u0026lt;sys_signal+35\u0026gt;: test %eax,%eax 17 0xc0112cad \u0026lt;sys_signal+37\u0026gt;: jne 0xc0112cb2 \u0026lt;sys_signal+42\u0026gt; 18 0xc0112caf \u0026lt;sys_signal+39\u0026gt;: mov 0xffffffd8(%ebp),%eax 19 0xc0112cb2 \u0026lt;sys_signal+42\u0026gt;: leave 20 0xc0112cb3 \u0026lt;sys_signal+43\u0026gt;: ret 21 22 crash\u0026gt; dis -l sys_signal 23 /usr/src/linux-2.2.5/kernel/signal.c: 1074 24 0xc0112c88 \u0026lt;sys_signal\u0026gt;: push %ebp 25 0xc0112c89 \u0026lt;sys_signal+1\u0026gt;: mov %esp,%ebp 26 0xc0112c8b \u0026lt;sys_signal+3\u0026gt;: sub $0x28,%esp 27 0xc0112c8e \u0026lt;sys_signal+6\u0026gt;: mov 0xc(%ebp),%eax 28 /usr/src/linux-2.2.5/kernel/signal.c: 1078 29 0xc0112c91 \u0026lt;sys_signal+9\u0026gt;: mov %eax,0xffffffec(%ebp) 30 /usr/src/linux-2.2.5/kernel/signal.c: 1079 31 0xc0112c94 \u0026lt;sys_signal+12\u0026gt;: movl $0xc0000000,0xfffffff0(%ebp) 32 /usr/src/linux-2.2.5/kernel/signal.c: 1081 33 0xc0112c9b \u0026lt;sys_signal+19\u0026gt;: lea 0xffffffd8(%ebp),%eax 34 0xc0112c9e \u0026lt;sys_signal+22\u0026gt;: push %eax 35 0xc0112c9f \u0026lt;sys_signal+23\u0026gt;: lea 0xffffffec(%ebp),%eax 36 0xc0112ca2 \u0026lt;sys_signal+26\u0026gt;: push %eax 37 0xc0112ca3 \u0026lt;sys_signal+27\u0026gt;: pushl 0x8(%ebp) 38 0xc0112ca6 \u0026lt;sys_signal+30\u0026gt;: call 0xc01124b8 \u0026lt;do_sigaction\u0026gt; 39 /usr/src/linux-2.2.5/kernel/signal.c: 1083 40 0xc0112cab \u0026lt;sys_signal+35\u0026gt;: test %eax,%eax 41 0xc0112cad \u0026lt;sys_signal+37\u0026gt;: jne 0xc0112cb2 \u0026lt;sys_signal+42\u0026gt; 42 0xc0112caf \u0026lt;sys_signal+39\u0026gt;: mov 0xffffffd8(%ebp),%eax 43 /usr/src/linux-2.2.5/kernel/signal.c: 1084 44 0xc0112cb2 \u0026lt;sys_signal+42\u0026gt;: leave 45 0xc0112cb3 \u0026lt;sys_signal+43\u0026gt;: ret 46 47 Given a return address expression of \u0026#34;do_no_page+65\u0026#34;, find out the 48 function that do_no_page() calls by using the reverse flag: 49 50 crash\u0026gt; dis -r (do_no_page+65) 51 0xc011ea68 \u0026lt;do_no_page\u0026gt;: push %ebp 52 0xc011ea69 \u0026lt;do_no_page+1\u0026gt;: mov %esp,%ebp 53 0xc011ea6b \u0026lt;do_no_page+3\u0026gt;: push %edi 54 0xc011ea6c \u0026lt;do_no_page+4\u0026gt;: push %esi 55 0xc011ea6d \u0026lt;do_no_page+5\u0026gt;: push %ebx 56 0xc011ea6e \u0026lt;do_no_page+6\u0026gt;: mov 0xc(%ebp),%ebx 57 0xc011ea71 \u0026lt;do_no_page+9\u0026gt;: mov 0x10(%ebp),%edx 58 0xc011ea74 \u0026lt;do_no_page+12\u0026gt;: mov 0x14(%ebp),%edi 59 0xc011ea77 \u0026lt;do_no_page+15\u0026gt;: mov 0x28(%ebx),%eax 60 0xc011ea7a \u0026lt;do_no_page+18\u0026gt;: test %eax,%eax 61 0xc011ea7c \u0026lt;do_no_page+20\u0026gt;: je 0xc011ea85 \u0026lt;do_no_page+29\u0026gt; 62 0xc011ea7e \u0026lt;do_no_page+22\u0026gt;: mov 0x18(%eax),%ecx 63 0xc011ea81 \u0026lt;do_no_page+25\u0026gt;: test %ecx,%ecx 64 0xc011ea83 \u0026lt;do_no_page+27\u0026gt;: jne 0xc011eab0 \u0026lt;do_no_page+72\u0026gt; 65 0xc011ea85 \u0026lt;do_no_page+29\u0026gt;: mov $0xffffe000,%eax 66 0xc011ea8a \u0026lt;do_no_page+34\u0026gt;: and %esp,%eax 67 0xc011ea8c \u0026lt;do_no_page+36\u0026gt;: decl 0x30(%eax) 68 0xc011ea8f \u0026lt;do_no_page+39\u0026gt;: jns 0xc011ea9a \u0026lt;do_no_page+50\u0026gt; 69 0xc011ea91 \u0026lt;do_no_page+41\u0026gt;: lock btrl $0x0,0xc022fb60 70 0xc011ea9a \u0026lt;do_no_page+50\u0026gt;: push %edi 71 0xc011ea9b \u0026lt;do_no_page+51\u0026gt;: mov 0x18(%ebp),%esi 72 0xc011ea9e \u0026lt;do_no_page+54\u0026gt;: push %esi 73 0xc011ea9f \u0026lt;do_no_page+55\u0026gt;: push %ebx 74 0xc011eaa0 \u0026lt;do_no_page+56\u0026gt;: mov 0x8(%ebp),%esi 75 0xc011eaa3 \u0026lt;do_no_page+59\u0026gt;: push %esi 76 0xc011eaa4 \u0026lt;do_no_page+60\u0026gt;: call 0xc011e9e4 \u0026lt;do_anonymous_page\u0026gt; 77 0xc011eaa9 \u0026lt;do_no_page+65\u0026gt;: jmp 0xc011eb47 \u0026lt;do_no_page+223\u0026gt; 78 79 Disassemble 10 instructions starting at user virtual address 0x81ec624: 80 81 crash\u0026gt; dis -u 81ec624 10 82 0x81ec624: push %ebp 83 0x81ec625: mov %esp,%ebp 84 0x81ec627: sub $0x18,%esp 85 0x81ec62a: movl $0x1,0x8(%ebp) 86 0x81ec631: mov 0x82f9040,%eax 87 0x81ec636: mov 0x10(%eax),%edx 88 0x81ec639: and $0x100,%edx 89 0x81ec63f: mov 0x14(%eax),%ecx 90 0x81ec642: and $0x0,%ecx 91 0x81ec645: mov %ecx,%eax 92 93 Override the current decimal output radix format: 94 95 crash\u0026gt; dis sys_read 10 -x 96 0xffffffff8001178f \u0026lt;sys_read\u0026gt;: push %r13 97 0xffffffff80011791 \u0026lt;sys_read+0x2\u0026gt;: mov %rsi,%r13 98 0xffffffff80011794 \u0026lt;sys_read+0x5\u0026gt;: push %r12 99 0xffffffff80011796 \u0026lt;sys_read+0x7\u0026gt;: mov $0xfffffffffffffff7,%r12 100 0xffffffff8001179d \u0026lt;sys_read+0xe\u0026gt;: push %rbp 101 0xffffffff8001179e \u0026lt;sys_read+0xf\u0026gt;: mov %rdx,%rbp 102 0xffffffff800117a1 \u0026lt;sys_read+0x12\u0026gt;: push %rbx 103 0xffffffff800117a2 \u0026lt;sys_read+0x13\u0026gt;: sub $0x18,%rsp 104 0xffffffff800117a6 \u0026lt;sys_read+0x17\u0026gt;: lea 0x14(%rsp),%rsi 105 0xffffffff800117ab \u0026lt;sys_read+0x1c\u0026gt;: callq 0xffffffff8000b5b4 \u0026lt;fget_light\u0026gt; 106 107 Disassemble from vfs_read+320 until the end of the function: 108 109 crash\u0026gt; dis -f vfs_read+320 110 0xffffffff8119d4e0 \u0026lt;vfs_read+320\u0026gt;: cmpq $0x0,0x20(%rax) 111 0xffffffff8119d4e5 \u0026lt;vfs_read+325\u0026gt;: jne 0xffffffff8119d3e8 \u0026lt;vfs_read+72\u0026gt; 112 0xffffffff8119d4eb \u0026lt;vfs_read+331\u0026gt;: mov $0xffffffffffffffea,%r12 113 0xffffffff8119d4f2 \u0026lt;vfs_read+338\u0026gt;: jmp 0xffffffff8119d4c3 \u0026lt;vfs_read+291\u0026gt; 114 0xffffffff8119d4f4 \u0026lt;vfs_read+340\u0026gt;: nopl 0x0(%rax) 115 0xffffffff8119d4f8 \u0026lt;vfs_read+344\u0026gt;: callq 0xffffffff8119cc40 \u0026lt;do_sync_read\u0026gt; 116 0xffffffff8119d4fd \u0026lt;vfs_read+349\u0026gt;: mov %rax,%r12 117 0xffffffff8119d500 \u0026lt;vfs_read+352\u0026gt;: jmpq 0xffffffff8119d44c \u0026lt;vfs_read+172\u0026gt; 118 0xffffffff8119d505 \u0026lt;vfs_read+357\u0026gt;: nopl (%rax) 119 0xffffffff8119d508 \u0026lt;vfs_read+360\u0026gt;: mov $0xfffffffffffffff7,%r12 120 0xffffffff8119d50f \u0026lt;vfs_read+367\u0026gt;: jmp 0xffffffff8119d4c3 \u0026lt;vfs_read+291\u0026gt; 121 0xffffffff8119d511 \u0026lt;vfs_read+369\u0026gt;: mov $0xfffffffffffffff2,%r12 122 0xffffffff8119d518 \u0026lt;vfs_read+376\u0026gt;: jmp 0xffffffff8119d4c3 \u0026lt;vfs_read+291\u0026gt; 123 0xffffffff8119d51a \u0026lt;vfs_read+378\u0026gt;: nopw 0x0(%rax,%rax,1) 124 125 Display the source code listing of the mmput() function: 126 127 crash\u0026gt; dis -s mmput 128 FILE: kernel/fork.c 129 LINE: 617 130 131 612 132 613 /* 133 614 * Decrement the use count and release all resources for an mm. 134 615 */ 135 616 void mmput(struct mm_struct *mm) 136 * 617 { 137 618 might_sleep(); 138 619 139 620 if (atomic_dec_and_test(\u0026amp;mm-\u0026gt;mm_users)) { 140 621 uprobe_clear_state(mm); 141 622 exit_aio(mm); 142 623 ksm_exit(mm); 143 624 khugepaged_exit(mm); /* must run before exit_mmap */ 144 625 exit_mmap(mm); 145 626 set_mm_exe_file(mm, NULL); 146 627 if (!list_empty(\u0026amp;mm-\u0026gt;mmlist)) { 147 628 spin_lock(\u0026amp;mmlist_lock); 148 629 list_del(\u0026amp;mm-\u0026gt;mmlist); 149 630 spin_unlock(\u0026amp;mmlist_lock); 150 631 } 151 632 if (mm-\u0026gt;binfmt) 152 633 module_put(mm-\u0026gt;binfmt-\u0026gt;module); 153 634 mmdrop(mm); 154 635 } 155 636 } 156 157 The disassembly of dentry_kill() shows an indirect call to a function 158 whose address is contained within a register. Display the source code 159 associated with the indirect function call: 160 161 crash\u0026gt; dis dentry_kill 162 ... 163 0xffffffff811dcfb4 \u0026lt;dentry_kill+324\u0026gt;:\tcallq *%rax 164 ... 165 crash\u0026gt; dis -s 0xffffffff811dcfb4 166 FILE: fs/dcache.c 167 LINE: 276 168 169 271 spin_unlock(\u0026amp;dentry-\u0026gt;d_lock); 170 272 spin_unlock(\u0026amp;inode-\u0026gt;i_lock); 171 273 if (!inode-\u0026gt;i_nlink) 172 274 fsnotify_inoderemove(inode); 173 275 if (dentry-\u0026gt;d_op \u0026amp;\u0026amp; dentry-\u0026gt;d_op-\u0026gt;d_iput) 174 * 276 dentry-\u0026gt;d_op-\u0026gt;d_iput(dentry, inode); 175 277 else 176 278 iput(inode); 177 279 } else { 178 280 spin_unlock(\u0026amp;dentry-\u0026gt;d_lock); 179 281 } 180 282 } 9. eval - evaluate 9.1. SYNOPSIS 1eval [-b][-l] (expression) | value 9.2. DESCRIPTION 1 This command evaluates an expression or numeric value, and displays its 2 result in hexadecimal, decimal, octal and binary. If the resultant value 3 is an integral number of gigabytes, megabytes, or kilobytes, a short-hand 4 translation of the number will also be shown next to the hexadecimal 5 value. If the most significant bit is set, the decimal display will show 6 both unsigned and signed (negative) values. Expressions must of the format 7 (x operator y), where \u0026#34;x\u0026#34; and \u0026#34;y\u0026#34; may be either numeric values or 8 symbols. The list of operators are: 9 10 + - \u0026amp; | ^ * % / \u0026lt;\u0026lt; \u0026gt;\u0026gt; 11 12 Enclosing the expression within parentheses is optional except when the 13 \u0026#34;|\u0026#34;, \u0026#34;\u0026lt;\u0026lt;\u0026#34; or \u0026#34;\u0026gt;\u0026gt;\u0026#34; operators are used. The single \u0026#34;value\u0026#34; argument may 14 be a number or symbol. Number arguments must be hexadecimal or decimal. 15 A leading \u0026#34;0x\u0026#34; identifies a number as hexadecimal, but is not required 16 when obvious. Numbers may be followed by the letters \u0026#34;k\u0026#34; or \u0026#34;K\u0026#34;, \u0026#34;m\u0026#34; 17 or \u0026#34;M\u0026#34;, and \u0026#34;g\u0026#34; or \u0026#34;G\u0026#34;, which multiplies the value by a factor of 1024, 18 1 megabyte or 1 gigabyte, respectively. Numeric arguments may be preceded 19 by the one\u0026#39;s complement operator ~. 20 21 -b Indicate which bit positions in the resultant value are set. 22 -l Numeric arguments are presumed to be 64-bit values, and the result 23 will be expressed as a 64-bit value. (ignored on 64-bit processors) 24 However, if either operand or the resultant value are 64-bit values, 25 then the result will be also be expressed as a 64-bit value. 26 27 The -b and -l options must precede the expression or value arguments. 9.3. EXAMPLES 1 crash\u0026gt; eval 128m 2 hexadecimal: 8000000 (128MB) 3 decimal: 134217728 4 octal: 1000000000 5 binary: 00001000000000000000000000000000 6 7 crash\u0026gt; eval 128 * 1m 8 hexadecimal: 8000000 (128MB) 9 decimal: 134217728 10 octal: 1000000000 11 binary: 00001000000000000000000000000000 12 13 crash\u0026gt; eval (1 \u0026lt;\u0026lt; 27) 14 hexadecimal: 8000000 (128MB) 15 decimal: 134217728 16 octal: 1000000000 17 binary: 00001000000000000000000000000000 18 19 crash\u0026gt; eval (1 \u0026lt;\u0026lt; 32) 20 hexadecimal: 100000000 (4GB) 21 decimal: 4294967296 22 octal: 40000000000 23 binary: 0000000000000000000000000000000100000000000000000000000000000000 24 25 crash\u0026gt; eval -b 41dc065 26 hexadecimal: 41dc065 27 decimal: 69058661 28 octal: 407340145 29 binary: 00000100000111011100000001100101 30 bits set: 26 20 19 18 16 15 14 6 5 2 0 31 32 crash\u0026gt; eval -lb 64g 33 hexadecimal: 1000000000 (64GB) 34 decimal: 68719476736 35 octal: 1000000000000 36 binary: 0000000000000000000000000001000000000000000000000000000000000000 37 bits set: 36 10. exit - exit this session 10.1. SYNOPSIS 1exit 10.2. DESCRIPTION 1 Bail out of the current crash session. 10.3. NOTE 1 This command is equivalent to the \u0026#34;q\u0026#34; command. 11. extend - extend the crash command set 11.1. SYNOPSIS 1extend [shared-object ...] | [-u [shared-object ...]] 11.2. DESCRIPTION 1 This command dynamically loads or unloads crash extension shared object 2 libraries: 3 4 shared-object load the specified shared object file; more than one 5 one object file may be entered. 6 -u shared-object unload the specified shared object file; if no file 7 arguments are specified, unload all objects. 8 9 If the shared-object filename is not expressed with a fully-qualified 10 pathname, the following directories will be searched in the order shown, 11 and the first instance of the file that is found will be selected: 12 13 1. the current working directory 14 2. the directory specified in the CRASH_EXTENSIONS environment variable 15 3. /usr/lib64/crash/extensions (64-bit architectures) 16 4. /usr/lib/crash/extensions 17 18 If no arguments are entered, the current set of shared object files and 19 a list of their commands will be displayed. The registered commands 20 contained in each shared object file will appear automatically in the 21 \u0026#34;help\u0026#34; command screen. 22 23 An example of a shared object prototype file, and how to compile it 24 into a shared object, is appended below. 11.3. EXAMPLES 1 Load two shared object files: 2 3 crash\u0026gt; extend extlib1.so extlib2.so 4 ./extlib1.so: shared object loaded 5 ./extlib2.so: shared object loaded 6 7 Display the current set of shared object files and their commands: 8 9 crash\u0026gt; extend 10 SHARED OBJECT COMMANDS 11 ./extlib1.so echo util bin 12 ./extlib2.so smp show 13 14 Unload one of the shared object files: 15 16 crash\u0026gt; extend -u extlib1.so 17 ./extlib1.so: shared object unloaded 18 19 Unload all currently-loaded object files: 20 21 crash\u0026gt; extend -u 22 ./extlib2.so: shared object unloaded 23 24CREATING A SHARED OBJECT 25 The extend command loads shared object files using dlopen(3), which in 26 turn calls the shared object\u0026#39;s constructor function. The shared object\u0026#39;s 27 constructor function should register its command set by calling 28 register_extension(), passing it a pointer to an array of one or more 29 structures of the following type: 30 31 struct command_table_entry { 32 char *name; 33 cmd_func_t func; 34 char **help_data, 35 ulong flags; 36 }; 37 38 Each command_table_entry structure contains the ASCII name of a command, 39 the command\u0026#39;s function address, a pointer to an array of help data strings, 40 and a flags field. The help_data field is optional; if it is non-NULL, it 41 should point to an array of character strings used by the \u0026#34;help\u0026#34; 42 command, and during command failures. The flags field currently has two 43 available bit settings, REFRESH_TASK_TABLE, which should be set if it is 44 preferable to reload the current set of running processes just prior to 45 executing the command (on a live system) and MINIMAL, which should be 46 set if the command should be available in minimal mode. Terminate the array 47 of command_table_entry structures with an entry with a NULL command name. 48 49 Below is an example shared object file consisting of just one command, 50 called \u0026#34;echo\u0026#34;, which simply echoes back all arguments passed to it. 51 Note the comments contained within it for further details. Cut and paste 52 the following output into a file, and call it, for example, \u0026#34;echo.c\u0026#34;. 53 Then compiled in either of two manners. Either manually like so: 54 55 gcc -shared -rdynamic -o echo.so echo.c -fPIC -D\u0026lt;machine-type\u0026gt; $(TARGET_CFLAGS) 56 57 where \u0026lt;machine-type\u0026gt; must be one of the MACHINE_TYPE #define\u0026#39;s in defs.h, 58 and where $(TARGET_CFLAGS) is the same as it is declared in the top-level 59 Makefile after a build is completed. Or alternatively, the \u0026#34;echo.c\u0026#34; file 60 can be copied into the \u0026#34;extensions\u0026#34; subdirectory, and compiled automatically 61 like so: 62 63 make extensions 64 65 The echo.so file may be dynamically linked into crash during runtime, or 66 during initialization by putting \u0026#34;extend echo.so\u0026#34; into a .crashrc file 67 located in the current directory, or in the user\u0026#39;s $HOME directory. 68 69---------------------------------- cut here ---------------------------------- 70 71#include \u0026#34;defs.h\u0026#34; /* From the crash source top-level directory */ 72 73void echo_init(void); /* constructor function */ 74void echo_fini(void); /* destructor function (optional) */ 75 76void cmd_echo(void); /* Declare the commands and their help data. */ 77char *help_echo[]; 78 79static struct command_table_entry command_table[] = { 80 { \u0026#34;echo\u0026#34;, cmd_echo, help_echo, 0}, /* One or more commands, */ 81 { NULL }, /* terminated by NULL, */ 82}; 83 84 85void __attribute__((constructor)) 86echo_init(void) /* Register the command set. */ 87{ 88 register_extension(command_table); 89} 90 91/* 92 * This function is called if the shared object is unloaded. 93 * If desired, perform any cleanups here. 94 */ 95void __attribute__((destructor)) 96echo_fini(void) { } 97 98 99/* 100 * Arguments are passed to the command functions in the global args[argcnt] 101 * array. See getopt(3) for info on dash arguments. Check out defs.h and 102 * other crash commands for usage of the myriad of utility routines available 103 * to accomplish what your task. 104 */ 105void 106cmd_echo(void) 107{ 108 int c; 109 110 while ((c = getopt(argcnt, args, \u0026#34;\u0026#34;)) != EOF) { 111 switch(c) 112 { 113 default: 114 argerrs++; 115 break; 116 } 117 } 118 119 if (argerrs) 120 cmd_usage(pc-\u0026gt;curcmd, SYNOPSIS); 121 122 while (args[optind]) 123 fprintf(fp, \u0026#34;%s \u0026#34;, args[optind++]); 124 125 fprintf(fp, \u0026#34;\\n\u0026#34;); 126} 127 128/* 129 * The optional help data is simply an array of strings in a defined format. 130 * For example, the \u0026#34;help echo\u0026#34; command will use the help_echo[] string 131 * array below to create a help page that looks like this: 132 * 133 * NAME 134 * echo - echoes back its arguments 135 * 136 * SYNOPSIS 137 * echo arg ... 138 * 139 * DESCRIPTION 140 * This command simply echoes back its arguments. 141 * 142 * EXAMPLE 143 * Echo back all command arguments: 144 * 145 * crash\u0026gt; echo hello, world 146 * hello, world 147 * 148 */ 149 150char *help_echo[] = { 151 \u0026#34;echo\u0026#34;, /* command name */ 152 \u0026#34;echoes back its arguments\u0026#34;, /* short description */ 153 \u0026#34;arg ...\u0026#34;, /* argument synopsis, or \u0026#34; \u0026#34; if none */ 154 155 \u0026#34; This command simply echoes back its arguments.\u0026#34;, 156 \u0026#34;\\nEXAMPLE\u0026#34;, 157 \u0026#34; Echo back all command arguments:\\n\u0026#34;, 158 \u0026#34; crash\u0026gt; echo hello, world\u0026#34;, 159 \u0026#34; hello, world\u0026#34;, 160 NULL 161}; 12. files - open files 12.1. SYNOPSIS 1files [-d dentry] | [-p inode] | [-c] [-R reference] [pid | taskp] ... 12.2. DESCRIPTION 1 This command displays information about open files of a context. 2 It prints the context\u0026#39;s current root directory and current working 3 directory, and then for each open file descriptor it prints a pointer 4 to its file struct, a pointer to its dentry struct, a pointer to the 5 inode, the file type, and the pathname. If no arguments are entered, 6 the current context is used. The -R option, typically invoked from 7 \u0026#34;foreach files\u0026#34;, searches for references to a supplied number, address, 8 or filename argument, and prints only the essential information leading 9 up to and including the reference. The -d option is not context 10 specific, and only shows the data requested. 11 12 -d dentry given a hexadecimal dentry address, display its inode, 13 super block, file type, and full pathname. 14 -p inode given a hexadecimal inode address, dump all of its pages 15 that are in the page cache. 16 -c for each open file descriptor, prints a pointer to its 17 inode, a pointer to the inode\u0026#39;s i_mapping address_space 18 structure, the number of pages of the inode that are in 19 the page cache, the file type, and the pathname. 20 -R reference search for references to this file descriptor number, 21 filename, dentry, inode, address_space, or file structure 22 address. 23 pid a process PID. 24 taskp a hexadecimal task_struct pointer. 12.3. EXAMPLES 1 Display the open files of the current context: 2 3 crash\u0026gt; files 4 PID: 720 TASK: c67f2000 CPU: 1 COMMAND: \u0026#34;innd\u0026#34; 5 ROOT: / CWD: /var/spool/news/articles 6 FD FILE DENTRY INODE TYPE PATH 7 0 c6b9c740 c7cc45a0 c7c939e0 CHR /dev/null 8 1 c6b9c800 c537bb20 c54d0000 REG /var/log/news/news 9 2 c6df9600 c537b420 c5c36360 REG /var/log/news/errlog 10 3 c74182c0 c6ede260 c6da3d40 PIPE 11 4 c6df9720 c696c620 c69398c0 SOCK 12 5 c6b9cc20 c68e7000 c6938d80 SOCK 13 6 c6b9c920 c7cc45a0 c7c939e0 CHR /dev/null 14 7 c6b9c680 c58fa5c0 c58a1200 REG /var/lib/news/history 15 8 c6df9f00 c6ede760 c6da3200 PIPE 16 9 c6b9c6e0 c58fa140 c5929560 REG /var/lib/news/history.dir 17 10 c7fa9320 c7fab160 c7fafd40 CHR /dev/console 18 11 c6b9c7a0 c58fa5c0 c58a1200 REG /var/lib/news/history 19 12 c377ec60 c58fa5c0 c58a1200 REG /var/lib/news/history 20 13 c4528aa0 c58fa6c0 c52fbb00 REG /var/lib/news/history.pag 21 14 c6df9420 c68e7700 c6938360 SOCK 22 15 c6df9360 c68e7780 c6938120 SOCK 23 16 c6b9c0e0 c68e7800 c6772000 SOCK 24 17 c6b9c200 c6b5f9c0 c6b5cea0 REG /var/lib/news/active 25 21 c6b9c080 c6ede760 c6da3200 PIPE 26 27 Display the files opened by the \u0026#34;crond\u0026#34; daemon, which is PID 462: 28 29 crash\u0026gt; files 462 30 PID: 462 TASK: f7220000 CPU: 2 COMMAND: \u0026#34;crond\u0026#34; 31 ROOT: / CWD: /var/spool 32 FD FILE DENTRY INODE TYPE PATH 33 0 f7534ae0 f7538de0 f7518dc0 CHR /dev/console 34 1 f7368f80 f72c7a40 f72f27e0 FIFO pipe:/[1456] 35 2 f74f3c80 f72c79c0 f72f2600 FIFO pipe:/[1457] 36 3 f7368b60 f72a5be0 f74300c0 REG /var/run/crond.pid 37 4 f7534360 f73408c0 f72c2840 REG /var/log/cron 38 7 f7368ce0 f72c7940 f72f2420 FIFO pipe:/[1458] 39 8 f7295de0 f72c7940 f72f2420 FIFO pipe:/[1458] 40 21 f74f36e0 f747cdc0 f747e840 CHR /dev/null 41 42 The -R option is typically invoked from \u0026#34;foreach files\u0026#34;. This example 43 shows all tasks that have \u0026#34;/dev/pts/4\u0026#34; open: 44 45 crash\u0026gt; foreach files -R pts/4 46 PID: 18633 TASK: c310a000 CPU: 0 COMMAND: \u0026#34;crash\u0026#34; 47 ROOT: / CWD: /home/CVS_pool/crash 48 FD FILE DENTRY INODE TYPE PATH 49 0 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 50 1 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 51 2 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 52 53 PID: 18664 TASK: c2392000 CPU: 1 COMMAND: \u0026#34;less\u0026#34; 54 ROOT: / CWD: /home/CVS_pool/crash 55 FD FILE DENTRY INODE TYPE PATH 56 1 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 57 2 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 58 59 PID: 23162 TASK: c5088000 CPU: 1 COMMAND: \u0026#34;bash\u0026#34; 60 ROOT: / CWD: /home/CVS_pool/crash 61 FD FILE DENTRY INODE TYPE PATH 62 0 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 63 1 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 64 2 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 65 255 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 66 67 PID: 23159 TASK: c10fc000 CPU: 1 COMMAND: \u0026#34;xterm\u0026#34; 68 ROOT: / CWD: /homes/anderson/ 69 FD FILE DENTRY INODE TYPE PATH 70 5 c1560da0 c2cb96d0 c2cad430 CHR /dev/pts/4 71 72 Display information about the dentry at address f745fd60: 73 74 crash\u0026gt; files -d f745fd60 75 DENTRY INODE SUPERBLK TYPE PATH 76 f745fd60 f7284640 f73a3e00 REG /var/spool/lpd/lpd.lock 77 78 For each open file, display the number of pages that are in the page cache: 79 80 crash\u0026gt; files -c 1954 81 PID: 1954 TASK: f7a28000 CPU: 1 COMMAND: \u0026#34;syslogd\u0026#34; 82 ROOT: / CWD: / 83 FD INODE I_MAPPING NRPAGES TYPE PATH 84 0 cb3ae868 cb3ae910 0 SOCK socket:/[4690] 85 2 f2721c5c f2721d04 461 REG /var/log/messages 86 3 cbda4884 cbda492c 47 REG /var/log/secure 87 4 e48092c0 e4809368 58 REG /var/log/maillog 88 5 f65192c0 f6519368 48 REG /var/log/cron 89 6 e4809e48 e4809ef0 0 REG /var/log/spooler 90 7 d9c43884 d9c4392c 0 REG /var/log/boot.log 91 92 For the inode at address f59b90fc, display all of its pages that are in 93 the page cache: 94 95 crash\u0026gt; files -p f59b90fc 96 INODE NRPAGES 97 f59b90fc 6 98 99 PAGE PHYSICAL MAPPING INDEX CNT FLAGS 100 ca3353e0 39a9f000 f59b91ac 0 2 82c referenced,uptodate,lru,private 101 ca22cb20 31659000 f59b91ac 1 2 82c referenced,uptodate,lru,private 102 ca220160 3100b000 f59b91ac 2 2 82c referenced,uptodate,lru,private 103 ca1ddde0 2eeef000 f59b91ac 3 2 82c referenced,uptodate,lru,private 104 ca36b300 3b598000 f59b91ac 4 2 82c referenced,uptodate,lru,private 105 ca202680 30134000 f59b91ac 5 2 82c referenced,uptodate,lru,private 13. foreach - display command data for multiple tasks in the system 13.1. SYNOPSIS 1foreach [[pid | taskp | name | state | [kernel | user | gleader]] ...] 2 command [flag] [argument] 13.2. DESCRIPTION 1 This command allows for an examination of various kernel data associated 2 with any, or all, tasks in the system, without having to set the context 3 to each targeted task. 4 5 pid perform the command(s) on this PID. 6 taskp perform the command(s) on task referenced by this hexadecimal 7 task_struct pointer. 8 name perform the command(s) on all tasks with this name. If the 9 task name can be confused with a foreach command name, then 10 precede the name string with a \u0026#34;\\\u0026#34;. If the name string is 11 enclosed within \u0026#34;\u0026#39;\u0026#34; characters, then the encompassed string 12 must be a POSIX extended regular expression that will be used 13 to match task names. 14 user perform the command(s) on all user (non-kernel) threads. 15 gleader perform the command(s) on all user (non-kernel) thread group leaders. 16 kernel perform the command(s) on all kernel threads. 17 active perform the command(s) on the active thread on each CPU. 18 state perform the command(s) on all tasks in the specified state, which 19 may be one of: RU, IN, UN, ST, ZO, TR, SW, DE, WA, PA, ID or NE. 20 21 If none of the task-identifying arguments above are entered, the command 22 will be performed on all tasks. 23 24 command select one or more of the following commands to be run on the tasks 25 selected, or on all tasks: 26 27 bt run the \u0026#34;bt\u0026#34; command (optional flags: -r -t -l -e -R -f -F 28 -o -s -x -d) 29 vm run the \u0026#34;vm\u0026#34; command (optional flags: -p -v -m -R -d -x) 30 task run the \u0026#34;task\u0026#34; command (optional flags: -R -d -x) 31 files run the \u0026#34;files\u0026#34; command (optional flag: -c -R) 32 net run the \u0026#34;net\u0026#34; command (optional flags: -s -S -R -d -x) 33 set run the \u0026#34;set\u0026#34; command 34 ps run the \u0026#34;ps\u0026#34; command (optional flags: -G -s -p -c -t -l -a 35 -g -r -y) 36 sig run the \u0026#34;sig\u0026#34; command (optional flag: -g) 37 vtop run the \u0026#34;vtop\u0026#34; command (optional flags: -c -u -k) 38 39 flag Pass this optional flag to the command selected. 40 argument Pass this argument to the command selected. 41 42 A header containing the PID, task address, cpu and command name will be 43 pre-pended before the command output for each selected task. Consult the 44 help page of each of the command types above for details. 13.3. EXAMPLES 1 Display the stack traces for all tasks: 2 3 crash\u0026gt; foreach bt 4 PID: 4752 TASK: c7680000 CPU: 1 COMMAND: \u0026#34;xterm\u0026#34; 5 #0 [c7681edc] schedule at c01135f6 6 (void) 7 #1 [c7681f34] schedule_timeout at c01131ff 8 (24) 9 #2 [c7681f64] do_select at c0132838 10 (5, c7681fa4, c7681fa0) 11 #3 [c7681fbc] sys_select at c0132dad 12 (5, 8070300, 8070380, 0, 0) 13 #4 [bffffb0c] system_call at c0109944 14 EAX: 0000008e EBX: 00000005 ECX: 08070300 EDX: 08070380 15 DS: 002b ESI: 00000000 ES: 002b EDI: 00000000 16 SS: 002b ESP: bffffadc EBP: bffffb0c 17 CS: 0023 EIP: 402259ee ERR: 0000008e EFLAGS: 00000246 18 19 PID: 557 TASK: c5600000 CPU: 0 COMMAND: \u0026#34;nfsd\u0026#34; 20 #0 [c5601f38] schedule at c01135f6 21 (void) 22 #1 [c5601f90] schedule_timeout at c01131ff 23 (c5600000) 24 #2 [c5601fb8] svc_recv at c805363a 25 (c0096f40, c5602800, 7fffffff, 100, c65c9f1c) 26 #3 [c5601fec] (nfsd module) at c806e303 27 (c5602800, c5602800, c0096f40, 6c6e0002, 50) 28 #4 [c65c9f24] kernel_thread at c010834f 29 (0, 0, ext2_file_inode_operations) 30 31 PID: 824 TASK: c7c84000 CPU: 0 COMMAND: \u0026#34;mingetty\u0026#34; 32 ... 33 34 Display the task_struct structure for each \u0026#34;bash\u0026#34; command: 35 36 crash\u0026gt; foreach bash task 37 ... 38 39 Display the open files for all tasks: 40 41 crash\u0026gt; foreach files 42 ... 43 44 Display the state of tasks whose name contains a match to \u0026#34;event.*\u0026#34;: 45 46 crash\u0026gt; foreach \u0026#39;event.*\u0026#39; task -R state 47 PID: 99 TASK: ffff8804750d5500 CPU: 0 COMMAND: \u0026#34;events/0\u0026#34; 48 state = 1, 49 50 PID: 100 TASK: ffff8804750d4ac0 CPU: 1 COMMAND: \u0026#34;events/1\u0026#34; 51 state = 1, 52 53 PID: 101 TASK: ffff8804750d4080 CPU: 2 COMMAND: \u0026#34;events/2\u0026#34; 54 state = 1, 55 ... 56 57 Display the stack traces for all blocked (TASK_UNINTERRUPTIBLE) tasks: 58 59 crash\u0026gt; foreach UN bt 60 PID: 428 TASK: ffff880036b6c560 CPU: 1 COMMAND: \u0026#34;jbd2/dm-1-8\u0026#34; 61 #0 [ffff880035779a70] __schedule at ffffffff815df272 62 #1 [ffff880035779b08] schedule at ffffffff815dfacf 63 #2 [ffff880035779b18] io_schedule at ffffffff815dfb7f 64 #3 [ffff880035779b38] sleep_on_page at ffffffff81119a4e 65 #4 [ffff880035779b48] __wait_on_bit at ffffffff815e039f 66 #5 [ffff880035779b98] wait_on_page_bit at ffffffff81119bb8 67 #6 [ffff880035779be8] filemap_fdatawait_range at ffffffff81119ccc 68 #7 [ffff880035779cd8] filemap_fdatawait at ffffffff81119d8b 69 #8 [ffff880035779ce8] jbd2_journal_commit_transaction at ffffffff8123a99c 70 #9 [ffff880035779e58] kjournald2 at ffffffff8123ee7b 71 #10 [ffff880035779ee8] kthread at ffffffff8108fb9c 72 #11 [ffff880035779f48] kernel_thread_helper at ffffffff815ebaf4 73 ... 14. fuser - file users 14.1. SYNOPSIS 1fuser [pathname | inode] 14.2. DESCRIPTION 1 This command displays the tasks using specified files or sockets. 2 Tasks will be listed that reference the file as the current working 3 directory, root directory, an open file descriptor, or that mmap the 4 file. If the file is held open in the kernel by the lockd server on 5 behalf of a client discretionary file lock, the client hostname is 6 listed. 7 8 pathname the full pathname of the file. 9 inode the hexadecimal inode address for the file. 14.3. EXAMPLES 1 Display the tasks using file /usr/lib/libkfm.so.2.0.0 2 3 crash\u0026gt; fuser /usr/lib/libkfm.so.2.0.0 4 PID TASK COMM USAGE 5 779 c5e82000 \u0026#34;kwm\u0026#34; mmap 6 808 c5a8e000 \u0026#34;krootwm\u0026#34; mmap 7 806 c5b42000 \u0026#34;kfm\u0026#34; mmap 8 809 c5dde000 \u0026#34;kpanel\u0026#34; mmap 15. gdb - gdb command 15.1. SYNOPSIS 1gdb command ... 15.2. DESCRIPTION 1 This command passes its arguments directly to gdb for processing. 2 This is typically not necessary, but where ambiguities between crash and 3 gdb command names exist, this will force the command to be executed by gdb. 4 5 Alternatively, if \u0026#34;set gdb on\u0026#34; is entered, the session will be run in a 6 mode where all commands are passed directly to gdb. When running in that 7 mode, native crash commands may be executed by preceding them with the 8 \u0026#34;crash\u0026#34; directive. To restore native crash mode, enter \u0026#34;set gdb off\u0026#34;. 15.3. EXAMPLES 1 crash\u0026gt; gdb help 2 List of classes of commands: 3 4 aliases -- Aliases of other commands 5 breakpoints -- Making program stop at certain points 6 data -- Examining data 7 files -- Specifying and examining files 8 internals -- Maintenance commands 9 obscure -- Obscure features 10 running -- Running the program 11 stack -- Examining the stack 12 status -- Status inquiries 13 support -- Support facilities 14 tracepoints -- Tracing of program execution without stopping the program 15 user-defined -- User-defined commands 16 17 Type \u0026#34;help\u0026#34; followed by a class name for a list of commands in that class. 18 Type \u0026#34;help\u0026#34; followed by command name for full documentation. 19 Command name abbreviations are allowed if unambiguous. 16. help - get help 16.1. SYNOPSIS 1help [command | all] [-\u0026lt;option\u0026gt;] 16.2. DESCRIPTION 1 When entered with no argument, a list of all currently available crash 2 commands is listed. If a name of a crash command is entered, a man-like 3 page for the command is displayed. If \u0026#34;all\u0026#34; is entered, help pages 4 for all commands will be displayed. If neither of the above is entered, 5 the argument string will be passed on to the gdb help command. 6 7 A number of internal debug, statistical, and other dumpfile related 8 data is available with the following options: 9 10 -a - alias data 11 -b - shared buffer data 12 -B - build data 13 -c - numargs cache 14 -d - device table 15 -D - dumpfile contents/statistics 16 -e - extension table data 17 -f - filesys table 18 -g - gdb data 19 -h - hash_table data 20 -H - hash_table data (verbose) 21 -k - kernel_table 22 -K - kernel_table (verbose) 23 -L - LKCD page cache environment 24 -M \u0026lt;num\u0026gt; machine specific 25 -m - machdep_table 26 -N - net_table 27 -n - dumpfile contents/statistics 28 -o - offset_table and size_table 29 -p - program_context 30 -r - dump registers from dumpfile header 31 -s - symbol table data 32 -t - task_table 33 -T - task_table plus context_array 34 -v - vm_table 35 -V - vm_table (verbose) 36 -x - text cache 37 -z - help options 17. ipcs - System V IPC facilities 17.1. SYNOPSIS 1ipcs [-smMq] [-n pid|task] [id | addr] 17.2. DESCRIPTION 1 This command provides information on the System V IPC facilities. With no 2 arguments, the command will display kernel usage of all three factilities. 3 4 -s show semaphore arrays. 5 -m show shared memory segments. 6 -M show shared memory segments with additional details. 7 -q show message queues. 8 id show the data associated with this resource ID. 9 addr show the data associated with this virtual address of a 10 shmid_kernel, sem_array or msq_queue. 11 12 For kernels supporting namespaces, the -n option may be used to 13 display the IPC facilities with respect to the namespace of a 14 specified task: 15 16 -n pid a process PID. 17 -n task a hexadecimal task_struct pointer. 17.3. EXAMPLES 1 Display all IPC facilities: 2 3 crash\u0026gt; ipcs 4 SHMID_KERNEL KEY SHMID UID PERMS BYTES NATTCH STATUS 5 ffff880473a28310 00000000 0 0 666 90000 1 6 ffff880473a28490 00000001 32769 0 666 90000 1 7 ffff880473a28250 00000002 65538 0 666 90000 1 8 9 SEM_ARRAY KEY SEMID UID PERMS NSEMS 10 ffff88047200f9d0 00000000 0 0 600 1 11 ffff88046f826910 00000000 32769 0 600 1 12 13 MSG_QUEUE KEY MSQID UID PERMS USED-BYTES MESSAGES 14 ffff8100036bb8d0 000079d7 0 3369 666 16640 104 15 ffff8100036bb3d0 000079d8 32769 3369 666 12960 81 16 ffff810026d751d0 000079d9 65538 3369 666 10880 68 17 18 Display shared memory usage with detailed information: 19 20 crash\u0026gt; ipcs -M 21 SHMID_KERNEL KEY SHMID UID PERMS BYTES NATTCH STATUS 22 ffff880473a28310 00000000 0 0 666 90000 1 23 PAGES ALLOCATED/RESIDENT/SWAPPED: 22/1/0 24 INODE: ffff88047239cd98 25 26 SHMID_KERNEL KEY SHMID UID PERMS BYTES NATTCH STATUS 27 ffff880473a28490 00000001 32769 0 666 90000 1 28 PAGES ALLOCATED/RESIDENT/SWAPPED: 22/1/0 29 INODE: ffff88047239c118 30 31 SHMID_KERNEL KEY SHMID UID PERMS BYTES NATTCH STATUS 32 ffff880473a28250 00000002 65538 0 666 90000 1 33 PAGES ALLOCATED/RESIDENT/SWAPPED: 22/1/0 34 INODE: ffff880470503758 35 36 Display the shared memory data associated with shmid_kernel ffff880473a28250: 37 38 crash\u0026gt; ipcs -M ffff880473a28250 39 SHMID_KERNEL KEY SHMID UID PERMS BYTES NATTCH STATUS 40 ffff880473a28250 00000002 65538 0 666 90000 1 41 PAGES ALLOCATED/RESIDENT/SWAPPED: 22/1/0 42 INODE: ffff880470503758 18. irq - IRQ data 18.1. SYNOPSIS 1irq [[[index ...] | -u ] | -d | -b | -a | -s [-c cpu]] 18.2. DESCRIPTION 1 This command collaborates the data in an irq_desc_t, along with its 2 associated hw_interrupt_type and irqaction structure data, into a 3 consolidated per-IRQ display. For kernel versions 2.6.37 and later 4 the display consists of the irq_desc/irq_data address, its irqaction 5 address(es), and the irqaction name strings. Alternatively, the 6 intel interrupt descriptor table, bottom half data, cpu affinity for 7 in-use irqs, or kernel irq stats may be displayed. If no index value 8 argument(s) nor any options are entered, the IRQ data for all IRQs will 9 be displayed. 10 11 index a valid IRQ index. 12 -u dump data for in-use IRQs only. 13 -d dump the intel interrupt descriptor table. 14 -b dump bottom half data. 15 -a dump cpu affinity for in-use IRQs. 16 -s dump the kernel irq stats; if no cpu specified with -c, the 17 irq stats of all cpus will be displayed. 18 -c cpu only usable with the -s option, dump the irq stats of the 19 specified cpu[s]; cpu can be specified as \u0026#34;1,3,5\u0026#34;, \u0026#34;1-3\u0026#34;, 20 \u0026#34;1,3,5-7,10\u0026#34;, \u0026#34;all\u0026#34;, or \u0026#34;a\u0026#34; (shortcut for \u0026#34;all\u0026#34;). 18.3. EXAMPLES 1 Display the relevant data for IRQ 18 from a pre-2.6.37 kernel: 2 3 crash\u0026gt; irq 18 4 IRQ: 18 5 STATUS: 0 6 HANDLER: c02301e0 \u0026lt;ioapic_level_irq_type\u0026gt; 7 typename: c01f9e0c \u0026#34;IO-APIC-level\u0026#34; 8 startup: c0110234 \u0026lt;unmask_IO_APIC_irq\u0026gt; 9 shutdown: c01101cc \u0026lt;mask_IO_APIC_irq\u0026gt; 10 handle: c0110518 \u0026lt;do_level_ioapic_IRQ\u0026gt; 11 enable: c0110234 \u0026lt;unmask_IO_APIC_irq\u0026gt; 12 disable: c01101cc \u0026lt;mask_IO_APIC_irq\u0026gt; 13 ACTION: c009c6b0 14 handler: c01ce818 \u0026lt;do_aic7xxx_isr\u0026gt; 15 flags: 4000000 (SA_SHIRQ) 16 mask: 0 17 name: c0217780 \u0026#34;aic7xxx\u0026#34; 18 dev_id: c0090078 19 next: c009c770 20 ACTION: c009c770 21 handler: c01ce818 \u0026lt;do_aic7xxx_isr\u0026gt; 22 flags: 4000000 (SA_SHIRQ) 23 mask: 0 24 name: c0217780 \u0026#34;aic7xxx\u0026#34; 25 dev_id: c0091078 26 next: 0 27 DEPTH: 0 28 29 Display the relevant data for IRQ 21 from a 2.6.37 kernel: 30 31 crash\u0026gt; irq 21 32 IRQ IRQ_DESC/_DATA IRQACTION NAME 33 21 ffff88003787f780 ffff8800379a8b40 \u0026#34;ehci_hcd:usb2\u0026#34; 34 ffff8800379cbac0 \u0026#34;uhci_hcd:usb5\u0026#34; 35 ffff8800379cb140 \u0026#34;uhci_hcd:usb7\u0026#34; 36 37 Display the intel interrupt descriptor table entries: 38 39 crash\u0026gt; irq -d 40 [0] divide_error 41 [1] debug 42 [2] nmi 43 [3] int3 44 [4] overflow 45 [5] bounds 46 [6] invalid_op 47 [7] device_not_available 48 [8] double_fault 49 [9] coprocessor_segment_overrun 50 [10] invalid_TSS 51 [11] segment_not_present 52 [12] stack_segment 53 [13] general_protection 54 [14] page_fault 55 [15] spurious_interrupt_bug 56 [16] coprocessor_error 57 [17] alignment_check 58 [18] ignore_int 59 [19] ignore_int 60 [20] ignore_int 61 [21] ignore_int 62 ... 63 64 [250] IRQ0xda_interrupt 65 [251] IRQ0xdb_interrupt 66 [252] IRQ0xdc_interrupt 67 [253] IRQ0xdd_interrupt 68 [254] IRQ0xde_interrupt 69 [255] spurious_interrupt 70 71 Display the bottom half data: 72 73 crash\u0026gt; irq -b 74 SOFTIRQ_VEC ACTION 75 [0] ffffffff81068f60 \u0026lt;tasklet_hi_action\u0026gt; 76 [1] ffffffff81071b80 \u0026lt;run_timer_softirq\u0026gt; 77 [2] ffffffff813e6f30 \u0026lt;net_tx_action\u0026gt; 78 [3] ffffffff813ee370 \u0026lt;net_rx_action\u0026gt; 79 [4] ffffffff81211a60 \u0026lt;blk_done_softirq\u0026gt; 80 [5] ffffffff812122f0 \u0026lt;blk_iopoll_softirq\u0026gt; 81 [6] ffffffff81069090 \u0026lt;tasklet_action\u0026gt; 82 [7] ffffffff81058830 \u0026lt;run_rebalance_domains\u0026gt; 83 [8] ffffffff81087f00 \u0026lt;run_hrtimer_softirq\u0026gt; 84 [9] ffffffff810ca7a0 \u0026lt;rcu_process_callbacks\u0026gt; 85 86 Display the cpu affinity for in-use IRQs: 87 88 crash\u0026gt; irq -a 89 IRQ NAME AFFINITY 90 0 timer 0-23 91 1 i8042 0-23 92 8 rtc0 0-23 93 9 acpi 0-23 94 16 ehci_hcd:usb2,uhci_hcd:usb3,uhci_hcd:usb6 0,6,18 95 17 uhci_hcd:usb4,uhci_hcd:usb7 0-23 96 18 ehci_hcd:usb1,uhci_hcd:usb5,uhci_hcd:usb8,ioc0 0,11,23 97 24 dmar0 0 98 35 pciehp 0-23 99 36 pciehp 0-23 100 37 pciehp 0-23 101 38 pciehp 0-23 102 39 megasas 0-5,12-17 103 40 lpfc:sp 0-5,12-17 104 41 lpfc:fp 0,6-11,18-23 105 42 lpfc:sp 0,6-11,18-23 106 43 lpfc:fp 0,6-11,18-23 107 ... 108 109 80 ioat-msix 0-23 110 81 ioat-msix 0-23 111 82 ioat-msix 0-23 112 83 ioat-msix 0-23 113 84 ioat-msix 0-23 114 85 ioat-msix 0-23 115 86 ioat-msix 0-23 116 87 ioat-msix 0-23 117 88 eth4 0,17 118 119 Display the kernel irq stats: 120 121 crash\u0026gt;irq -c 0,2 -s 122 CPU0 CPU2 123 0: 2068161471 0 IR-IO-APIC-edge timer 124 1: 9 0 IR-IO-APIC-edge i8042 125 8: 1 0 IR-IO-APIC-edge rtc0 126 9: 0 0 IR-IO-APIC-fasteoi acpi 127 16: 36 0 IR-IO-APIC-fasteoi ehci_hcd:usb2 128 ... 129 130 85: 3 0 IR-PCI-MSI-edge ioat-msix 131 86: 3 0 IR-PCI-MSI-edge ioat-msix 132 87: 3 0 IR-PCI-MSI-edge ioat-msix 133 88: 24 295 IR-PCI-MSI-edge eth4 19. kmem - kernel memory 19.1. SYNOPSIS 1kmem [-f|-F|-c|-C|-i|-v|-V|-n|-z|-o|-h] [-p | -m member[,member]] 2 [[-s|-S|-r] [slab] [-I slab[,slab]]] [-g [flags]] [[-P] address]] 19.2. DESCRIPTION 1 This command displays information about the use of kernel memory. 2 3 -f displays the contents of the system free memory headers. 4 also verifies that the page count equals nr_free_pages. 5 -F same as -f, but also dumps all pages linked to that header. 6 -c walks through the page_hash_table and verifies page_cache_size. 7 -C same as -c, but also dumps all pages in the page_hash_table. 8 -i displays general memory usage information 9 -v displays the mapped virtual memory regions allocated by vmalloc(). 10 -V displays the kernel vm_stat table if it exists, or in more recent 11 kernels, the vm_zone_stat, vm_node_stat and vm_numa_stat tables, 12 the cumulative page_states counter values if they exist, and/or 13 the cumulative, vm_event_states counter values if they exist. 14 -n display memory node, memory section, and memory block data 15 and state; the state of each memory section state is encoded 16 as \u0026#34;P\u0026#34;, \u0026#34;M\u0026#34;, \u0026#34;O\u0026#34; and/or \u0026#34;E\u0026#34;, meaning SECTION_MARKED_PRESENT, 17 SECTION_HAS_MEM_MAP, SECTION_IS_ONLINE and SECTION_IS_EARLY. 18 -z displays per-zone memory statistics. 19 -o displays each cpu\u0026#39;s offset value that is added to per-cpu symbol 20 values to translate them into kernel virtual addresses. 21 -h display the address of hugepage hstate array entries, along with 22 their hugepage size, total and free counts, and name. 23 -p displays basic information about each page structure in the system 24 mem_map[] array, made up of the page struct address, its associated 25 physical address, the page.mapping, page.index, page._count and 26 page.flags fields. 27 -m member similar to -p, but displays page structure contents specified by 28 a comma-separated list of one or more struct page members. The 29 \u0026#34;flags\u0026#34; member will always be expressed in hexadecimal format, and 30 the \u0026#34;_count\u0026#34; and \u0026#34;_mapcount\u0026#34; members will always be expressed 31 in decimal format. Otherwise, all other members will be displayed 32 in hexadecimal format unless the output radix is 10 and the member 33 is a signed/unsigned integer. Members that are data structures may 34 be specified either by the data structure\u0026#39;s member name, or expanded 35 to specify a member of the data structure. For example, \u0026#34;-m lru\u0026#34; 36 refers to a list_head data structure, and both the list_head.next 37 and list_head.prev pointer values will be displayed, whereas if 38 \u0026#34;-m lru.next\u0026#34; is specified, just the list_head.next value will 39 be displayed. 40 -s displays basic kmalloc() slab data. 41 -S displays all kmalloc() slab data, including all slab objects, 42 and whether each object is in use or is free. If CONFIG_SLUB, 43 slab data for each per-cpu slab is displayed, along with the 44 address of each kmem_cache_node, its count of full and partial 45 slabs, and a list of all tracked slabs. 46 -r displays the accumulated basic kmalloc() slab data of each 47 root slab cache and its children. The kernel must contain the 48 \u0026#34;slab_root_caches\u0026#34; list_head. (currently only available if 49 CONFIG_SLUB) 50 slab when used with -s, -S or -r, limits the command to only the slab 51 cache of name \u0026#34;slab\u0026#34;. If the slab argument is \u0026#34;list\u0026#34;, then 52 all slab cache names and addresses are listed. 53 -I slab when used with -s, -S or -r, one or more slab cache names in a 54 comma-separated list may be specified as slab caches to ignore. 55 -g displays the enumerator value of all bits in the page structure\u0026#39;s 56 \u0026#34;flags\u0026#34; field. 57 flags when used with -g, translates all bits in this hexadecimal page 58 structure flags value into its enumerator values. 59 -P declares that the following address argument is a physical address. 60 address when used without any flag, the address can be a kernel virtual, 61 or physical address; a search is made through the symbol table, 62 the kmalloc() slab subsystem, the free list, the page_hash_table, 63 the vmalloc() region subsystem, the current set of task_structs 64 and kernel stacks, and the mem_map array. If found in any of 65 those areas, the information will be dumped in the same manner as 66 if the location-specific flags were used; if contained within a 67 curent task_struct or kernel stack, that task\u0026#39;s context will be 68 displayed. 69 address when used with -s or -S, searches the kmalloc() slab subsystem 70 for the slab containing of this virtual address, showing whether 71 it is in use or free. 72 address when used with -f, the address can be either a page pointer, 73 a physical address, or a kernel virtual address; the free_area 74 header containing the page (if any) is displayed. 75 address when used with -p, the address can be either a page pointer, a 76 physical address, or a kernel virtual address; its basic mem_map 77 page information is displayed. 78 address when used with -m, the address can be either a page pointer, a 79 physical address, or a kernel virtual address; the specified 80 members of the associated page struct are displayed. 81 address when used with -c, the address must be a page pointer address; 82 the page_hash_table entry containing the page is displayed. 83 address when used with -l, the address must be a page pointer address; 84 the page address is displayed if it is contained with the list. 85 address when used with -v, the address can be a mapped kernel virtual 86 address or physical address; the mapped region containing the 87 address is displayed. 88 89 All address arguments above must be expressed in hexadecimal format. 19.3. EXAMPLES 1 Display memory usage information: 2 3 crash\u0026gt; kmem -i 4 PAGES TOTAL PERCENTAGE 5 TOTAL MEM 1974231 7.5 GB ---- 6 FREE 208962 816.3 MB 10% of TOTAL MEM 7 USED 1765269 6.7 GB 89% of TOTAL MEM 8 SHARED 365066 1.4 GB 18% of TOTAL MEM 9 BUFFERS 111376 435.1 MB 5% of TOTAL MEM 10 CACHED 1276196 4.9 GB 64% of TOTAL MEM 11 SLAB 120410 470.4 MB 6% of TOTAL MEM 12 13 TOTAL HUGE 524288 2 GB ---- 14 HUGE FREE 524288 2 GB 100% of TOTAL HUGE 15 16 TOTAL SWAP 2498559 9.5 GB ---- 17 SWAP USED 81978 320.2 MB 3% of TOTAL SWAP 18 SWAP FREE 2416581 9.2 GB 96% of TOTAL SWAP 19 20 COMMIT LIMIT 3485674 13.3 GB ---- 21 COMMITTED 850651 3.2 GB 24% of TOTAL LIMIT 22 23 Display and verify free memory data: 24 25 crash\u0026gt; kmem -f 26 NODE 27 0 28 ZONE NAME SIZE FREE MEM_MAP START_PADDR START_MAPNR 29 0 DMA 4096 3372 c4000040 0 0 30 AREA SIZE FREE_AREA_STRUCT BLOCKS PAGES 31 0 4k c02eb004 2 2 32 1 8k c02eb010 3 6 33 2 16k c02eb01c 5 20 34 3 32k c02eb028 4 32 35 4 64k c02eb034 5 80 36 5 128k c02eb040 3 96 37 6 256k c02eb04c 3 192 38 7 512k c02eb058 1 128 39 8 1024k c02eb064 1 256 40 9 2048k c02eb070 5 2560 41 42 ZONE NAME SIZE FREE MEM_MAP START_PADDR START_MAPNR 43 1 Normal 225280 202269 c4044040 1000000 4096 44 AREA SIZE FREE_AREA_STRUCT BLOCKS PAGES 45 0 4k c02eb0b8 1 1 46 1 8k c02eb0c4 2 4 47 2 16k c02eb0d0 0 0 48 3 32k c02eb0dc 1 8 49 4 64k c02eb0e8 1 16 50 5 128k c02eb0f4 0 0 51 6 256k c02eb100 0 0 52 7 512k c02eb10c 0 0 53 8 1024k c02eb118 0 0 54 9 2048k c02eb124 395 202240 55 56 ZONE NAME SIZE FREE MEM_MAP START_PADDR START_MAPNR 57 2 HighMem 819200 748686 c4ee0040 38000000 229376 58 AREA SIZE FREE_AREA_STRUCT BLOCKS PAGES 59 0 4k c02eb16c 10 10 60 1 8k c02eb178 2 4 61 2 16k c02eb184 0 0 62 3 32k c02eb190 2 16 63 4 64k c02eb19c 1 16 64 5 128k c02eb1a8 1 32 65 6 256k c02eb1b4 1 64 66 7 512k c02eb1c0 0 0 67 8 1024k c02eb1cc 0 0 68 9 2048k c02eb1d8 1462 748544 69 70 nr_free_pages: 954327 (verified) 71 72 Dump all the base addresses of each free memory area from above: 73 74 crash\u0026gt; kmem -F 75 NODE 76 0 77 ZONE NAME SIZE FREE MEM_MAP START_PADDR START_MAPNR 78 0 DMA 4096 3372 c4000040 0 0 79 AREA SIZE FREE_AREA_STRUCT 80 0 4k c02eb004 81 c400ded8 82 c4042528 83 AREA SIZE FREE_AREA_STRUCT 84 1 8k c02eb010 85 c400de50 86 c400cee8 87 c40424a0 88 AREA SIZE FREE_AREA_STRUCT 89 2 16k c02eb01c 90 c400dd40 91 c400cf70 92 c40425b0 93 c400f7d0 94 c40028a0 95 AREA SIZE FREE_AREA_STRUCT 96 3 32k c02eb028 97 c4042280 98 c400f8e0 99 c4002680 100 c4000260 101 AREA SIZE FREE_AREA_STRUCT 102 4 64k c02eb034 103 c400d080 104 c4041e40 105 ... 106 107 Dump the mem_map[] array: 108 109 crash\u0026gt; kmem -p 110 PAGE PHYSICAL MAPPING INDEX CNT FLAGS 111 f5c51200 10000 0 0 1 80 slab 112 f5c51220 11000 0 0 1 80 slab 113 f5c51240 12000 0 0 1 80 slab 114 f5c51260 13000 0 0 1 80 slab 115 f5c51280 14000 0 0 1 80 slab 116 f5c512a0 15000 0 0 1 80 slab 117 f5c512c0 16000 0 0 1 80 slab 118 f5c512e0 17000 0 0 1 80 slab 119 f5c51300 18000 0 0 1 80 slab 120 f5c51320 19000 0 0 1 80 slab 121 f5c51340 1a000 0 0 1 80 slab 122 f5c51360 1b000 0 0 1 80 slab 123 f5c51380 1c000 e6c6a754 13b67 2 868 uptodate,lru,active,private 124 f5c513a0 1d000 0 0 1 80 slab 125 f5c513c0 1e000 0 0 1 80 slab 126 f5c513e0 1f000 0 0 1 80 slab 127 f5c51400 20000 e6c6a754 13bbb 2 868 uptodate,lru,active,private 128 f5c51420 21000 0 0 1 80 slab 129 f5c51440 22000 0 0 1 80 slab 130 ... 131 132 Display the \u0026#34;page.lru\u0026#34; list_head structure member in each page: 133 134 crash\u0026gt; kmem -m lru 135 PAGE lru 136 ffffea0000000000 0000000000000000,0000000000000000 137 ffffea0000000040 ffffea0000000060,ffffea0000000060 138 ffffea0000000080 ffffea00000000a0,ffffea00000000a0 139 ffffea00000000c0 ffffea00000000e0,ffffea00000000e0 140 ffffea0000000100 ffffea0000000120,ffffea0000000120 141 ffffea0000000140 ffffea0000000160,ffffea0000000160 142 ffffea0000000180 ffffea00000001a0,ffffea00000001a0 143 ffffea00000001c0 ffffea00000001e0,ffffea00000001e0 144 ffffea0000000200 ffffea0000000220,ffffea0000000220 145 ffffea0000000240 ffffea0000000260,ffffea0000000260 146 ffffea0000000280 ffffea00000002a0,ffffea00000002a0 147 ffffea00000002c0 ffffea00000002e0,ffffea00000002e0 148 ffffea0000000300 ffffea0000000320,ffffea0000000320 149 ffffea0000000340 ffffea0000000360,ffffea0000000360 150 ffffea0000000380 ffffea00000003a0,ffffea00000003a0 151 ffffea00000003c0 ffffea00000003e0,ffffea00000003e0 152 ffffea0000000400 ffff88021e5e41e8,ffffea0000002020 153 ffffea0000000440 dead000000100100,dead000000200200 154 ffffea0000000480 dead000000100100,dead000000200200 155 ffffea00000004c0 dead000000100100,dead000000200200 156 ... 157 158 Find the two pages that link to the page at ffffea0001dafb20 159 via their page.lru list_head\u0026#39;s next and prev pointers: 160 161 crash\u0026gt; kmem -m lru | grep ffffea0001dafb20 162 ffffea000006b500 ffffea0001dafb20,ffffea0001eb4520 163 ffffea0000127d80 ffffea000152b620,ffffea0001dafb20 164 165 Find all of the combined slab/page structures that are used by 166 the kmalloc-8192 slab cache: 167 168 crash\u0026gt; kmem -s kmalloc-8192 169 CACHE OBJSIZE ALLOCATED TOTAL SLABS SSIZE NAME 170 ffff880215802e00 8192 65 80 20 32k kmalloc-8192 171 crash\u0026gt; kmem -m slab_cache | grep ffff880215802e00 172 ffffea0004117800 ffff880215802e00 173 ffffea00041ca600 ffff880215802e00 174 ffffea00044ab200 ffff880215802e00 175 ffffea0004524000 ffff880215802e00 176 ffffea0004591600 ffff880215802e00 177 ffffea00047eac00 ffff880215802e00 178 ffffea0004875800 ffff880215802e00 179 ffffea0008357a00 ffff880215802e00 180 ffffea0008362a00 ffff880215802e00 181 ffffea00083b9400 ffff880215802e00 182 ffffea00083c1000 ffff880215802e00 183 ffffea00083c1e00 ffff880215802e00 184 ffffea00083c2000 ffff880215802e00 185 ffffea00083c2a00 ffff880215802e00 186 ffffea00083d2000 ffff880215802e00 187 ffffea00083d3e00 ffff880215802e00 188 ffffea0008407c00 ffff880215802e00 189 ffffea000848ce00 ffff880215802e00 190 ffffea0008491800 ffff880215802e00 191 ffffea00084bf800 ffff880215802e00 192 193 Use the commands above with a page pointer or a physical address argument: 194 195 crash\u0026gt; kmem -f c40425b0 196 NODE 197 0 198 ZONE NAME SIZE FREE MEM_MAP START_PADDR START_MAPNR 199 0 DMA 4096 3372 c4000040 0 0 200 AREA SIZE FREE_AREA_STRUCT 201 2 16k c02eb01c 202 c40425b0 (c40425b0 is 1st of 4 pages) 203 204 crash\u0026gt; kmem -p c25a9c00 205 PAGE PHYSICAL MAPPING INDEX CNT FLAGS 206 c25a9c00 1fe0000 f429d2e4 21fe3eb 2 800828 uptodate,lru,private 207 208 crash\u0026gt; kmem -p 1fe0000 209 PAGE PHYSICAL MAPPING INDEX CNT FLAGS 210 c25a9c00 1fe0000 f429d2e4 21fe3eb 2 800828 uptodate,lru,private 211 212 Display the mapped memory regions allocated by vmalloc(): 213 214 crash\u0026gt; kmem -v 215 VMAP_AREA VM_STRUCT ADDRESS RANGE SIZE 216 f7048e00 f7048e40 f7dfe000 - f7e00000 8192 217 f7048ec0 f7048f00 f7e00000 - f7e05000 20480 218 f7151fc0 f7159540 f7e06000 - f7e08000 8192 219 f704da80 f704dac0 f7e0a000 - f7e0c000 8192 220 f704d980 f704d9c0 f7e0e000 - f7e10000 8192 221 f724f1c0 f724f200 f7e12000 - f7e14000 8192 222 f704d840 f704d880 f7e14000 - f7e17000 12288 223 f704d400 f704d440 f7e18000 - f7e1d000 20480 224 f73f5840 f73f5880 f7e1e000 - f7e2a000 49152 225 f6334480 f63344c0 f7e2c000 - f7e2e000 8192 226 f635d600 f635d640 f7e4a000 - f7e5b000 69632 227 f41b4700 f5771a40 f7e6e000 - f7e70000 8192 228 f622f6c0 f622f700 f7e71000 - f7e79000 32768 229 f63a9f00 f63a9f40 f7e84000 - f7e87000 12288 230 f63a9d00 f63a9d40 f7e8f000 - f7e91000 8192 231 f5546480 f39db800 f7eb8000 - f7ec2000 40960 232 f5ce9640 f5777e80 f7ec6000 - f7ed1000 45056 233 f63a9b00 f63a9b40 f7ed1000 - f7efd000 180224 234 f63a9800 f63a9840 f7f1d000 - f7f26000 36864 235 f63a9640 f63a9880 f7f43000 - f7f52000 61440 236 f5771f00 f4183840 f7f53000 - f7f64000 69632 237 f5ce9a00 f30c4a00 f7fcf000 - f801e000 323584 238 f63a93c0 f63a9400 f805d000 - f8132000 872448 239 f63a91c0 f63a95c0 f814b000 - f8150000 20480 240 f63a9140 f63a9180 f8151000 - f8352000 2101248 241 f624eb00 f624eb40 f8353000 - f8355000 8192 242 f563eb40 f563eb80 f8356000 - f835e000 32768 243 f63d5ec0 f63d5f00 f8360000 - f8371000 69632 244 f63d5cc0 f6287b80 f83c2000 - f84c3000 1052672 245 ... 246 247 Dump the virtual memory statistics: 248 249 crash\u0026gt; kmem -V 250 VM_ZONE_STAT: 251 NR_FREE_PAGES: 30085 252 NR_ZONE_INACTIVE_ANON: 1985 253 NR_ZONE_ACTIVE_ANON: 338275 254 NR_ZONE_INACTIVE_FILE: 19760 255 NR_ZONE_ACTIVE_FILE: 12018 256 NR_ZONE_UNEVICTABLE: 0 257 NR_ZONE_WRITE_PENDING: 4 258 NR_MLOCK: 0 259 NR_PAGETABLE: 1562 260 NR_KERNEL_STACK_KB: 1728 261 NR_BOUNCE: 0 262 NR_FREE_CMA_PAGES: 0 263 264 VM_NODE_STAT: 265 NR_INACTIVE_ANON: 1985 266 NR_ACTIVE_ANON: 338275 267 NR_INACTIVE_FILE: 19760 268 NR_ACTIVE_FILE: 12018 269 NR_UNEVICTABLE: 0 270 NR_SLAB_RECLAIMABLE: 3111 271 NR_SLAB_UNRECLAIMABLE: 3039 272 NR_ISOLATED_ANON: 0 273 NR_ISOLATED_FILE: 0 274 WORKINGSET_REFAULT: 0 275 WORKINGSET_ACTIVATE: 0 276 WORKINGSET_NODERECLAIM: 0 277 NR_ANON_MAPPED: 338089 278 NR_FILE_MAPPED: 8102 279 NR_FILE_PAGES: 33949 280 NR_FILE_DIRTY: 4 281 NR_WRITEBACK: 0 282 NR_WRITEBACK_TEMP: 0 283 NR_SHMEM: 2171 284 NR_SHMEM_THPS: 0 285 NR_SHMEM_PMDMAPPED: 0 286 NR_ANON_THPS: 86 287 NR_UNSTABLE_NFS: 0 288 NR_VMSCAN_WRITE: 0 289 NR_VMSCAN_IMMEDIATE: 0 290 NR_DIRTIED: 155 291 NR_WRITTEN: 75 292 293 VM_NUMA_STAT: 294 NUMA_HIT: 575409 295 NUMA_MISS: 0 296 NUMA_FOREIGN: 0 297 NUMA_INTERLEAVE_HIT: 12930 298 NUMA_LOCAL: 575409 299 NUMA_OTHER: 0 300 301 VM_EVENT_STATES: 302 PGPGIN: 282492 303 PGPGOUT: 6773 304 PSWPIN: 0 305 PSWPOUT: 0 306 PGALLOC_DMA: 0 307 PGALLOC_DMA32: 693092 308 PGALLOC_NORMAL: 0 309 ... 310 311 Display hugepage hstate information: 312 313 crash\u0026gt; kmem -h 314 HSTATE SIZE FREE TOTAL NAME 315 ffffffff81f7a800 2MB 10 64 hugepages-2048kB 316 317 Determine (and verify) the page cache size: 318 319 crash\u0026gt; kmem -c 320 page_cache_size: 18431 (verified) 321 322 Dump all pages in the page_hash_table: 323 324 crash\u0026gt; kmem -C 325 page_hash_table[0] 326 c0325b40 327 c03a0598 328 c03b4070 329 c0364c28 330 c0357690 331 c02ef338 332 c02d7c60 333 c02c11e0 334 c02a3d70 335 page_hash_table[1] 336 c0394ce8 337 c03c4218 338 c03b4048 339 c0364c00 340 c0357668 341 c02d6e50 342 c02d7dc8 343 c02c0cb8 344 c02db630 345 c02ebad0 346 page_hash_table[2] 347 c037e808 348 c034e248 349 c03b4020 350 c02ec868 351 c03baa60 352 ... 353 page_hash_table[2047] 354 c033a798 355 c0390b48 356 c03b4098 357 c0364890 358 c03576b8 359 c02d2c38 360 c02d7c88 361 c02de5d8 362 363 page_cache_size: 18437 (verified) 364 365 Find the page_hash_table entry containing page c03576b8: 366 367 crash\u0026gt; kmem -c c03576b8 368 page_hash_table[2047] 369 c03576b8 370 371 Display kmalloc() slab data: 372 373 crash\u0026gt; kmem -s 374 CACHE OBJSIZE ALLOCATED TOTAL SLABS SSIZE NAME 375 c02eadc0 232 58 68 4 4k kmem_cache 376 f79c2888 128 0 0 0 4k ip_vs_conn 377 f79c2970 96 0 0 0 4k tcp_tw_bucket 378 f79c2a58 32 12 565 5 4k tcp_bind_bucket 379 f79c2b40 64 0 59 1 4k tcp_open_request 380 f79c2c28 64 1 59 1 4k inet_peer_cache 381 f79c2d10 32 11 339 3 4k ip_fib_hash 382 f79c2df8 160 8 120 5 4k ip_dst_cache 383 f79c2ee0 128 1 30 1 4k arp_cache 384 c8402970 96 30208 37800 945 4k blkdev_requests 385 c8402a58 384 0 0 0 4k nfs_read_data 386 c8402b40 384 0 0 0 4k nfs_write_data 387 c8402c28 96 0 0 0 4k nfs_page 388 c8402d10 20 0 0 0 4k dnotify cache 389 c8402df8 92 3 336 8 4k file lock cache 390 c8402ee0 16 0 0 0 4k fasync cache 391 c84027a0 32 3 339 3 4k uid_cache 392 c84026b8 160 320 624 26 4k skbuff_head_cache 393 c84025d0 832 32 180 20 8k sock 394 c84024e8 132 0 203 7 4k sigqueue 395 c8402400 64 19 472 8 4k cdev_cache 396 c8402318 64 8 236 4 4k bdev_cache 397 c8402230 96 11 120 3 4k mnt_cache 398 c8402148 480 817 848 106 4k inode_cache 399 c8402060 128 1352 1470 49 4k dentry_cache 400 c8403ee0 96 244 440 11 4k filp 401 c8403df8 4096 0 12 12 4k names_cache 402 c8403d10 96 14936 16000 400 4k buffer_head 403 c8403c28 128 25 240 8 4k mm_struct 404 c8403b40 64 393 1298 22 4k vm_area_struct 405 c8403a58 64 30 472 8 4k fs_cache 406 c8403970 416 30 135 15 4k files_cache 407 c8403888 1312 32 99 33 4k signal_act 408 c84037a0 131072 0 0 0 128k size-131072(DMA) 409 c84036b8 131072 1 1 1 128k size-131072 410 c84035d0 65536 0 0 0 64k size-65536(DMA) 411 c84034e8 65536 0 0 0 64k size-65536 412 c8403400 32768 0 0 0 32k size-32768(DMA) 413 c8403318 32768 0 1 1 32k size-32768 414 c8403230 16384 0 0 0 16k size-16384(DMA) 415 c8403148 16384 0 0 0 16k size-16384 416 c8403060 8192 0 0 0 8k size-8192(DMA) 417 c8401ee0 8192 1 2 2 8k size-8192 418 c8401df8 4096 0 0 0 4k size-4096(DMA) 419 c8401d10 4096 30 30 30 4k size-4096 420 c8401c28 2048 0 0 0 4k size-2048(DMA) 421 c8401b40 2048 37 132 66 4k size-2048 422 c8401a58 1024 0 0 0 4k size-1024(DMA) 423 c8401970 1024 301 328 82 4k size-1024 424 c8401888 512 0 0 0 4k size-512(DMA) 425 c84017a0 512 141 168 21 4k size-512 426 c84016b8 256 0 0 0 4k size-256(DMA) 427 c84015d0 256 80 435 29 4k size-256 428 c84014e8 128 0 0 0 4k size-128(DMA) 429 c8401400 128 508 840 28 4k size-128 430 c8401318 64 0 0 0 4k size-64(DMA) 431 c8401230 64 978 1357 23 4k size-64 432 c8401148 32 0 0 0 4k size-32(DMA) 433 c8401060 32 1244 1808 16 4k size-32 434 435 Display all slab data in the \u0026#34;arp_cache\u0026#34; cache: 436 437 crash\u0026gt; kmem -S arp_cache 438 CACHE OBJSIZE ALLOCATED TOTAL SLABS SSIZE NAME 439 f79c2ee0 128 1 30 1 4k arp_cache 440 SLAB MEMORY TOTAL ALLOCATED FREE 441 f729d000 f729d0a0 30 1 29 442 FREE / [ALLOCATED] 443 f729d0a0 (cpu 7 cache) 444 f729d120 (cpu 7 cache) 445 f729d1a0 (cpu 7 cache) 446 f729d220 (cpu 7 cache) 447 f729d2a0 (cpu 7 cache) 448 f729d320 (cpu 7 cache) 449 f729d3a0 (cpu 7 cache) 450 f729d420 (cpu 7 cache) 451 f729d4a0 (cpu 7 cache) 452 f729d520 (cpu 7 cache) 453 f729d5a0 (cpu 7 cache) 454 f729d620 (cpu 7 cache) 455 f729d6a0 (cpu 7 cache) 456 f729d720 (cpu 7 cache) 457 f729d7a0 (cpu 7 cache) 458 f729d820 (cpu 7 cache) 459 f729d8a0 (cpu 7 cache) 460 f729d920 (cpu 7 cache) 461 f729d9a0 (cpu 7 cache) 462 f729da20 (cpu 7 cache) 463 f729daa0 (cpu 7 cache) 464 f729db20 (cpu 7 cache) 465 f729dba0 (cpu 7 cache) 466 f729dc20 (cpu 7 cache) 467 f729dca0 (cpu 7 cache) 468 f729dd20 (cpu 7 cache) 469 f729dda0 (cpu 7 cache) 470 f729de20 (cpu 7 cache) 471 f729dea0 (cpu 3 cache) 472 [f729df20] 473 474 Search the kmalloc() slab subsystem for address c3fbdb60: 475 476 crash\u0026gt; kmem -s c3fbdb60 477 CACHE OBJSIZE ALLOCATED TOTAL SLABS SSIZE NAME 478 c8402970 96 30208 37800 945 4k blkdev_requests 479 SLAB MEMORY TOTAL ALLOCATED FREE 480 c3fbd020 c3fbd0e0 40 40 0 481 FREE / [ALLOCATED] 482 [c3fbdb60] 483 484 Make a generic search (no flags) for the same address c3fbdb60: 485 486 crash\u0026gt; kmem c3fbdb60 487 CACHE OBJSIZE ALLOCATED TOTAL SLABS SSIZE NAME 488 c8402970 96 30208 37800 945 4k blkdev_requests 489 SLAB MEMORY TOTAL ALLOCATED FREE 490 c3fbd020 c3fbd0e0 40 40 0 491 FREE / [ALLOCATED] 492 [c3fbdb60] 493 494 PAGE PHYSICAL MAPPING INDEX CNT FLAGS 495 c410ee74 3fbd000 0 0 1 slab 496 497 Display memory node data (if supported): 498 499 crash\u0026gt; kmem -n 500 NODE SIZE PGLIST_DATA BOOTMEM_DATA NODE_ZONES 501 0 262095 ffff88003d52a000 ---- ffff88003d52a000 502 ffff88003d52a740 503 ffff88003d52ae80 504 ffff88003d52b5c0 505 MEM_MAP START_PADDR START_MAPNR 506 ffffea0000000040 1000 1 507 508 ZONE NAME SIZE MEM_MAP START_PADDR START_MAPNR 509 0 DMA 4095 ffffea0000000040 1000 1 510 1 DMA32 258000 ffffea0000040000 1000000 4096 511 2 Normal 0 0 0 0 512 3 Movable 0 0 0 0 513 514 ------------------------------------------------------------------- 515 516 NR SECTION CODED_MEM_MAP MEM_MAP STATE PFN 517 0 ffff88003d4d9000 ffffea0000000000 ffffea0000000000 PM 0 518 1 ffff88003d4d9020 ffffea0000000000 ffffea0000200000 PM 32768 519 2 ffff88003d4d9040 ffffea0000000000 ffffea0000400000 PM 65536 520 3 ffff88003d4d9060 ffffea0000000000 ffffea0000600000 PM 98304 521 4 ffff88003d4d9080 ffffea0000000000 ffffea0000800000 PM 131072 522 5 ffff88003d4d90a0 ffffea0000000000 ffffea0000a00000 PM 163840 523 6 ffff88003d4d90c0 ffffea0000000000 ffffea0000c00000 PM 196608 524 7 ffff88003d4d90e0 ffffea0000000000 ffffea0000e00000 PM 229376 525 526 MEM_BLOCK NAME PHYSICAL RANGE STATE START_SECTION_NO 527 ffff88003a707c00 memory0 0 - 7ffffff ONLINE 0 528 ffff88003a6e0000 memory1 8000000 - fffffff ONLINE 1 529 ffff88003a6e1000 memory2 10000000 - 17ffffff ONLINE 2 530 ffff88003a6e1400 memory3 18000000 - 1fffffff ONLINE 3 531 ffff88003a6e1800 memory4 20000000 - 27ffffff ONLINE 4 532 ffff88003a6e0400 memory5 28000000 - 2fffffff ONLINE 5 533 ffff88003a6e0800 memory6 30000000 - 37ffffff ONLINE 6 534 ffff88003a6e0c00 memory7 38000000 - 3fffffff ONLINE 7 535 536 Translate a page structure\u0026#39;s flags field contents: 537 538 crash\u0026gt; kmem -g 4080 539 FLAGS: 4080 540 PAGE-FLAG BIT VALUE 541 PG_slab 7 0000080 542 PG_head 14 0004000 543 crash\u0026gt; 20. list - linked list 20.1. SYNOPSIS 1list [[-o] offset][-e end][-[s|S] struct[.member[,member] [-l offset]] -[x|d]] 2 [-r|-B] [-h|-H] start 20.2. DESCRIPTION 1 2 This command dumps the contents of a linked list. The entries in a linked 3 list are typically data structures that are tied together in one of two 4 formats: 5 6 1. A starting address points to a data structure; that structure contains 7 a member that is a pointer to the next structure, and so on. This type 8 of a singly-linked list typically ends when a \u0026#34;next\u0026#34; pointer value 9 contains one of the following: 10 11 (a) a NULL pointer. 12 (b) a pointer to the start address. 13 (c) a pointer to the first item pointed to by the start address. 14 (d) a pointer to its containing structure. 15 16 2. Most Linux lists of data structures are doubly-linked using \u0026#34;list_head\u0026#34; 17 structures that are embedded members of the data structures in the list: 18 19 struct list_head { 20 struct list_head *next, *prev; 21 }; 22 23 The linked list is typically headed by an external, standalone list_head, 24 which is simply initialized to point to itself, signifying that the list 25 is empty: 26 27 #define LIST_HEAD_INIT(name) { \u0026amp;(name), \u0026amp;(name) } 28 #define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name) 29 30 In the case of list_head-linked lists, the \u0026#34;list_head.next\u0026#34; pointer is 31 the address of a list_head structure that is embedded in the next data 32 structure in the list, and not the address of the next data structure 33 itself. The starting point of the list may be: 34 35 (a) an external, standalone, LIST_HEAD(). 36 (b) a list_head that is embedded within a data structure of the same 37 type as the whole linked list. 38 (c) a list_head that is embedded within a data structure that is 39 different than the type of structures in the the linked list. 40 41 The list typically ends when the embedded \u0026#34;list_head.next\u0026#34; pointer of 42 a data structure in the linked list points back to the LIST_HEAD() 43 address. However, some list_head-linked lists have no defined starting 44 point, but just link back onto themselves in a circular manner. 45 46 This command can handle both types of linked list; in both cases the list 47 of addresses that are dumped are the addresses of the data structures 48 themselves. 49 50 Alternatively, the address of a list_head, or other similar list linkage 51 structure whose first member points to the next linkage structure, may be 52 used as the starting address. The caveat with this type of usage is that 53 the list may pass through, and display the address of, an external standalone 54 list head which is not an address of a list linkage structure that is embedded 55 within the data structure of interest. 56 57 The arguments are as follows: 58 59 [-o] offset The offset within the structure to the \u0026#34;next\u0026#34; pointer 60 (default is 0). If non-zero, the offset may be entered 61 in either of two manners: 62 63 1. In \u0026#34;structure.member\u0026#34; format; the \u0026#34;-o\u0026#34; is not necessary. 64 2. A number of bytes; the \u0026#34;-o\u0026#34; is only necessary on processors 65 where the offset value could be misconstrued as a kernel 66 virtual address. 67 68 -e end If the list ends in a manner unlike the typical manners that 69 are described above, an explicit ending address value may be 70 entered. 71 -s struct For each address in list, format and print as this type of 72 structure; use the \u0026#34;struct.member\u0026#34; format in order to display 73 a particular member of the structure. To display multiple 74 members of a structure, use a comma-separated list of members. 75 If any structure member contains an embedded structure or is an 76 array, the output may be restricted to the embedded structure 77 or an array element by expressing the struct argument as 78 \u0026#34;struct.member.member\u0026#34; or \u0026#34;struct.member[index]\u0026#34;; embedded 79 member specifications may extend beyond one level deep by 80 expressing the argument as \u0026#34;struct.member.member.member...\u0026#34;. 81 -S struct Similar to -s, but instead of parsing gdb output, member values 82 are read directly from memory, so the command works much faster 83 for 1-, 2-, 4-, and 8-byte members. 84 -l offset Only used in conjunction with -s, if the start address argument 85 is a pointer to an embedded list head (or any other similar list 86 linkage structure whose first member points to the next linkage 87 structure), the offset to the embedded member may be entered 88 in either of the following manners: 89 90 1. in \u0026#34;structure.member\u0026#34; format. 91 2. a number of bytes. 92 93 -x Override the default output format with hexadecimal format. 94 -d Override the default output format with decimal format. 95 -r For a list linked with list_head structures, traverse the list 96 in the reverse order by using the \u0026#34;prev\u0026#34; pointer instead 97 of \u0026#34;next\u0026#34;. 98 -B Use the algorithm from R. P. Brent to detect loops instead of 99 using a hash table. This algorithm uses a tiny fixed amount of 100 memory and so is especially helpful for longer lists. The output 101 is slightly different than the normal list output as it will 102 print the length of the loop, the start of the loop, and the 103 first duplicate in the list. 104 105 The meaning of the \u0026#34;start\u0026#34; argument, which can be expressed symbolically, 106 in hexadecimal format, or an expression evaluating to an address, depends 107 upon whether the -h or -H option is pre-pended: 108 109 start The address of the first data structure in the list. 110 start When both the -s and -l options are used, the address of an 111 embedded list_head or similar linkage structure whose first 112 member points to the next linkage structure. 113 -H start The address of a list_head structure, typically that of an 114 external, standalone LIST_HEAD(). The list typically ends 115 when the embedded \u0026#34;list_head.next\u0026#34; of a data structure in 116 the linked list points back to this \u0026#34;start\u0026#34; address. 117 -h start The address of a data structure which contains an embedded 118 list_head. The list typically ends when the embedded 119 \u0026#34;list_head.next\u0026#34; of a data structure in the linked list 120 points back to the embedded list_head contained in the data 121 structure whose address is this \u0026#34;start\u0026#34; argument. 122 123WARNING 124 When the \u0026#34;-h start\u0026#34; option is used, it is possible that the list_head-linked 125 list will: 126 127 1. pass through an external standalone LIST_HEAD(), or 128 2. pass through a list_head that is the actual starting list_head, but is 129 contained within a data structure that is not the same type as all of 130 the other data structures in the list. 131 132 When that occurs, the data structure address displayed for that list_head 133 will be incorrect, because the \u0026#34;-h start\u0026#34; option presumes that all 134 list_head structures in the list are contained within the same type of 135 data structure. Furthermore, if the \u0026#34;-s struct[.member[,member]\u0026#34; option 136 is used, it will display bogus data for that particular list_head. 137 138 A similar issue may be encountered when the \u0026#34;start\u0026#34; address is an embedded 139 list_head or similar linkage structure whose first member points to the next 140 linkage structure. When that occurs, the address of any external list head 141 will not be distinguishable from the addresses that are embedded in the data 142 structure of interest. Furthermore, if the \u0026#34;-s\u0026#34; and \u0026#34;-l\u0026#34; options are used, 143 it will display bogus structure data when passing through any external list 144 head structure that is not embedded in the specified data structure type. 20.3. EXAMPLES 1 Note that each task_struct is linked to its parent\u0026#39;s task_struct via the 2 p_pptr member: 3 4 crash\u0026gt; struct task_struct.p_pptr 5 struct task_struct { 6 [136] struct task_struct *p_pptr; 7 } 8 9 That being the case, given a task_struct pointer of c169a000, show its 10 parental hierarchy back to the \u0026#34;init_task\u0026#34; (the \u0026#34;swapper\u0026#34; task): 11 12 crash\u0026gt; list task_struct.p_pptr c169a000 13 c169a000 14 c0440000 15 c50d0000 16 c0562000 17 c0d28000 18 c7894000 19 c6a98000 20 c009a000 21 c0252000 22 23 Given that the \u0026#34;task_struct.p_pptr\u0026#34; offset is 136 bytes, the same 24 result could be accomplished like so: 25 26 crash\u0026gt; list 136 c169a000 27 c169a000 28 c0440000 29 c50d0000 30 c0562000 31 c0d28000 32 c7894000 33 c6a98000 34 c009a000 35 c0252000 36 37 The list of currently-registered file system types are headed up by a 38 struct file_system_type pointer named \u0026#34;file_systems\u0026#34;, and linked by 39 the \u0026#34;next\u0026#34; field in each file_system_type structure. The following 40 sequence displays the structure address followed by the name and 41 fs_flags members of each registered file system type: 42 43 crash\u0026gt; p file_systems 44 file_systems = $1 = (struct file_system_type *) 0xc03adc90 45 crash\u0026gt; list file_system_type.next -s file_system_type.name,fs_flags c03adc90 46 c03adc90 47 name = 0xc02c05c8 \u0026#34;rootfs\u0026#34;, 48 fs_flags = 0x30, 49 c03abf94 50 name = 0xc02c0319 \u0026#34;bdev\u0026#34;, 51 fs_flags = 0x10, 52 c03acb40 53 name = 0xc02c07c4 \u0026#34;proc\u0026#34;, 54 fs_flags = 0x8, 55 c03e9834 56 name = 0xc02cfc83 \u0026#34;sockfs\u0026#34;, 57 fs_flags = 0x10, 58 c03ab8e4 59 name = 0xc02bf512 \u0026#34;tmpfs\u0026#34;, 60 fs_flags = 0x20, 61 c03ab8c8 62 name = 0xc02c3d6b \u0026#34;shm\u0026#34;, 63 fs_flags = 0x20, 64 c03ac394 65 name = 0xc02c03cf \u0026#34;pipefs\u0026#34;, 66 fs_flags = 0x10, 67 c03ada74 68 name = 0xc02c0e6b \u0026#34;ext2\u0026#34;, 69 fs_flags = 0x1, 70 c03adc74 71 name = 0xc02c0e70 \u0026#34;ramfs\u0026#34;, 72 fs_flags = 0x20, 73 c03ade74 74 name = 0xc02c0e76 \u0026#34;hugetlbfs\u0026#34;, 75 fs_flags = 0x20, 76 c03adf8c 77 name = 0xc02c0f84 \u0026#34;iso9660\u0026#34;, 78 fs_flags = 0x1, 79 c03aec14 80 name = 0xc02c0ffd \u0026#34;devpts\u0026#34;, 81 fs_flags = 0x8, 82 c03e93f4 83 name = 0xc02cf1b9 \u0026#34;pcihpfs\u0026#34;, 84 fs_flags = 0x28, 85 e0831a14 86 name = 0xe082f89f \u0026#34;ext3\u0026#34;, 87 fs_flags = 0x1, 88 e0846af4 89 name = 0xe0841ac6 \u0026#34;usbdevfs\u0026#34;, 90 fs_flags = 0x8, 91 e0846b10 92 name = 0xe0841acf \u0026#34;usbfs\u0026#34;, 93 fs_flags = 0x8, 94 e0992370 95 name = 0xe099176c \u0026#34;autofs\u0026#34;, 96 fs_flags = 0x0, 97 e2dcc030 98 name = 0xe2dc8849 \u0026#34;nfs\u0026#34;, 99 fs_flags = 0x48000, 100 101 In some kernels, the system run queue is a linked list headed up by the 102 \u0026#34;runqueue_head\u0026#34;, which is defined like so: 103 104 static LIST_HEAD(runqueue_head); 105 106 The run queue linking is done with the \u0026#34;run_list\u0026#34; member of the task_struct: 107 108 crash\u0026gt; struct task_struct.run_list 109 struct task_struct { 110 [60] struct list_head run_list; 111 } 112 113 Therefore, to view the list of task_struct addresses in the run queue, 114 either of the following commands will work: 115 116 crash\u0026gt; list task_struct.run_list -H runqueue_head 117 f79ac000 118 f7254000 119 f7004000 120 crash\u0026gt; list 60 -H runqueue_head 121 f79ac000 122 f7254000 123 f7004000 124 125 In some kernel versions, the vfsmount structures of the mounted 126 filesystems are linked by the LIST_HEAD \u0026#34;vfsmntlist\u0026#34;, which uses the 127 mnt_list list_head of each vfsmount structure in the list. To dump each 128 vfsmount structure in the list, append the -s option: 129 130 crash\u0026gt; list -H vfsmntlist vfsmount.mnt_list -s vfsmount 131 c3fc9e60 132 struct vfsmount { 133 mnt_hash = { 134 next = 0xc3fc9e60, 135 prev = 0xc3fc9e60 136 }, 137 mnt_parent = 0xc3fc9e60, 138 mnt_mountpoint = 0xc3fc5dc0, 139 mnt_root = 0xc3fc5dc0, 140 mnt_instances = { 141 next = 0xc3f60a74, 142 prev = 0xc3f60a74 143 }, 144 mnt_sb = 0xc3f60a00, 145 mnt_mounts = { 146 next = 0xf7445e08, 147 prev = 0xf7445f88 148 }, 149 mnt_child = { 150 next = 0xc3fc9e88, 151 prev = 0xc3fc9e88 152 }, 153 mnt_count = { 154 counter = 209 155 }, 156 mnt_flags = 0, 157 mnt_devname = 0xc8465b20 \u0026#34;/dev/root\u0026#34;, 158 mnt_list = { 159 next = 0xf7445f9c, 160 prev = 0xc02eb828 161 }, 162 mnt_owner = 0 163 } 164 f7445f60 165 struct vfsmount { 166 ... 167 168 The task_struct of every task in the system is linked into a circular list 169 by its embedded \u0026#34;tasks\u0026#34; list_head. Show the task_struct addresses and the 170 pids of all tasks in the system using \u0026#34;-h\u0026#34; option, starting with the 171 task_struct at ffff88012b98e040: 172 173 crash\u0026gt; list task_struct.tasks -s task_struct.pid -h ffff88012b98e040 174 ffff88012b98e040 175 pid = 14187 176 ffff8801277be0c0 177 pid = 14248 178 ffffffff81a2d020 179 pid = 0 180 ffff88012d7dd4c0 181 pid = 1 182 ffff88012d7dca80 183 pid = 2 184 ffff88012d7dc040 185 pid = 3 186 ffff88012d7e9500 187 pid = 4 188 ... 189 ffff88012961a100 190 pid = 14101 191 ffff880129017580 192 pid = 14134 193 ffff8801269ed540 194 pid = 14135 195 ffff880128256080 196 pid = 14138 197 ffff88012b8f4100 198 pid = 14183 199 200 Similar to the above, display the embedded sched_entity structure\u0026#39;s on_rq 201 member from each task_struct in the system: 202 203 crash\u0026gt; list task_struct.tasks -s task_struct.se.on_rq -h ffff8800b66a0000 204 ffff8800b66a0000 205 se.on_rq = 1, 206 ffff8800b66a0ad0 207 se.on_rq = 0, 208 ffff8800b66a15a0 209 se.on_rq = 0, 210 ffff8800b66a2070 211 se.on_rq = 0, 212 ffff8800b66a2b40 213 se.on_rq = 0, 214 ffff8800b67315a0 215 se.on_rq = 0, 216 ffff8800b6732b40 217 se.on_rq = 0, 218 ... 219 220 The task_struct.tasks example above requires that the -h option be given 221 the address of a task_struct. Alternatively, the -l option can be given 222 the address of a list_head or similar linkage structure whose first member 223 points to the next linkage structure. Again using the task_struct.tasks 224 embedded list_head, dump the \u0026#34;comm\u0026#34; member of all tasks by using -l in 225 conjunction with -s option: 226 227 crash\u0026gt; task -R tasks.next 228 PID: 7044 TASK: ffff88005ac10000 CPU: 2 COMMAND: \u0026#34;crash\u0026#34; 229 tasks.next = 0xffff880109b8e3d0, 230 crash\u0026gt; list 0xffff880109b8e3d0 -l task_struct.tasks -s task_struct.comm 231 ffff880109b8e3d0 232 comm = \u0026#34;kworker/1:2\u0026#34; 233 ffff880109b8be00 234 comm = \u0026#34;bash\u0026#34; 235 ffff88019d26c590 236 comm = \u0026#34;cscope\u0026#34; 237 ffff880109b8b670 238 comm = \u0026#34;kworker/0:1\u0026#34; 239 ffff880109b8cd20 240 comm = \u0026#34;kworker/1:0\u0026#34; 241 ffff88005ac15c40 242 comm = \u0026#34;vi\u0026#34; 243 ffff88005ac11fc0 244 comm = \u0026#34;sleep\u0026#34; 245 ffffffff81c135c0 246 comm = \u0026#34;swapper/0\u0026#34; 247 ffff880212828180 248 comm = \u0026#34;systemd\u0026#34; 249 ... 250 ffff8801288d1830 251 comm = \u0026#34;chrome\u0026#34; 252 ffff8801534dd4b0 253 comm = \u0026#34;kworker/0:0\u0026#34; 254 ffff8801534d8180 255 comm = \u0026#34;kworker/1:1\u0026#34; 256 ffff88010902b670 257 comm = \u0026#34;kworker/2:2\u0026#34; 258 ffff880109b8a750 259 comm = \u0026#34;sudo\u0026#34; 260 ffff88005ac10180 261 comm = \u0026#34;crash\u0026#34; 21. log - dump system message buffer 21.1. SYNOPSIS 1log [-tdma] 21.2. DESCRIPTION 1 This command dumps the kernel log_buf contents in chronological order. The 2 command supports the older log_buf formats, which may or may not contain a 3 timestamp inserted prior to each message, as well as the newer variable-length 4 record format, where the timestamp is contained in each log entry\u0026#39;s header. 5 6 -t Display the message text without the timestamp; only applicable to the 7 variable-length record format. 8 -d Display the dictionary of key/value pair properties that are optionally 9 appended to a message by the kernel\u0026#39;s dev_printk() function; only 10 applicable to the variable-length record format. 11 -m Display the message log level in brackets preceding each message. For 12 the variable-length record format, the level will be displayed in 13 hexadecimal, and depending upon the kernel version, also contains the 14 facility or flags bits. 15 -a Dump the audit logs remaining in kernel audit buffers that have not 16 been copied out to the user-space audit daemon. 21.3. EXAMPLES 1 Dump the kernel message buffer: 2 3 crash\u0026gt; log 4 Linux version 2.2.5-15smp (root@mclinux1) (gcc version egcs-2.91.66 19990 5 314/Linux (egcs-1.1.2 release)) #1 SMP Thu Aug 26 11:04:37 EDT 1999 6 Intel MultiProcessor Specification v1.4 7 Virtual Wire compatibility mode. 8 OEM ID: DELL Product ID: WS 410 APIC at: 0xFEE00000 9 Processor #0 Pentium(tm) Pro APIC version 17 10 Processor #1 Pentium(tm) Pro APIC version 17 11 I/O APIC #2 Version 17 at 0xFEC00000. 12 Processors: 2 13 mapped APIC to ffffe000 (fee00000) 14 mapped IOAPIC to ffffd000 (fec00000) 15 Detected 447696347 Hz processor. 16 Console: colour VGA+ 80x25 17 Calibrating delay loop... 445.64 BogoMIPS 18 ... 19 8K byte-wide RAM 5:3 Rx:Tx split, autoselect/Autonegotiate interface. 20 MII transceiver found at address 24, status 782d. 21 Enabling bus-master transmits and whole-frame receives. 22 Installing knfsd (copyright (C) 1996 okir@monad.swb.de). 23 nfsd_init: initialized fhcache, entries=256 24 ... 25 26 Do the same thing, but also show the log level preceding each message: 27 28 crash\u0026gt; log -m 29 \u0026lt;4\u0026gt;Linux version 2.2.5-15smp (root@mclinux1) (gcc version egcs-2.91.66 19990 30 314/Linux (egcs-1.1.2 release)) #1 SMP Thu Aug 26 11:04:37 EDT 1999 31 \u0026lt;4\u0026gt;Intel MultiProcessor Specification v1.4 32 \u0026lt;4\u0026gt; Virtual Wire compatibility mode. 33 \u0026lt;4\u0026gt;OEM ID: DELL Product ID: WS 410 APIC at: 0xFEE00000 34 \u0026lt;4\u0026gt;Processor #0 Pentium(tm) Pro APIC version 17 35 \u0026lt;4\u0026gt;Processor #1 Pentium(tm) Pro APIC version 17 36 \u0026lt;4\u0026gt;I/O APIC #2 Version 17 at 0xFEC00000. 37 \u0026lt;4\u0026gt;Processors: 2 38 \u0026lt;4\u0026gt;mapped APIC to ffffe000 (fee00000) 39 \u0026lt;4\u0026gt;mapped IOAPIC to ffffd000 (fec00000) 40 \u0026lt;4\u0026gt;Detected 447696347 Hz processor. 41 \u0026lt;4\u0026gt;Console: colour VGA+ 80x25 42 \u0026lt;4\u0026gt;Calibrating delay loop... 445.64 BogoMIPS 43 ... 44 \u0026lt;6\u0026gt; 8K byte-wide RAM 5:3 Rx:Tx split, autoselect/Autonegotiate interface. 45 \u0026lt;6\u0026gt; MII transceiver found at address 24, status 782d. 46 \u0026lt;6\u0026gt; Enabling bus-master transmits and whole-frame receives. 47 \u0026lt;6\u0026gt;Installing knfsd (copyright (C) 1996 okir@monad.swb.de). 48 \u0026lt;7\u0026gt;nfsd_init: initialized fhcache, entries=256 49 ... 50 51 On a system with the variable-length record format, and whose log_buf has been 52 filled and wrapped around, display the log with timestamp data: 53 54 crash\u0026gt; log 55 [ 0.467730] pci 0000:ff:02.0: [8086:2c10] type 00 class 0x060000 56 [ 0.467749] pci 0000:ff:02.1: [8086:2c11] type 00 class 0x060000 57 [ 0.467769] pci 0000:ff:02.4: [8086:2c14] type 00 class 0x060000 58 [ 0.467788] pci 0000:ff:02.5: [8086:2c15] type 00 class 0x060000 59 [ 0.467809] pci 0000:ff:03.0: [8086:2c18] type 00 class 0x060000 60 [ 0.467828] pci 0000:ff:03.1: [8086:2c19] type 00 class 0x060000 61 ... 62 63 Display the same message text as above, without the timestamp data: 64 65 crash\u0026gt; log -t 66 pci 0000:ff:02.0: [8086:2c10] type 00 class 0x060000 67 pci 0000:ff:02.1: [8086:2c11] type 00 class 0x060000 68 pci 0000:ff:02.4: [8086:2c14] type 00 class 0x060000 69 pci 0000:ff:02.5: [8086:2c15] type 00 class 0x060000 70 pci 0000:ff:03.0: [8086:2c18] type 00 class 0x060000 71 pci 0000:ff:03.1: [8086:2c19] type 00 class 0x060000 72 ... 73 74 Display the same message text as above, with appended dictionary data: 75 76 crash\u0026gt; log -td 77 pci 0000:ff:02.0: [8086:2c10] type 00 class 0x060000 78 SUBSYSTEM=pci 79 DEVICE=+pci:0000:ff:02.0 80 pci 0000:ff:02.1: [8086:2c11] type 00 class 0x060000 81 SUBSYSTEM=pci 82 DEVICE=+pci:0000:ff:02.1 83 pci 0000:ff:02.4: [8086:2c14] type 00 class 0x060000 84 SUBSYSTEM=pci 85 DEVICE=+pci:0000:ff:02.4 86 pci 0000:ff:02.5: [8086:2c15] type 00 class 0x060000 87 SUBSYSTEM=pci 88 DEVICE=+pci:0000:ff:02.5 89 pci 0000:ff:03.0: [8086:2c18] type 00 class 0x060000 90 SUBSYSTEM=pci 91 DEVICE=+pci:0000:ff:03.0 92 pci 0000:ff:03.1: [8086:2c19] type 00 class 0x060000 93 SUBSYSTEM=pci 94 DEVICE=+pci:0000:ff:03.1 95 ... 96 97 Dump the kernel audit logs: 98 99 crash\u0026gt; log -a 100 type=1320 audit(1489384479.809:4342): 101 type=1300 audit(1489384479.809:4343): arch=c000003e syscall=0 success=yes 102 exit=0 a0=4 a1=7f84154a2000 a2=400 a3=22 items=0 ppid=2560 pid=2591 auid=0 103 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=ttyS0 ses=1 104 comm=\u0026#34;pidof\u0026#34; exe=\u0026#34;/usr/sbin/killall5\u0026#34; 105 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null) 106 type=1320 audit(1489384479.809:4343): 107 type=1300 audit(1489384479.809:4344): arch=c000003e syscall=3 success=yes 108 exit=0 a0=4 a1=1 a2=8 a3=0 items=0 ppid=2560 pid=2591 auid=0 uid=0 gid=0 109 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=ttyS0 ses=1 comm=\u0026#34;pidof\u0026#34; 110 exe=\u0026#34;/usr/sbin/killall5\u0026#34; 111 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null) 112 type=1320 audit(1489384479.809:4344): 113 type=1300 audit(1489384479.809:4345): arch=c000003e syscall=11 114 success=yes exit=0 a0=7f84154a2000 a1=1000 a2=0 a3=0 items=0 ppid=2560 115 pid=2591 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 116 tty=ttyS0 ses=1 comm=\u0026#34;pidof\u0026#34; exe=\u0026#34;/usr/sbin/killall5\u0026#34; 117 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null) 118 type=1320 audit(1489384479.809:4345): 119 type=1300 audit(1489384479.809:4346): arch=c000003e syscall=2 success=yes 120 exit=4 a0=7ffcfd20f5a0 a1=0 a2=1b6 a3=24 items=1 ppid=2560 pid=2591 auid=0 121 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=ttyS0 ses=1 122 comm=\u0026#34;pidof\u0026#34; exe=\u0026#34;/usr/sbin/killall5\u0026#34; 123 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null) 124 type=1307 audit(1489384479.809:4346): cwd=\u0026#34;/proc\u0026#34; 125 ... 22. mach - machine specific data 22.1. SYNOPSIS 1mach [-m | -c -[xd] | -o] 22.2. DESCRIPTION 1 This command displays data specific to a machine type. 2 3 -m Display the physical memory map (x86, x86_64 and ia64 only). 4 -c Display each cpu\u0026#39;s cpuinfo structure (x86, x86_64 and ia64 only). 5 Display each cpu\u0026#39;s x8664_pda structure (x86_64 only), 6 Display the hwrpb_struct, and each cpu\u0026#39;s percpu_struct (alpha only). 7 -x override default output format with hexadecimal format. 8 -d override default output format with decimal format. 9 -o Display the OPAL console log (ppc64 only). 22.3. EXAMPLES 1 crash\u0026gt; mach 2 MACHINE TYPE: i686 3 MEMORY SIZE: 512 MB 4 CPUS: 2 5 HYPERVISOR: KVM 6 PROCESSOR SPEED: 1993 Mhz 7 HZ: 100 8 PAGE SIZE: 4096 9 KERNEL VIRTUAL BASE: c0000000 10 KERNEL VMALLOC BASE: e0800000 11 KERNEL STACK SIZE: 8192 12 13 Display the system physical memory map: 14 15 crash\u0026gt; mach -m 16 PHYSICAL ADDRESS RANGE TYPE 17 0000000000000000 - 00000000000a0000 E820_RAM 18 00000000000f0000 - 0000000000100000 E820_RESERVED 19 0000000000100000 - 000000001ff75000 E820_RAM 20 000000001ff75000 - 000000001ff77000 E820_NVS 21 000000001ff77000 - 000000001ff98000 E820_ACPI 22 000000001ff98000 - 0000000020000000 E820_RESERVED 23 00000000fec00000 - 00000000fec90000 E820_RESERVED 24 00000000fee00000 - 00000000fee10000 E820_RESERVED 25 00000000ffb00000 - 0000000100000000 E820_RESERVED 26 27 Display the OPAL console log: 28 29 crash\u0026gt; mach -o 30 [ 65.219056911,5] SkiBoot skiboot-5.4.0-218-ge0225cc-df9a248 starting... 31 [ 65.219065872,5] initial console log level: memory 7, driver 5 32 [ 65.219068917,6] CPU: P8 generation processor(max 8 threads/core) 33 [ 65.219071681,7] CPU: Boot CPU PIR is 0x0060 PVR is 0x004d0200 34 [ 65.219074685,7] CPU: Initial max PIR set to 0x1fff 35 [ 65.219607955,5] FDT: Parsing fdt @0xff00000 36 [ 494.026291523,7] BT: seq 0x25 netfn 0x0a cmd 0x48: Message sent to host 37 [ 494.027636927,7] BT: seq 0x25 netfn 0x0a cmd 0x48: IPMI MSG done 23. mod - module information and loading of symbols and debugging data 23.1. SYNOPSIS 1mod -s module [objfile] | -d module | -S [directory] [-D|-t|-r|-R|-o|-g] 23.2. DESCRIPTION 1 With no arguments, this command displays basic information of the currently 2 installed modules, consisting of the module address, name, size, the 3 object file name (if known), and whether the module was compiled with 4 CONFIG_KALLSYMS. 5 6 The arguments are concerned with with the loading or deleting of symbolic 7 and debugging data from a module\u0026#39;s object file. A modules\u0026#39;s object file 8 always contains symbolic data (symbol names and addresses), but contains 9 debugging data only if the module was compiled with the -g CFLAG. In 10 addition, the module may have compiled with CONFIG_KALLSYMS, which means 11 that the module\u0026#39;s symbolic data will have been loaded into the kernel\u0026#39;s 12 address space when it was installed. If the module was not compiled with 13 CONFIG_KALLSYMS, then only the module\u0026#39;s exported symbols will be loaded 14 into the kernel\u0026#39;s address space. Therefore, for the purpose of this 15 command, it should noted that a kernel module may have been compiled in 16 one of following manners: 17 18 1. If the module was built without CONFIG_KALLSYMS and without the -g CFLAG, 19 then the loading of the module\u0026#39;s additional non-exported symbols can 20 be accomplished with this command. 21 2. If the module was built with CONFIG_KALLSYMS, but without the -g CFLAG, 22 then there is no benefit in loading the symbols from the module object 23 file, because all of the module\u0026#39;s symbols will have been loaded into the 24 kernel\u0026#39;s address space when it was installed. 25 3. If the module was built with CONFIG_KALLSYMS and with the the -g CFLAG, 26 then the loading of the module\u0026#39;s debugging data can be accomplished 27 with this command. 28 4. If the module was built without CONFIG_KALLSYMS but with the -g CFLAG, 29 then the loading of the both module\u0026#39;s symbolic and debugging data can 30 be accomplished with this command. 31 32 -s module [objfile] Loads symbolic and debugging data from the object file 33 for the module specified. If no objfile argument is 34 appended, a search will be made for an object file 35 consisting of the module name with a .o or .ko suffix, 36 starting at the /lib/modules/\u0026lt;release\u0026gt; directory on 37 the host system, or if not found there, starting at the 38 directory containing the kernel namelist file. If an 39 objfile argument is appended, then that file will be 40 used. 41 -d module Deletes the symbolic and debugging data of the module 42 specified. 43 -S [directory] Load symbolic and debugging data from the object file 44 for all loaded modules. For each module, a search 45 will be made for an object file consisting of the 46 module name with a .o or .ko suffix, starting at the 47 /lib/modules/\u0026lt;release\u0026gt; directory of the host system, 48 or if not found there, starting at the directory 49 containing the kernel namelist file. If a directory 50 argument is appended, then the search will be restricted 51 to that directory. 52 -D Deletes the symbolic and debugging data of all modules. 53 -t Display the contents of the module\u0026#39;s \u0026#34;taints\u0026#34; bitmask 54 if it is non-zero. When possible, the \u0026#34;taints\u0026#34; bits 55 are translated to symbolic letters of the taint type; 56 otherwise the hexadecimal value is shown. In older 57 kernels, the contents of the \u0026#34;license_gplok\u0026#34; field is 58 displayed in hexadecimal; the field may be either a 59 bitmask or a boolean, depending upon the kernel version. 60 The relevant kernel sources should be consulted for the 61 meaning of the letter(s) or hexadecimal bit value(s). 62 For modules that have a \u0026#34;gpgsig_ok\u0026#34; field that is zero 63 (unsigned), the notation \u0026#34;(U)\u0026#34; is shown. 64 -r Passes the -readnow flag to the embedded gdb module, 65 which will override the two-stage strategy that it uses 66 for reading symbol tables from module object files. 67 -R Reinitialize module data. All currently-loaded symbolic 68 and debugging data will be deleted, and the installed 69 module list will be updated (live system only). 70 -g When used with -s or -S, add a module object\u0026#39;s section 71 start and end addresses to its symbol list. 72 -o Load module symbols with old mechanism. 73 74 If the crash session was invoked with the \u0026#34;--mod \u0026lt;directory\u0026gt;\u0026#34; option, or 75 a CRASH_MODULE_PATH environment variable exists, then /lib/modules/\u0026lt;release\u0026gt; 76 will be overridden as the default directory tree that is searched for module 77 object files. 78 79 After symbolic and debugging data have been loaded, backtraces and text 80 disassembly will be displayed appropriately. Depending upon the processor 81 architecture, data may also printed symbolically with the \u0026#34;p\u0026#34; command; 82 at a minimum, the \u0026#34;rd\u0026#34; command may be used with module data symbols. 83 84 If crash can recognize that the set of modules has changed while running a 85 session on a live kernel, the module data will be reinitialized the next 86 time this command is run; the -r option forces the reinitialization. 23.3. EXAMPLES 1 Display the currently-installed modules: 2 3 crash\u0026gt; mod 4 MODULE NAME SIZE OBJECT FILE 5 c8019000 soundcore 2788 (not loaded) 6 c801b000 soundlow 336 (not loaded) 7 c801d000 sound 59864 (not loaded) 8 c802d000 ad1848 15728 (not loaded) 9 c8032000 uart401 6000 (not loaded) 10 c8035000 cs4232 2472 (not loaded) 11 c8043000 opl3 11048 (not loaded) 12 c8047000 3c59x 18152 (not loaded) 13 c804d000 sunrpc 53796 (not loaded) 14 c805c000 lockd 31528 (not loaded) 15 c8065000 nfsd 151896 (not loaded) 16 c8092000 nfs 29752 (not loaded) 17 18 Display the currently-installed modules on a system where all modules were 19 compiled with CONFIG_KALLSYMS: 20 21 crash\u0026gt; mod 22 MODULE NAME SIZE OBJECT FILE 23 e080d000 jbd 57016 (not loaded) [CONFIG_KALLSYMS] 24 e081e000 ext3 92360 (not loaded) [CONFIG_KALLSYMS] 25 e0838000 usbcore 83168 (not loaded) [CONFIG_KALLSYMS] 26 e0850000 usb-uhci 27532 (not loaded) [CONFIG_KALLSYMS] 27 e085a000 ehci-hcd 20904 (not loaded) [CONFIG_KALLSYMS] 28 e0865000 input 6208 (not loaded) [CONFIG_KALLSYMS] 29 e086a000 hid 22404 (not loaded) [CONFIG_KALLSYMS] 30 e0873000 mousedev 5688 (not loaded) [CONFIG_KALLSYMS] 31 e0878000 keybdev 2976 (not loaded) [CONFIG_KALLSYMS] 32 e08fd000 cdrom 34144 (not loaded) [CONFIG_KALLSYMS] 33 e0909000 ide-cd 35776 (not loaded) [CONFIG_KALLSYMS] 34 e0915000 scsi_mod 117928 (not loaded) [CONFIG_KALLSYMS] 35 e0935000 ide-scsi 12752 (not loaded) [CONFIG_KALLSYMS] 36 e093c000 microcode 5248 (not loaded) [CONFIG_KALLSYMS] 37 e0943000 sr_mod 18136 (not loaded) [CONFIG_KALLSYMS] 38 e0956000 floppy 59056 (not loaded) [CONFIG_KALLSYMS] 39 e0966000 sg 38060 (not loaded) [CONFIG_KALLSYMS] 40 e0971000 ip_tables 16544 (not loaded) [CONFIG_KALLSYMS] 41 e097d000 iptable_filter 2412 (not loaded) [CONFIG_KALLSYMS] 42 e097f000 e1000 76096 (not loaded) [CONFIG_KALLSYMS] 43 e09ba000 autofs 13780 (not loaded) [CONFIG_KALLSYMS] 44 e09c1000 parport 39072 (not loaded) [CONFIG_KALLSYMS] 45 e09ce000 lp 9220 (not loaded) [CONFIG_KALLSYMS] 46 e09d4000 parport_pc 19204 (not loaded) [CONFIG_KALLSYMS] 47 e09e2000 agpgart 59128 (not loaded) [CONFIG_KALLSYMS] 48 e0a1a000 radeon 117156 (not loaded) [CONFIG_KALLSYMS] 49 e2dc7000 sunrpc 91996 (not loaded) [CONFIG_KALLSYMS] 50 e2de1000 lockd 60624 (not loaded) [CONFIG_KALLSYMS] 51 e2df3000 nfs 96880 (not loaded) [CONFIG_KALLSYMS] 52 53 Load the symbolic and debugging data of all modules: 54 55 crash\u0026gt; mod -S 56 MODULE NAME SIZE OBJECT FILE 57 c8019000 soundcore 2788 /lib/modules/2.2.5-15/misc/soundcore.o 58 c801b000 soundlow 336 /lib/modules/2.2.5-15/misc/soundlow.o 59 c801d000 sound 59864 /lib/modules/2.2.5-15/misc/sound.o 60 c802d000 ad1848 15728 /lib/modules/2.2.5-15/misc/ad1848.o 61 c8032000 uart401 6000 /lib/modules/2.2.5-15/misc/uart401.o 62 c8035000 cs4232 2472 /lib/modules/2.2.5-15/misc/cs4232.o 63 c8043000 opl3 11048 /lib/modules/2.2.5-15/misc/opl3.o 64 c8047000 3c59x 18152 /lib/modules/2.2.5-15/net/3c59x.o 65 c804d000 sunrpc 53796 /lib/modules/2.2.5-15/misc/sunrpc.o 66 c805c000 lockd 31528 /lib/modules/2.2.5-15/fs/lockd.o 67 c8065000 nfsd 151896 /lib/modules/2.2.5-15/fs/nfsd.o 68 c8092000 nfs 29752 /lib/modules/2.2.5-15/fs/nfs.o 69 70 Load the symbolic and debugging data of the soundcore module from its 71 known location: 72 73 crash\u0026gt; mod -s soundcore 74 MODULE NAME SIZE OBJECT FILE 75 c8019000 soundcore 2788 /lib/modules/2.2.5-15/misc/soundcore.o 76 77 Delete the current symbolic and debugging data of the soundcore module, 78 and then re-load it from a specified object file: 79 80 crash\u0026gt; mod -d soundcore 81 crash\u0026gt; mod -s soundcore /tmp/soundcore.o 82 MODULE NAME SIZE OBJECT FILE 83 c8019000 soundcore 2788 /tmp/soundcore.o 84 85 After installing a new kernel module on a live system, reinitialize the 86 installed module list: 87 88 crash\u0026gt; !insmod mdacon 89 crash\u0026gt; mod 90 mod: NOTE: modules have changed on this system -- reinitializing 91 MODULE NAME SIZE OBJECT FILE 92 c8019000 soundcore 2788 (not loaded) 93 c801b000 soundlow 336 (not loaded) 94 c801d000 sound 59864 (not loaded) 95 c802d000 ad1848 15728 (not loaded) 96 c8032000 uart401 6000 (not loaded) 97 c8035000 cs4232 2472 (not loaded) 98 c8043000 opl3 11048 (not loaded) 99 c8047000 3c59x 18152 (not loaded) 100 c804d000 sunrpc 53796 (not loaded) 101 c805c000 lockd 31528 (not loaded) 102 c8065000 nfs 29752 (not loaded) 103 c806e000 autofs 9316 (not loaded) 104 c8072000 nfsd 151896 (not loaded) 105 c80a1000 mdacon 3556 (not loaded) 106 107 Display modules that are \u0026#34;tainted\u0026#34;, where in this case 108 where they are proprietary and unsigned: 109 110 crash\u0026gt; mod -t 111 NAME TAINT 112 vxspec P(U) 113 vxportal P(U) 114 fdd P(U) 115 vxfs P(U) 116 vxdmp P(U) 117 vxio P(U) 118 vxglm P(U) 119 vxgms P(U) 120 vxodm P(U) 24. mount - mounted filesystem data 24.1. SYNOPSIS 1mount [-f][-i] [-n pid|task] [mount|vfsmount|superblock|dev|dir|dentry|inode] 24.2. DESCRIPTION 1 This command displays basic information about the currently-mounted 2 filesystems. The per-filesystem dirty inode list or list of open 3 files for the filesystem may also be displayed. 4 5 -f dump dentries and inodes for open files in each filesystem; only 6 supported on kernels prior to Linux 3.13. 7 -i dump all dirty inodes associated with each filesystem; only 8 supported on kernels prior to Linux 2.6.32. 9 10 For kernels supporting namespaces, the -n option may be used to 11 display the mounted filesystems with respect to the namespace of a 12 specified task: 13 14 -n pid a process PID. 15 -n task a hexadecimal task_struct pointer. 16 17 Specific filesystems may be selected using the following forms: 18 19 vfsmount hexadecimal address of a filesystem vfsmount structure. 20 mount hexadecimal address of a filesystem mount structure (Linux 3.3 21 and later). 22 superblock hexadecimal address of a filesystem super_block structure. 23 dev device name of a filesystem. 24 dir directory where a filesystem is mounted. 25 dentry hexadecimal address of an open dentry of a filesystem. 26 inode hexadecimal address of an open inode of a filesystem. 27 28 The first column of the command output displays the filesystem\u0026#39;s vfsmount 29 structure address for kernels prior to Linux 3.3. For Linux 3.3 and later 30 kernels, the first column displays the filesystem\u0026#39;s mount structure address, 31 which contains an embedded vfsmount structure. 24.3. EXAMPLES 1 Display mounted filesystem data: 2 3 crash\u0026gt; mount 4 VFSMOUNT SUPERBLK TYPE DEVNAME DIRNAME 5 c0089ea0 c0088a00 ext2 /dev/root / 6 c0089cf0 c0088c00 proc /proc /proc 7 c0089e10 c0088800 ext2 /dev/sda5 /boot 8 c0089d80 c0088600 ext2 /dev/sda6 /usr 9 c0089f30 c0088400 devpts none /dev/pts 10 c3f4b010 c0088200 ext2 /dev/sda1 /home 11 12 On Linux 3.3 and later kernels, the filesystem\u0026#39;s mount structure address 13 is shown: 14 15 crash\u0026gt; mount 16 MOUNT SUPERBLK TYPE DEVNAME DIRNAME 17 ffff880212fb8200 ffff880212fc0800 rootfs rootfs / 18 ffff88020ffbea00 ffff880212fc2000 proc proc proc 19 ffff880211db7f00 ffff88020e01a800 sysfs sysfs /sys 20 ffff88020ffe1300 ffff880212a40000 devtmpfs devtmpfs /dev 21 ffff88020ff15000 ffff880212bbc800 devpts devpts /dev/pts 22 ffff88020e542800 ffff88020e62b800 tmpfs tmpfs /dev/shm 23 ... 24 25 Display the open files associated with each mounted filesystem: 26 27 crash\u0026gt; mount -f 28 VFSMOUNT SUPERBLK TYPE DEVNAME DIRNAME 29 c7fb2b80 c7fb3200 ext2 /dev/root / 30 OPEN FILES: 31 DENTRY INODE TYPE PATH 32 c6d02200 c6d0f7a0 REG usr/X11R6/lib/libX11.so.6.1 33 c6d02100 c6d0f9e0 REG usr/X11R6/lib/libXext.so.6.3 34 c6d02000 c6d0fc20 REG usr/X11R6/lib/libICE.so.6.3 35 c6d02680 c6d0f320 REG usr/X11R6/bin/xfs 36 c7106580 c70c5440 CHR dev/psaux 37 ... 38 39 Display the dirty inodes associated with each mounted filesystem: 40 41 crash\u0026gt; mount -i 42 VFSMOUNT SUPERBLK TYPE DEVNAME DIRNAME 43 c0089ea0 c0088a00 ext2 /dev/root / 44 DIRTY INODES 45 c7ad4008 46 c2233438 47 c72c4008 48 c7d6b548 49 c3af1a98 50 c7d6b768 51 c3c4e228 52 ... 53 54 Display the mounted filesystem containing inode c5000aa8: 55 56 crash\u0026gt; mount c5000aa8 57 VFSMOUNT SUPERBLK TYPE DEVNAME DIRNAME 58 c0089f30 c0088600 ext2 /dev/sda6 /usr 59 60 Display the mounted filesystem containing inode ffff8801f4245e40: 61 62 crash\u0026gt; mount ffff8801f4245e40 63 MOUNT SUPERBLK TYPE DEVNAME DIRNAME 64 ffff88020ffbea00 ffff880212fc2000 proc proc /proc 25. net - network command 25.1. SYNOPSIS 1net [[-s | -S] [-xd] [-R ref] [pid | task]] [-a] [ -n [pid | task]] [-N addr] 25.2. DESCRIPTION 1 Displays various network related data. 2 3 If no arguments are entered, the list of network devices, names and IP 4 addresses are displayed. For kernels supporting namespaces, the -n option 5 may be used to display the list of network devices with respect to the 6 network namespace of a current context or a task specified by pid or task: 7 8 -n the namespace of the current context. 9 -n pid a process PID. 10 -n task a hexadecimal task_struct pointer. 11 12 The -s and -S options display data with respect to the current context, but 13 may be appended with an argument to show the socket data with respect 14 to a specified task: 15 16 -s display open network socket/sock addresses, their family and type, 17 and for INET and INET6 families, their source and destination 18 addresses and ports. 19 -s pid same as above, for task with process PID pid. 20 -s task same as above, for task with hexadecimal task_struct pointer task. 21 22 -S displays open network socket/sock addresses followed by a dump 23 of both data structures. 24 -S pid same as above, with respect to process PID. 25 -S task same as above, with respect to hexadecimal task_struct pointer. 26 27 The -R option, typically invoked from \u0026#34;foreach net\u0026#34;, and in conjunction 28 with the -s or -S options, searches for references to a socket address, 29 sock address, or a file descriptor; if found, only the referenced fd, socket 30 or sock data will be displayed: 31 32 -R ref socket or sock address, or file descriptor. 33 34 Other options: 35 36 -a display the ARP cache. 37 -N addr translates an IPv4 address expressed as a decimal or hexadecimal 38 value into a standard numbers-and-dots notation. 39 -x override default output format with hexadecimal format. 40 -d override default output format with decimal format. 25.3. EXAMPLES 1 Display the system\u0026#39;s network device list: 2 3 crash\u0026gt; net 4 NET_DEVICE NAME IP ADDRESS(ES) 5 ffff8803741c0000 lo 127.0.0.1 6 fff88037059c0000 eth0 10.226.229.141 7 ffff8803705c0000 eth1 10.226.228.250 8 ffff880374ad6000 usb0 169.254.95.120 9 10 Display the network device list with respect to the network namespace 11 of PID 2618: 12 13 crash\u0026gt; net -n 2618 14 NET_DEVICE NAME IP ADDRESS(ES) 15 ffff880456ee7020 lo 127.0.0.1 16 ffff8804516a1020 eth0 10.1.9.223 17 18 Dump the ARP cache: 19 20 crash\u0026gt; net -a 21 NEIGHBOUR IP ADDRESS HW TYPE HW ADDRESS DEVICE STATE 22 f38d1b00 10.16.64.14 ETHER 00:16:3e:4b:a5:4a eth1 STALE 23 f38d1080 0.0.0.0 UNKNOWN 00 00 00 00 00 00 lo NOARP 24 f38d1bc0 10.16.71.254 ETHER 00:00:0c:07:ac:00 eth1 REACHABLE 25 f38d1200 10.16.64.21 ETHER 00:16:3e:51:d8:09 eth1 REACHABLE 26 27 Display the sockets for PID 2517, using both -s and -S output formats: 28 29 crash\u0026gt; net -s 2517 30 PID: 2517 TASK: c1598000 CPU: 1 COMMAND: \u0026#34;rlogin\u0026#34; 31 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 32 3 c57375dc c1ff1850 INET:STREAM 10.1.8.20-1023 10.1.16.62-513 33 34 crash\u0026gt; net -S 2517 35 PID: 2517 TASK: c1598000 CPU: 1 COMMAND: \u0026#34;rlogin\u0026#34; 36 FD SOCKET SOCK 37 3 c57375dc c1ff1850 38 39 struct socket { 40 state = SS_CONNECTED, 41 flags = 131072, 42 ops = 0xc023f820, 43 inode = 0xc5737540, 44 fasync_list = 0x0, 45 file = 0xc58892b0, 46 sk = 0xc1ff1850, 47 wait = 0xc14d9ed4, 48 type = 1, 49 passcred = 0 \u0026#39;\\000\u0026#39;, 50 tli = 0 \u0026#39;\\000\u0026#39; 51 } 52 struct sock { 53 sklist_next = 0xc1ff12f0, 54 sklist_prev = 0xc216bc00, 55 bind_next = 0x0, 56 bind_pprev = 0xc0918448, 57 daddr = 1041236234, 58 rcv_saddr = 336068874, 59 dport = 258, 60 num = 1023, 61 bound_dev_if = 0, 62 next = 0x0, 63 pprev = 0xc0286dd4, 64 state = 1 \u0026#39;\\001\u0026#39;, 65 zapped = 0 \u0026#39;\\000\u0026#39;, 66 sport = 65283, 67 family = 2, 68 reuse = 0 \u0026#39;\\000\u0026#39;, 69 ... 70 Translate the rcv_saddr from above into dotted-decimal notation: 71 72 crash\u0026gt; net -N 1041236234 73 10.1.16.62 74 75 From \u0026#34;foreach\u0026#34;, find all tasks with references to socket c08ea3cc: 76 77 crash\u0026gt; foreach net -s -R c08ea3cc 78 PID: 2184 TASK: c7026000 CPU: 1 COMMAND: \u0026#34;klines.kss\u0026#34; 79 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 80 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 81 82 PID: 2200 TASK: c670a000 CPU: 1 COMMAND: \u0026#34;kpanel\u0026#34; 83 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 84 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 85 86 PID: 2201 TASK: c648a000 CPU: 1 COMMAND: \u0026#34;kbgndwm\u0026#34; 87 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 88 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 89 90 PID: 19294 TASK: c250a000 CPU: 0 COMMAND: \u0026#34;prefdm\u0026#34; 91 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 92 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 93 94 PID: 2194 TASK: c62dc000 CPU: 1 COMMAND: \u0026#34;kaudioserver\u0026#34; 95 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 96 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 97 98 PID: 2195 TASK: c6684000 CPU: 1 COMMAND: \u0026#34;maudio\u0026#34; 99 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 100 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 101 102 PID: 2196 TASK: c6b58000 CPU: 1 COMMAND: \u0026#34;kwmsound\u0026#34; 103 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 104 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 105 106 PID: 2197 TASK: c6696000 CPU: 0 COMMAND: \u0026#34;kfm\u0026#34; 107 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 108 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 109 110 PID: 2199 TASK: c65ec000 CPU: 0 COMMAND: \u0026#34;krootwm\u0026#34; 111 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 112 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 113 114 PID: 694 TASK: c1942000 CPU: 0 COMMAND: \u0026#34;prefdm\u0026#34; 115 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 116 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 117 118 PID: 698 TASK: c6a2c000 CPU: 1 COMMAND: \u0026#34;X\u0026#34; 119 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 120 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 121 122 PID: 2159 TASK: c4a5a000 CPU: 1 COMMAND: \u0026#34;kwm\u0026#34; 123 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 124 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 26. p - print the value of an expression 26.1. SYNOPSIS 1p [-x|-d][-u] [expression | symbol[:cpuspec]] 26.2. DESCRIPTION 1 This command passes its arguments on to gdb \u0026#34;print\u0026#34; command for evaluation. 2 3 expression an expression to be evaluated. 4 symbol a kernel symbol. 5 :cpuspec CPU specification for a per-cpu symbol: 6 : CPU of the currently selected task. 7 :a[ll] all CPUs. 8 :#[-#][,...] CPU list(s), e.g. \u0026#34;1,3,5\u0026#34;, \u0026#34;1-3\u0026#34;, 9 or \u0026#34;1,3,5-7,10\u0026#34;. 10 -x override default output format with hexadecimal format. 11 -d override default output format with decimal format. 12 -u the expression evaluates to a user address reference. 13 14 The default output format is decimal, but that can be changed at any time 15 with the two built-in aliases \u0026#34;hex\u0026#34; and \u0026#34;dec\u0026#34;. Alternatively, there 16 are two other built-in aliases, \u0026#34;px\u0026#34; and \u0026#34;pd\u0026#34;, which force the command 17 output to be displayed in hexadecimal or decimal, without changing the 18 default mode. 26.3. EXAMPLES 1 Print the contents of jiffies: 2 3 crash\u0026gt; p jiffies 4 jiffies = $6 = 166532620 5 crash\u0026gt; px jiffies 6 jiffies = $7 = 0x9ed174b 7 crash\u0026gt; pd jiffies 8 jiffies = $8 = 166533160 9 10 Print the contents of the vm_area_struct \u0026#34;init_mm\u0026#34;: 11 12 crash\u0026gt; p init_mm 13 init_mm = $5 = { 14 mmap = 0xc022d540, 15 mmap_avl = 0x0, 16 mmap_cache = 0x0, 17 pgd = 0xc0101000, 18 count = { 19 counter = 0x6 20 }, 21 map_count = 0x1, 22 mmap_sem = { 23 count = { 24 counter = 0x1 25 }, 26 waking = 0x0, 27 wait = 0x0 28 }, 29 context = 0x0, 30 start_code = 0xc0000000, 31 end_code = 0xc022b4c8, 32 start_data = 0x0, 33 end_data = 0xc0250388, 34 start_brk = 0x0, 35 brk = 0xc02928d8, 36 start_stack = 0x0, 37 arg_start = 0x0, 38 arg_end = 0x0, 39 env_start = 0x0, 40 env_end = 0x0, 41 rss = 0x0, 42 total_vm = 0x0, 43 locked_vm = 0x0, 44 def_flags = 0x0, 45 cpu_vm_mask = 0x0, 46 swap_cnt = 0x0, 47 swap_address = 0x0, 48 segments = 0x0 49 } 50 51 If a per-cpu symbol is entered as a argument, its data type 52 and all of its per-cpu addresses are displayed: 53 54 crash\u0026gt; p irq_stat 55 PER-CPU DATA TYPE: 56 irq_cpustat_t irq_stat; 57 PER-CPU ADDRESSES: 58 [0]: ffff88021e211540 59 [1]: ffff88021e251540 60 [2]: ffff88021e291540 61 [3]: ffff88021e2d1540 62 63 To display the contents a per-cpu symbol for CPU 1, append 64 a cpu-specifier: 65 66 crash\u0026gt; p irq_stat:1 67 per_cpu(irq_stat, 1) = $29 = { 68 __softirq_pending = 0, 69 __nmi_count = 209034, 70 apic_timer_irqs = 597509876, 71 irq_spurious_count = 0, 72 icr_read_retry_count = 2, 73 x86_platform_ipis = 0, 74 apic_perf_irqs = 209034, 75 apic_irq_work_irqs = 0, 76 irq_resched_count = 264922233, 77 irq_call_count = 7036692, 78 irq_tlb_count = 4750442, 79 irq_thermal_count = 0, 80 irq_threshold_count = 0 81 } 27. ps - display process status information 27.1. SYNOPSIS 1ps [-k|-u|-G|-y policy] [-s] [-p|-c|-t|-[l|m][-C cpu]|-a|-g|-r|-S|-A] 2 [pid | task | command] ... 27.2. DESCRIPTION 1 This command displays process status for selected, or all, processes 2 in the system. If no arguments are entered, the process data is 3 is displayed for all processes. Specific processes may be selected 4 by using the following identifier formats: 5 6 pid a process PID. 7 task a hexadecimal task_struct pointer. 8 command a command name. If a command name is made up of letters that 9 are all numerical values, precede the name string with a \u0026#34;\\\u0026#34;. 10 If the command string is enclosed within \u0026#34;\u0026#39;\u0026#34; characters, then 11 the encompassed string must be a POSIX extended regular expression 12 that will be used to match task names. 13 14 The process list may be further restricted by the following options: 15 16 -k restrict the output to only kernel threads. 17 -u restrict the output to only user tasks. 18 -G display only the thread group leader in a thread group. 19 -y policy restrict the output to tasks having a specified scheduling policy 20 expressed by its integer value or by its (case-insensitive) name; 21 multiple policies may be entered in a comma-separated list: 22 0 or NORMAL 23 1 or FIFO 24 2 or RR 25 3 or BATCH 26 4 or ISO 27 5 or IDLE 28 6 or DEADLINE 29 30 The process identifier types may be mixed. For each task, the following 31 items are displayed: 32 33 1. the process PID. 34 2. the parent process PID. 35 3. the CPU number that the task ran on last. 36 4. the task_struct address or the kernel stack pointer of the process. 37 (see -s option below) 38 5. the task state (RU, IN, UN, ZO, ST, TR, DE, SW, WA, PA, ID, NE). 39 6. the percentage of physical memory being used by this task. 40 7. the virtual address size of this task in kilobytes. 41 8. the resident set size of this task in kilobytes. 42 9. the command name. 43 44 The default output shows the task_struct address of each process under a 45 column titled \u0026#34;TASK\u0026#34;. This can be changed to show the kernel stack 46 pointer under a column titled \u0026#34;KSTACKP\u0026#34;. 47 48 -s replace the TASK column with the KSTACKP column. 49 50 On SMP machines, the active task on each CPU will be highlighted by an 51 angle bracket (\u0026#34;\u0026gt;\u0026#34;) preceding its information. If the crash variable 52 \u0026#34;offline\u0026#34; is set to \u0026#34;hide\u0026#34;, the active task on an offline CPU will 53 be highlighted by a \u0026#34;-\u0026#34; preceding its information. 54 55 Alternatively, information regarding parent-child relationships, 56 per-task time usage data, argument/environment data, thread groups, 57 or resource limits may be displayed: 58 59 -p display the parental hierarchy of selected, or all, tasks. 60 -c display the children of selected, or all, tasks. 61 -t display the task run time, start time, and cumulative user 62 and system times. 63 -l display the task\u0026#39;s last-run timestamp value, using either the 64 task_struct\u0026#39;s last_run value, the task_struct\u0026#39;s timestamp value 65 or the task_struct\u0026#39;s sched_entity last_arrival value, whichever 66 applies, of selected, or all, tasks; the list is sorted with the 67 most recently-run task (with the largest timestamp) shown first, 68 followed by the task\u0026#39;s current state. 69 -m similar to -l, but the timestamp value is translated into days, 70 hours, minutes, seconds, and milliseconds since the task was 71 last run on a cpu. 72 -C cpus only usable with the -l or -m options, dump the timestamp data 73 in per-cpu blocks, where the cpu[s] can be specified as \u0026#34;1,3,5\u0026#34;, 74 \u0026#34;1-3\u0026#34;, \u0026#34;1,3,5-7,10\u0026#34;, \u0026#34;all\u0026#34;, or \u0026#34;a\u0026#34; (shortcut for \u0026#34;all\u0026#34;). 75 -a display the command line arguments and environment strings of 76 selected, or all, user-mode tasks. 77 -g display tasks by thread group, of selected, or all, tasks. 78 -r display resource limits (rlimits) of selected, or all, tasks. 79 -S display a summary consisting of the number of tasks in a task state. 80 -A display only the active task on each cpu. 27.3. EXAMPLES 1 Show the process status of all current tasks: 2 3 crash\u0026gt; ps 4 PID PPID CPU TASK ST %MEM VSZ RSS COMM 5 \u0026gt; 0 0 3 c024c000 RU 0.0 0 0 [swapper] 6 \u0026gt; 0 0 0 c0dce000 RU 0.0 0 0 [swapper] 7 0 0 1 c0fa8000 RU 0.0 0 0 [swapper] 8 \u0026gt; 0 0 2 c009a000 RU 0.0 0 0 [swapper] 9 1 0 1 c0098000 IN 0.0 1096 476 init 10 2 1 1 c0090000 IN 0.0 0 0 [kflushd] 11 3 1 1 c000e000 IN 0.0 0 0 [kpiod] 12 4 1 3 c000c000 IN 0.0 0 0 [kswapd] 13 5 1 1 c0008000 IN 0.0 0 0 [mdrecoveryd] 14 253 1 2 fbc4c000 IN 0.0 1088 376 portmap 15 268 1 2 fbc82000 IN 0.1 1232 504 ypbind 16 274 268 2 fa984000 IN 0.1 1260 556 ypbind 17 321 1 1 fabf6000 IN 0.1 1264 608 syslogd 18 332 1 1 fa9be000 RU 0.1 1364 736 klogd 19 346 1 2 fae88000 IN 0.0 1112 472 atd 20 360 1 2 faeb2000 IN 0.1 1284 592 crond 21 378 1 2 fafd6000 IN 0.1 1236 560 inetd 22 392 1 0 fb710000 IN 0.1 2264 1468 named 23 406 1 3 fb768000 IN 0.1 1284 560 lpd 24 423 1 1 fb8ac000 IN 0.1 1128 528 rpc.statd 25 434 1 2 fb75a000 IN 0.0 1072 376 rpc.rquotad 26 445 1 2 fb4a4000 IN 0.0 1132 456 rpc.mountd 27 460 1 1 fa938000 IN 0.0 0 0 [nfsd] 28 461 1 1 faa86000 IN 0.0 0 0 [nfsd] 29 462 1 0 fac48000 IN 0.0 0 0 [nfsd] 30 463 1 0 fb4ca000 IN 0.0 0 0 [nfsd] 31 464 1 0 fb4c8000 IN 0.0 0 0 [nfsd] 32 465 1 2 fba6e000 IN 0.0 0 0 [nfsd] 33 466 1 1 fba6c000 IN 0.0 0 0 [nfsd] 34 467 1 2 fac04000 IN 0.0 0 0 [nfsd] 35 468 461 2 fa93a000 IN 0.0 0 0 [lockd] 36 469 468 2 fa93e000 IN 0.0 0 0 [rpciod] 37 486 1 0 fab54000 IN 0.1 1596 880 amd 38 523 1 2 fa84e000 IN 0.1 1884 1128 sendmail 39 538 1 0 fa82c000 IN 0.0 1112 416 gpm 40 552 1 3 fa70a000 IN 0.1 2384 1220 httpd 41 556 552 3 fa776000 IN 0.1 2572 1352 httpd 42 557 552 2 faba4000 IN 0.1 2572 1352 httpd 43 558 552 1 fa802000 IN 0.1 2572 1352 httpd 44 559 552 3 fa6ee000 IN 0.1 2572 1352 httpd 45 560 552 3 fa700000 IN 0.1 2572 1352 httpd 46 561 552 0 fa6f0000 IN 0.1 2572 1352 httpd 47 562 552 3 fa6ea000 IN 0.1 2572 1352 httpd 48 563 552 0 fa67c000 IN 0.1 2572 1352 httpd 49 564 552 3 fa674000 IN 0.1 2572 1352 httpd 50 565 552 3 fa66a000 IN 0.1 2572 1352 httpd 51 582 1 2 fa402000 IN 0.2 2968 1916 xfs 52 633 1 2 fa1ec000 IN 0.2 5512 2248 innd 53 636 1 3 fa088000 IN 0.1 2536 804 actived 54 676 1 0 fa840000 IN 0.0 1060 384 mingetty 55 677 1 1 fa590000 IN 0.0 1060 384 mingetty 56 678 1 2 fa3b8000 IN 0.0 1060 384 mingetty 57 679 1 0 fa5b8000 IN 0.0 1060 384 mingetty 58 680 1 1 fa3a4000 IN 0.0 1060 384 mingetty 59 681 1 2 fa30a000 IN 0.0 1060 384 mingetty 60 683 1 3 fa5d8000 IN 0.0 1052 280 update 61 686 378 1 fa3aa000 IN 0.1 2320 1136 in.rlogind 62 687 686 2 f9e52000 IN 0.1 2136 1000 login 63 688 687 0 f9dec000 IN 0.1 1732 976 bash 64 \u0026gt; 700 688 1 f9d62000 RU 0.0 1048 256 gen12 65 66 Display the parental hierarchy of the \u0026#34;crash\u0026#34; process on a live system: 67 68 crash\u0026gt; ps -p 4249 69 PID: 0 TASK: c0252000 CPU: 0 COMMAND: \u0026#34;swapper\u0026#34; 70 PID: 1 TASK: c009a000 CPU: 1 COMMAND: \u0026#34;init\u0026#34; 71 PID: 632 TASK: c73b6000 CPU: 1 COMMAND: \u0026#34;prefdm\u0026#34; 72 PID: 637 TASK: c5a4a000 CPU: 1 COMMAND: \u0026#34;prefdm\u0026#34; 73 PID: 649 TASK: c179a000 CPU: 0 COMMAND: \u0026#34;kwm\u0026#34; 74 PID: 683 TASK: c1164000 CPU: 0 COMMAND: \u0026#34;kfm\u0026#34; 75 PID: 1186 TASK: c165a000 CPU: 0 COMMAND: \u0026#34;xterm\u0026#34; 76 PID: 1188 TASK: c705e000 CPU: 1 COMMAND: \u0026#34;bash\u0026#34; 77 PID: 4249 TASK: c6b9a000 CPU: 0 COMMAND: \u0026#34;crash\u0026#34; 78 79 Display all children of the \u0026#34;kwm\u0026#34; window manager: 80 81 crash\u0026gt; ps -c kwm 82 PID: 649 TASK: c179a000 CPU: 0 COMMAND: \u0026#34;kwm\u0026#34; 83 PID: 682 TASK: c2d58000 CPU: 1 COMMAND: \u0026#34;kwmsound\u0026#34; 84 PID: 683 TASK: c1164000 CPU: 1 COMMAND: \u0026#34;kfm\u0026#34; 85 PID: 685 TASK: c053c000 CPU: 0 COMMAND: \u0026#34;krootwm\u0026#34; 86 PID: 686 TASK: c13fa000 CPU: 0 COMMAND: \u0026#34;kpanel\u0026#34; 87 PID: 687 TASK: c13f0000 CPU: 1 COMMAND: \u0026#34;kbgndwm\u0026#34; 88 89 Display all threads in a firefox session: 90 91 crash\u0026gt; ps firefox 92 PID PPID CPU TASK ST %MEM VSZ RSS COMM 93 21273 21256 6 ffff81003ec15080 IN 46.3 1138276 484364 firefox 94 21276 21256 6 ffff81003f49e7e0 IN 46.3 1138276 484364 firefox 95 21280 21256 0 ffff81003ec1d7e0 IN 46.3 1138276 484364 firefox 96 21286 21256 6 ffff81000b0d1820 IN 46.3 1138276 484364 firefox 97 21287 21256 2 ffff81000b0d10c0 IN 46.3 1138276 484364 firefox 98 26975 21256 5 ffff81003b5c1820 IN 46.3 1138276 484364 firefox 99 26976 21256 5 ffff810023232820 IN 46.3 1138276 484364 firefox 100 26977 21256 4 ffff810021a11820 IN 46.3 1138276 484364 firefox 101 26978 21256 5 ffff810003159040 IN 46.3 1138276 484364 firefox 102 26979 21256 5 ffff81003a058820 IN 46.3 1138276 484364 firefox 103 104 Display only the thread group leader in the firefox session: 105 106 crash\u0026gt; ps -G firefox 107 PID PPID CPU TASK ST %MEM VSZ RSS COMM 108 21273 21256 0 ffff81003ec15080 IN 46.3 1138276 484364 firefox 109 110 Show the time usage data for pid 10318: 111 112 crash\u0026gt; ps -t 10318 113 PID: 10318 TASK: f7b85550 CPU: 5 COMMAND: \u0026#34;bash\u0026#34; 114 RUN TIME: 1 days, 01:35:32 115 START TIME: 5209 116 UTIME: 95 117 STIME: 57 118 119 Show the process status of PID 1, task f9dec000, and all nfsd tasks: 120 121 crash\u0026gt; ps 1 f9dec000 nfsd 122 PID PPID CPU TASK ST %MEM VSZ RSS COMM 123 1 0 1 c0098000 IN 0.0 1096 476 init 124 688 687 0 f9dec000 IN 0.1 1732 976 bash 125 460 1 1 fa938000 IN 0.0 0 0 [nfsd] 126 461 1 1 faa86000 IN 0.0 0 0 [nfsd] 127 462 1 0 fac48000 IN 0.0 0 0 [nfsd] 128 463 1 0 fb4ca000 IN 0.0 0 0 [nfsd] 129 464 1 0 fb4c8000 IN 0.0 0 0 [nfsd] 130 465 1 2 fba6e000 IN 0.0 0 0 [nfsd] 131 466 1 1 fba6c000 IN 0.0 0 0 [nfsd] 132 467 1 2 fac04000 IN 0.0 0 0 [nfsd] 133 134 Show all kernel threads: 135 136 crash\u0026gt; ps -k 137 PID PPID CPU TASK ST %MEM VSZ RSS COMM 138 0 0 1 c0fac000 RU 0.0 0 0 [swapper] 139 0 0 0 c0252000 RU 0.0 0 0 [swapper] 140 2 1 1 c0fa0000 IN 0.0 0 0 [kflushd] 141 3 1 1 c03de000 IN 0.0 0 0 [kpiod] 142 4 1 1 c03dc000 IN 0.0 0 0 [kswapd] 143 5 1 0 c0092000 IN 0.0 0 0 [mdrecoveryd] 144 336 1 0 c4a9a000 IN 0.0 0 0 [rpciod] 145 337 1 0 c4830000 IN 0.0 0 0 [lockd] 146 487 1 1 c4ba6000 IN 0.0 0 0 [nfsd] 147 488 1 0 c18c6000 IN 0.0 0 0 [nfsd] 148 489 1 0 c0cac000 IN 0.0 0 0 [nfsd] 149 490 1 0 c056a000 IN 0.0 0 0 [nfsd] 150 491 1 0 c0860000 IN 0.0 0 0 [nfsd] 151 492 1 1 c0254000 IN 0.0 0 0 [nfsd] 152 493 1 0 c0a86000 IN 0.0 0 0 [nfsd] 153 494 1 0 c0968000 IN 0.0 0 0 [nfsd] 154 155 Display a summary consisting of the number of tasks in a task state: 156 157 crash\u0026gt; ps -S 158 RU: 5 159 IN: 259 160 UN: 31 161 ZO: 1 162 163 Display only the active task, on each cpu: 164 165 crash\u0026gt; ps -A 166 PID PPID CPU TASK ST %MEM VSZ RSS COMM 167 \u0026gt; 10 2 1 ffff880212969710 IN 0.0 0 0 [migration/1] 168 \u0026gt; 0 0 3 ffff884026d43520 RU 0.0 0 0 [swapper] 169 \u0026gt; 6582 1 2 ffff880f49c52040 RU 0.0 42202472 33368 oracle 170 \u0026gt; 9497 1 0 ffff880549ec2ab0 RU 0.0 42314692 138664 oracle 171 172 Show all tasks sorted by their task_struct\u0026#39;s last_run, timestamp, or 173 sched_entity last_arrival timestamp value, whichever applies: 174 175 crash\u0026gt; ps -l 176 [20811245123] [IN] PID: 37 TASK: f7153030 CPU: 2 COMMAND: \u0026#34;events/2\u0026#34; 177 [20811229959] [IN] PID: 1756 TASK: f2a5a570 CPU: 2 COMMAND: \u0026#34;ntpd\u0026#34; 178 [20800696644] [IN] PID: 1456 TASK: f2b1f030 CPU: 4 COMMAND: \u0026#34;irqbalance\u0026#34; 179 [20617047229] [IN] PID: 2324 TASK: f57f9570 CPU: 5 COMMAND: \u0026#34;flush-253:0\u0026#34; 180 [20617029209] [IN] PID: 49 TASK: f7167030 CPU: 4 COMMAND: \u0026#34;bdi-default\u0026#34; 181 [20438025365] [IN] PID: 345 TASK: f55c7ab0 CPU: 3 COMMAND: \u0026#34;mpt_poll_0\u0026#34; 182 [20103026046] [IN] PID: 728 TASK: f72ba570 CPU: 3 COMMAND: \u0026#34;edac-poller\u0026#34; 183 [20000189409] [IN] PID: 35 TASK: f7153ab0 CPU: 0 COMMAND: \u0026#34;events/0\u0026#34; 184 [20000179905] [IN] PID: 48 TASK: f7167570 CPU: 0 COMMAND: \u0026#34;sync_supers\u0026#34; 185 [19997120354] [IN] PID: 36 TASK: f7153570 CPU: 1 COMMAND: \u0026#34;events/1\u0026#34; 186 [19991059209] [IN] PID: 38 TASK: f715fab0 CPU: 3 COMMAND: \u0026#34;events/3\u0026#34; 187 [19988091608] [IN] PID: 39 TASK: f715f570 CPU: 4 COMMAND: \u0026#34;events/4\u0026#34; 188 [19985076530] [IN] PID: 40 TASK: f715f030 CPU: 5 COMMAND: \u0026#34;events/5\u0026#34; 189 [19982019106] [IN] PID: 41 TASK: f7161ab0 CPU: 6 COMMAND: \u0026#34;events/6\u0026#34; 190 [19982016294] [IN] PID: 29 TASK: f7109ab0 CPU: 6 COMMAND: \u0026#34;ksoftirqd/6\u0026#34; 191 [19838402345] [RU] PID: 2331 TASK: f297f570 CPU: 7 COMMAND: \u0026#34;bash\u0026#34; 192 [19837129436] [IN] PID: 2326 TASK: f2ad5030 CPU: 6 COMMAND: \u0026#34;sshd\u0026#34; 193 [19289476417] [IN] PID: 1772 TASK: f5665570 CPU: 5 COMMAND: \u0026#34;sendmail\u0026#34; 194 ... 195 196 Show the most-recently run tasks on cpu 0 using both the -l and the -m 197 options: 198 199 crash\u0026gt; ps -m -C0 200 CPU: 0 201 [ 0 00:00:00.003] [RU] PID: 1205 TASK: dee03f20 CPU: 0 COMMAND: \u0026#34;insmod\u0026#34; 202 [ 0 00:00:00.006] [RU] PID: 770 TASK: df9e9940 CPU: 0 COMMAND: \u0026#34;rsyslogd\u0026#34; 203 [ 0 00:00:00.009] [IN] PID: 603 TASK: df9bcbc0 CPU: 0 COMMAND: \u0026#34;udevd\u0026#34; 204 [ 0 00:00:00.010] [IN] PID: 348 TASK: df9ecbc0 CPU: 0 COMMAND: \u0026#34;udevd\u0026#34; 205 [ 0 00:00:00.013] [IN] PID: 934 TASK: df9171a0 CPU: 0 COMMAND: \u0026#34;hald\u0026#34; 206 [ 0 00:00:00.023] [IN] PID: 6 TASK: df443f20 CPU: 0 COMMAND: \u0026#34;events/0\u0026#34; 207 [ 0 00:00:00.029] [IN] PID: 15 TASK: df46b280 CPU: 0 COMMAND: \u0026#34;kblockd/0\u0026#34; 208 [ 0 00:00:00.101] [IN] PID: 1168 TASK: dee01940 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 209 [ 0 00:00:01.404] [IN] PID: 272 TASK: dfa48ca0 CPU: 0 COMMAND: \u0026#34;flush-8:0\u0026#34; 210 ... 211 212 crash\u0026gt; ps -l -C0 213 CPU: 0 214 [137146164748] [RU] PID: 1205 TASK: dee03f20 CPU: 0 COMMAND: \u0026#34;insmod\u0026#34; 215 [137142534372] [RU] PID: 770 TASK: df9e9940 CPU: 0 COMMAND: \u0026#34;rsyslogd\u0026#34; 216 [137140168469] [IN] PID: 603 TASK: df9bcbc0 CPU: 0 COMMAND: \u0026#34;udevd\u0026#34; 217 [137138826427] [IN] PID: 348 TASK: df9ecbc0 CPU: 0 COMMAND: \u0026#34;udevd\u0026#34; 218 [137135214599] [IN] PID: 934 TASK: df9171a0 CPU: 0 COMMAND: \u0026#34;hald\u0026#34; 219 [137125651275] [IN] PID: 6 TASK: df443f20 CPU: 0 COMMAND: \u0026#34;events/0\u0026#34; 220 [137119564815] [IN] PID: 15 TASK: df46b280 CPU: 0 COMMAND: \u0026#34;kblockd/0\u0026#34; 221 [137047715027] [IN] PID: 1168 TASK: dee01940 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 222 [135744209052] [IN] PID: 272 TASK: dfa48ca0 CPU: 0 COMMAND: \u0026#34;flush-8:0\u0026#34; 223 ... 224 225 Show the kernel stack pointer of each user task: 226 227 crash\u0026gt; ps -us 228 PID PPID CPU KSTACKP ST %MEM VSZ RSS COMM 229 1 0 0 c009bedc IN 0.0 1096 52 init 230 239 1 0 c15e7ed8 IN 0.2 1332 224 pump 231 280 1 1 c7cbdedc IN 0.2 1092 208 portmap 232 295 1 0 c7481edc IN 0.0 1232 0 ypbind 233 301 295 0 c7c7bf28 IN 0.1 1260 124 ypbind 234 376 1 1 c5053f28 IN 0.0 1316 40 automount 235 381 1 0 c34ddf28 IN 0.2 1316 224 automount 236 391 1 1 c2777f28 IN 0.2 1316 224 automount 237 ... 238 239 Display the argument and environment data for the automount task: 240 241 crash\u0026gt; ps -a automount 242 PID: 3948 TASK: f722ee30 CPU: 0 COMMAND: \u0026#34;automount\u0026#34; 243 ARG: /usr/sbin/automount --timeout=60 /net program /etc/auto.net 244 ENV: SELINUX_INIT=YES 245 CONSOLE=/dev/console 246 TERM=linux 247 INIT_VERSION=sysvinit-2.85 248 PATH=/sbin:/usr/sbin:/bin:/usr/bin 249 LC_MESSAGES=en_US 250 RUNLEVEL=3 251 runlevel=3 252 PWD=/ 253 LANG=ja_JP.UTF-8 254 PREVLEVEL=N 255 previous=N 256 HOME=/ 257 SHLVL=2 258 _=/usr/sbin/automount 259 260 Display the tasks in the thread group containing task c20ab0b0: 261 262 crash\u0026gt; ps -g c20ab0b0 263 PID: 6425 TASK: f72f50b0 CPU: 0 COMMAND: \u0026#34;firefox-bin\u0026#34; 264 PID: 6516 TASK: f71bf1b0 CPU: 0 COMMAND: \u0026#34;firefox-bin\u0026#34; 265 PID: 6518 TASK: d394b930 CPU: 0 COMMAND: \u0026#34;firefox-bin\u0026#34; 266 PID: 6520 TASK: c20aa030 CPU: 0 COMMAND: \u0026#34;firefox-bin\u0026#34; 267 PID: 6523 TASK: c20ab0b0 CPU: 0 COMMAND: \u0026#34;firefox-bin\u0026#34; 268 PID: 6614 TASK: f1f181b0 CPU: 0 COMMAND: \u0026#34;firefox-bin\u0026#34; 269 270 Display the tasks in the thread group for each instance of the 271 program named \u0026#34;multi-thread\u0026#34;: 272 273 crash\u0026gt; ps -g multi-thread 274 PID: 2522 TASK: 1003f0dc7f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 275 PID: 2523 TASK: 10037b13030 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 276 PID: 2524 TASK: 1003e064030 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 277 PID: 2525 TASK: 1003e13a7f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 278 279 PID: 2526 TASK: 1002f82b7f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 280 PID: 2527 TASK: 1003e1737f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 281 PID: 2528 TASK: 10035b4b7f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 282 PID: 2529 TASK: 1003f0c37f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 283 PID: 2530 TASK: 10035597030 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 284 PID: 2531 TASK: 100184be7f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 285 286 Display the resource limits of \u0026#34;bash\u0026#34; task 13896: 287 288 crash\u0026gt; ps -r 13896 289 PID: 13896 TASK: cf402000 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 290 RLIMIT CURRENT MAXIMUM 291 CPU (unlimited) (unlimited) 292 FSIZE (unlimited) (unlimited) 293 DATA (unlimited) (unlimited) 294 STACK 10485760 (unlimited) 295 CORE (unlimited) (unlimited) 296 RSS (unlimited) (unlimited) 297 NPROC 4091 4091 298 NOFILE 1024 1024 299 MEMLOCK 4096 4096 300 AS (unlimited) (unlimited) 301 LOCKS (unlimited) (unlimited) 302 303 Search for task names matching a POSIX regular expression: 304 305 crash\u0026gt; ps \u0026#39;migration*\u0026#39; 306 PID PPID CPU TASK ST %MEM VSZ RSS COMM 307 8 2 0 ffff8802128a2e20 IN 0.0 0 0 [migration/0] 308 10 2 1 ffff880212969710 IN 0.0 0 0 [migration/1] 309 15 2 2 ffff880212989710 IN 0.0 0 0 [migration/2] 310 20 2 3 ffff8802129a9710 IN 0.0 0 0 [migration/3] 28. pte - translate a page table entry 28.1. SYNOPSIS 1pte contents ... 28.2. DESCRIPTION 1 This command translates the hexadecimal contents of a PTE into its physical 2 page address and page bit settings. If the PTE references a swap location, 3 the swap device and offset are displayed. 28.3. EXAMPLES 1 2 crash\u0026gt; pte d8e067 3 PTE PHYSICAL FLAGS 4 d8e067 d8e000 (PRESENT|RW|USER|ACCESSED|DIRTY) 5 6 crash\u0026gt; pte 13f600 7 PTE SWAP OFFSET 8 13f600 /dev/hda2 5104 29. ptob - page to bytes 29.1. SYNOPSIS 1ptob page_number ... 29.2. DESCRIPTION 1 This command translates a page frame number to its byte value. 29.3. EXAMPLES 1 crash\u0026gt; ptob 512a 2 512a: 512a000 30. ptov - physical to virtual per-cpu to virtual 30.1. SYNOPSIS 1ptov [address | offset:cpuspec] 30.2. DESCRIPTION 1 This command translates a hexadecimal physical address into a kernel 2 virtual address. Alternatively, a hexadecimal per-cpu offset and 3 cpu specifier will be translated into kernel virtual addresses for 4 each cpu specified. 5 6 address a physical address 7 offset:cpuspec a per-cpu offset with a CPU specifier: 8 : CPU of the currently selected task. 9 :a[ll] all CPUs. 10 :#[-#][,...] CPU list(s), e.g. \u0026#34;1,3,5\u0026#34;, \u0026#34;1-3\u0026#34;, 11 or \u0026#34;1,3,5-7,10\u0026#34;. 30.3. EXAMPLES 1 Translate physical address 56e000 into a kernel virtual address: 2 3 crash\u0026gt; ptov 56e000 4 VIRTUAL PHYSICAL 5 ffff88000056e000 56e000 6 7 Translate per-cpu offset b0c0 into a kernel virtual address for 8 all cpus: 9 10 crash\u0026gt; ptov b0c0:a 11 PER-CPU OFFSET: b0c0 12 CPU VIRTUAL 13 [0] ffff88021e20b0c0 14 [1] ffff88021e24b0c0 15 [2] ffff88021e28b0c0 16 [3] ffff88021e2cb0c0 31. q - exit this session 31.1. SYNOPSIS 1q 31.2. DESCRIPTION 1 Bail out of the current crash session. 31.3. NOTE 1 This command is equivalent to the \u0026#34;exit\u0026#34; command. 32. rd - read memory 32.1. SYNOPSIS 1rd [-adDsSupxmfNR][-8|-16|-32|-64][-o offs][-e addr][-r file][address|symbol] 2 [count] 32.2. DESCRIPTION 1 This command displays the contents of memory, with the output formatted 2 in several different manners. The starting address may be entered either 3 symbolically or by address. The default output size is the size of a long 4 data type, and the default output format is hexadecimal. When hexadecimal 5 output is used, the output will be accompanied by an ASCII translation. 6 7 -p address argument is a physical address. 8 -u address argument is a user virtual address; only required on 9 processors with common user and kernel virtual address spaces. 10 -m address argument is a xen host machine address. 11 -f address argument is a dumpfile offset. 12 -d display output in signed decimal format (default is hexadecimal). 13 -D display output in unsigned decimal format (default is hexadecimal). 14 -s displays output symbolically when appropriate. 15 -S[S] displays output symbolically when appropriate; if the memory 16 contents reference a slab cache object, the name of the slab cache 17 will be displayed in brackets. If -S is entered twice, and the 18 memory contents reference a slab cache object, both the memory 19 contents and the name of the slab cache will be displayed in 20 brackets. 21 -x do not display ASCII translation at end of each line. 22 -8 display output in 8-bit values. 23 -16 display output in 16-bit values. 24 -32 display output in 32-bit values (default on 32-bit machines). 25 -64 display output in 64-bit values (default on 64-bit machines). 26 -a display output in ASCII characters if the memory contains printable 27 ASCII characters; if no count argument is entered, stop at the first 28 non-printable character. 29 -N display output in network byte order (only valid for 16- and 32-bit 30 values) 31 -R display memory in reverse order; memory will be displayed up to and 32 including the address argument, requiring the count argument to be 33 greater than 1 in order to display memory before the specified 34 address. 35 -o offs offset the starting address by offs. 36 -e addr display memory until reaching specified ending hexadecimal address. 37 -r file dumps raw data to the specified output file; the number of bytes that 38 are copied to the file must be specified either by a count argument 39 or by the -e option. 40 address starting hexadecimal address: 41 1 the default presumes a kernel virtual address. 42 2. -p specifies a physical address. 43 3. -u specifies a user virtual address, but is only necessary on 44 processors with common user and kernel virtual address spaces. 45 symbol symbol of starting address to read. 46 count number of memory locations to display; if entered, it must be the 47 last argument on the command line; if not entered, the count defaults 48 to 1, or unlimited for -a; when used with the -r option, it is the 49 number of bytes to be written to the file. 32.3. EXAMPLES 1 Display the kernel\u0026#39;s version string: 2 3 crash\u0026gt; rd -a linux_banner 4 c082a020: Linux version 2.6.32-119.el6.i686 (mockbuild@hs20-bc2-4.buil 5 c082a05c: d.redhat.com) (gcc version 4.4.4 20100726 (Red Hat 4.4.4-13) 6 c082a098: (GCC) ) #1 SMP Tue Mar 1 18:16:57 EST 2011 7 8 Display the same block of memory, first without symbols, again 9 with symbols, and then with symbols and slab cache references: 10 11 crash\u0026gt; rd f6e31f70 28 12 f6e31f70: f6e31f6c f779c180 c04a4032 00a9dd40 l.....y.2@J.@... 13 f6e31f80: 00000fff c0472da0 f6e31fa4 f779c180 .....-G.......y. 14 f6e31f90: fffffff7 00a9b70f f6e31000 c04731ee .............1G. 15 f6e31fa0: f6e31fa4 00000000 00000000 00000000 ................ 16 f6e31fb0: 00000000 00a9dd40 c0404f17 00000000 ....@....O@..... 17 f6e31fc0: 00a9dd40 00000fff 00a9dd40 00a9b70f @.......@....... 18 f6e31fd0: bf9e2718 ffffffda c040007b 0000007b .\u0026#39;......{.@.{... 19 crash\u0026gt; rd -s f6e31f70 28 20 f6e31f70: f6e31f6c f779c180 kmsg_read 00a9dd40 21 f6e31f80: 00000fff vfs_read+159 f6e31fa4 f779c180 22 f6e31f90: fffffff7 00a9b70f f6e31000 sys_read+60 23 f6e31fa0: f6e31fa4 00000000 00000000 00000000 24 f6e31fb0: 00000000 00a9dd40 syscall_call+7 00000000 25 f6e31fc0: 00a9dd40 00000fff 00a9dd40 00a9b70f 26 f6e31fd0: bf9e2718 ffffffda startup_32+123 0000007b 27 crash\u0026gt; rd -S f6e31f70 28 28 f6e31f70: [size-4096] [filp] kmsg_read 00a9dd40 29 f6e31f80: 00000fff vfs_read+159 [size-4096] [filp] 30 f6e31f90: fffffff7 00a9b70f [size-4096] sys_read+60 31 f6e31fa0: [size-4096] 00000000 00000000 00000000 32 f6e31fb0: 00000000 00a9dd40 syscall_call+7 00000000 33 f6e31fc0: 00a9dd40 00000fff 00a9dd40 00a9b70f 34 f6e31fd0: bf9e2718 ffffffda startup_32+123 0000007b 35 crash\u0026gt; rd -SS f6e31f70 28 36 f6e31f70: [f6e31f6c:size-4096] [f779c180:filp] kmsg_read 00a9dd40 37 f6e31f80: 00000fff vfs_read+159 [f6e31fa4:size-4096] [f779c180:filp] 38 f6e31f90: fffffff7 00a9b70f [f6e31000:size-4096] sys_read+60 39 f6e31fa0: [f6e31fa4:size-4096] 00000000 00000000 00000000 40 f6e31fb0: 00000000 00a9dd40 syscall_call+7 00000000 41 f6e31fc0: 00a9dd40 00000fff 00a9dd40 00a9b70f 42 f6e31fd0: bf9e2718 ffffffda startup_32+123 0000007b 43 44 Read jiffies in hexadecimal and decimal format: 45 46 crash\u0026gt; rd jiffies 47 c0213ae0: 0008cc3a :... 48 49 crash\u0026gt; rd -d jiffies 50 c0213ae0: 577376 51 52 Access the same memory in different sizes: 53 54 crash\u0026gt; rd -64 kernel_version 55 c0226a6c: 35312d352e322e32 2.2.5-15 56 57 crash\u0026gt; rd -32 kernel_version 2 58 c0226a6c: 2e322e32 35312d35 2.2.5-15 59 60 crash\u0026gt; rd -16 kernel_version 4 61 c0226a6c: 2e32 2e32 2d35 3531 2.2.5-15 62 63 crash\u0026gt; rd -8 kernel_version 8 64 c0226a6c: 32 2e 32 2e 35 2d 31 35 2.2.5-15 65 66 Read the range of memory from c009bf2c to c009bf60: 67 68 crash\u0026gt; rd c009bf2c -e c009bf60 69 c009bf2c: c009bf64 c01328c3 c009bf64 c0132838 d....(..d...8(.. 70 c009bf3c: 0000002a 00000004 c57d77e8 00000104 *........w}..... 71 c009bf4c: 0000000b c009a000 7fffffff 00000000 ................ 72 c009bf5c: 00000000 .... 33. repeat - repeat a command 33.1. SYNOPSIS 1repeat [-seconds] command 33.2. DESCRIPTION 1 This command repeats a command indefinitely, optionally delaying a given 2 number of seconds between each command execution. 3 4 -seconds The number of seconds to delay between command executions. 5 This option must precede the command name to be executed. 6 7 Command execution may be stopped with CTRL-C, or if scrolling is in effect, 8 by entering \u0026#34;q\u0026#34;. This command is meant for use on a live system; it is 9 hard to conceive of a reason to use it when debugging a crash dump. 33.3. EXAMPLES 1 Display the value of jiffies once per second: 2 3 crash\u0026gt; repeat -1 p jiffies 4 jiffies = $1 = 155551079 5 jiffies = $2 = 155551180 6 jiffies = $3 = 155551281 7 jiffies = $4 = 155551382 8 jiffies = $5 = 155551483 9 jiffies = $6 = 155551584 10 jiffies = $7 = 155551685 11 jiffies = $8 = 155551786 12 jiffies = $9 = 155551887 13 jiffies = $10 = 155551988 14 jiffies = $11 = 155552089 15 jiffies = $12 = 155552190 16 jiffies = $13 = 155552291 17 jiffies = $14 = 155552392 18 jiffies = $15 = 155552493 19 jiffies = $16 = 155552594 20 jiffies = $17 = 155552695 21 jiffies = $18 = 155552796 22 ... 34. runq - run queue 34.1. SYNOPSIS 1runq [-t] [-T] [-m] [-g] [-c cpu(s)] 34.2. DESCRIPTION 1 With no argument, this command displays the tasks on the run queues 2 of each cpu. 3 4 -t Display the timestamp information of each cpu\u0026#39;s runqueue, which is the 5 rq.clock, rq.most_recent_timestamp or rq.timestamp_last_tick value, 6 whichever applies; following each cpu timestamp is the last_run or 7 timestamp value of the active task on that cpu, whichever applies, 8 along with the task identification. 9 -T Display the time lag of each CPU relative to the most recent runqueue 10 timestamp. 11 -m Display the amount of time that the active task on each cpu has been 12 running, expressed in a format consisting of days, hours, minutes, 13 seconds and milliseconds. 14 -g Display tasks hierarchically by task_group. The task_group line shows 15 the task_group address, the cfs_rq or rt_rq address, the task_group 16 name (if any), and whether the task_group is throttled. 17 -c cpu restrict the output to the run queue data of one or more CPUs, 18 which can be specified using the format \u0026#34;3\u0026#34;, \u0026#34;1,8,9\u0026#34;, \u0026#34;1-23\u0026#34;, 19 or \u0026#34;1,8,9-14\u0026#34;. 34.3. EXAMPLES 1 Display the tasks on an O(1) scheduler run queue: 2 3 crash\u0026gt; runq 4 CPU 0 RUNQUEUE: ffff880001cdb460 5 CURRENT: PID: 2739 TASK: ffff8800320fa7e0 COMMAND: \u0026#34;bash\u0026#34; 6 ACTIVE PRIO_ARRAY: ffff880001cdb4d8 7 [115] PID: 2739 TASK: ffff8800320fa7e0 COMMAND: \u0026#34;bash\u0026#34; 8 PID: 1776 TASK: ffff88003217d820 COMMAND: \u0026#34;syslogd\u0026#34; 9 EXPIRED PRIO_ARRAY: ffff880001cdbdb8 10 [no tasks queued] 11 12 CPU 1 RUNQUEUE: ffff880001ce3460 13 CURRENT: PID: 1779 TASK: ffff88003207a860 COMMAND: \u0026#34;klogd\u0026#34; 14 ACTIVE PRIO_ARRAY: ffff880001ce34d8 15 [115] PID: 1779 TASK: ffff88003207a860 COMMAND: \u0026#34;klogd\u0026#34; 16 EXPIRED PRIO_ARRAY: ffff880001ce3db8 17 [no tasks queued] 18 19 Display the tasks on a CFS run queue: 20 21 crash\u0026gt; runq 22 CPU 0 RUNQUEUE: ffff8800090436c0 23 CURRENT: PID: 588 TASK: ffff88007e4877a0 COMMAND: \u0026#34;udevd\u0026#34; 24 RT PRIO_ARRAY: ffff8800090437c8 25 [no tasks queued] 26 CFS RB_ROOT: ffff880009043740 27 [118] PID: 2110 TASK: ffff88007d470860 COMMAND: \u0026#34;check-cdrom.sh\u0026#34; 28 [118] PID: 2109 TASK: ffff88007f1247a0 COMMAND: \u0026#34;check-cdrom.sh\u0026#34; 29 [118] PID: 2114 TASK: ffff88007f20e080 COMMAND: \u0026#34;udevd\u0026#34; 30 31 CPU 1 RUNQUEUE: ffff88000905b6c0 32 CURRENT: PID: 2113 TASK: ffff88007e8ac140 COMMAND: \u0026#34;udevd\u0026#34; 33 RT PRIO_ARRAY: ffff88000905b7c8 34 [no tasks queued] 35 CFS RB_ROOT: ffff88000905b740 36 [118] PID: 2092 TASK: ffff88007d7a4760 COMMAND: \u0026#34;MAKEDEV\u0026#34; 37 [118] PID: 1983 TASK: ffff88007e59f140 COMMAND: \u0026#34;udevd\u0026#34; 38 [118] PID: 2064 TASK: ffff88007e40f7a0 COMMAND: \u0026#34;udevd\u0026#34; 39 [115] PID: 2111 TASK: ffff88007e4278a0 COMMAND: \u0026#34;kthreadd\u0026#34; 40 41 Display run queue timestamp data: 42 43 crash\u0026gt; runq -t 44 CPU 0: 2680990637359 45 2680986653330 PID: 28228 TASK: ffff880037ca2ac0 COMMAND: \u0026#34;loop\u0026#34; 46 CPU 1: 2680940618478 47 2680940618478 PID: 28167 TASK: ffff880078130040 COMMAND: \u0026#34;bash\u0026#34; 48 CPU 2: 2680990763425 49 2680986785772 PID: 28227 TASK: ffff8800787780c0 COMMAND: \u0026#34;loop\u0026#34; 50 CPU 3: 2680990954469 51 2680986059540 PID: 28226 TASK: ffff880078778b00 COMMAND: \u0026#34;loop\u0026#34; 52 53 Display the amount of time the active task on each cpu has been running: 54 55 crash\u0026gt; runq -m 56 CPU 0: [0 00:00:00.014] PID: 5275 TASK: f5dbcaa0 COMMAND: \u0026#34;sh\u0026#34; 57 CPU 1: [0 00:00:00.002] PID: 5203 TASK: f5c7baa0 COMMAND: \u0026#34;cat\u0026#34; 58 CPU 2: [0 00:00:00.014] PID: 7971 TASK: f5c6c550 COMMAND: \u0026#34;khelper\u0026#34; 59 CPU 3: [0 00:00:00.002] PID: 0 TASK: f4ccd000 COMMAND: \u0026#34;swapper\u0026#34; 60 61 Display tasks hierarchically by task_group: 62 63 crash\u0026gt; runq -g 64 CPU 0 65 CURRENT: PID: 14734 TASK: ffff88010626f500 COMMAND: \u0026#34;sh\u0026#34; 66 ROOT_TASK_GROUP: ffffffff81ed93e0 RT_RQ: ffff880028216808 67 [ 0] TASK_GROUP: ffff88022c6bbc00 RT_RQ: ffff880139fc9800 (THROTTLED) 68 [ 0] PID: 14750 TASK: ffff88013a4dd540 COMMAND: \u0026#34;rtloop99\u0026#34; 69 [ 1] PID: 14748 TASK: ffff88013bbca040 COMMAND: \u0026#34;rtloop98\u0026#34; 70 [ 1] TASK_GROUP: ffff88012b0fb400 RT_RQ: ffff880089029000 71 [ 1] PID: 14752 TASK: ffff880088abf500 COMMAND: \u0026#34;rtloop98\u0026#34; 72 [ 54] PID: 14749 TASK: ffff880037a4e080 COMMAND: \u0026#34;rtloop45\u0026#34; 73 [ 98] PID: 14746 TASK: ffff88012678c080 COMMAND: \u0026#34;rtloop1\u0026#34; 74 ROOT_TASK_GROUP: ffffffff81ed93e0 CFS_RQ: ffff8800282166e8 75 [120] PID: 14740 TASK: ffff88013b1e6080 COMMAND: \u0026#34;sh\u0026#34; 76 [120] PID: 14738 TASK: ffff88012678d540 COMMAND: \u0026#34;sh\u0026#34; 77 [120] PID: 14734 TASK: ffff88010626f500 COMMAND: \u0026#34;sh\u0026#34; [CURRENT] 78 TASK_GROUP: ffff884052bc9800 CFS_RQ: ffff8831e4a1b000 (THROTTLED) 79 [120] PID: 14732 TASK: ffff88013bbcb500 COMMAND: \u0026#34;sh\u0026#34; 80 [120] PID: 14728 TASK: ffff8800b3496080 COMMAND: \u0026#34;sh\u0026#34; 81 [120] PID: 14730 TASK: ffff880037833540 COMMAND: \u0026#34;sh\u0026#34; 82 TASK_GROUP: ffff884058f1d000 CFS_RQ: ffff88120a101600 (THROTTLED) 83 [120] PID: 14726 TASK: ffff880138d42aa0 COMMAND: \u0026#34;sh\u0026#34; 84 ... 85 86 Display tasks hierarchically by task_group for cpu 3 only: 87 88 crash\u0026gt; runq -g -c3 89 CPU 3 90 CURRENT: PID: 2948 TASK: ffff88022af2a100 COMMAND: \u0026#34;bash\u0026#34; 91 INIT_TASK_GROUP: ffffffff81e1a780 RT_RQ: ffff880028216148 92 [no tasks queued] 93 INIT_TASK_GROUP: ffffffff81e1a780 CFS_RQ: ffff880028216028 94 [120] PID: 2948 TASK: ffff88022af2a100 COMMAND: \u0026#34;bash\u0026#34; [CURRENT] 95 TASK_GROUP: ffff88012b880800 CFS_RQ: ffff88012c5d1000 \u0026lt;libvirt\u0026gt; 96 TASK_GROUP: ffff88012c078000 CFS_RQ: ffff88012c663e00 \u0026lt;qemu\u0026gt; 97 TASK_GROUP: ffff88022c7f4c00 CFS_RQ: ffff88012bb56000 \u0026lt;guest2\u0026gt; 98 TASK_GROUP: ffff88022b621400 CFS_RQ: ffff88012b012000 \u0026lt;vcpu0\u0026gt; 99 [120] PID: 3248 TASK: ffff88012a9d4100 COMMAND: \u0026#34;qemu-kvm\u0026#34; 36. search - search memory 36.1. SYNOPSIS 1search [-s start] [ -[kKV] | -u | -p | -t | -T ] [-e end | -l length] [-m mask] 2 [-x count] -[cwh] [value | (expression) | symbol | string] ... 36.2. DESCRIPTION 1 This command searches for a given value within a range of user virtual, kernel 2 virtual, or physical memory space. If no end nor length value is entered, 3 then the search stops at the end of user virtual, kernel virtual, or physical 4 address space, whichever is appropriate. 5 6 An optional mask value may be entered to mask off \u0026#34;don\u0026#39;t care\u0026#34; bits. 7 8 -s start Start the search at this hexadecimal user or kernel virtual 9 address, physical address, or kernel symbol. The start address 10 must be appropriate for the memory type specified; if no memory 11 type is specified, the default is kernel virtual address space. 12 -k If no start address is specified, start the search at the base 13 of kernel virtual address space. This option is the default. 14 -K Same as -k, except that mapped kernel virtual memory that was 15 allocated by vmalloc(), module memory, or virtual mem_map regions 16 will not be searched. 17 -V Same as -k, except that unity-mapped kernel virtual memory and 18 mapped kernel-text/static-data (x86_64 and ia64) will not be 19 searched. 20 -u If no start address is specified, start the search at the base 21 of the current context\u0026#39;s user virtual address space. If a start 22 address is specified, then this option specifies that the start 23 address is a user virtual address. 24 -p If no start address is specified, start the search at the base 25 of physical address space. If a start address is specified, 26 then this option specifies that the start address is a physical 27 address. 28 -t Search only the kernel stack pages of every task. If one or more 29 matches are found in a task\u0026#39;s kernel stack, precede the output 30 with a task-identifying header. 31 -T Same as -t, except only the active task(s) are considered. 32 -e end Stop the search at this hexadecimal user or kernel virtual 33 address, kernel symbol, or physical address. The end address 34 must be appropriate for the memory type specified. 35 -l length Length in bytes of address range to search. 36 -m mask Ignore the bits that are set in the hexadecimal mask value. 37 -c Search for character string values instead of unsigned longs. If 38 the string contains any space(s), it must be encompassed by double 39 quotes. 40 -w Search for unsigned hexadecimal ints instead of unsigned longs. 41 This is only meaningful on 64-bit systems in order to search both 42 the upper and lower 32-bits of each 64-bit long for the value. 43 -h Search for unsigned hexadecimal shorts instead of unsigned longs. 44 -x count Display the memory contents before and after any found value. The 45 before and after memory context will consist of \u0026#34;count\u0026#34; memory 46 items of the same size as the \u0026#34;value\u0026#34; argument. This option is 47 not applicable with the -c option. 48 value Search for this hexadecimal long, unless modified by the -c, -w, 49 or -h options. 50(expression) Search for the value of this expression; the expression value must 51 not overflow the designated size when -h or -w are used; not 52 applicable when used with the -c option. 53 symbol Search for this symbol value; the symbol value must not overflow 54 the designated size when -h or -w are used; not applicable when 55 used with the -c option. 56 string Search for character string values; if the string contains any 57 space(s), it must be encompassed by double quotes; only applicable 58 with the -c option. 59 60 If -k, -K, -V, -u, -p or -t are not used, then the search defaults to kernel 61 virtual address space. The starting address must be long-word aligned. 62 Address ranges that start in user space and end in kernel space are not 63 accepted. 36.3. EXAMPLES 1 Search the current context\u0026#39;s address space for all instances of 0xdeadbeef: 2 3 crash\u0026gt; search -u deadbeef 4 81aba5c: deadbeef 5 81abaa8: deadbeef 6 bfffc698: deadbeef 7 bffff390: deadbeef 8 9 Search all kernel memory above the kernel text space for all instances 10 of 0xabcd occurring in the lower 16-bits of each 32-bit word: 11 12 crash\u0026gt; search -s _etext -m ffff0000 abcd 13 c071481c: abcd 14 c0c2b0fc: 804abcd 15 c0cf5e74: 7489abcd 16 c17c0b44: c012abcd 17 c1dac730: 3dbeabcd 18 c226d0e8: ffffabcd 19 c23ed5dc: abcd 20 c3022544: 3dbeabcd 21 c3069b58: 3dbeabcd 22 c3e86e84: aabcd 23 c3e88ed0: aabcd 24 c3e8ee5c: aabcd 25 c3e9df50: aabcd 26 c3e9e930: aabcd 27 c440a778: 804abcd 28 c486eb44: 3dbeabcd 29 c578f0fc: 804abcd 30 c6394f90: 8ababcd 31 c65219f0: 3abcd 32 c661399c: abcd 33 c68514ac: 8abcd 34 c7e036bc: 3dbeabcd 35 c7e12568: 5abcd 36 c7e1256c: 5abcd 37 38 Search the 4K page at c532c000 for all instances of 0xffffffff: 39 40 crash\u0026gt; search -s c532c000 -l 4096 ffffffff 41 c532c33c: ffffffff 42 c532c3fc: ffffffff 43 44 Search the static kernel data area for all instances of c2d400eb: 45 46 crash\u0026gt; search -s _etext -e _edata c2d400eb 47 c022b550: c2d400eb 48 c022b590: c2d400eb 49 c022b670: c2d400eb 50 c022b6e0: c2d400eb 51 c022b7b0: c2d400eb 52 c022b7e0: c2d400eb 53 c022b8b0: c2d400eb 54 55 Search physical memory for all instances of 0xbabe occurring in the 56 upper 16 bits of each 32-bit word: 57 58 crash\u0026gt; search -p babe0000 -m ffff 59 2a1dc4: babe671e 60 2b6928: babe3de1 61 2f99ac: babe0d54 62 31843c: babe70b9 63 3ba920: babeb5d7 64 413ce4: babe7540 65 482747c: babe2600 66 48579a4: babe2600 67 4864a68: babe2600 68 ... 69 70 Search physical memory for all instances of 0xbabe occurring in the 71 upper 16 bits of each 32-bit word on a 64-bit system: 72 73 crash\u0026gt; search -p babe0000 -m ffff -w 74 102e248: babe1174 75 11d2f90: babe813d 76 122d3ad70: babe6b27 77 124d8cd30: babe3dc8 78 124d8eefc: babef981 79 124d8f060: babe3dc8 80 124d8f17c: babefc81 81 ... 82 83 Search kernel memory for all instances of 32-bit value 0xbabe1174 84 on a 64-bit system: 85 86 crash\u0026gt; search -k -w babe1174 87 ffff88000102e248: babe1174 88 ffffffff8102e248: babe1174 89 90 Search kernel memory for two strings: 91 92 crash\u0026gt; search -k -c \u0026#34;can\u0026#39;t allocate memory\u0026#34; \u0026#34;Failure to\u0026#34; 93 ffff8800013ddec1: can\u0026#39;t allocate memory for key lists..\u0026lt;3\u0026gt;%s %s: error con 94 ffff8801258be748: Failure to install fence: %d..\u0026lt;3\u0026gt;[drm:%s] *ERROR* Failed 95 ffff880125f07ec9: can\u0026#39;t allocate memory..\u0026lt;3\u0026gt;ACPI: Invalid data..Too many d 96 ffffffff813ddec1: can\u0026#39;t allocate memory for key lists..\u0026lt;3\u0026gt;%s %s: error con 97 98 Search the kernel stacks of all tasks for those that contain the inode 99 address ffff81002c0a3050: 100 101 crash\u0026gt; search -t ffff81002c0a3050 102 PID: 4876 TASK: ffff81003e9f5860 CPU: 7 COMMAND: \u0026#34;automount\u0026#34; 103 ffff8100288fbe98: ffff81002c0a3050 104 105 PID: 4880 TASK: ffff81003ce967a0 CPU: 0 COMMAND: \u0026#34;automount\u0026#34; 106 ffff81002c0fbdd8: ffff81002c0a3050 107 ffff81002c0fbe78: ffff81002c0a3050 108 109 When a kernel symbol or an (expression) is used an argument, both the 110 resultant value and the input string are displayed: 111 112 crash\u0026gt; search anon_inode_inode (__down_interruptible+191) 113 ffff81000222a728: ffffffff80493d60 (anon_inode_inode) 114 ffff810005a1e918: ffffffff800649d6 (__down_interruptible+191) 115 ffff810005a1e9d0: ffffffff800649d6 (__down_interruptible+191) 116 ffff810005a1eb48: ffffffff800649d6 (__down_interruptible+191) 117 ffff81000b409c60: ffffffff80493d60 (anon_inode_inode) 118 ffff81000c155b98: ffffffff80493d60 (anon_inode_inode) 119 ffff8100194fac70: ffffffff80493d60 (anon_inode_inode) 120 ffff81001daa1008: ffffffff80493d60 (anon_inode_inode) 121 ffff810028b95830: ffffffff800649d6 (__down_interruptible+191) 122 ffff81002cea0c70: ffffffff80493d60 (anon_inode_inode) 123 ffff810031327268: ffffffff80493d60 (anon_inode_inode) 124 ffff810031327270: ffffffff800649d6 (__down_interruptible+191) 125 ffff810034b1ccd0: ffffffff800649d6 (__down_interruptible+191) 126 ffff8100399565a8: ffffffff80493d60 (anon_inode_inode) 127 ffff81003a278cd0: ffffffff800649d6 (__down_interruptible+191) 128 ffff81003cc23e08: ffffffff800649d6 (__down_interruptible+191) 37. set - set a process context or internal crash variable 37.1. SYNOPSIS 1set [[-a] [pid | taskp] | [-c cpu] | -p] | [crash_variable [setting]] | -v 37.2. DESCRIPTION 1 This command either sets a new context, or gets the current context for 2 display. The context can be set by the use of: 3 4 pid a process PID. 5 taskp a hexadecimal task_struct pointer. 6 -a sets the pid or task as the active task on its cpu (dumpfiles only). 7 -c cpu sets the context to the active task on a cpu (dumpfiles only). 8 -p sets the context to the panic task, or back to the crash task on 9 a live system. 10 -v display the current state of internal crash variables. 11 12 If no argument is entered, the current context is displayed. The context 13 consists of the PID, the task pointer, the CPU, and task state. The task 14 state shows the bits found in both the task_struct state and exit_state 15 fields. 16 17 This command may also be used to set internal crash variables. If no value 18 argument is entered, the current value of the crash variable is shown. These 19 are the crash variables, acceptable arguments, and purpose: 20 21 scroll on | off controls output scrolling. 22 scroll less /usr/bin/less as the output scrolling program. 23 scroll more /bin/more as the output scrolling program. 24 scroll CRASHPAGER use CRASHPAGER environment variable as the 25 output scrolling program. 26 radix 10 | 16 sets output radix to 10 or 16. 27 refresh on | off controls internal task list refresh. 28 print_max number set maximum number of array elements to print. 29 print_array on | off if on, set gdb\u0026#39;s printing of arrays to \u0026#34;pretty\u0026#34; 30 format, with one line per element. 31 console device-name sets debug console device. 32 debug number sets crash debug level. 33 core on | off if on, drops core when the next error message 34 is displayed. 35 hash on | off controls internal list verification. 36 silent on | off turns off initialization messages; turns off 37 crash prompt during input file execution. 38 (scrolling is turned off if silent is on) 39 edit vi | emacs set line editing mode (from .crashrc file only). 40 namelist filename name of kernel (from .crashrc file only). 41 zero_excluded on | off controls whether excluded pages, or pages that 42 are missing from an incomplete dumpfile, should 43 return zero-filled memory when read. 44 null-stop on | off if on, gdb\u0026#39;s printing of character arrays will 45 stop at the first NULL encountered. 46 gdb on | off if on, the crash session will be run in a mode 47 where all commands will be passed directly to 48 gdb, and the command prompt will change to 49 \u0026#34;gdb\u0026gt;\u0026#34;; when running in this mode, native crash 50 commands may be executed by preceding them with 51 the \u0026#34;crash\u0026#34; directive. 52 scope text-addr sets the text scope for viewing the definition 53 of data structures; the \u0026#34;text-addr\u0026#34; argument 54 must be a kernel or module text address, which 55 may be expressed symbolically or as a hexadecimal 56 value. 57 offline show | hide show or hide command output that is associated 58 with offline cpus. 59 redzone on | off if on, CONFIG_SLUB object addresses displayed by 60 the kmem command will point to the SLAB_RED_ZONE 61 padding inserted at the beginning of the object. 62 error default | redirect | filename set the destination of error messages. 63 \u0026#34;default\u0026#34;: error messages are always displayed 64 on the console; if the output of a command is 65 piped to an external command or redirected 66 to a file, the error messages are also sent 67 to the pipe or file. 68 \u0026#34;redirect\u0026#34;: if the output of a command is piped 69 to an external command or redirected to a file, 70 error messages are only sent to the pipe or 71 file; otherwise they are displayed on the 72 console. 73 \u0026#34;filename\u0026#34;: error messages are only sent to the 74 specified filename; they are not displayed on 75 the console and are not sent to a pipe or file. 76 77 Internal variables may be set in four manners: 78 79 1. entering the set command in $HOME/.crashrc. 80 2. entering the set command in .crashrc in the current directory. 81 3. executing an input file containing the set command. 82 4. during runtime with this command. 83 84 During initialization, $HOME/.crashrc is read first, followed by the 85 .crashrc file in the current directory. Set commands in the .crashrc file 86 in the current directory override those in $HOME/.crashrc. Set commands 87 entered with this command or by runtime input file override those 88 defined in either .crashrc file. Multiple set command arguments or argument 89 pairs may be entered in one command line. 37.3. EXAMPLES 1 Set the current context to task c2fe8000: 2 3 crash\u0026gt; set c2fe8000 4 PID: 15917 5 COMMAND: \u0026#34;bash\u0026#34; 6 TASK: c2fe8000 7 CPU: 0 8 STATE: TASK_INTERRUPTIBLE 9 10 Set the context back to the panicking task: 11 12 crash\u0026gt; set -p 13 PID: 698 14 COMMAND: \u0026#34;gen12\u0026#34; 15 TASK: f9d78000 16 CPU: 2 17 STATE: TASK_RUNNING (PANIC) 18 19 Turn off output scrolling: 20 21 crash\u0026gt; set scroll off 22 scroll: off (/usr/bin/less) 23 24 Show the current state of crash internal variables: 25 26 crash\u0026gt; set -v 27 scroll: on (/usr/bin/less) 28 radix: 10 (decimal) 29 refresh: on 30 print_max: 256 31 print_array: off 32 console: /dev/pts/2 33 debug: 0 34 core: off 35 hash: on 36 silent: off 37 edit: vi 38 namelist: vmlinux 39 zero_excluded: off 40 null-stop: on 41 gdb: off 42 scope: (not set) 43 offline: show 44 redzone: on 45 error: default 46 47 Show the current context: 48 49 crash\u0026gt; set 50 PID: 1525 51 COMMAND: \u0026#34;bash\u0026#34; 52 TASK: c1ede000 53 CPU: 0 54 STATE: TASK_INTERRUPTIBLE 38. sig - task signal handling 38.1. SYNOPSIS 1sig [[-l] | [-s sigset]] | [-g] [pid | taskp] ... 38.2. DESCRIPTION 1 This command displays signal-handling data of one or more tasks. Multiple 2 task or PID numbers may be entered; if no arguments are entered, the signal 3 handling data of the current context will be displayed. The default display 4 shows: 5 6 1. A formatted dump of the \u0026#34;sig\u0026#34; signal_struct structure referenced by 7 the task_struct. For each defined signal, it shows the sigaction 8 structure address, the signal handler, the signal sigset_t mask 9 (also expressed as a 64-bit hexadecimal value), and the flags. 10 2. Whether the task has an unblocked signal pending. 11 3. The contents of the \u0026#34;blocked\u0026#34; and \u0026#34;signal\u0026#34; sigset_t structures 12 from the task_struct/signal_struct, both of which are represented 13 as a 64-bit hexadecimal value. 14 4. For each queued signal, private and/or shared, if any, its signal 15 number and associated siginfo structure address. 16 17 The -l option lists the signal numbers and their name(s). The -s option 18 translates a 64-bit hexadecimal value representing the contents of a 19 sigset_t structure into the signal names whose bits are set. 20 21 pid a process PID. 22 taskp a hexadecimal task_struct pointer. 23 -g displays signal information for all threads in a task\u0026#39;s 24 thread group. 25 -l displays the defined signal numbers and names. 26 -s sigset translates a 64-bit hexadecimal value representing a sigset_t 27 into a list of signal names associated with the bits set. 38.3. EXAMPLES 1 Dump the signal-handling data of PID 8970: 2 3 crash\u0026gt; sig 8970 4 PID: 8970 TASK: f67d8560 CPU: 1 COMMAND: \u0026#34;procsig\u0026#34; 5 SIGNAL_STRUCT: f6018680 COUNT: 1 6 SIG SIGACTION HANDLER MASK FLAGS 7 [1] f7877684 SIG_DFL 0000000000000000 0 8 [2] f7877698 SIG_DFL 0000000000000000 0 9 ... 10 [8] f7877710 SIG_DFL 0000000000000000 0 11 [9] f7877724 SIG_DFL 0000000000000000 0 12 [10] f7877738 804867a 0000000000000000 80000000 (SA_RESETHAND) 13 [11] f787774c SIG_DFL 0000000000000000 0 14 [12] f7877760 804867f 0000000000000000 10000004 (SA_SIGINFO|SA_RESTART) 15 [13] f7877774 SIG_DFL 0000000000000000 0 16 ... 17 [31] f78778dc SIG_DFL 0000000000000000 0 18 [32] f78778f0 SIG_DFL 0000000000000000 0 19 [33] f7877904 SIG_DFL 0000000000000000 0 20 [34] f7877918 804867f 0000000000000000 10000004 (SA_SIGINFO|SA_RESTART) 21 [35] f787792c SIG_DFL 0000000000000000 0 22 [36] f7877940 SIG_DFL 0000000000000000 0 23 ... 24 [58] f7877af8 SIG_DFL 0000000000000000 0 25 [59] f7877b0c SIG_DFL 0000000000000000 0 26 [60] f7877b20 SIG_DFL 0000000000000000 0 27 [61] f7877b34 SIG_DFL 0000000000000000 0 28 [62] f7877b48 SIG_DFL 0000000000000000 0 29 [63] f7877b5c SIG_DFL 0000000000000000 0 30 [64] f7877b70 804867f 0000000000000000 10000004 (SA_SIGINFO|SA_RESTART) 31 SIGPENDING: no 32 BLOCKED: 8000000200000800 33 PRIVATE_PENDING 34 SIGNAL: 0000000200000800 35 SIGQUEUE: SIG SIGINFO 36 12 f51b9c84 37 34 f51b9594 38 SHARED_PENDING 39 SIGNAL: 8000000000000800 40 SIGQUEUE: SIG SIGINFO 41 12 f51b9188 42 64 f51b9d18 43 64 f51b9500 44 45 Dump the signal-handling data for all tasks in the thread group containing 46 PID 2578: 47 48 crash\u0026gt; sig -g 2578 49 PID: 2387 TASK: f617d020 CPU: 0 COMMAND: \u0026#34;slapd\u0026#34; 50 SIGNAL_STRUCT: f7dede00 COUNT: 6 51 SIG SIGACTION HANDLER MASK FLAGS 52 [1] c1f60c04 a258a7 0000000000000000 10000000 (SA_RESTART) 53 [2] c1f60c18 a258a7 0000000000000000 10000000 (SA_RESTART) 54 [3] c1f60c2c SIG_DFL 0000000000000000 0 55 [4] c1f60c40 SIG_DFL 0000000000000000 0 56 [5] c1f60c54 a258a7 0000000000000000 10000000 (SA_RESTART) 57 [6] c1f60c68 SIG_DFL 0000000000000000 0 58 [7] c1f60c7c SIG_DFL 0000000000000000 0 59 [8] c1f60c90 SIG_DFL 0000000000000000 0 60 [9] c1f60ca4 SIG_DFL 0000000000000000 0 61 [10] c1f60cb8 a25911 0000000000000000 10000000 (SA_RESTART) 62 ... 63 [64] c1f610f0 SIG_DFL 0000000000000000 0 64 SHARED_PENDING 65 SIGNAL: 0000000000000000 66 SIGQUEUE: (empty) 67 68 PID: 2387 TASK: f617d020 CPU: 0 COMMAND: \u0026#34;slapd\u0026#34; 69 SIGPENDING: no 70 BLOCKED: 0000000000000000 71 PRIVATE_PENDING 72 SIGNAL: 0000000000000000 73 SIGQUEUE: (empty) 74 75 PID: 2392 TASK: f6175aa0 CPU: 0 COMMAND: \u0026#34;slapd\u0026#34; 76 SIGPENDING: no 77 BLOCKED: 0000000000000000 78 PRIVATE_PENDING 79 SIGNAL: 0000000000000000 80 SIGQUEUE: (empty) 81 82 PID: 2523 TASK: f7cd4aa0 CPU: 1 COMMAND: \u0026#34;slapd\u0026#34; 83 SIGPENDING: no 84 BLOCKED: 0000000000000000 85 PRIVATE_PENDING 86 SIGNAL: 0000000000000000 87 SIGQUEUE: (empty) 88 89 ... 90 91 Translate the sigset_t mask value, cut-and-pasted from the signal handling 92 data from signals 1 and 10 above: 93 94 crash\u0026gt; sig -s 800A000000000201 95 SIGHUP SIGUSR1 SIGRTMAX-14 SIGRTMAX-12 SIGRTMAX 96 97 List the signal numbers and their names: 98 99 crash\u0026gt; sig -l 100 [1] SIGHUP 101 [2] SIGINT 102 [3] SIGQUIT 103 [4] SIGILL 104 [5] SIGTRAP 105 [6] SIGABRT/SIGIOT 106 [7] SIGBUS 107 [8] SIGFPE 108 [9] SIGKILL 109 [10] SIGUSR1 110 [11] SIGSEGV 111 [12] SIGUSR2 112 [13] SIGPIPE 113 [14] SIGALRM 114 [15] SIGTERM 115 [16] SIGSTKFLT 116 [17] SIGCHLD/SIGCLD 117 [18] SIGCONT 118 [19] SIGSTOP 119 [20] SIGTSTP 120 [21] SIGTTIN 121 [22] SIGTTOU 122 [23] SIGURG 123 [24] SIGXCPU 124 [25] SIGXFSZ 125 [26] SIGVTALRM 126 [27] SIGPROF 127 [28] SIGWINCH 128 [29] SIGIO/SIGPOLL 129 [30] SIGPWR 130 [31] SIGSYS 131 [32] SIGRTMIN 132 [33] SIGRTMIN+1 133 [34] SIGRTMIN+2 134 [35] SIGRTMIN+3 135 [36] SIGRTMIN+4 136 [37] SIGRTMIN+5 137 [38] SIGRTMIN+6 138 [39] SIGRTMIN+7 139 [40] SIGRTMIN+8 140 [41] SIGRTMIN+9 141 [42] SIGRTMIN+10 142 [43] SIGRTMIN+11 143 [44] SIGRTMIN+12 144 [45] SIGRTMIN+13 145 [46] SIGRTMIN+14 146 [47] SIGRTMIN+15 147 [48] SIGRTMIN+16 148 [49] SIGRTMAX-15 149 [50] SIGRTMAX-14 150 [51] SIGRTMAX-13 151 [52] SIGRTMAX-12 152 [53] SIGRTMAX-11 153 [54] SIGRTMAX-10 154 [55] SIGRTMAX-9 155 [56] SIGRTMAX-8 156 [57] SIGRTMAX-7 157 [58] SIGRTMAX-6 158 [59] SIGRTMAX-5 159 [60] SIGRTMAX-4 160 [61] SIGRTMAX-3 161 [62] SIGRTMAX-2 162 [63] SIGRTMAX-1 163 [64] SIGRTMAX 39. struct - structure contents 39.1. SYNOPSIS 1struct struct_name[.member[,member]][-o][-l offset][-rfuxdp] 2 [address | symbol][:cpuspec] [count | -c count] 39.2. DESCRIPTION 1 This command displays either a structure definition, or a formatted display 2 of the contents of a structure at a specified address. When no address is 3 specified, the structure definition is shown along with the structure size. 4 A structure member may be appended to the structure name in order to limit 5 the scope of the data displayed to that particular member; when no address 6 is specified, the member\u0026#39;s offset and definition are shown. 7 8 struct_name name of a C-code structure used by the kernel. 9 .member name of a structure member; to display multiple members of a 10 structure, use a comma-separated list of members. If any 11 member contains an embedded structure, or the member is an 12 array, the output may be restricted to just the embedded 13 structure or an array element by expressing the member argument 14 as \u0026#34;member.member\u0026#34; or \u0026#34;member[index]\u0026#34;; embedded member 15 specifications may extend beyond one level deep, by expressing 16 the member argument as \u0026#34;member.member.member...\u0026#34;. 17 -o show member offsets when displaying structure definitions; 18 if used with an address or symbol argument, each member will 19 be preceded by its virtual address. 20 -l offset if the address argument is a pointer to a structure member that 21 is contained by the target data structure, typically a pointer 22 to an embedded list_head, the offset to the embedded member may 23 be entered in either of the following manners: 24 1. in \u0026#34;structure.member\u0026#34; format. 25 2. a number of bytes. 26 -r raw dump of structure data. 27 -f address argument is a dumpfile offset. 28 -u address argument is a user virtual address in the current 29 context. 30 -x override default output format with hexadecimal format. 31 -d override default output format with decimal format. 32 -p if a structure member is a pointer value, show the member\u0026#39;s 33 data type on the output line; and on the subsequent line(s), 34 dereference the pointer, display the pointer target\u0026#39;s symbol 35 value in brackets if appropriate, and if possible, display the 36 target data; requires an address argument. 37 address hexadecimal address of a structure; if the address points 38 to an embedded list_head structure contained within the 39 target data structure, then the \u0026#34;-l\u0026#34; option must be used. 40 symbol symbolic reference to the address of a structure. 41 :cpuspec CPU specification for a per-cpu address or symbol: 42 : CPU of the currently selected task. 43 :a[ll] all CPUs. 44 :#[-#][,...] CPU list(s), e.g. \u0026#34;1,3,5\u0026#34;, \u0026#34;1-3\u0026#34;, 45 or \u0026#34;1,3,5-7,10\u0026#34;. 46 count count of structures to dump from an array of structures; 47 if used, this must be the last argument entered. 48 -c count \u0026#34;-c\u0026#34; is only required if \u0026#34;count\u0026#34; is not the last argument 49 entered or if a negative number is entered; if a negative 50 value is entered, the (positive) \u0026#34;count\u0026#34; structures that 51 lead up to and include the target structure will be displayed. 52 53 Structure data, sizes, and member offsets are shown in the current output 54 radix unless the -x or -d option is specified. 55 56 Please note that in the vast majority of cases, the \u0026#34;struct\u0026#34; command 57 name may be dropped; if the structure name does not conflict with any crash 58 or gdb command name, then the \u0026#34;struct_name[.member]\u0026#34; argument will be 59 recognized as a structure name, and this command automatically executed. 60 See the NOTE below. 39.3. EXAMPLES 1 Display the vm_area_struct at address c1e44f10: 2 3 crash\u0026gt; struct vm_area_struct c1e44f10 4 struct vm_area_struct { 5 vm_mm = 0xc2857750, 6 vm_start = 0x8048000, 7 vm_end = 0x80a5000, 8 vm_next = 0xc1e44a10, 9 vm_page_prot = { 10 pgprot = 0x25 11 }, 12 vm_flags = 0x1875, 13 vm_avl_height = 0x2, 14 vm_avl_left = 0xc30fe200, 15 vm_avl_right = 0xc30fed00, 16 vm_next_share = 0x0, 17 vm_pprev_share = 0xc1e44a30, 18 vm_ops = 0xc0215ca0, 19 vm_offset = 0x0, 20 vm_file = 0xc0bfdc70, 21 vm_pte = 0 22 } 23 24 Display the definition and size of a vm_area_struct structure. This first 25 example below displays just the structure and size. The second example 26 uses the -o option to also display member offsets. Both examples were 27 run with the output radix set to 10 (decimal): 28 29 crash\u0026gt; struct vm_area_struct 30 struct vm_area_struct { 31 struct mm_struct *vm_mm; 32 long unsigned int vm_start; 33 long unsigned int vm_end; 34 struct vm_area_struct *vm_next; 35 pgprot_t vm_page_prot; 36 short unsigned int vm_flags; 37 short int vm_avl_height; 38 struct vm_area_struct *vm_avl_left; 39 struct vm_area_struct *vm_avl_right; 40 struct vm_area_struct *vm_next_share; 41 struct vm_area_struct **vm_pprev_share; 42 struct vm_operations_struct *vm_ops; 43 long unsigned int vm_offset; 44 struct file *vm_file; 45 long unsigned int vm_pte; 46 } 47 SIZE: 56 48 49 crash\u0026gt; struct vm_area_struct -o 50 struct vm_area_struct { 51 [0] struct mm_struct *vm_mm; 52 [4] long unsigned int vm_start; 53 [8] long unsigned int vm_end; 54 [12] struct vm_area_struct *vm_next; 55 [16] pgprot_t vm_page_prot; 56 [20] short unsigned int vm_flags; 57 [22] short int vm_avl_height; 58 [24] struct vm_area_struct *vm_avl_left; 59 [28] struct vm_area_struct *vm_avl_right; 60 [32] struct vm_area_struct *vm_next_share; 61 [36] struct vm_area_struct **vm_pprev_share; 62 [40] struct vm_operations_struct *vm_ops; 63 [44] long unsigned int vm_offset; 64 [48] struct file *vm_file; 65 [52] long unsigned int vm_pte; 66 } 67 SIZE: 56 68 69 Display the definition and offset of the pgd member of an mm_struct: 70 71 crash\u0026gt; struct mm_struct.pgd 72 struct mm_struct { 73 [80] pgd_t *pgd; 74 } 75 76 Display the pgd member of the mm_struct at address ffff810022e7d080: 77 78 crash\u0026gt; struct mm_struct.pgd ffff810022e7d080 79 pgd = 0xffff81000e3ac000 80 81 Display the pgd_t pointed to by the mm_struct.pgd pointer above, forcing 82 the output to be expressed in hexadecimal: 83 84 crash\u0026gt; mm_struct.pgd ffff810022e7d080 -px 85 pgd_t *pgd = 0xffff81000e3ac000 86 -\u0026gt; { 87 pgd = 0x2c0a6067 88 } 89 90 Display the thread_info structure pointed to by the thread_info 91 member of the task_struct at ffff8100181190c0: 92 93 crash\u0026gt; task_struct.thread_info ffff8100181190c0 -p 94 struct thread_info *thread_info = 0xffff810023c06000 95 -\u0026gt; { 96 task = 0xffff8100181190c0, 97 exec_domain = 0xffffffff802f78e0, 98 flags = 128, 99 status = 1, 100 cpu = 3, 101 preempt_count = 0, 102 addr_limit = { 103 seg = 18446604435732824064 104 }, 105 restart_block = { 106 fn = 0xffffffff80095a52 \u0026lt;do_no_restart_syscall\u0026gt;, 107 arg0 = 0, 108 arg1 = 0, 109 arg2 = 0, 110 arg3 = 0 111 } 112 } 113 114 Display the flags and virtual members of 4 contigous page structures 115 in the mem_map page structure array: 116 117 crash\u0026gt; page.flags,virtual c101196c 4 118 flags = 0x8000, 119 virtual = 0xc04b0000 120 121 flags = 0x8000, 122 virtual = 0xc04b1000 123 124 flags = 0x8000, 125 virtual = 0xc04b2000 126 127 flags = 0x8000, 128 virtual = 0xc04b3000 129 130 Display the array of tcp_sl_timer structures declared by tcp_slt_array[]: 131 132 crash\u0026gt; struct tcp_sl_timer tcp_slt_array 4 133 struct tcp_sl_timer { 134 count = { 135 counter = 0x0 136 }, 137 period = 0x32, 138 last = 0x1419e4, 139 handler = 0xc0164854 \u0026lt;tcp_syn_recv_timer\u0026gt; 140 } 141 struct tcp_sl_timer { 142 count = { 143 counter = 0x2 144 }, 145 period = 0x753, 146 last = 0x14a6df, 147 handler = 0xc01645b0 \u0026lt;tcp_keepalive\u0026gt; 148 } 149 struct tcp_sl_timer { 150 count = { 151 counter = 0x0 152 }, 153 period = 0x2ee, 154 last = 0x143134, 155 handler = 0xc016447c \u0026lt;tcp_twkill\u0026gt; 156 } 157 struct tcp_sl_timer { 158 count = { 159 counter = 0x0 160 }, 161 period = 0x64, 162 last = 0x143198, 163 handler = 0xc0164404 \u0026lt;tcp_bucketgc\u0026gt; 164 } 165 166 Without using the \u0026#34;struct\u0026#34; command name, display the the \u0026#34;d_child\u0026#34; 167 list_head member from a dentry structure: 168 169 crash\u0026gt; dentry.d_child 0xe813cb4 170 d_child = { 171 next = 0x3661344, 172 prev = 0xdea4bc4 173 }, 174 175 Display the child dentry structure referenced by the \u0026#34;next\u0026#34; pointer above. 176 Since the \u0026#34;next\u0026#34; address of 0x3661344 above is a pointer to an embedded 177 list_head structure within the child dentry structure, the -l option 178 is required: 179 180 crash\u0026gt; dentry -l dentry.d_child 0x3661344 181 struct dentry { 182 d_count = { 183 counter = 1 184 }, 185 d_flags = 0, 186 d_inode = 0xf9aa604, 187 d_parent = 0x11152b1c, 188 d_hash = { 189 next = 0x11fb3fc0, 190 prev = 0x11fb3fc0 191 }, 192 d_lru = { 193 next = 0x366133c, 194 prev = 0x366133c 195 }, 196 d_child = { 197 next = 0x36613cc, 198 prev = 0xe813cd4 199 }, 200 d_subdirs = { 201 next = 0x366134c, 202 prev = 0x366134c 203 }, 204 d_alias = { 205 next = 0xf9aa614, 206 prev = 0xf9aa614 207 }, 208 d_mounted = 0, 209 d_name = { 210 name = 0x3661384 \u0026#34;boot.log\u0026#34;, 211 len = 8, 212 hash = 1935169207 213 }, 214 d_time = 1515870810, 215 d_op = 0x0, 216 d_sb = 0x11fc9c00, 217 d_vfs_flags = 0, 218 d_fsdata = 0x0, 219 d_extra_attributes = 0x0, 220 d_iname = \u0026#34;boot.log\\000\u0026#34; 221 } 222 223 Display the virtual address of each member of the task_struct at 224 ffff8100145d2080: 225 226 crash\u0026gt; task_struct -o ffff8100145d2080 227 struct task_struct { 228 [ffff8100145d2080] volatile long int state; 229 [ffff8100145d2088] struct thread_info *thread_info; 230 [ffff8100145d2090] atomic_t usage; 231 [ffff8100145d2098] long unsigned int flags; 232 [ffff8100145d20a0] int lock_depth; 233 [ffff8100145d20a4] int load_weight; 234 [ffff8100145d20a8] int prio; 235 [ffff8100145d20ac] int static_prio; 236 [ffff8100145d20b0] int normal_prio; 237 [ffff8100145d20b8] struct list_head run_list; 238 [ffff8100145d20c8] struct prio_array *array; 239 ... 240 241 Display the embedded sched_entity structure\u0026#39;s on_rq member and 242 the third pid_link structure in the embedded pids[] array of the 243 task_struct at ffff88011653e250: 244 245 crash\u0026gt; task_struct.se.on_rq,pids[2] ffff88011653e250 246 se.on_rq = 1, 247 pids[2] = { 248 node = { 249 next = 0xffff88011653aff0, 250 pprev = 0xffff88011653a860 251 }, 252 pid = 0xffff88010d07ed00 253 } 254 255 For an example of displaying per-cpu variables, consider the 256 struct hd_struct.dkstats member, which is a percpu pointer to 257 a disk_stats structure: 258 259 crash\u0026gt; struct hd_struct.dkstats 260 struct hd_struct { 261 [1232] struct disk_stats *dkstats; 262 } 263 264 Taking an hd_struct at address ffff8802450e2848, display all 265 of the per-cpu disk_stats structures that it references: 266 267 crash\u0026gt; struct hd_struct.dkstats ffff8802450e2848 268 dkstats = 0x60fdb48026c8 269 crash\u0026gt; struct disk_stats 0x60fdb48026c8:a 270 [0]: ffffe8fefe6026c8 271 struct disk_stats { 272 sectors = {451376, 80468}, 273 ios = {6041, 971}, 274 merges = {386, 390}, 275 ticks = {194877, 56131}, 276 io_ticks = 12371, 277 time_in_queue = 309163 278 } 279 [1]: ffffe8fefe8026c8 280 struct disk_stats { 281 sectors = {0, 0}, 282 ios = {0, 0}, 283 merges = {7, 242}, 284 ticks = {0, 0}, 285 io_ticks = 23, 286 time_in_queue = 581 287 } 288 [2]: ffffe8fefea026c8 289 struct disk_stats { 290 sectors = {0, 0}, 291 ios = {0, 0}, 292 merges = {4, 112}, 293 ticks = {0, 0}, 294 io_ticks = 11, 295 time_in_queue = 305 296 } 297 [3]: ffffe8fefec026c8 298 struct disk_stats { 299 sectors = {0, 0}, 300 ios = {0, 0}, 301 merges = {5, 54}, 302 ticks = {0, 0}, 303 io_ticks = 17, 304 time_in_queue = 41 305 } 39.4. NOTE 1 If the structure name does not conflict with any crash command name, the 2 \u0026#34;struct\u0026#34; command may be dropped. Accordingly, the examples above could 3 also have been accomplished like so: 4 5 crash\u0026gt; vm_area_struct c1e44f10 6 crash\u0026gt; vm_area_struct 7 crash\u0026gt; vm_area_struct -o 8 crash\u0026gt; mm_struct.pgd ffff810022e7d080 9 crash\u0026gt; mm_struct.pgd 10 crash\u0026gt; tcp_sl_timer tcp_slt_array 4 11 12 Lastly, the short-cut \u0026#34;*\u0026#34; pointer-to command may also be used to negate 13 the need to enter the \u0026#34;struct\u0026#34; command name (enter \u0026#34;help *\u0026#34; for details). 40. swap - swap device information 40.1. SYNOPSIS 1swap 40.2. DESCRIPTION 1 This command displays information for each configured swap device. 2 3EXAMPLE 4 crash\u0026gt; swap 5 SWAP_INFO_STRUCT TYPE SIZE USED PCT PRI FILENAME 6 ffff880153d45f40 PARTITION 7192568k 1200580k 16% -1 /dev/dm-1 41. sym - translate a symbol to its virtual address, or vice-versa 41.1. SYNOPSIS 1sym [-l] | [-M] | [-m module] | [-p|-n] | [-q string] | [symbol | vaddr] 41.2. DESCRIPTION 1 This command translates a symbol to its virtual address, or a static 2 kernel virtual address to its symbol -- or to a symbol-plus-offset value, 3 if appropriate. Additionally, the symbol type is shown in parentheses, 4 and if the symbol is a known text value, the file and line number are shown. 5 6 -l dumps all symbols and their values. 7 -M dumps the current set of module symbols. 8 -m module dumps the current set of symbols for a specified module. 9 -p display the target symbol and the previous symbol. 10 -n display the target symbol and the next symbol. 11 -q string searches for all symbols containing \u0026#34;string\u0026#34;. 12 symbol a kernel text or data symbol. 13 vaddr a kernel virtual address. 14 15 If the \u0026#34;symbol\u0026#34;, \u0026#34;vaddr\u0026#34; or \u0026#34;string\u0026#34; argument resolves to a module 16 symbol, then the module name will be displayed in brackets following the 17 symbol value. 41.3. EXAMPLES 1 Translate data symbol jiffies to its value, and vice-versa: 2 3 crash\u0026gt; sym jiffies 4 c0213ae0 (D) jiffies 5 6 crash\u0026gt; sym c0213ae0 7 c0213ae0 (D) jiffies 8 9 Translate a text address to its symbolic value and source file: 10 11 crash\u0026gt; sym c0109944 12 c0109944 (T) system_call+0x34 ../linux-2.2.5/arch/i386/kernel/signal.c: 723 13 14 Dump the whole symbol table: 15 16 crash\u0026gt; sym -l 17 c0100000 (T) _stext 18 c0100000 (A) _text 19 c0100000 (t) startup_32 20 c0100000 (T) stext 21 c01000a4 (t) checkCPUtype 22 c0100139 (t) is486 23 c0100148 (t) is386 24 c01001b1 (t) L6 25 c01001b3 (t) ready 26 c01001b4 (t) check_x87 27 c01001da (t) setup_idt 28 c01001f7 (t) rp_sidt 29 c0100204 (T) stack_start 30 c010020c (t) int_msg 31 c0100220 (t) ignore_int 32 c0100242 (t) idt_descr 33 c0100244 (T) idt 34 c010024a (t) gdt_descr 35 c010024c (T) gdt 36 c0101000 (T) swapper_pg_dir 37 c0102000 (T) pg0 38 c0103000 (T) empty_bad_page 39 c0104000 (T) empty_bad_page_table 40 c0105000 (T) empty_zero_page 41 ... 42 43 Find all symbols containing the string \u0026#34;pipe\u0026#34;: 44 45 crash\u0026gt; sym -q pipe 46 c010ec60 (T) sys_pipe 47 c012f660 (t) pipe_read 48 c012f7b8 (t) pipe_write 49 c012f9c0 (t) pipe_lseek 50 c012f9d0 (t) bad_pipe_r 51 c012f9dc (t) bad_pipe_w 52 c012f9e8 (t) pipe_ioctl 53 c012fa18 (t) pipe_poll 54 c012fb00 (t) pipe_release 55 c012fb48 (t) pipe_read_release 56 c012fb5c (t) pipe_write_release 57 c012fb70 (t) pipe_rdwr_release 58 c012fba0 (t) pipe_read_open 59 c012fbb0 (t) pipe_write_open 60 c012fbc0 (t) pipe_rdwr_open 61 c012fbec (t) get_pipe_inode 62 c012fcc4 (T) do_pipe 63 c023a920 (D) read_pipe_fops 64 c023a960 (D) write_pipe_fops 65 c023a9a0 (D) rdwr_pipe_fops 66 c023a9e0 (D) pipe_inode_operations 67 68 Dump the symbols of the uart401 module, both before, and then after, 69 the complete set of symbols are loaded with the \u0026#34;mod -s\u0026#34; command: 70 71 crash\u0026gt; sym -m uart401 72 c8032000 MODULE START: uart401 73 c8032138 (?) uart401intr 74 c803235c (?) attach_uart401 75 c8032638 (?) probe_uart401 76 c80326d4 (?) unload_uart401 77 c8033770 MODULE END: uart401 78 crash\u0026gt; mod -s uart401 79 MODULE NAME SIZE OBJECT FILE 80 c8032000 uart401 6000 /lib/modules/2.2.14/misc/uart401.o 81 crash\u0026gt; sym -m uart401 82 c8032000 MODULE START: uart401 83 c8032050 (t) my_notifier_call 84 c8032084 (t) uart401_status 85 c8032098 (t) uart401_cmd 86 c80320a8 (t) uart401_read 87 c80320bc (t) uart401_write 88 c80320cc (t) uart401_input_loop 89 c8032138 (T) uart401intr 90 c8032168 (t) uart401_open 91 c80321c8 (t) uart401_close 92 c80321f4 (t) uart401_out 93 c80322ac (t) uart401_start_read 94 c80322b4 (t) uart401_end_read 95 c80322bc (t) uart401_kick 96 c80322c4 (t) uart401_buffer_status 97 c80322cc (t) enter_uart_mode 98 c803235c (T) attach_uart401 99 c803259c (t) reset_uart401 100 c8032638 (T) probe_uart401 101 c80326d4 (T) unload_uart401 102 c8032760 (T) init_module 103 c80327cc (T) cleanup_module 104 c8032b00 (d) sound_notifier 105 c8032b0c (d) detected_devc 106 c8032b20 (d) std_synth_info 107 c8032bc0 (d) std_midi_synth 108 c8033600 (d) uart401_operations 109 c80336c4 (D) io 110 c80336c8 (D) irq 111 c80336e0 (b) hw_info.508 112 c8033770 MODULE END: uart401 113 114 Display the value of jiffies, along with the next and previous symbols: 115 116 crash\u0026gt; sym -np jiffies 117 c023027c (D) prof_shift 118 c0230280 (D) jiffies 119 c02302a0 (D) task 120 121 Translate a symbol value to its name and module: 122 123 crash\u0026gt; sym f88878d1 124 f88878d1 (t) ext3_readdir [ext3] 125 crash\u0026gt; 42. sys - system data 42.1. SYNOPSIS 1sys [-c [name|number]] [-t] [-i] config 42.2. DESCRIPTION 1 This command displays system-specific data. If no arguments are entered, 2 the same system data shown during crash invocation is shown. 3 4 -c [name|number] If no name or number argument is entered, dump all 5 sys_call_table entries. If a name string is entered, 6 search the table for all entries containing the string. 7 If a number is entered, the table entry associated with 8 that number is displayed. If the current output radix 9 has been set to 16, the system call numbers will be 10 displayed in hexadecimal. 11 config If the kernel was configured with CONFIG_IKCONFIG, then 12 dump the in-kernel configuration data. 13 -t Display kernel taint information. If the \u0026#34;tainted_mask\u0026#34; 14 symbol exists, show its hexadecimal value and translate 15 each bit set to the symbolic letter of the taint type. 16 On older kernels with the \u0026#34;tainted\u0026#34; symbol, only its 17 hexadecimal value is shown. The relevant kernel sources 18 should be consulted for the meaning of the letter(s) or 19 hexadecimal bit value(s). 20 -panic Panic a live system. Requires write permission to 21 /dev/mem. Results in the crash context causing an 22 \u0026#34;Attempted to kill the idle task!\u0026#34; panic. (The dump 23 will indicate that the crash context has a PID of 0). 24 -i Dump the DMI string data if available in the kernel. 42.3. EXAMPLES 1 Display essential system information: 2 3 crash\u0026gt; sys 4 KERNEL: vmlinux.4 5 DUMPFILE: lcore.cr.4 6 CPUS: 4 7 DATE: Mon Oct 11 18:48:55 1999 8 UPTIME: 10 days, 14:14:39 9 LOAD AVERAGE: 0.74, 0.23, 0.08 10 TASKS: 77 11 NODENAME: test.mclinux.com 12 RELEASE: 2.2.5-15smp 13 VERSION: #24 SMP Mon Oct 11 17:41:40 CDT 1999 14 MACHINE: i686 (500 MHz) 15 MEMORY: 1 GB 16 17 Dump the system configuration data (if CONFIG_IKCONFIG): 18 19 crash\u0026gt; sys config 20 # 21 # Automatically generated make config: don\u0026#39;t edit 22 # Linux kernel version: 2.6.16 23 # Mon Apr 10 07:58:06 2006 24 # 25 CONFIG_X86_64=y 26 CONFIG_64BIT=y 27 CONFIG_X86=y 28 CONFIG_SEMAPHORE_SLEEPERS=y 29 CONFIG_MMU=y 30 CONFIG_RWSEM_GENERIC_SPINLOCK=y 31 CONFIG_GENERIC_CALIBRATE_DELAY=y 32 CONFIG_X86_CMPXCHG=y 33 CONFIG_EARLY_PRINTK=y 34 CONFIG_GENERIC_ISA_DMA=y 35 CONFIG_GENERIC_IOMAP=y 36 CONFIG_ARCH_MAY_HAVE_PC_FDC=y 37 CONFIG_DMI=y 38 ... 39 40 Display the kernel taint information, in this case where both the 41 TAINT_WARN and TAINT_PROPRIETARY_MODULE bits have been set: 42 43 crash\u0026gt; sys -t 44 TAINTED_MASK: 201 PW 45 46 Dump the system call table: 47 48 crash\u0026gt; sys -c 49 NUM SYSTEM CALL FILE AND LINE NUMBER 50 0 sys_ni_syscall ../kernel/sys.c: 48 51 1 sys_exit ../kernel/exit.c: 404 52 2 sys_fork ../arch/i386/kernel/process.c: 771 53 3 sys_read ../fs/read_write.c: 117 54 4 sys_write ../fs/read_write.c: 146 55 5 sys_open ../fs/open.c: 754 56 6 sys_close ../fs/open.c: 839 57 7 sys_waitpid ../kernel/exit.c: 503 58 8 sys_creat ../fs/open.c: 789 59 9 sys_link ../fs/namei.c: 1213 60 10 sys_unlink ../fs/namei.c: 1074 61 11 sys_execve ../arch/i386/kernel/process.c: 806 62 ... 63 64 Find the system call number of the select system call: 65 66 crash\u0026gt; sys -c select 67 NUM SYSTEM CALL FILE AND LINE NUMBER 68 65 sys_select ../fs/select.c: 259 69 70 If the current output radix has been set to 16, the system call numbers 71 will be displayed in hexadecimal. 72 73 Dump the DMI string data: 74 75 crash\u0026gt; sys -i 76 DMI_BIOS_VENDOR: LENOVO 77 DMI_BIOS_VERSION: G4ET37WW (1.12 ) 78 DMI_BIOS_DATE: 05/29/2012 79 DMI_SYS_VENDOR: LENOVO 80 DMI_PRODUCT_NAME: 2429BQ1 81 DMI_PRODUCT_VERSION: ThinkPad T530 82 DMI_PRODUCT_SERIAL: R9R91HZ 83 DMI_PRODUCT_UUID: 568DFA01-5180-11CB-B851-BD06085ADDB0 84 DMI_BOARD_VENDOR: LENOVO 85 DMI_BOARD_NAME: 2429BQ1 86 DMI_BOARD_VERSION: Not Available 87 DMI_BOARD_SERIAL: 1ZLV127F17M 88 DMI_BOARD_ASSET_TAG: Not Available 89 DMI_CHASSIS_VENDOR: LENOVO 90 DMI_CHASSIS_TYPE: 10 91 DMI_CHASSIS_VERSION: Not Available 92 DMI_CHASSIS_SERIAL: R9R91HZ 93 DMI_CHASSIS_ASSET_TAG: RH0004111 43. task - task_struct and thread_info contents 43.1. SYNOPSIS 1task [-R member[,member]] [-dx] [pid | taskp] ... 43.2. DESCRIPTION 1 This command dumps a formatted display of the contents of a task\u0026#39;s 2 task_struct and thread_info structures. Multiple task or PID numbers 3 may be entered; if no arguments are entered, the task_struct and 4 thread_info structures of the current context are displayed. The -R option, 5 which may also be invoked indirectly via \u0026#34;foreach task\u0026#34;, pares the output 6 down to one or more structure members. 7 8 pid a process PID. 9 taskp a hexadecimal task_struct pointer. 10 -R member a comma-separated list of one or more task_struct and/or 11 thread_info structure members. If any member contains an embedded 12 structure, or is an array, the output may be restricted to the 13 embedded structure or an array element by expressing the member 14 argument as \u0026#34;member.member\u0026#34; or \u0026#34;member[index]\u0026#34;; embedded member 15 specifications may extend beyond one level deep, by expressing the 16 member argument as \u0026#34;member.member.member...\u0026#34;. 17 -x override default output format with hexadecimal format. 18 -d override default output format with decimal format. 43.3. EXAMPLES 1 Dump the task_struct and thread_info structures of the current context 2 in hexadecimal format: 3 4 crash\u0026gt; task -x 5 PID: 3176 TASK: f2451550 CPU: 1 COMMAND: \u0026#34;memtest\u0026#34; 6 struct task_struct { 7 state = 0x0, 8 stack = 0xf05b6000, 9 usage = { 10 counter = 0x2 11 }, 12 flags = 0x402040, 13 ptrace = 0x0, 14 lock_depth = 0xffffffff, 15 prio = 0x78, 16 static_prio = 0x78, 17 normal_prio = 0x78, 18 rt_priority = 0x0, 19 ... 20 perf_event_ctxp = {0x0, 0x0}, 21 memcg_batch = { 22 do_batch = 0x0, 23 memcg = 0x0, 24 bytes = 0x0, 25 memsw_bytes = 0x0 26 } 27 } 28 29 struct thread_info { 30 task = 0xf2451550, 31 exec_domain = 0xc0a60860, 32 flags = 0x88, 33 status = 0x0, 34 cpu = 0x1, 35 preempt_count = 0x4010000, 36 addr_limit = { 37 seg = 0xc0000000 38 }, 39 restart_block = { 40 ... 41 42 Display the ngroups and groups task_struct members for PID 2958: 43 44 crash\u0026gt; task -R ngroups,groups 2958 45 PID: 2958 TASK: c6718000 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 46 ngroups = 6, 47 groups = {504, 8, 9, 1000, 1007, 1006, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 49 50 Display the embedded sched_entity structure\u0026#39;s on_rq member: 51 52 crash\u0026gt; task -R se.on_rq 53 PID: 6529 TASK: ffff880116538790 CPU: 1 COMMAND: \u0026#34;bash\u0026#34; 54 se.on_rq = 1, 55 56 Display the 3rd pid_link structure in the embedded pids[] array: 57 58 crash\u0026gt; task -R pids[2] 59 PID: 6529 TASK: ffff880116538790 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 60 pids[2] = { 61 node = { 62 next = 0xffff8801165391b0, 63 pprev = 0xffff880209d011b0 64 }, 65 pid = 0xffff8801f0876e00 66 } 67 68 NOTE: When this command is invoked directly (i.e., not from \u0026#34;foreach\u0026#34;), it 69 is not necessary to include the \u0026#34;-R\u0026#34; before the task_struct/thread_info 70 member name(s). 44. tree - display radix tree, XArray or red-black tree 44.1. SYNOPSIS 1tree [-t [radix|xarray|rbtree]] [-r offset] [-[s|S] struct[.member[,member]]] 2 -[x|d] [-o offset] [-l] [-p] [-N] start 44.2. DESCRIPTION 1 This command dumps the contents of a radix tree, an XAarray, or a red-black 2 tree. The arguments are as follows: 3 4 -t type The type of tree to dump; the type string can be one of 5 \u0026#34;radix\u0026#34;, \u0026#34;rbtree\u0026#34;, or \u0026#34;xarray\u0026#34;, or alternatively, \u0026#34;ra\u0026#34;, 6 \u0026#34;rb\u0026#34; or \u0026#34;x\u0026#34; are acceptable. If not specified, rbtree is the 7 default type. 8 -r offset If the \u0026#34;start\u0026#34; argument is the address of a data structure that 9 contains an radix_tree_root, xarray or rb_root structure, then this 10 is the offset to that structure member. If the offset is non-zero, 11 then this option is required. The offset may be entered in either 12 of two manners: 13 1. In \u0026#34;structure.member\u0026#34; format. 14 2. A number of bytes. 15 -o offset For red-black trees only, the offset of the rb_node within its 16 containing data structure; if the offset is non-zero, then this 17 option is required. The offset may be entered in either of two 18 manners: 19 1. In \u0026#34;structure.member\u0026#34; format. 20 2. A number of bytes. 21 This option is not applicable to radix trees. 22 -s struct For each entry in a tree, format and print it as this type of data 23 structure; use the \u0026#34;struct.member\u0026#34; format in order to display a 24 particular member of the structure. To display multiple members 25 of a structure, use a comma-separated list of members. If any 26 structure member contains an embedded structure or is an array, the 27 the output may be restricted to the embedded structure or an array 28 element by expressing the member argument as \u0026#34;struct.member.member\u0026#34; 29 or \u0026#34;struct.member[index]\u0026#34;; embedded member specifications may 30 extend beyond one level deep by expressing the struct argument as 31 \u0026#34;struct.member.member.member...\u0026#34;. 32 -S struct Similar to -s, but instead of parsing gdb output, member values 33 are read directly from memory, so the command works much faster 34 for 1-, 2-, 4-, and 8-byte members. 35 -l For red-black trees, dump the tree sorted in linear order starting 36 with the leftmost node and progressing to the right. This option 37 does not apply to radix trees. 38 -p Display the node\u0026#39;s position information, showing the relationship 39 between it and the root. For red-black trees, a position that 40 indicates \u0026#34;root/l/r\u0026#34; means that the node is the right child 41 of the left child of the root node. For radix trees and xarrays, 42 the index, the height, and the slot index values are shown with 43 respect to the root. 44 -x Override default output format with hexadecimal format. 45 -d Override default output format with decimal format. 46 47 The meaning of the \u0026#34;start\u0026#34; argument, which can be expressed either in 48 hexadecimal format or symbolically, depends upon whether the -N option 49 is prepended: 50 51 start The address of a radix_tree_root, xarray or rb_root structure, or 52 the address of a structure containing the radix_tree_root, xarray 53 or rb_root structure; if the latter, then the \u0026#34;-r offset\u0026#34; option 54 must be used if the member offset of the root structure is 55 non-zero. 56 57 -N start The address of a radix_tree_node, xa_node or rb_node structure, 58 bypassing the radix_tree_root, xarray, or rb_root that points 59 to it. 44.3. EXAMPLES 1 The vmap_area_root is a standalone rb_root structure. Display the 2 virtual addresses of each vmap_area in its red-black tree: 3 4 crash\u0026gt; whatis vmap_area_root 5 struct rb_root vmap_area_root; 6 crash\u0026gt; tree -t rbtree -o vmap_area.rb_node vmap_area_root 7 ffff880128c508c0 8 ffff88012cb68140 9 ffff88012c9afec0 10 ffff88012d65c440 11 ... 12 13 Display the vmap_area\u0026#39;s va_start and va_end members of each of 14 the entries above expressing the vmap_area.rb_node offset as a 15 number of bytes: 16 17 crash\u0026gt; tree -t rbtree -o 24 vmap_area_root -s vmap_area.va_start,va_end 18 ffff880128c508c0 19 va_start = 0xffffc90014900000 20 va_end = 0xffffc90014921000 21 ffff88012cb68140 22 va_start = 0xffffc900110c0000 23 va_end = 0xffffc900110d1000 24 ffff88012c9afec0 25 va_start = 0xffffc90000640000 26 va_end = 0xffffc90000642000 27 ffff88012d65c440 28 va_start = 0xffffc90000620000 29 va_end = 0xffffc90000622000 30 ... 31 32 Alternatively, use the -N option with the rb_node address contained 33 in the vmap_area_root structure: 34 35 crash\u0026gt; p vmap_area_root 36 vmap_area_root = $8 = { 37 rb_node = 0xffff880128c508d8 38 } 39 crash\u0026gt; tree -t rbtree -o vmap_area.rb_node -N 0xffff880128c508d8 40 ffff880128c508c0 41 ffff88012cb68140 42 ffff88012c9afec0 43 ffff88012d65c440 44 45 Display the virtual address of each vm_area_struct in the red-black 46 tree that has its root inside an mm_struct located at ffff880128b5a300. 47 The vm_area_struct.vm_rb rb_node member has an offset of 0x38 bytes: 48 49 crash\u0026gt; tree -t rbtree -r mm_struct.mm_rb ffff880128b5a300 -o 0x38 50 ffff88012a0de080 51 ffff880123e3ac78 52 ffff880123e3a700 53 ffff88012b2837c8 54 ... 55 ffff880128c02ed0 56 ffff8801292e7958 57 ffff880123e3a318 58 ffff880123e3ad40 59 60 Add the -p option to the command above to show position information: 61 62 crash\u0026gt; tree -t rbtree -r mm_struct.mm_rb ffff880128b5a300 -o 0x38 -p 63 ffff88012a0de080 64 position: root 65 ffff880123e3ac78 66 position: root/l 67 ffff880123e3a700 68 position: root/l/l 69 ffff88012b2837c8 70 position: root/l/l/l 71 ... 72 ffff880128c02ed0 73 position: root/r/r/l/r 74 ffff8801292e7958 75 position: root/r/r/l/r/r 76 ffff880123e3a318 77 position: root/r/r/r 78 ffff880123e3ad40 79 position: root/r/r/r/r 80 81 Given an mm_struct address of 0xffff880074b5be80, list the VMA tree in linear 82 order from the leftmost node progressing to the right using the -l option: 83 84 crash\u0026gt; tree -ls vm_area_struct.vm_start -o vm_area_struct.vm_rb \\ 85 -r mm_struct.mm_rb 0xffff880074b5be80 | paste - - 86 ffff88001f2c50e0\tvm_start = 0x400000 87 ffff88001f2c5290\tvm_start = 0xceb000 88 ffff880074bfc6c0\tvm_start = 0xcec000 89 ffff88001f2c4bd0\tvm_start = 0xd10000 90 ffff880074bfc948\tvm_start = 0x1fe9000 91 ffff880036e54510\tvm_start = 0x7ff6aa296000 92 ffff88001f2c5bd8\tvm_start = 0x7ff6aa298000 93 ffff880036e54af8\tvm_start = 0x7ff6aa497000 94 ffff880036e54f30\tvm_start = 0x7ff6aa498000 95 ffff88000e06aa20\tvm_start = 0x7ff6aa499000 96 ffff88000e06b368\tvm_start = 0x7ff6ab95f000 97 ... 98 ffff88001f2c5e60\tvm_start = 0x7ff6bc1af000 99 ffff88001f2c4ca8\tvm_start = 0x7ff6bc1b6000 100 ffff88001f2c5008\tvm_start = 0x7ff6bc200000 101 ffff88001f2c5d88\tvm_start = 0x7ff6bc205000 102 ffff880074bfd6c8\tvm_start = 0x7ff6bc206000 103 ffff88001f2c4288\tvm_start = 0x7ff6bc207000 104 ffff88001f2c4510\tvm_start = 0x7ffc7a5fc000 105 ffff88001f2c5b00\tvm_start = 0x7ffc7a6d1000 106 107 Compared to the top/down root/leaves order: 108 109 crash\u0026gt; tree -s vm_area_struct.vm_start -o vm_area_struct.vm_rb \\ 110 -r mm_struct.mm_rb 0xffff880074b5be80 | paste - - 111 ffff88001f2c5a28\tvm_start = 0x7ff6bbbb9000 112 ffff88001f2c55f0\tvm_start = 0x7ff6bb252000 113 ffff88000e06a360\tvm_start = 0x7ff6ac6c3000 114 ffff88001f2c4bd0\tvm_start = 0xd10000 115 ffff88001f2c5290\tvm_start = 0xceb000 116 ffff88001f2c50e0\tvm_start = 0x400000 117 ffff880074bfc6c0\tvm_start = 0xcec000 118 ffff88000e06b368\tvm_start = 0x7ff6ab95f000 119 ffff88001f2c5bd8\tvm_start = 0x7ff6aa298000 120 ffff880074bfc948\tvm_start = 0x1fe9000 121 ffff880036e54510\tvm_start = 0x7ff6aa296000 122 ffff880036e54f30\tvm_start = 0x7ff6aa498000 123 ffff880036e54af8\tvm_start = 0x7ff6aa497000 124 ffff88000e06aa20\tvm_start = 0x7ff6aa499000 125 ffff88000e06ae58\tvm_start = 0x7ff6ac1df000 126 ffff88000e06ba28\tvm_start = 0x7ff6abefc000 127 ffff88000e06a6c0\tvm_start = 0x7ff6ac41b000 128 ffff88001f2c4000\tvm_start = 0x7ff6bac75000 129 ffff88000e06bd88\tvm_start = 0x7ff6b2d00000 130 ffff88000e06b440\tvm_start = 0x7ff6b28de000 131 ... 132 ffff880074bfd6c8\tvm_start = 0x7ff6bc206000 133 ffff88001f2c4510\tvm_start = 0x7ffc7a5fc000 134 ffff88001f2c5b00\tvm_start = 0x7ffc7a6d1000 135 136 Display a list of the page structs in the radix tree of an address_space 137 structure located at ffff88012d364de0: 138 139 crash\u0026gt; tree -t radix -r address_space.page_tree ffff88012d364de0 140 ffffea00040d12c0 141 ffffea00040d9a60 142 ffffea00040d9b08 143 ffffea000407eda8 144 ffffea0004084288 145 ... 146 ffffea000407bc70 147 ffffea00040baf48 148 ffffea0004043f48 149 ffffea000407de58 150 151 Add the -p option to the command above to show position information: 152 153 crash\u0026gt; tree -t radix -r address_space.page_tree ffff88012d364de0 -p 154 ffffea00040d12c0 155 index: 0 position: root/0/0 156 ffffea00040d9a60 157 index: 1 position: root/0/1 158 ffffea00040d9b08 159 index: 2 position: root/0/2 160 ffffea000407eda8 161 index: 3 position: root/0/3 162 ffffea0004084288 163 index: 4 position: root/0/4 164 ... 165 ffffea000407bc70 166 index: 217 position: root/3/25 167 ffffea00040baf48 168 index: 218 position: root/3/26 169 ffffea0004043f48 170 index: 219 position: root/3/27 171 ffffea000407de58 172 index: 220 position: root/3/28 173 174 Alternatively, take the address of the radix_tree_node from the 175 radix_tree_root structure in the address_space structure above, 176 and display the tree with the -N option: 177 178 crash\u0026gt; struct address_space.page_tree ffff88012d364de0 179 page_tree = { 180 height = 0x2, 181 gfp_mask = 0x20, 182 rnode = 0xffff8801238add71 183 } 184 crash\u0026gt; tree -t radix -N 0xffff8801238add71 185 ffffea00040d12c0 186 ffffea00040d9a60 187 ffffea00040d9b08 188 ffffea000407eda8 189 ffffea0004084288 190 ffffea00040843a0 191 ... 192 193 Using the same radix tree as above, display the flags and _count 194 members of each page struct in the list, and force the output format 195 to be hexadecimal: 196 197 crash\u0026gt; tree -t radix -N 0xffff8801238add71 -s page.flags,_count -x 198 ffffea00040d12c0 199 flags = 0x4000000002006c 200 _count = { 201 counter = 0x7 202 } 203 ffffea00040d9a60 204 flags = 0x4000000002006c 205 _count = { 206 counter = 0x7 207 } 208 ffffea00040d9b08 209 flags = 0x4000000002006c 210 _count = { 211 counter = 0x7 212 } 213 ffffea000407eda8 214 flags = 0x4000000002006c 215 _count = { 216 counter = 0x7 217 } 218 ... 219 220 In more recent kernels, the XArray facility has replaced radix trees. 221 Display a list of the page structs in the XArray of an address_space 222 structure located at 0xffff94c235e76828, where the i_pages field is 223 an embedded xarray structure: 224 225 crash\u0026gt; tree -t xarray -r address_space.i_pages 0xffff94c235e76828 226 fffffcc005aa8380 227 fffffcc005cafa80 228 fffffcc005a79c80 229 fffffcc005ccad80 230 fffffcc005a72ec0 231 fffffcc005e27c00 232 fffffcc005ce3100 233 fffffcc005ff8dc0 234 fffffcc005c9a100 235 fffffcc005a49e40 236 fffffcc005c95a80 237 238 Add the -p option to the command above to show position information: 239 240 crash\u0026gt; tree -t xarray -r address_space.i_pages 0xffff94c235e76828 -p 241 fffffcc005aa8380 242 index: 90 position: root/1/26 243 fffffcc005cafa80 244 index: 91 position: root/1/27 245 fffffcc005a79c80 246 index: 92 position: root/1/28 247 fffffcc005ccad80 248 index: 93 position: root/1/29 249 fffffcc005a72ec0 250 index: 94 position: root/1/30 251 fffffcc005e27c00 252 index: 95 position: root/1/31 253 fffffcc005ce3100 254 index: 96 position: root/1/32 255 fffffcc005ff8dc0 256 index: 97 position: root/1/33 257 fffffcc005c9a100 258 index: 98 position: root/1/34 259 fffffcc005a49e40 260 index: 99 position: root/1/35 261 fffffcc005c95a80 262 index: 100 position: root/1/36 263 264 Alternatively, take the value found in the xa_head field from 265 the xarray structure, and display the tree with the -N option: 266 267 crash\u0026gt; address_space.i_pages 0xffff94c235e76828 268 i_pages = { 269 ... [ xa_lock field not shown ] ... 270 xa_flags = 1, 271 xa_head = 0xffff94c23c1566ca 272 } 273 crash\u0026gt; tree -t x -N 0xffff94c23c1566ca 274 fffffcc005aa8380 275 fffffcc005cafa80 276 fffffcc005a79c80 277 fffffcc005ccad80 278 fffffcc005a72ec0 279 fffffcc005e27c00 280 fffffcc005ce3100 281 fffffcc005ff8dc0 282 fffffcc005c9a100 283 fffffcc005a49e40 284 fffffcc005c95a80 285 286 Using the same xarray command as above, display the flags and _refcount 287 members of each page struct in the list, and force the output format 288 to be hexadecimal: 289 290 crash\u0026gt; tree -t x -N 0xffff94c23c1566ca -s page.flags,_refcount -x 291 fffffcc005aa8380 292 flags = 0x57ffffc0000014 293 _refcount = { 294 counter = 0x1 295 } 296 fffffcc005cafa80 297 flags = 0x57ffffc0000014 298 _refcount = { 299 counter = 0x1 300 } 301 fffffcc005a79c80 302 flags = 0x57ffffc0000014 303 _refcount = { 304 counter = 0x1 305 } 306 fffffcc005ccad80 307 flags = 0x57ffffc0000014 308 _refcount = { 309 counter = 0x1 310 } 311 fffffcc005a72ec0 312 flags = 0x57ffffc0000014 313 _refcount = { 314 counter = 0x1 315 } 316 fffffcc005e27c00 317 flags = 0x57ffffc0000014 318 _refcount = { 319 counter = 0x1 320 } 321 fffffcc005ce3100 322 flags = 0x57ffffc0000014 323 _refcount = { 324 counter = 0x1 325 } 326 fffffcc005ff8dc0 327 flags = 0x57ffffc0000014 328 _refcount = { 329 counter = 0x1 330 } 331 fffffcc005c9a100 332 flags = 0x57ffffc0000014 333 _refcount = { 334 counter = 0x1 335 } 336 fffffcc005a49e40 337 flags = 0x57ffffc0000014 338 _refcount = { 339 counter = 0x1 340 } 341 fffffcc005c95a80 342 flags = 0x57ffffc0000014 343 _refcount = { 344 counter = 0x1 345 } 45. timer - timer queue data 45.1. SYNOPSIS 1timer [-r][-C cpu] 45.2. DESCRIPTION 1 This command displays the timer queue entries, both old- and new-style, 2 in chronological order. In the case of the old-style timers, the 3 timer_table array index is shown; in the case of the new-style timers, 4 the timer_list address is shown. On later kernels, the timer data is 5 per-cpu. 6 7 -r Display hrtimer timer queue entries, both old- and new-style, in 8 chronological order. In the case of the old-style hrtimers, the 9 expiration time is a single value; in the new-style hrtimers, the 10 expiration time is a range. 11 -C cpu Restrict the output to one or more CPUs, where multiple cpu[s] can 12 be specified, for example, as \u0026#34;1,3,5\u0026#34;, \u0026#34;1-3\u0026#34;, or \u0026#34;1,3,5-7,10\u0026#34;. 45.3. EXAMPLES 1 Display the timer queue on an SMP system: 2 3 crash\u0026gt; timer 4 JIFFIES 5 4296291038 6 ... 7 TIMER_BASES[1][BASE_STD]: ffff9801aba5aa00 8 EXPIRES TTE TIMER_LIST FUNCTION 9 4296282997 -8041 ffff9801aba55ce0 ffffffff83a3bda0 \u0026lt;mce_timer_fn\u0026gt; 10 4296283104 -7934 ffff97fd84bd35e0 ffffffff83ac6b70 \u0026lt;delayed_work_timer_fn\u0026gt; 11 4296291061 23 ffffa6b283967de0 ffffffff83b29880 \u0026lt;process_timeout\u0026gt; 12 4296291112 74 ffff9800c9b62ad8 ffffffff83e6b550 \u0026lt;cursor_timer_handler\u0026gt; 13 4296291345 307 ffff980186d5ef88 ffffffff84146b80 \u0026lt;tcp_keepalive_timer\u0026gt; 14 4296291484 446 ffff9801a7c54740 ffffffff84147f50 \u0026lt;tcp_write_timer\u0026gt; 15 4296291997 959 ffffffffc073f880 ffffffff83ac6b70 \u0026lt;delayed_work_timer_fn\u0026gt; 16 4296296213 5175 ffffa6b28339be18 ffffffff83b29880 \u0026lt;process_timeout\u0026gt; 17 4296304383 13345 ffff980194ca72a8 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 18 4296305724 14686 ffff980194ca6918 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 19 4296306036 14998 ffff980194ca6d58 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 20 4296306883 15845 ffff980194ca7e58 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 21 4296307588 16550 ffff9801aaa27e58 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 22 4296307625 16587 ffff980194ca6a28 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 23 4296313542 22504 ffff980194ca7c38 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 24 4296317680 26642 ffff9800c9149c58 ffffffff840da870 \u0026lt;neigh_timer_handler\u0026gt; 25 4296317744 26706 ffff9801a5354468 ffffffff83ac6b70 \u0026lt;delayed_work_timer_fn\u0026gt; 26 4296343322 52284 ffff980194ca63c8 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 27 4296343581 52543 ffff980194ca7088 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 28 4296343597 52559 ffff9801aaa274c8 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 29 4296714205 423167 ffffffff84caf3c0 ffffffff83ac6b70 \u0026lt;delayed_work_timer_fn\u0026gt; 30 TIMER_BASES[1][BASE_DEF]: ffff9801aba5bc80 31 EXPIRES TTE TIMER_LIST FUNCTION 32 4296291264 226 ffffffff855eb238 ffffffff83c08fb0 \u0026lt;writeout_period\u0026gt; 33 4296319997 28959 ffffffffc06ede40 ffffffff83ac6b70 \u0026lt;delayed_work_timer_fn\u0026gt; 34 4296506084 215046 ffff9801aba629c8 ffffffff83ac5ea0 \u0026lt;idle_worker_timeout\u0026gt; 35 ... 36 37 Display a new-style hrtimer queue: 38 39 crash\u0026gt; timer -r 40 ... 41 CPU: 2 HRTIMER_CPU_BASE: ffff9801aba9cf00 42 CLOCK: 0 HRTIMER_CLOCK_BASE: ffff9801aba9cf40 [ktime_get] 43 CURRENT 44 1623742000000 45 SOFTEXPIRES EXPIRES TTE HRTIMER FUNCTION 46 1623741000000 1623741000000 -1000000 ffff9801aba9d540 ffffffff83b3c8e0 \u0026lt;tick_sched_timer\u0026gt; 47 1624024000000 1624024000000 282000000 ffff9801aba9d720 ffffffff83b7e7a0 \u0026lt;watchdog_timer_fn\u0026gt; 48 1626000939806 1626010929804 2268929804 ffffa6b28399fa40 ffffffff83b2c1e0 \u0026lt;hrtimer_wakeup\u0026gt; 49 1627576915615 1627576915615 3834915615 ffff9801a5727978 ffffffff83b365c0 \u0026lt;posix_timer_fn\u0026gt; 50 1627637194488 1627647194487 3905194487 ffffa6b283977db0 ffffffff83b2c1e0 \u0026lt;hrtimer_wakeup\u0026gt; 51 1629937423000 1629937423000 6195423000 ffff9801a9af2900 ffffffff83cf3d30 \u0026lt;timerfd_tmrproc\u0026gt; 52 53 CLOCK: 1 HRTIMER_CLOCK_BASE: ffff9801aba9cf80 [ktime_get_real] 54 CURRENT 55 1558362388334558243 56 SOFTEXPIRES EXPIRES TTE HRTIMER FUNCTION 57 1558362389331238000 1558362389331288000 996729757 ffffa6b28574bcf0 ffffffff83b2c1e0 \u0026lt;hrtimer_wakeup\u0026gt; 58 1558364372000000000 1558364372000000000 1983665441757 ffff9801a3513278 ffffffff83b365c0 \u0026lt;posix_timer_fn\u0026gt; 59 60 CLOCK: 2 HRTIMER_CLOCK_BASE: ffff9801aba9cfc0 [ktime_get_boottime] 61 (empty) 62 ... 46. union - union contents 46.1. SYNOPSIS 1union union_name[.member[,member]] [-o][-l offset][-rfuxdp] 2 [address | symbol][:cpuspec] [count | -c count] 46.2. DESCRIPTION 1 This command displays either a union definition, or a formatted display 2 of the contents of a union at a specified address. When no address is 3 specified, the union definition is shown along with the union size. 4 A union member may be appended to the structure name in order to limit 5 the scope of the data displayed to that particular member; when no address 6 is specified, the member\u0026#39;s offset (always 0) and definition are shown. 7 8 union_name name of a C-code union used by the kernel. 9 .member name of a union member; to display multiple members of a 10 union, use a comma-separated list of members. If any member 11 contains an embedded structure, or the member is an array, the 12 output may be restricted to just the embedded structure or an 13 array element by expressing the argument as \u0026#34;member.member\u0026#34; 14 or \u0026#34;member[index]\u0026#34;; embedded member specifications may extend 15 beyond one level deep, by expressing the member argument as 16 \u0026#34;member.member.member...\u0026#34;. 17 -o show member offsets when displaying union definitions; the 18 offset is always 0 unless used with an address or symbol 19 argument, in which case each member will be preceded by its 20 virtual address. 21 -l offset if the address argument is a pointer to a list_head structure 22 that is embedded in the target union structure, the offset 23 to the list_head member may be entered in either of the 24 following manners: 25 1. in \u0026#34;structure.member\u0026#34; format. 26 2. a number of bytes. 27 -r raw dump of union data. 28 -f address argument is a dumpfile offset. 29 -x override default output format with hexadecimal format. 30 -d override default output format with decimal format. 31 -p if a union member is a pointer value, show the member\u0026#39;s 32 data type on the output line; and on the subsequent line(s), 33 dereference the pointer, display the pointer target\u0026#39;s symbol 34 value in brackets if appropriate, and if possible, display the 35 target data; requires an address argument. 36 -u address argument is a user virtual address in the current 37 context. 38 address hexadecimal address of a union; if the address points 39 to an embedded list_head structure contained within the 40 target union structure, then the \u0026#34;-l\u0026#34; option must be used. 41 symbol symbolic reference to the address of a union. 42 :cpuspec CPU specification for a per-cpu address or symbol: 43 : CPU of the currently selected task. 44 :a[ll] all CPUs. 45 :#[-#][,...] CPU list(s), e.g. \u0026#34;1,3,5\u0026#34;, \u0026#34;1-3\u0026#34;, 46 or \u0026#34;1,3,5-7,10\u0026#34;. 47 count count of unions to dump from an array of unions; if used, 48 this must be the last argument entered. 49 -c count \u0026#34;-c\u0026#34; is only required if \u0026#34;count\u0026#34; is not the last argument 50 entered or if a negative number is entered; if a negative 51 value is entered, the (positive) \u0026#34;count\u0026#34; structures that 52 lead up to and include the target structure will be displayed. 53 54 Union data, sizes, and member offsets are shown in the current output radix 55 unless the -x or -d option is specified. 56 57 Please note that in the vast majority of cases, the \u0026#34;union\u0026#34; command 58 name may be dropped; if the union name does not conflict with any crash 59 or gdb command name, then the \u0026#34;union_name[.member]\u0026#34; argument will be 60 recognized as a union name, and this command automatically executed. 61 See the NOTE below. 46.3. EXAMPLES 1 2 Display the bdflush_param union definition, and then an instance of it: 3 4 crash\u0026gt; union bdflush_param 5 union bdflush_param { 6 struct { 7 int nfract; 8 int ndirty; 9 int nrefill; 10 int nref_dirt; 11 int dummy1; 12 int age_buffer; 13 int age_super; 14 int dummy2; 15 int dummy3; 16 } b_un; 17 unsigned int data[9]; 18 } 19 20 SIZE: 36 (0x24) 21 22 crash\u0026gt; union bdflush_param bdf_prm 23 union bdflush_param { 24 b_un = { 25 nfract = 40, 26 ndirty = 500, 27 nrefill = 64, 28 nref_dirt = 256, 29 dummy1 = 15, 30 age_buffer = 3000, 31 age_super = 500, 32 dummy2 = 1884, 33 dummy3 = 2 34 }, 35 data = {40, 500, 64, 256, 15, 3000, 500, 1884, 2} 36 } 46.4. NOTE 1 If the union name does not conflict with any crash command name, the 2 \u0026#34;union\u0026#34; command may be dropped. Accordingly, the examples above could 3 also have been accomplished like so: 4 5 crash\u0026gt; bdflush_param 6 crash\u0026gt; bdflush_param bdf_prm 7 8 Lastly, the short-cut \u0026#34;*\u0026#34; (pointer-to) command may also be used to negate 9 the need to enter the \u0026#34;union\u0026#34; command name (enter \u0026#34;help *\u0026#34; for details). 47. vm - virtual memory 47.1. SYNOPSIS 1vm [-p | -P vma | -M mm | -v | -m | -x | -d | [-R reference] [pid | task]] 2 [-f vm_flags] 47.2. DESCRIPTION 1 This command displays basic virtual memory information of a context, 2 consisting of a pointer to its mm_struct and page dirctory, its RSS and 3 total virtual memory size; and a list of pointers to each vm_area_struct, 4 its starting and ending address, vm_flags value, and file pathname. If no 5 arguments are entered, the current context is used. Additionally, the -p 6 option translates each virtual page of each VM area to its physical address. 7 The -R option, typically invoked from \u0026#34;foreach vm\u0026#34;, searches for references 8 to a supplied number, address, or filename argument, and prints only the 9 essential information leading up to and including the reference. 10 Alternatively, the -m or -v options may be used to dump the task\u0026#39;s mm_struct 11 or all of its vm_area_structs respectively. The -p, -v, -m, -R and -f 12 options are all mutually exclusive. 13 14 -p translate each virtual page to its physical address, or if 15 the page is not mapped, its swap device and offset, or 16 filename and offset. 17 -P vma similar to -p, but only translate the pages belonging to the 18 specified VM area of a context. 19 -M mm if the mm_struct address has been removed from the task_struct 20 of an exiting task, the virtual memory data cannot be displayed. 21 However, if the address can be determined from the kernel stack, 22 it can be entered manually in order to try to resurrect the 23 virtual memory data of the task. 24 -R reference search for references to this number or filename. 25 -m dump the mm_struct assocated with the task. 26 -v dump all of the vm_area_structs associated with the task. 27 -x override the default output format for the -m or -v options 28 with hexadecimal format. 29 -d override the default output format for the -m or -v options 30 with decimal format. 31 -f vm_flags translate the bits of a FLAGS (vm_flags) value. 32 pid a process PID. 33 task a hexadecimal task_struct pointer. 47.3. EXAMPLES 1 Display the virtual memory data of the current context: 2 3 crash\u0026gt; vm 4 PID: 30986 TASK: c0440000 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 5 MM PGD RSS TOTAL_VM 6 c303fe20 c4789000 88k 1728k 7 VMA START END FLAGS FILE 8 c0d1f540 8048000 80ad000 1875 /bin/bash 9 c0d1f400 80ad000 80b3000 1873 /bin/bash 10 c0d1f880 80b3000 80ec000 77 11 c0d1f0c0 40000000 40012000 875 /lib/ld-2.1.1.so 12 c0d1f700 40012000 40013000 873 /lib/ld-2.1.1.so 13 c0d1fe00 40013000 40014000 77 14 c0d1f580 40014000 40016000 73 15 c0d1f280 4001a000 4004b000 75 /usr/lib/libncurses.so.4.2 16 c0d1f100 4004b000 40054000 73 /usr/lib/libncurses.so.4.2 17 c0d1f600 40054000 40057000 73 18 c0d1f9c0 40057000 40059000 75 /lib/libdl-2.1.1.so 19 c0d1f800 40059000 4005a000 73 /lib/libdl-2.1.1.so 20 c0d1fd00 4005a000 40140000 75 /lib/libc-2.1.1.so 21 c0d1fe40 40140000 40145000 73 /lib/libc-2.1.1.so 22 c0d1f780 40145000 40148000 73 23 c0d1f140 40148000 40150000 75 /lib/libnss_files-2.1.1.so 24 c0d1fa80 40150000 40151000 73 /lib/libnss_files-2.1.1.so 25 c0d1fb00 40151000 4015a000 75 /lib/libnss_nisplus-2.1.1.so 26 c5f754e0 4015a000 4015b000 73 /lib/libnss_nisplus-2.1.1.so 27 c0d1fec0 4015b000 4016d000 75 /lib/libnsl-2.1.1.so 28 c5f75460 4016d000 4016e000 73 /lib/libnsl-2.1.1.so 29 c5f75420 4016e000 40170000 73 30 c5f753e0 40170000 40178000 75 /lib/libnss_nis-2.1.1.so 31 c5f753a0 40178000 40179000 73 /lib/libnss_nis-2.1.1.so 32 c0d1f240 bfffc000 c0000000 177 33 34 Display the virtual memory data along with page translations for PID 386: 35 36 crash\u0026gt; vm -p 386 37 PID: 386 TASK: c11cc000 CPU: 0 COMMAND: \u0026#34;atd\u0026#34; 38 MM PGD RSS TOTAL_VM 39 c7e30560 c10e5000 104k 1112k 40 VMA START END FLAGS FILE 41 c0fbe6a0 8048000 804b000 1875 /usr/sbin/atd 42 VIRTUAL PHYSICAL 43 8048000 20e1000 44 8049000 17c6000 45 804a000 1f6f000 46 VMA START END FLAGS FILE 47 c61e0ba0 804b000 804d000 1873 /usr/sbin/atd 48 VIRTUAL PHYSICAL 49 804b000 254d000 50 804c000 6a9c000 51 VMA START END FLAGS FILE 52 c61e04e0 804d000 8050000 77 53 VIRTUAL PHYSICAL 54 804d000 219d000 55 804e000 2617000 56 804f000 SWAP: /dev/sda8 OFFSET: 24225 57 VMA START END FLAGS FILE 58 c61e0720 40000000 40012000 875 /lib/ld-2.1.1.so 59 VIRTUAL PHYSICAL 60 40000000 FILE: /lib/ld-2.1.1.so OFFSET: 0 61 40001000 FILE: /lib/ld-2.1.1.so OFFSET: 1000 62 40002000 FILE: /lib/ld-2.1.1.so OFFSET: 2000 63 40003000 FILE: /lib/ld-2.1.1.so OFFSET: 3000 64 40004000 FILE: /lib/ld-2.1.1.so OFFSET: 4000 65 40005000 FILE: /lib/ld-2.1.1.so OFFSET: 5000 66 ... 67 68 Although the -R option is typically invoked from \u0026#34;foreach vm\u0026#34;, it can be 69 executed directly. This example displays all VM areas with vm_flags of 75: 70 71 crash\u0026gt; vm -R 75 72 PID: 694 TASK: c0c76000 CPU: 1 COMMAND: \u0026#34;crash\u0026#34; 73 MM PGD RSS TOTAL_VM 74 c6c43110 c0fe9000 8932k 10720k 75 VMA START END FLAGS FILE 76 c322c0d0 40019000 4004a000 75 /usr/lib/libncurses.so.4.2 77 c67537c0 40056000 40071000 75 /lib/libm-2.1.1.so 78 c6753d00 40072000 40074000 75 /lib/libdl-2.1.1.so 79 c6753540 40075000 40081000 75 /usr/lib/libz.so.1.1.3 80 c6753740 40085000 4016b000 75 /lib/libc-2.1.1.so 81 82 One reason to use -R directly is to pare down the output associated with 83 the -p option on a task with a huge address space. This example displays 84 the page data associated with virtual address 40121000: 85 86 crash\u0026gt; vm -R 40121000 87 PID: 694 TASK: c0c76000 CPU: 0 COMMAND: \u0026#34;crash\u0026#34; 88 MM PGD RSS TOTAL_VM 89 c6c43110 c0fe9000 8928k 10720k 90 VMA START END FLAGS FILE 91 c6753740 40085000 4016b000 75 /lib/libc-2.1.1.so 92 VIRTUAL PHYSICAL 93 40121000 FILE: /lib/libc-2.1.1.so OFFSET: 9c000 94 95 Display the mm_struct for PID 4777: 96 97 crash\u0026gt; vm -m 4777 98 PID: 4777 TASK: c0896000 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 99 struct mm_struct { 100 mmap = 0xc6caa1c0, 101 mmap_avl = 0x0, 102 mmap_cache = 0xc6caabc0, 103 pgd = 0xc100a000, 104 count = { 105 counter = 0x1 106 }, 107 map_count = 0x14, 108 mmap_sem = { 109 count = { 110 counter = 0x1 111 }, 112 waking = 0x0, 113 wait = 0x0 114 }, 115 context = 0x0, 116 start_code = 0x8048000, 117 end_code = 0x809c6f7, 118 start_data = 0x0, 119 end_data = 0x80a2090, 120 start_brk = 0x80a5420, 121 brk = 0x80b9000, 122 start_stack = 0xbffff9d0, 123 arg_start = 0xbffffad1, 124 arg_end = 0xbffffad7, 125 env_start = 0xbffffad7, 126 env_end = 0xbffffff2, 127 rss = 0xf6, 128 total_vm = 0x1a3, 129 locked_vm = 0x0, 130 def_flags = 0x0, 131 cpu_vm_mask = 0x0, 132 swap_cnt = 0x23d, 133 swap_address = 0x0, 134 segments = 0x0 135 } 136 137 Display all of the vm_area_structs for task c47d4000: 138 139 crash\u0026gt; vm -v c47d4000 140 PID: 4971 TASK: c47d4000 CPU: 1 COMMAND: \u0026#34;login\u0026#34; 141 struct vm_area_struct { 142 vm_mm = 0xc4b0d200, 143 vm_start = 0x8048000, 144 vm_end = 0x804d000, 145 vm_next = 0xc3e3abd0, 146 vm_page_prot = { 147 pgprot = 0x25 148 }, 149 vm_flags = 0x1875, 150 vm_avl_height = 0x1, 151 vm_avl_left = 0x0, 152 vm_avl_right = 0x0, 153 vm_next_share = 0x0, 154 vm_pprev_share = 0xc3e3abf0, 155 vm_ops = 0xc02392a0, 156 vm_offset = 0x0, 157 vm_file = 0xc1e23660, 158 vm_pte = 0x0 159 } 160 struct vm_area_struct { 161 vm_mm = 0xc4b0d200, 162 vm_start = 0x804d000, 163 vm_end = 0x804e000, 164 vm_next = 0xc3e3a010, 165 vm_page_prot = { 166 pgprot = 0x25 167 }, 168 vm_flags = 0x1873, 169 vm_avl_height = 0x2, 170 vm_avl_left = 0xc3e3a810, 171 vm_avl_right = 0xc3e3a010, 172 vm_next_share = 0xc3e3a810, 173 vm_pprev_share = 0xc3699c14 174 ... 175 176 Translate a FLAGS value: 177 178 crash\u0026gt; vm -f 3875 179 3875: (READ|EXEC|MAYREAD|MAYWRITE|MAYEXEC|DENYWRITE|EXECUTABLE|LOCKED) 180 181 Display the page translations of the VM area at address f5604f2c: 182 183 crash\u0026gt; vm -P f5604f2c 184 PID: 5508 TASK: f56a9570 CPU: 0 COMMAND: \u0026#34;crond\u0026#34; 185 VMA START END FLAGS FILE 186 f5604f2c f5b000 f67000 8000075 /lib/libnss_files-2.12.so 187 VIRTUAL PHYSICAL 188 f5b000 3fec1000 189 f5c000 3d3a4000 190 f5d000 FILE: /lib/libnss_files-2.12.so OFFSET: 2000 191 f5e000 FILE: /lib/libnss_files-2.12.so OFFSET: 3000 192 f5f000 FILE: /lib/libnss_files-2.12.so OFFSET: 4000 193 f60000 3fd31000 194 f61000 3fd32000 195 f62000 FILE: /lib/libnss_files-2.12.so OFFSET: 7000 196 f63000 FILE: /lib/libnss_files-2.12.so OFFSET: 8000 197 f64000 3ff35000 198 f65000 FILE: /lib/libnss_files-2.12.so OFFSET: a000 199 f66000 FILE: /lib/libnss_files-2.12.so OFFSET: b000 48. vtop - virtual to physical 48.1. SYNOPSIS 1vtop [-c [pid | taskp]] [-u|-k] address ... 48.2. DESCRIPTION 1 This command translates a user or kernel virtual address to its physical 2 address. Also displayed is the PTE translation, the vm_area_struct data 3 for user virtual addresses, the mem_map page data associated with the 4 physical page, and the swap location or file location if the page is 5 not mapped. The -u and -k options specify that the address is a user 6 or kernel virtual address; -u and -k are not necessary on processors whose 7 virtual addresses self-define themselves as user or kernel. User addresses 8 are translated with respect to the current context unless the -c option 9 is used. Kernel virtual addresses are translated using the swapper_pg_dir 10 as the base page directory unless the -c option is used. 11 12 -u The address is a user virtual address; only required 13 on processors with overlapping user and kernel virtual 14 address spaces. 15 -k The address is a kernel virtual address; only required 16 on processors with overlapping user and kernel virtual 17 address spaces. 18 -c [pid | taskp] Translate the virtual address from the page directory 19 of the specified PID or hexadecimal task_struct pointer. 20 However, if this command is invoked from \u0026#34;foreach vtop\u0026#34;, 21 the pid or taskp argument should NOT be entered; the 22 address will be translated using the page directory of 23 each task specified by \u0026#34;foreach\u0026#34;. 24 address A hexadecimal user or kernel virtual address. 48.3. EXAMPLES 1 Translate user virtual address 80b4000: 2 3 crash\u0026gt; vtop 80b4000 4 VIRTUAL PHYSICAL 5 80b4000 660f000 6 7 PAGE DIRECTORY: c37f0000 8 PGD: c37f0080 =\u0026gt; e0d067 9 PMD: c37f0080 =\u0026gt; e0d067 10 PTE: c0e0d2d0 =\u0026gt; 660f067 11 PAGE: 660f000 12 13 PTE PHYSICAL FLAGS 14 660f067 660f000 (PRESENT|RW|USER|ACCESSED|DIRTY) 15 16 VMA START END FLAGS FILE 17 c773daa0 80b4000 810c000 77 18 19 PAGE PHYSICAL INODE OFFSET CNT FLAGS 20 c0393258 660f000 0 17000 1 uptodate 21 22 Translate kernel virtual address c806e000, first using swapper_pg_dir 23 as the page directory base, and secondly, using the page table base 24 of PID 1359: 25 26 crash\u0026gt; vtop c806e000 27 VIRTUAL PHYSICAL 28 c806e000 2216000 29 30 PAGE DIRECTORY: c0101000 31 PGD: c0101c80 =\u0026gt; 94063 32 PMD: c0101c80 =\u0026gt; 94063 33 PTE: c00941b8 =\u0026gt; 2216063 34 PAGE: 2216000 35 36 PTE PHYSICAL FLAGS 37 2216063 2216000 (PRESENT|RW|ACCESSED|DIRTY) 38 39 PAGE PHYSICAL INODE OFFSET CNT FLAGS 40 c02e9370 2216000 0 0 1 41 42 crash\u0026gt; vtop -c 1359 c806e000 43 VIRTUAL PHYSICAL 44 c806e000 2216000 45 46 PAGE DIRECTORY: c5caf000 47 PGD: c5cafc80 =\u0026gt; 94063 48 PMD: c5cafc80 =\u0026gt; 94063 49 PTE: c00941b8 =\u0026gt; 2216063 50 PAGE: 2216000 51 52 PTE PHYSICAL FLAGS 53 2216063 2216000 (PRESENT|RW|ACCESSED|DIRTY) 54 55 PAGE PHYSICAL INODE OFFSET CNT FLAGS 56 c02e9370 2216000 0 0 1 57 58 Determine swap location of user virtual address 40104000: 59 60 crash\u0026gt; vtop 40104000 61 VIRTUAL PHYSICAL 62 40104000 (not mapped) 63 64 PAGE DIRECTORY: c40d8000 65 PGD: c40d8400 =\u0026gt; 6bbe067 66 PMD: c40d8400 =\u0026gt; 6bbe067 67 PTE: c6bbe410 =\u0026gt; 58bc00 68 69 PTE SWAP OFFSET 70 58bc00 /dev/sda8 22716 71 72 VMA START END FLAGS FILE 73 c7200ae0 40104000 40b08000 73 74 75 SWAP: /dev/sda8 OFFSET: 22716 49. waitq - list tasks queued on a wait queue 49.1. SYNOPSIS 1waitq [ symbol ] | [ struct.member struct_addr ] | [ address ] 49.2. DESCRIPTION 1 This command walks the wait queue list displaying the tasks which 2 are blocked on the specified wait queue. The command differentiates 3 between the old- and new-style wait queue structures used by the kernel. 4 It can be invoked with the following argument types: 5 6 symbol a global symbol of a wait queue. 7 struct.member struct_addr a structure name and wait queue member combination 8 followed by the structure\u0026#39;s hexadecimal address. 9 address a hexadecimal wait queue pointer. 49.3. EXAMPLES 1 2 Find out if any tasks are blocked on the \u0026#34;buffer_wait\u0026#34; wait queue: 3 4 crash\u0026gt; waitq buffer_wait 5 wait queue \u0026#34;buffer_wait\u0026#34; (c02927f0) is empty 6 7 See who is blocked on the \u0026#34;wait_chldexit\u0026#34; queue of task c5496000: 8 9 crash\u0026gt; waitq task_struct.wait_chldexit c5496000 10 PID: 30879 TASK: c5496000 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 11 12 Display the task list waiting on a known task queue: 13 14 crash\u0026gt; waitq c3534098 15 PID: 13691 TASK: c3534000 CPU: 1 COMMAND: \u0026#34;bash\u0026#34; 50. whatis - search symbol table for data or type information 50.1. SYNOPSIS 1whatis [[-o] [struct | union | typedef | symbol]] | 2 [[-r [size|range]] [-m member]] 50.2. DESCRIPTION 1 This command displays the definition of structures, unions, typedefs or 2 text/data symbols: 3 4 struct a structure name. The output is the same as if the \u0026#34;struct\u0026#34; 5 command was used. 6 union a union name. The output is the same as if the \u0026#34;union\u0026#34; command 7 was used. 8 -o display the offsets of structure/union members. 9 typedef a typedef name. If the typedef translates to a structure or union 10 the output is the same as if the \u0026#34;struct\u0026#34; or \u0026#34;union\u0026#34; command 11 was used. If the typedef is a primitive datatype, the one-line 12 declaration is displayed. 13 symbol a kernel symbol. 14 15 Alternatively, a search can be made for data structures of a given size or 16 size range, that contain a member of a given type, or contain a pointer to 17 given type. The -r and -m options may be used alone or in conjunction with 18 one another: 19 20 -r size search for structures of this exact size. 21 -r range search for structures of a range of sizes, expressed as \u0026#34;low-high\u0026#34;. 22 -m member search for structures that contain a member of this data type, or 23 that contain a pointer to this data type; if a structure contains 24 another structure, the members of the embedded structure will also 25 be subject to the search. The member argument may also be expressed 26 as a substring of a member\u0026#39;s data type. 50.3. EXAMPLES 1 Display the definition of a linux_binfmt structure: 2 3 crash\u0026gt; whatis linux_binfmt 4 struct linux_binfmt { 5 struct list_head lh; 6 struct module *module; 7 int (*load_binary)(struct linux_binprm *); 8 int (*load_shlib)(struct file *); 9 int (*core_dump)(struct coredump_params *); 10 unsigned long min_coredump; 11 } 12 SIZE: 56 13 14 Display the same structure with member offsets: 15 16 crash\u0026gt; whatis -o linux_binfmt 17 struct linux_binfmt { 18 [0] struct list_head lh; 19 [16] struct module *module; 20 [24] int (*load_binary)(struct linux_binprm *); 21 [32] int (*load_shlib)(struct file *); 22 [40] int (*core_dump)(struct coredump_params *); 23 [48] unsigned long min_coredump; 24 } 25 SIZE: 56 26 27 Since a kmem_bufctl_t is typedef\u0026#39;d to be a kmem_bufctl_s structure, the 28 output of the following two commands is identical: 29 30 crash\u0026gt; whatis kmem_bufctl_s 31 struct kmem_bufctl_s { 32 union { 33 struct kmem_bufctl_s *buf_nextp; 34 kmem_slab_t *buf_slabp; 35 void *buf_objp; 36 } u; 37 }; 38 39 crash\u0026gt; whatis kmem_bufctl_t 40 struct kmem_bufctl_s { 41 union { 42 struct kmem_bufctl_s *buf_nextp; 43 kmem_slab_t *buf_slabp; 44 void *buf_objp; 45 } u; 46 }; 47 SIZE: 4 (0x4) 48 49 Display the type data of sys_read() and jiffies text and data symbols: 50 51 crash\u0026gt; whatis sys_read 52 ssize_t sys_read(unsigned int, char *, size_t); 53 54 crash\u0026gt; whatis jiffies 55 long unsigned int jiffies; 56 57 Display definition of a kdev_t typedef: 58 59 crash\u0026gt; whatis kdev_t 60 typedef short unsigned int kdev_t; 61 SIZE: 2 (0x2) 62 63 Display all structures which have a size of 192 bytes: 64 65 crash\u0026gt; whatis -r 192 66 SIZE TYPE 67 192 _intel_private 68 192 blkcg_gq 69 192 clock_event_device 70 192 cper_sec_proc_generic 71 192 dentry 72 192 dst_ops 73 192 ehci_itd 74 192 ethtool_rxnfc 75 192 fb_ops 76 192 file_lock 77 192 inode_operations 78 192 input_device_id 79 192 ip_vs_stats 80 192 numa_group 81 192 parallel_data 82 192 pcie_port_service_driver 83 192 pebs_record_hsw 84 192 pnp_driver 85 192 regmap_config 86 192 sched_entity 87 192 tcp_timewait_sock 88 192 timerfd_ctx 89 192 tpm_vendor_specific 90 192 urb 91 92 Display all structures that contain members that point to 93 an mm_struct: 94 95 crash\u0026gt; whatis -m mm_struct 96 SIZE TYPE 97 16 tlb_state 98 24 flush_tlb_info 99 24 ftrace_raw_xen_mmu_pgd 100 24 futex_key 101 24 map_info 102 32 ftrace_raw_xen_mmu_alloc_ptpage 103 32 ftrace_raw_xen_mmu_pte_clear 104 40 ftrace_raw_xen_mmu_flush_tlb_others 105 40 ftrace_raw_xen_mmu_ptep_modify_prot 106 40 ftrace_raw_xen_mmu_set_pte_at 107 40 mm_slot 108 64 mm_walk 109 64 rmap_item 110 104 userfaultfd_ctx 111 128 mmu_gather 112 216 vm_area_struct 113 256 linux_binprm 114 2616 rq 115 2936 task_struct 116 117 Display all structures sized from 256 to 512 bytes that 118 contain members that point to a task_struct: 119 120 crash\u0026gt; whatis -r 256-512 -m task_struct 121 SIZE TYPE 122 256 file 123 256 od_cpu_dbs_info_s 124 264 srcu_notifier_head 125 272 protection_domain 126 288 clk_notifier 127 288 fsnotify_group 128 296 quota_info 129 312 tty_port 130 320 workqueue_struct 131 344 trace_array 132 344 uart_state 133 352 cpufreq_policy 134 352 elf_thread_core_info 135 376 perf_event_context 136 384 rcu_data 137 400 cgroup 138 408 subsys_private 139 424 hvc_struct 140 496 psmouse 51. wr - write memory 51.1. SYNOPSIS 1wr [-u|-k|-p] [-8|-16|-32|-64] [address|symbol] value 51.2. DESCRIPTION 1 This command modifies the contents of memory. The starting address may be 2 entered either symbolically or by address. The default modification size 3 is the size of a long data type. Write permission must exist on the 4 /dev/mem. When writing to memory on a live system, this command should 5 obviously be used with great care. 6 7 -u address argument is a user virtual address. 8 -k address argument is a kernel virtual address. 9 -p address argument is a physical address. 10 -8 write data in an 8-bit value. 11 -16 write data in a 16-bit value. 12 -32 write data in a 32-bit values (default on 32-bit machines). 13 -64 write data in a 64-bit values (default on 64-bit machines). 14 address address to write. The address is considered virtual unless the 15 -p option is used. If a virtual address is specified, the 16 -u or -k options are necessary only if the address space cannot 17 be determined from the address value itself. If a user virtual 18 address is specified, the address space of the current context 19 implied. The address must be expressed in hexadecimal format. 20 symbol symbol of starting address to write. 21 value the value of the data to write. 51.3. EXAMPLES 1 Turn on a debug flag: 2 3 crash\u0026gt; wr my_debug_flag 1 ","date":"December 3, 2023","img":"https://kingdix10.github.io/covers/laptop_backlight_colorful_194324_300x168.jpg","lang":"en","langName":"English","largeImg":"","permalink":"/en/docs/04-kernel/linux-6.6/debug/kdump_crash/help/","series":[{"title":"kdump crash","url":"/en/series/kdump-crash/"}],"smallImg":"","tags":[{"title":"kdump crash","url":"/en/tags/kdump-crash/"},{"title":"tools","url":"/en/tags/tools/"}],"timestamp":1701561600,"title":"Crash Help"},{"categories":[{"title":"kdump crash","url":"/zh-cn/categories/kdump-crash/"},{"title":"内核调试","url":"/zh-cn/categories/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"}],"content":" 1. * - pointer-to short-cut 1.1. SYNOPSIS 1* (struct or union command arguments) 1.2. DESCRIPTION 1 This command is a short-cut command that replaces the requirement to enter 2 \u0026#34;struct\u0026#34; or \u0026#34;union\u0026#34; command names. For details on the arguments to 3 those commands, enter \u0026#34;help struct\u0026#34; or \u0026#34;help union\u0026#34;. 1.3. EXAMPLES 1 Dump the page structure at address c02943c0: 2 3 crash\u0026gt; *page c02943c0 4 struct page { 5 next = 0xc0fae740, 6 prev = 0xc0018fb0, 7 inode = 0x0, 8 offset = 0x3f000, 9 next_hash = 0xc02d6310, 10 count = { 11 counter = 0x1 12 }, 13 flags = 0x310, 14 wait = 0xc02943d8, 15 pprev_hash = 0x0, 16 buffers = 0x0 17 } 2. alias - command aliases 2.1. SYNOPSIS 1alias [alias] [command string] 2.2. DESCRIPTION 1 This command creates an alias for a given command string. If no arguments 2 are entered, the current list of aliases are displayed. If one argument is 3 entered, the command string for that alias, if any, is displayed. 4 5 alias the single word to be used as an alias 6 command string the word(s) that will be substituted for the alias 7 8 Aliases may be created in four manners: 9 10 1. entering the alias in $HOME/.crashrc. 11 2. entering the alias in .crashrc in the current directory. 12 3. executing an input file containing the alias command. 13 4. during runtime with this command. 14 15 During initialization, $HOME/.crashrc is read first, followed by the 16 .crashrc file in the current directory. Aliases in the .crashrc file 17 in the current directory override those in $HOME/.crashrc. Aliases 18 entered with this command or by runtime input file override those 19 defined in either .crashrc file. Aliases may be deleted by entering an 20 empty string for the second argument. If redirection characters are to 21 be part of the command string, the command string must be enclosed by 22 quotation marks. 23 24 Note that there are a number of helpful built-in aliases -- see the 25 first example below. 2.3. EXAMPLES 1 Display the currently-defined aliases, which in this example, only 2 consist of the built-in aliases: 3 4 crash\u0026gt; alias 5 ORIGIN ALIAS COMMAND 6 builtin man help 7 builtin ? help 8 builtin quit q 9 builtin sf set scroll off 10 builtin sn set scroll on 11 builtin hex set radix 16 12 builtin dec set radix 10 13 builtin g gdb 14 builtin px p -x 15 builtin pd p -d 16 builtin for foreach 17 builtin size * 18 builtin dmesg log 19 builtin lsmod mod 20 builtin last ps -l 21 22 Create a new alias to be added to the list: 23 24 crash\u0026gt; alias kp kmem -p 25 ORIGIN ALIAS COMMAND 26 runtime kp kmem -p 27 28 Create an alias with redirection characters: 29 30 crash\u0026gt; alias ksd \u0026#34;kmem -p | grep slab | grep DMA\u0026#34; 31 ORIGIN ALIAS COMMAND 32 runtime ksd kmem -p | grep slab | grep DMA 33 34 Remove an alias: 35 36 crash\u0026gt; alias kp \u0026#34;\u0026#34; 37 alias deleted: kp 3. ascii - translate a hexadecimal string to ASCII 3.1. SYNOPSIS 1ascii value ... 3.2. DESCRIPTION 1 Translates 32-bit or 64-bit hexadecimal values to ASCII. If no argument 2 is entered, an ASCII chart is displayed. 3.3. EXAMPLES 1 Translate the hexadecimal value of 0x62696c2f7273752f to ASCII: 2 3 crash\u0026gt; ascii 62696c2f7273752f 4 62696c2f7273752f: /usr/lib 5 6 Display an ASCII chart: 7 8 crash\u0026gt; ascii 9 10 0 1 2 3 4 5 6 7 11 +------------------------------- 12 0 | NUL DLE SP 0 @ P \u0026#39; p 13 1 | SOH DC1 ! 1 A Q a q 14 2 | STX DC2 \u0026#34; 2 B R b r 15 3 | ETX DC3 # 3 C S c s 16 4 | EOT DC4 $ 4 D T d t 17 5 | ENQ NAK % 5 E U e u 18 6 | ACK SYN \u0026amp; 6 F V f v 19 7 | BEL ETB ` 7 G W g w 20 8 | BS CAN ( 8 H X h x 21 9 | HT EM ) 9 I Y i y 22 A | LF SUB * : J Z j z 23 B | VT ESC + ; K [ k { 24 C | FF FS , \u0026lt; L \\ l | 25 D | CR GS _ = M ] m } 26 E | SO RS . \u0026gt; N ^ n ~ 27 F | SI US / ? O - o DEL 4. bpf - extended Berkeley Packet Filter (eBPF) 4.1. SYNOPSIS 1bpf [[-p ID | -P] [-tTj]] [[-m ID] | -M] [-s] [-xd] 4.2. DESCRIPTION 1 2 This command provides information on currently-loaded eBPF programs and maps. 3 With no arguments, basic information about each loaded eBPF program and map 4 is displayed. For each eBPF program, its ID number, the addresses of its 5 bpf_prog and bpf_prog_aux data structures, its type, tag, and the IDs of the 6 eBPF maps that it uses are displayed. For each eBPF map, its ID number, the 7 address of its bpf_map data structure, its type, and the hexadecimal value of 8 its map_flags are displayed. 9 10 -p ID displays the basic information specific to the program ID, plus the 11 size in bytes of its translated bytecode, the size in bytes of its 12 jited code, the number of bytes locked into memory, the time that 13 the program was loaded, whether it is GPL compatible, and its UID. 14 -P same as -p, but displays the basic and extra data for all programs. 15 -m ID displays the basic information specific to the map ID, plus the 16 size in bytes of its key and value, the maximum number of key-value 17 pairs that can be stored within the map, the number of bytes locked 18 into memory, its name string, and its UID. 19 -M same as -m, but displays the basic and extra data for all maps. 20 -t translate the bytecode of the specified program ID. 21 -T same as -t, but also dump the bytecode of each instruction. 22 -j disassemble the jited code of the specified program ID. 23 -s with -p or -P, dump the bpf_prog and bpf_prog_aux data structures. 24 with -m or -M, dump the bpf_map structure. 25 -x with -s, override default output format with hexadecimal format. 26 -d with -s, override default output format with decimal format. 4.3. EXAMPLES 1 Display all loaded eBPF programs and maps: 2 3 crash\u0026gt; bpf 4 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 5 13 ffffbc00c06d1000 ffff9ff260f0c400 CGROUP_SKB 7be49e3934a125ba 13,14 6 14 ffffbc00c0761000 ffff9ff260f0f600 CGROUP_SKB 2a142ef67aaad174 13,14 7 15 ffffbc00c001d000 ffff9ff2618f9e00 CGROUP_SKB 7be49e3934a125ba 15,16 8 16 ffffbc00c06c9000 ffff9ff2618f9400 CGROUP_SKB 2a142ef67aaad174 15,16 9 19 ffffbc00c0d39000 ffff9ff2610fa000 CGROUP_SKB 7be49e3934a125ba 19,20 10 20 ffffbc00c0d41000 ffff9ff2610f8e00 CGROUP_SKB 2a142ef67aaad174 19,20 11 30 ffffbc00c065f000 ffff9ff1b64de200 KPROBE 69fed6de18629d7a 32 12 31 ffffbc00c065b000 ffff9ff1b64df200 KPROBE 69fed6de18629d7a 37 13 32 ffffbc00c0733000 ffff9ff1b64dc600 KPROBE 69fed6de18629d7a 38 14 33 ffffbc00c0735000 ffff9ff1b64dca00 KPROBE 69fed6de18629d7a 39 15 34 ffffbc00c0737000 ffff9ff1b64dfc00 KPROBE 4abbddae72a6ee17 33,36,34 16 36 ffffbc00c0839000 ffff9ff1b64dd000 KPROBE da4fc6a3f41761a2 32 17 41 ffffbc00c07ec000 ffff9ff207b70400 TRACEPOINT e2094f9f46284bf6 55,54 18 44 ffffbc00c07ee000 ffff9ff1b64dc800 PERF_EVENT 19578a12836c4115 62 19 46 ffffbc00c07f0000 ffff9ff207b70400 SOCKET_FILTER 1fcfc04afd689133 64 20 21 ID BPF_MAP BPF_MAP_TYPE MAP_FLAGS 22 13 ffff9ff260f0ec00 LPM_TRIE 00000001 23 14 ffff9ff260f0de00 LPM_TRIE 00000001 24 15 ffff9ff2618fbe00 LPM_TRIE 00000001 25 16 ffff9ff2618fb800 LPM_TRIE 00000001 26 19 ffff9ff2610faa00 LPM_TRIE 00000001 27 20 ffff9ff2610fb800 LPM_TRIE 00000001 28 32 ffff9ff260d74000 HASH 00000000 29 33 ffff9ff260d76400 LRU_HASH 00000000 30 34 ffff9ff260d70000 LRU_HASH 00000002 31 35 ffff9ff260d73800 LRU_HASH 00000004 32 36 ffff9ff1b4f44000 ARRAY_OF_MAPS 00000000 33 37 ffff9ff260d77c00 PERCPU_HASH 00000000 34 38 ffff9ff260d70800 HASH 00000001 35 39 ffff9ff260d76c00 PERCPU_HASH 00000001 36 54 ffff9ff260dd2c00 HASH 00000000 37 55 ffff9ff260dd1400 HASH 00000000 38 62 ffff9ff1ae784000 HASH 00000000 39 64 ffff9ff1aea15000 ARRAY 00000000 40 41 Display additional data about program ID 20: 42 43 crash\u0026gt; bpf -p 20 44 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 45 20 ffffbc00c0d41000 ffff9ff2610f8e00 CGROUP_SKB 2a142ef67aaad174 19,20 46 XLATED: 296 JITED: 229 MEMLOCK: 4096 47 LOAD_TIME: Fri Apr 20 19:39:21 2018 48 GPL_COMPATIBLE: yes UID: 0 49 50 Display additional data about map ID 34: 51 52 crash\u0026gt; bpf -m 34 53 ID BPF_MAP BPF_MAP_TYPE MAP_FLAGS 54 34 ffff9ff260d70000 LRU_HASH 00000000 55 KEY_SIZE: 4 VALUE_SIZE: 8 MAX_ENTRIES: 10000 MEMLOCK: 1953792 56 NAME: \u0026#34;lru_hash_map\u0026#34; UID: 0 57 58 Disassemble the jited program of program ID 20: 59 60 crash\u0026gt; bpf -p 20 -j 61 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 62 20 ffffbc00c0d41000 ffff9ff2610f8e00 CGROUP_SKB 2a142ef67aaad174 19,20 63 XLATED: 296 JITED: 229 MEMLOCK: 4096 64 LOAD_TIME: Fri Apr 20 19:39:21 2018 65 GPL_COMPATIBLE: yes UID: 0 66 67 0xffffffffc06887a2: push %rbp 68 0xffffffffc06887a3: mov %rsp,%rbp 69 0xffffffffc06887a6: sub $0x40,%rsp 70 0xffffffffc06887ad: sub $0x28,%rbp 71 0xffffffffc06887b1: mov %rbx,0x0(%rbp) 72 0xffffffffc06887b5: mov %r13,0x8(%rbp) 73 0xffffffffc06887b9: mov %r14,0x10(%rbp) 74 0xffffffffc06887bd: mov %r15,0x18(%rbp) 75 0xffffffffc06887c1: xor %eax,%eax 76 0xffffffffc06887c3: mov %rax,0x20(%rbp) 77 0xffffffffc06887c7: mov %rdi,%rbx 78 0xffffffffc06887ca: movzwq 0xc0(%rbx),%r13 79 0xffffffffc06887d2: xor %r14d,%r14d 80 0xffffffffc06887d5: cmp $0x8,%r13 81 0xffffffffc06887d9: jne 0xffffffffc068881b 82 0xffffffffc06887db: mov %rbx,%rdi 83 0xffffffffc06887de: mov $0xc,%esi 84 0xffffffffc06887e3: mov %rbp,%rdx 85 0xffffffffc06887e6: add $0xfffffffffffffffc,%rdx 86 0xffffffffc06887ea: mov $0x4,%ecx 87 0xffffffffc06887ef: callq 0xffffffffb0865340 \u0026lt;bpf_skb_load_bytes\u0026gt; 88 0xffffffffc06887f4: movabs $0xffff9ff2610faa00,%rdi 89 0xffffffffc06887fe: mov %rbp,%rsi 90 0xffffffffc0688801: add $0xfffffffffffffff8,%rsi 91 0xffffffffc0688805: movl $0x20,0x0(%rsi) 92 0xffffffffc068880c: callq 0xffffffffb01fcba0 \u0026lt;bpf_map_lookup_elem\u0026gt; 93 0xffffffffc0688811: cmp $0x0,%rax 94 0xffffffffc0688815: je 0xffffffffc068881b 95 0xffffffffc0688817: or $0x2,%r14d 96 0xffffffffc068881b: cmp $0xdd86,%r13 97 0xffffffffc0688822: jne 0xffffffffc0688864 98 0xffffffffc0688824: mov %rbx,%rdi 99 0xffffffffc0688827: mov $0x8,%esi 100 0xffffffffc068882c: mov %rbp,%rdx 101 0xffffffffc068882f: add $0xfffffffffffffff0,%rdx 102 0xffffffffc0688833: mov $0x10,%ecx 103 0xffffffffc0688838: callq 0xffffffffb0865340 \u0026lt;bpf_skb_load_bytes\u0026gt; 104 0xffffffffc068883d: movabs $0xffff9ff2610fb800,%rdi 105 0xffffffffc0688847: mov %rbp,%rsi 106 0xffffffffc068884a: add $0xffffffffffffffec,%rsi 107 0xffffffffc068884e: movl $0x80,0x0(%rsi) 108 0xffffffffc0688855: callq 0xffffffffb01fcba0 \u0026lt;bpf_map_lookup_elem\u0026gt; 109 0xffffffffc068885a: cmp $0x0,%rax 110 0xffffffffc068885e: je 0xffffffffc0688864 111 0xffffffffc0688860: or $0x2,%r14d 112 0xffffffffc0688864: mov $0x1,%eax 113 0xffffffffc0688869: cmp $0x2,%r14 114 0xffffffffc068886d: jne 0xffffffffc0688871 115 0xffffffffc068886f: xor %eax,%eax 116 0xffffffffc0688871: mov 0x0(%rbp),%rbx 117 0xffffffffc0688875: mov 0x8(%rbp),%r13 118 0xffffffffc0688879: mov 0x10(%rbp),%r14 119 0xffffffffc068887d: mov 0x18(%rbp),%r15 120 0xffffffffc0688881: add $0x28,%rbp 121 0xffffffffc0688885: leaveq 122 0xffffffffc0688886: retq 123 124 Translate each bytecode instruction of program ID 13: 125 126 crash\u0026gt; bpf -p 13 -t 127 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 128 13 ffffbc00c06d1000 ffff9ff260f0c400 CGROUP_SKB 7be49e3934a125ba 13,14 129 XLATED: 296 JITED: 229 MEMLOCK: 4096 130 LOAD_TIME: Fri Apr 20 19:39:11 2018 131 GPL_COMPATIBLE: yes UID: 0 132 133 0: (bf) r6 = r1 134 1: (69) r7 = *(u16 *)(r6 +192) 135 2: (b4) (u32) r8 = (u32) 0 136 3: (55) if r7 != 0x8 goto pc+14 137 4: (bf) r1 = r6 138 5: (b4) (u32) r2 = (u32) 16 139 6: (bf) r3 = r10 140 7: (07) r3 += -4 141 8: (b4) (u32) r4 = (u32) 4 142 9: (85) call bpf_skb_load_bytes#6793152 143 10: (18) r1 = map[id:13] 144 12: (bf) r2 = r10 145 13: (07) r2 += -8 146 14: (62) *(u32 *)(r2 +0) = 32 147 15: (85) call bpf_map_lookup_elem#73760 148 16: (15) if r0 == 0x0 goto pc+1 149 17: (44) (u32) r8 |= (u32) 2 150 18: (55) if r7 != 0xdd86 goto pc+14 151 19: (bf) r1 = r6 152 20: (b4) (u32) r2 = (u32) 24 153 21: (bf) r3 = r10 154 22: (07) r3 += -16 155 23: (b4) (u32) r4 = (u32) 16 156 24: (85) call bpf_skb_load_bytes#6793152 157 25: (18) r1 = map[id:14] 158 27: (bf) r2 = r10 159 28: (07) r2 += -20 160 29: (62) *(u32 *)(r2 +0) = 128 161 30: (85) call bpf_map_lookup_elem#73760 162 31: (15) if r0 == 0x0 goto pc+1 163 32: (44) (u32) r8 |= (u32) 2 164 33: (b7) r0 = 1 165 34: (55) if r8 != 0x2 goto pc+1 166 35: (b7) r0 = 0 167 36: (95) exit 168 169 Translate, and then dump each bytecode instruction of program ID 13: 170 171 crash\u0026gt; bpf -p 13 -T 172 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 173 13 ffffbc00c06d1000 ffff9ff260f0c400 CGROUP_SKB 7be49e3934a125ba 13,14 174 XLATED: 296 JITED: 229 MEMLOCK: 4096 175 LOAD_TIME: Fri Apr 20 19:39:11 2018 176 GPL_COMPATIBLE: yes UID: 0 177 178 0: (bf) r6 = r1 179 bf 16 00 00 00 00 00 00 180 1: (69) r7 = *(u16 *)(r6 +192) 181 69 67 c0 00 00 00 00 00 182 2: (b4) (u32) r8 = (u32) 0 183 b4 08 00 00 00 00 00 00 184 3: (55) if r7 != 0x8 goto pc+14 185 55 07 0e 00 08 00 00 00 186 4: (bf) r1 = r6 187 bf 61 00 00 00 00 00 00 188 5: (b4) (u32) r2 = (u32) 16 189 b4 02 00 00 10 00 00 00 190 6: (bf) r3 = r10 191 bf a3 00 00 00 00 00 00 192 7: (07) r3 += -4 193 07 03 00 00 fc ff ff ff 194 8: (b4) (u32) r4 = (u32) 4 195 b4 04 00 00 04 00 00 00 196 9: (85) call bpf_skb_load_bytes#6793152 197 85 00 00 00 c0 a7 67 00 198 10: (18) r1 = map[id:13] 199 18 01 00 00 00 7a 96 61 00 00 00 00 b2 9d ff ff 200 12: (bf) r2 = r10 201 bf a2 00 00 00 00 00 00 202 13: (07) r2 += -8 203 07 02 00 00 f8 ff ff ff 204 14: (62) *(u32 *)(r2 +0) = 32 205 62 02 00 00 20 00 00 00 206 15: (85) call bpf_map_lookup_elem#73760 207 85 00 00 00 20 20 01 00 208 16: (15) if r0 == 0x0 goto pc+1 209 15 00 01 00 00 00 00 00 210 17: (44) (u32) r8 |= (u32) 2 211 44 08 00 00 02 00 00 00 212 18: (55) if r7 != 0xdd86 goto pc+14 213 55 07 0e 00 86 dd 00 00 214 19: (bf) r1 = r6 215 bf 61 00 00 00 00 00 00 216 20: (b4) (u32) r2 = (u32) 24 217 b4 02 00 00 18 00 00 00 218 21: (bf) r3 = r10 219 bf a3 00 00 00 00 00 00 220 22: (07) r3 += -16 221 07 03 00 00 f0 ff ff ff 222 23: (b4) (u32) r4 = (u32) 16 223 b4 04 00 00 10 00 00 00 224 24: (85) call bpf_skb_load_bytes#6793152 225 85 00 00 00 c0 a7 67 00 226 25: (18) r1 = map[id:14] 227 18 01 00 00 00 68 96 61 00 00 00 00 b2 9d ff ff 228 27: (bf) r2 = r10 229 bf a2 00 00 00 00 00 00 230 28: (07) r2 += -20 231 07 02 00 00 ec ff ff ff 232 29: (62) *(u32 *)(r2 +0) = 128 233 62 02 00 00 80 00 00 00 234 30: (85) call bpf_map_lookup_elem#73760 235 85 00 00 00 20 20 01 00 236 31: (15) if r0 == 0x0 goto pc+1 237 15 00 01 00 00 00 00 00 238 32: (44) (u32) r8 |= (u32) 2 239 44 08 00 00 02 00 00 00 240 33: (b7) r0 = 1 241 b7 00 00 00 01 00 00 00 242 34: (55) if r8 != 0x2 goto pc+1 243 55 08 01 00 02 00 00 00 244 35: (b7) r0 = 0 245 b7 00 00 00 00 00 00 00 246 36: (95) exit 247 95 00 00 00 00 00 00 00 248 249 Display the bpf_map data structure for map ID 13: 250 251 crash\u0026gt; bpf -m 13 -s 252 ID BPF_MAP BPF_MAP_TYPE MAP_FLAGS 253 13 ffff9ff260f0ec00 LPM_TRIE 00000001 254 KEY_SIZE: 8 VALUE_SIZE: 8 MAX_ENTRIES: 1 MEMLOCK: 4096 255 NAME: (unused) UID: 0 256 257 struct bpf_map { 258 ops = 0xffffffffb0e36720, 259 inner_map_meta = 0x0, 260 security = 0xffff9ff26873a158, 261 map_type = BPF_MAP_TYPE_LPM_TRIE, 262 key_size = 8, 263 value_size = 8, 264 max_entries = 1, 265 map_flags = 1, 266 pages = 1, 267 id = 13, 268 numa_node = -1, 269 unpriv_array = false, 270 user = 0xffffffffb14578a0, 271 refcnt = { 272 counter = 3 273 }, 274 usercnt = { 275 counter = 1 276 }, 277 work = { 278 data = { 279 counter = 0 280 }, 281 entry = { 282 next = 0x0, 283 prev = 0x0 284 }, 285 func = 0x0, 286 lockdep_map = { 287 key = 0x0, 288 class_cache = {0x0, 0x0}, 289 name = 0x0, 290 cpu = 0, 291 ip = 0 292 } 293 }, 294 name = \u0026#34; 295 } 296 297 Display the bpf_prog and bpf_prog_aux structures for program ID 13: 298 299 crash\u0026gt; bpf -p 13 -s 300 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 301 13 ffffbc00c06d1000 ffff9ff260f0c400 CGROUP_SKB 7be49e3934a125ba 13,14 302 XLATED: 296 JITED: 229 MEMLOCK: 4096 303 LOAD_TIME: Fri Apr 20 19:39:10 2018 304 GPL_COMPATIBLE: yes UID: 0 305 306 struct bpf_prog { 307 pages = 1, 308 jited = 1, 309 jit_requested = 1, 310 locked = 1, 311 gpl_compatible = 1, 312 cb_access = 0, 313 dst_needed = 0, 314 blinded = 0, 315 is_func = 0, 316 kprobe_override = 0, 317 type = BPF_PROG_TYPE_CGROUP_SKB, 318 len = 37, 319 jited_len = 229, 320 tag = \u0026#34;{\\344\\236\\071\\064\\241%\\272\u0026#34;, 321 aux = ffff9ff260f0c400, 322 orig_prog = 0x0, 323 bpf_func = 0xffffffffc0218a59, 324 { 325 insns = 0xffffb0cf406d1030, 326 insnsi = 0xffffb0cf406d1030 327 } 328 } 329 330 struct bpf_prog_aux { 331 refcnt = { 332 counter = 2 333 }, 334 used_map_cnt = 2, 335 max_ctx_offset = 20, 336 stack_depth = 20, 337 id = 13, 338 func_cnt = 0, 339 offload_requested = false, 340 func = 0x0, 341 jit_data = 0x0, 342 ksym_tnode = { 343 node = {{ 344 __rb_parent_color = 18446635988194065457, 345 rb_right = 0x0, 346 rb_left = 0x0 347 }, { 348 __rb_parent_color = 18446635988194065481, 349 rb_right = 0x0, 350 rb_left = 0x0 351 }} 352 }, 353 ksym_lnode = { 354 next = 0xffff9db261966460, 355 prev = 0xffffffffb85d1150 356 }, 357 ops = 0xffffffffb7f09060, 358 used_maps = 0xffff9db261e03600, 359 prog = 0xffffb0cf406d1000, 360 user = 0xffffffffb84578a0, 361 load_time = 23962237943, 362 name = \u0026#34; 363 security = 0xffff9db266f9cf50, 364 offload = 0x0, 365 { 366 work = { 367 data = { 368 counter = 0 369 }, 370 entry = { 371 next = 0x0, 372 prev = 0x0 373 }, 374 func = 0x0, 375 lockdep_map = { 376 key = 0x0, 377 class_cache = {0x0, 0x0}, 378 name = 0x0, 379 cpu = 0, 380 ip = 0 381 } 382 }, 383 rcu = { 384 next = 0x0, 385 func = 0x0 386 } 387 } 388 } 389 390 Display the extra data about all programs: 391 392 crash\u0026gt; bpf -P 393 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 394 13 ffffbc00c06d1000 ffff9ff260f0c400 CGROUP_SKB 7be49e3934a125ba 13,14 395 XLATED: 296 JITED: 229 MEMLOCK: 4096 396 LOAD_TIME: Fri Apr 20 19:39:10 2018 397 GPL_COMPATIBLE: yes UID: 0 398 399 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 400 14 ffffbc00c0761000 ffff9ff260f0f600 CGROUP_SKB 2a142ef67aaad174 13,14 401 XLATED: 296 JITED: 229 MEMLOCK: 4096 402 LOAD_TIME: Fri Apr 20 19:39:10 2018 403 GPL_COMPATIBLE: yes UID: 0 404 405 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 406 15 ffffbc00c001d000 ffff9ff2618f9e00 CGROUP_SKB 7be49e3934a125ba 15,16 407 XLATED: 296 JITED: 229 MEMLOCK: 4096 408 LOAD_TIME: Fri Apr 20 19:39:11 2018 409 GPL_COMPATIBLE: yes UID: 0 410 411 ... 412 413 ID BPF_PROG BPF_PROG_AUX BPF_PROG_TYPE TAG USED_MAPS 414 75 ffffbc00c0ed1000 ffff9ff2429c6400 KPROBE da4fc6a3f41761a2 107 415 XLATED: 5168 JITED: 2828 MEMLOCK: 8192 416 LOAD_TIME: Fri Apr 27 14:54:40 2018 417 GPL_COMPATIBLE: yes UID: 0 418 419 Display the extra data for all maps: 420 421 crash\u0026gt; bpf -M 422 ID BPF_MAP BPF_MAP_TYPE MAP_FLAGS 423 13 ffff9ff260f0ec00 LPM_TRIE 00000001 424 KEY_SIZE: 8 VALUE_SIZE: 8 MAX_ENTRIES: 1 MEMLOCK: 4096 425 NAME: (unused) UID: 0 426 427 ID BPF_MAP BPF_MAP_TYPE MAP_FLAGS 428 14 ffff9ff260f0de00 LPM_TRIE 00000001 429 KEY_SIZE: 20 VALUE_SIZE: 8 MAX_ENTRIES: 1 MEMLOCK: 4096 430 NAME: (unused) UID: 0 431 432 ... 433 434 ID BPF_MAP BPF_MAP_TYPE MAP_FLAGS 435 108 ffff9ff1aeab9400 LRU_HASH 00000000 436 KEY_SIZE: 4 VALUE_SIZE: 8 MAX_ENTRIES: 1000 MEMLOCK: 147456 437 NAME: \u0026#34;lru_hash_lookup\u0026#34; UID: 0 438 439 To display all possible information that this command offers about 440 all programs and maps, enter: 441 442 crash\u0026gt; bpf -PM -jTs 5. bt - backtrace 5.1. SYNOPSIS 1bt [-a|-c cpu(s)|-g|-r|-t|-T|-l|-e|-E|-f|-F|-o|-O|-v|-p] [-R ref] [-s [-x|d]] 2 [-I ip] [-S sp] [pid | task] 5.2. DESCRIPTION 1 Display a kernel stack backtrace. If no arguments are given, the stack 2 trace of the current context will be displayed. 3 4 -a displays the stack traces of the active task on each CPU. 5 (only applicable to crash dumps) 6 -A same as -a, but also displays vector registers (S390X only). 7 -p display the stack trace of the panic task only. 8 (only applicable to crash dumps) 9 -c cpu display the stack trace of the active task on one or more CPUs, 10 which can be specified using the format \u0026#34;3\u0026#34;, \u0026#34;1,8,9\u0026#34;, \u0026#34;1-23\u0026#34;, 11 or \u0026#34;1,8,9-14\u0026#34;. (only applicable to crash dumps) 12 -g displays the stack traces of all threads in the thread group of 13 the target task; the thread group leader will be displayed first. 14 -r display raw stack data, consisting of a memory dump of the two 15 pages of memory containing the task_union structure. 16 -t display all text symbols found from the last known stack location 17 to the top of the stack. (helpful if the back trace fails) 18 -T display all text symbols found from just above the task_struct or 19 thread_info to the top of the stack. (helpful if the back trace 20 fails or the -t option starts too high in the process stack). 21 -l show file and line number of each stack trace text location. 22 -e search the stack for possible kernel and user mode exception frames. 23 -E search the IRQ stacks (x86, x86_64, arm64, and ppc64), and the 24 exception stacks (x86_64) for possible exception frames; all other 25 arguments except for -c will be ignored since this is not a context- 26 sensitive operation. 27 -f display all stack data contained in a frame; this option can be 28 used to determine the arguments passed to each function; on ia64, 29 the argument register contents are dumped. 30 -F[F] similar to -f, except that the stack data is displayed symbolically 31 when appropriate; if the stack data references a slab cache object, 32 the name of the slab cache will be displayed in brackets; on ia64, 33 the substitution is done to the argument register contents. If -F 34 is entered twice, and the stack data references a slab cache object, 35 both the address and the name of the slab cache will be displayed 36 in brackets. 37 -v check the kernel stack of all tasks for evidence of stack overflows. 38 It does so by verifying the thread_info.task pointer, ensuring that 39 the thread_info.cpu is a valid cpu number, and checking the end of 40 the stack for the STACK_END_MAGIC value. 41 -o arm64: use optional backtrace method; not supported on Linux 4.14 or 42 later kernels. 43 x86: use old backtrace method, permissible only on kernels that were 44 compiled without the -fomit-frame_pointer. 45 x86_64: use old backtrace method, which dumps potentially stale 46 kernel text return addresses found on the stack. 47 -O arm64: use optional backtrace method by default; subsequent usage 48 of this option toggles the backtrace method. 49 x86: use old backtrace method by default, permissible only on kernels 50 that were compiled without the -fomit-frame_pointer; subsequent usage 51 of this option toggles the backtrace method. 52 x86_64: use old backtrace method by default; subsequent usage of this 53 option toggles the backtrace method. 54 -R ref display stack trace only if there is a reference to this symbol 55 or text address. 56 -s display the symbol name plus its offset. 57 -x when displaying a symbol offset with the -s option, override the 58 default output format with hexadecimal format. 59 -d when displaying a symbol offset with the -s option, override the 60 default output format with decimal format. 61 -I ip use ip as the starting text location. 62 -S sp use sp as the starting stack frame address. 63 pid displays the stack trace(s) of this pid. 64 taskp displays the stack trace the the task referenced by this hexadecimal 65 task_struct pointer. 66 67 Multiple pid and taskp arguments may be specified. 68 69 Note that all examples below are for x86 only. The output format will differ 70 for other architectures. x86 backtraces from kernels that were compiled 71 with the --fomit-frame-pointer CFLAG occasionally will drop stack frames, 72 or display a stale frame reference. When in doubt as to the accuracy of a 73 backtrace, the -t or -T options may help fill in the blanks. 5.3. EXAMPLES 1 Display the stack trace of the active task(s) when the kernel panicked: 2 3 crash\u0026gt; bt -a 4 PID: 286 TASK: c0b3a000 CPU: 0 COMMAND: \u0026#34;in.rlogind\u0026#34; 5 #0 [c0b3be90] crash_save_current_state at c011aed0 6 #1 [c0b3bea4] panic at c011367c 7 #2 [c0b3bee8] tulip_interrupt at c01bc820 8 #3 [c0b3bf08] handle_IRQ_event at c010a551 9 #4 [c0b3bf2c] do_8259A_IRQ at c010a319 10 #5 [c0b3bf3c] do_IRQ at c010a653 11 #6 [c0b3bfbc] ret_from_intr at c0109634 12 EAX: 00000000 EBX: c0e68280 ECX: 00000000 EDX: 00000004 EBP: c0b3bfbc 13 DS: 0018 ESI: 00000004 ES: 0018 EDI: c0e68284 14 CS: 0010 EIP: c012f803 ERR: ffffff09 EFLAGS: 00000246 15 #7 [c0b3bfbc] sys_select at c012f803 16 #8 [c0b3bfc0] system_call at c0109598 17 EAX: 0000008e EBX: 00000004 ECX: bfffc9a0 EDX: 00000000 18 DS: 002b ESI: bfffc8a0 ES: 002b EDI: 00000000 19 SS: 002b ESP: bfffc82c EBP: bfffd224 20 CS: 0023 EIP: 400d032e ERR: 0000008e EFLAGS: 00000246 21 22 Display the stack trace of the active task on CPU 0 and 1: 23 24 crash\u0026gt; bt -c 0,1 25 PID: 0 TASK: ffffffff81a8d020 CPU: 0 COMMAND: \u0026#34;swapper\u0026#34; 26 #0 [ffff880002207e90] crash_nmi_callback at ffffffff8102fee6 27 #1 [ffff880002207ea0] notifier_call_chain at ffffffff8152d525 28 #2 [ffff880002207ee0] atomic_notifier_call_chain at ffffffff8152d58a 29 #3 [ffff880002207ef0] notify_die at ffffffff810a155e 30 #4 [ffff880002207f20] do_nmi at ffffffff8152b1eb 31 #5 [ffff880002207f50] nmi at ffffffff8152aab0 32 [exception RIP: native_safe_halt+0xb] 33 RIP: ffffffff8103eacb RSP: ffffffff81a01ea8 RFLAGS: 00000296 34 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000 35 RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffffffff81de5228 36 RBP: ffffffff81a01ea8 R8: 0000000000000000 R9: 0000000000000000 37 R10: 0012099429a6bea3 R11: 0000000000000000 R12: ffffffff81c066c0 38 R13: 0000000000000000 R14: ffffffffffffffff R15: ffffffff81de1000 39 ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018 40 --- \u0026lt;NMI exception stack\u0026gt; --- 41 #6 [ffffffff81a01ea8] native_safe_halt at ffffffff8103eacb 42 #7 [ffffffff81a01eb0] default_idle at ffffffff810167bd 43 #8 [ffffffff81a01ed0] cpu_idle at ffffffff81009fc6 44 45 PID: 38 TASK: ffff88003eaae040 CPU: 1 COMMAND: \u0026#34;khungtaskd\u0026#34; 46 #0 [ffff88003ad97ce8] machine_kexec at ffffffff81038f3b 47 #1 [ffff88003ad97d48] crash_kexec at ffffffff810c5da2 48 #2 [ffff88003ad97e18] panic at ffffffff8152721a 49 #3 [ffff88003ad97e98] watchdog at ffffffff810e6346 50 #4 [ffff88003ad97ee8] kthread at ffffffff8109af06 51 #5 [ffff88003ad97f48] kernel_thread at ffffffff8100c20a 52 53 Display the stack traces of task f2814000 and PID 1592: 54 55 crash\u0026gt; bt f2814000 1592 56 PID: 1018 TASK: f2814000 CPU: 1 COMMAND: \u0026#34;java\u0026#34; 57 #0 [f2815db4] schedule at c011af85 58 #1 [f2815de4] __down at c010600f 59 #2 [f2815e14] __down_failed at c01061b3 60 #3 [f2815e24] stext_lock (via drain_cpu_caches) at c025fa55 61 #4 [f2815ec8] kmem_cache_shrink_nr at c013a53e 62 #5 [f2815ed8] do_try_to_free_pages at c013f402 63 #6 [f2815f04] try_to_free_pages at c013f8d2 64 #7 [f2815f1c] _wrapped_alloc_pages at c01406bd 65 #8 [f2815f40] __alloc_pages at c014079d 66 #9 [f2815f60] __get_free_pages at c014083e 67 #10 [f2815f68] do_fork at c011cebb 68 #11 [f2815fa4] sys_clone at c0105ceb 69 #12 [f2815fc0] system_call at c010740c 70 EAX: 00000078 EBX: 00000f21 ECX: bc1ffbd8 EDX: bc1ffbe0 71 DS: 002b ESI: 00000000 ES: 002b EDI: bc1ffd04 72 SS: 002b ESP: 0807316c EBP: 080731bc 73 CS: 0023 EIP: 4012881e ERR: 00000078 EFLAGS: 00000296 74 75 PID: 1592 TASK: c0cec000 CPU: 3 COMMAND: \u0026#34;httpd\u0026#34; 76 #0 [c0ceded4] schedule at c011af85 77 #1 [c0cedf04] pipe_wait at c0153083 78 #2 [c0cedf58] pipe_read at c015317f 79 #3 [c0cedf7c] sys_read at c0148be6 80 #4 [c0cedfc0] system_call at c010740c 81 EAX: 00000003 EBX: 00000004 ECX: bffed4a3 EDX: 00000001 82 DS: 002b ESI: 00000001 ES: 002b EDI: bffed4a3 83 SS: 002b ESP: bffed458 EBP: bffed488 84 CS: 0023 EIP: 4024f1d4 ERR: 00000003 EFLAGS: 00000286 85 86 In order to examine each stack frame\u0026#39;s contents use the bt -f option. 87 From the extra frame data that is displayed, the arguments passed to each 88 function can be determined. Re-examining the PID 1592 trace above: 89 90 crash\u0026gt; bt -f 1592 91 PID: 1592 TASK: c0cec000 CPU: 3 COMMAND: \u0026#34;httpd\u0026#34; 92 #0 [c0ceded4] schedule at c011af85 93 [RA: c0153088 SP: c0ceded4 FP: c0cedf04 SIZE: 52] 94 c0ceded4: c0cedf00 c0cec000 ce1a6000 00000003 95 c0cedee4: c0cec000 f26152c0 cfafc8c0 c0cec000 96 c0cedef4: ef70a0a0 c0cec000 c0cedf28 c0cedf54 97 c0cedf04: c0153088 98 #1 [c0cedf04] pipe_wait at c0153083 99 [RA: c0153184 SP: c0cedf08 FP: c0cedf58 SIZE: 84] 100 c0cedf08: 00000000 c0cec000 00000000 00000000 101 c0cedf18: 00000000 c0a41fa0 c011d38b c0394120 102 c0cedf28: 00000000 c0cec000 ceeebf30 ce4adf30 103 c0cedf38: 00000000 d4b60ce0 00000000 c0cedf58 104 c0cedf48: e204f820 ef70a040 00000001 c0cedf78 105 c0cedf58: c0153184 106 #2 [c0cedf58] pipe_read at c015317f 107 [RA: c0148be8 SP: c0cedf5c FP: c0cedf7c SIZE: 36] 108 c0cedf5c: ef70a040 c0cec000 00000000 00000000 109 c0cedf6c: 00000001 f27ae680 ffffffea c0cedfbc 110 c0cedf7c: c0148be8 111 #3 [c0cedf7c] sys_read at c0148be6 112 [RA: c0107413 SP: c0cedf80 FP: c0cedfc0 SIZE: 68] 113 c0cedf80: f27ae680 bffed4a3 00000001 f27ae6a0 114 c0cedf90: 40160370 24000000 4019ba28 00000000 115 c0cedfa0: 00000000 fffffffe bffba207 fffffffe 116 c0cedfb0: c0cec000 00000001 bffed4a3 bffed488 117 c0cedfc0: c0107413 118 #4 [c0cedfc0] system_call at c010740c 119 EAX: 00000003 EBX: 00000004 ECX: bffed4a3 EDX: 00000001 120 DS: 002b ESI: 00000001 ES: 002b EDI: bffed4a3 121 SS: 002b ESP: bffed458 EBP: bffed488 122 CS: 0023 EIP: 4024f1d4 ERR: 00000003 EFLAGS: 00000286 123 [RA: 4024f1d4 SP: c0cedfc4 FP: c0cedffc SIZE: 60] 124 c0cedfc4: 00000004 bffed4a3 00000001 00000001 125 c0cedfd4: bffed4a3 bffed488 00000003 0000002b 126 c0cedfe4: 0000002b 00000003 4024f1d4 00000023 127 c0cedff4: 00000286 bffed458 0000002b 128 129 Typically the arguments passed to a function will be the last values 130 that were pushed onto the stack by the next higher-numbered function, i.e., 131 the lowest stack addresses in the frame above the called function\u0026#39;s 132 stack frame. That can be verified by disassembling the calling function. 133 For example, the arguments passed from sys_read() to pipe_read() above 134 are the file pointer, the user buffer address, the count, and a pointer 135 to the file structure\u0026#39;s f_pos field. Looking at the frame #3 data for 136 sys_read(), the last four items pushed onto the stack (lowest addresses) 137 are f27ae680, bffed4a3, 00000001, and f27ae6a0 -- which are the 4 arguments 138 above, in that order. Note that the first (highest address) stack content 139 in frame #2 data for pipe_read() is c0148be8, which is the return address 140 back to sys_read(). 141 142 Dump the text symbols found in the current context\u0026#39;s stack: 143 144 crash\u0026gt; bt -t 145 PID: 1357 TASK: c1aa0000 CPU: 0 COMMAND: \u0026#34;lockd\u0026#34; 146 START: schedule at c01190e0 147 [c1aa1f28] dput at c0157dbc 148 [c1aa1f4c] schedule_timeout at c0124cd4 149 [c1aa1f78] svc_recv at cb22c4d8 [sunrpc] 150 [c1aa1f98] put_files_struct at c011eb21 151 [c1aa1fcc] nlmclnt_proc at cb237bef [lockd] 152 [c1aa1ff0] kernel_thread at c0105826 153 [c1aa1ff8] nlmclnt_proc at cb237a60 [lockd] 154 155 Search the current stack for possible exception frames: 156 157 crash\u0026gt; bt -e 158 PID: 286 TASK: c0b3a000 CPU: 0 COMMAND: \u0026#34;in.rlogind\u0026#34; 159 160 KERNEL-MODE EXCEPTION FRAME AT c0b3bf44: 161 EAX: 00000000 EBX: c0e68280 ECX: 00000000 EDX: 00000004 EBP: c0b3bfbc 162 DS: 0018 ESI: 00000004 ES: 0018 EDI: c0e68284 163 CS: 0010 EIP: c012f803 ERR: ffffff09 EFLAGS: 00000246 164 165 USER-MODE EXCEPTION FRAME AT c0b3bfc4: 166 EAX: 0000008e EBX: 00000004 ECX: bfffc9a0 EDX: 00000000 167 DS: 002b ESI: bfffc8a0 ES: 002b EDI: 00000000 168 SS: 002b ESP: bfffc82c EBP: bfffd224 169 CS: 0023 EIP: 400d032e ERR: 0000008e EFLAGS: 00000246 170 171 Display the back trace from a dumpfile that resulted from the execution 172 of the crash utility\u0026#39;s \u0026#34;sys -panic\u0026#34; command: 173 174 crash\u0026gt; bt 175 PID: 12523 TASK: c610c000 CPU: 0 COMMAND: \u0026#34;crash\u0026#34; 176 #0 [c610de64] die at c01076ec 177 #1 [c610de74] do_invalid_op at c01079bc 178 #2 [c610df2c] error_code (via invalid_op) at c0107256 179 EAX: 0000001d EBX: c024a4c0 ECX: c02f13c4 EDX: 000026f6 EBP: c610c000 180 DS: 0018 ESI: 401de2e0 ES: 0018 EDI: c610c000 181 CS: 0010 EIP: c011bbb4 ERR: ffffffff EFLAGS: 00010296 182 #3 [c610df68] panic at c011bbb4 183 #4 [c610df78] do_exit at c011f1fe 184 #5 [c610dfc0] system_call at c0107154 185 EAX: 00000001 EBX: 00000000 ECX: 00001000 EDX: 401df154 186 DS: 002b ESI: 401de2e0 ES: 002b EDI: 00000000 187 SS: 002b ESP: bffebf0c EBP: bffebf38 188 CS: 0023 EIP: 40163afd ERR: 00000001 EFLAGS: 00000246 189 190 Display the back trace from a dumpfile that resulted from an attempt to 191 insmod the sample \u0026#34;crash.c\u0026#34; kernel module that comes as part of the 192 Red Hat netdump package: 193 194 crash\u0026gt; bt 195 PID: 1696 TASK: c74de000 CPU: 0 COMMAND: \u0026#34;insmod\u0026#34; 196 #0 [c74dfdcc] die at c01076ec 197 #1 [c74dfddc] do_page_fault at c0117bbc 198 #2 [c74dfee0] error_code (via page_fault) at c0107256 199 EAX: 00000013 EBX: cb297000 ECX: 00000000 EDX: c5962000 EBP: c74dff28 200 DS: 0018 ESI: 00000000 ES: 0018 EDI: 00000000 201 CS: 0010 EIP: cb297076 ERR: ffffffff EFLAGS: 00010282 202 #3 [c74dff1c] crash_init at cb297076 [crash] 203 #4 [c74dff2c] sys_init_module at c011d233 204 #5 [c74dffc0] system_call at c0107154 205 EAX: 00000080 EBX: 08060528 ECX: 08076450 EDX: 0000000a 206 DS: 002b ESI: 0804b305 ES: 002b EDI: 08074ed0 207 SS: 002b ESP: bffe9a90 EBP: bffe9ac8 208 CS: 0023 EIP: 4012066e ERR: 00000080 EFLAGS: 00000246 209 210 Display the symbol name plus its offset in each frame, overriding 211 the current output format with hexadecimal: 212 213 crash\u0026gt; bt -sx 214 PID: 1499 TASK: ffff88006af43cc0 CPU: 2 COMMAND: \u0026#34;su\u0026#34; 215 #0 [ffff8800664a1c90] machine_kexec+0x167 at ffffffff810327b7 216 #1 [ffff8800664a1ce0] crash_kexec+0x60 at ffffffff810a9ec0 217 #2 [ffff8800664a1db0] oops_end+0xb0 at ffffffff81504160 218 #3 [ffff8800664a1dd0] general_protection+0x25 at ffffffff81503435 219 [exception RIP: kmem_cache_alloc+120] 220 RIP: ffffffff8113cf88 RSP: ffff8800664a1e88 RFLAGS: 00010086 221 RAX: 0000000000000000 RBX: ff88006ef56840ff RCX: ffffffff8114e9e4 222 RDX: 0000000000000000 RSI: 00000000000080d0 RDI: ffffffff81796020 223 RBP: ffffffff81796020 R8: ffff88000a3137a0 R9: 0000000000000000 224 R10: ffff88007ac97300 R11: 0000000000000400 R12: 00000000000080d0 225 R13: 0000000000000292 R14: 00000000000080d0 R15: 00000000000000c0 226 ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018 227 #4 [ffff8800664a1ed0] get_empty_filp+0x74 at ffffffff8114e9e4 228 #5 [ffff8800664a1ef0] sock_alloc_fd+0x23 at ffffffff8142f553 229 #6 [ffff8800664a1f10] sock_map_fd+0x23 at ffffffff8142f693 230 #7 [ffff8800664a1f50] sys_socket+0x43 at ffffffff814302a3 231 #8 [ffff8800664a1f80] system_call_fastpath+0x16 at ffffffff81013042 232 RIP: 00007f5720b368e7 RSP: 00007fff52b629a8 RFLAGS: 00010206 233 RAX: 0000000000000029 RBX: ffffffff81013042 RCX: 0000000000000000 234 RDX: 0000000000000009 RSI: 0000000000000003 RDI: 0000000000000010 235 RBP: 000000000066f320 R8: 0000000000000001 R9: 0000000000000000 236 R10: 0000000000000000 R11: 0000000000000202 R12: ffff88007ac97300 237 R13: 0000000000000000 R14: 00007f571e104a80 R15: 00007f571e305048 238 ORIG_RAX: 0000000000000029 CS: 0033 SS: 002b 239 240 The following three examples show the difference in the display of 241 the same stack frame\u0026#39;s contents using -f, -F, and -FF: 242 243 crash\u0026gt; bt -f 244 ... 245 #4 [ffff810072b47f10] vfs_write at ffffffff800789d8 246 ffff810072b47f18: ffff81007e020380 ffff81007e2c2880 247 ffff810072b47f28: 0000000000000002 fffffffffffffff7 248 ffff810072b47f38: 00002b141825d000 ffffffff80078f75 249 #5 [ffff810072b47f40] sys_write at ffffffff80078f75 250 ... 251 crash\u0026gt; bt -F 252 ... 253 #4 [ffff810072b47f10] vfs_write at ffffffff800789d8 254 ffff810072b47f18: [files_cache] [filp] 255 ffff810072b47f28: 0000000000000002 fffffffffffffff7 256 ffff810072b47f38: 00002b141825d000 sys_write+69 257 #5 [ffff810072b47f40] sys_write at ffffffff80078f75 258 ... 259 crash\u0026gt; bt -FF 260 ... 261 #4 [ffff810072b47f10] vfs_write at ffffffff800789d8 262 ffff810072b47f18: [ffff81007e020380:files_cache] [ffff81007e2c2880:filp] 263 ffff810072b47f28: 0000000000000002 fffffffffffffff7 264 ffff810072b47f38: 00002b141825d000 sys_write+69 265 #5 [ffff810072b47f40] sys_write at ffffffff80078f75 266 ... 267 268 Check the kernel stack of all tasks for evidence of a stack overflow: 269 270 crash\u0026gt; bt -v 271 PID: 5823 TASK: ffff88102aae0040 CPU: 1 COMMAND: \u0026#34;flush-253:0\u0026#34; 272 possible stack overflow: thread_info.task: 102efb5adc0 != ffff88102aae0040 273 possible stack overflow: 40ffffffff != STACK_END_MAGIC 6. btop - bytes to page 6.1. SYNOPSIS 1btop address ... 6.2. DESCRIPTION 1 This command translates a hexadecimal address to its page number. 6.3. EXAMPLES 1 crash\u0026gt; btop 512a000 2 512a000: 512a 7. dev - device data 7.1. SYNOPSIS 1dev [-i | -p | -d | -D ] [-V | -v index [file]] 7.2. DESCRIPTION 1 If no argument is entered, this command dumps character and block 2 device data. 3 4 -i display I/O port usage; on 2.4 kernels, also display I/O memory usage. 5 -p display PCI device data. 6 -d display disk I/O statistics: 7 TOTAL: total number of allocated in-progress I/O requests 8 SYNC: I/O requests that are synchronous 9 ASYNC: I/O requests that are asynchronous 10 READ: I/O requests that are reads (older kernels) 11 WRITE: I/O requests that are writes (older kernels) 12 DRV: I/O requests that are in-flight in the device driver. 13 If the device driver uses blk-mq interface, this field 14 shows N/A(MQ). If not available, this column is not shown. 15 -D same as -d, but filter out disks with no in-progress I/O requests. 16 17 If the dumpfile contains device dumps: 18 -V display an indexed list of all device dumps present in the vmcore, 19 showing their file offset, size and name. 20 -v index select and display one device dump based upon an index value 21 shown by the -V option, shown in a default human-readable format; 22 alternatively, the \u0026#34;rd -f\u0026#34; option along with its various format 23 options may be used to further tailor the output. 24 file only used with -v, copy the device dump data to a file. 7.3. EXAMPLES 1 Display character and block device data: 2 3 crash\u0026gt; dev 4 CHRDEV NAME CDEV OPERATIONS 5 1 mem f79b83c0 memory_fops 6 4 /dev/vc/0 c07bc560 console_fops 7 4 tty f7af5004 tty_fops 8 4 ttyS f7b02204 tty_fops 9 5 /dev/tty c07bc440 tty_fops 10 5 /dev/console c07bc4a0 console_fops 11 5 /dev/ptmx c07bc500 ptmx_fops 12 6 lp c5797e40 lp_fops 13 7 vcs f7b03d40 vcs_fops 14 10 misc f7f68640 misc_fops 15 13 input f79b8840 input_fops 16 21 sg f7f12840 sg_fops 17 29 fb f7f8c640 fb_fops 18 128 ptm f7b02604 tty_fops 19 136 pts f7b02404 tty_fops 20 162 raw c0693e40 raw_fops 21 180 usb f79b8bc0 usb_fops 22 189 usb_device c06a0300 usbfs_device_file_operations 23 216 rfcomm f5961a04 tty_fops 24 254 pcmcia f79b82c0 ds_fops 25 26 BLKDEV NAME GENDISK OPERATIONS 27 1 ramdisk f7b23480 rd_bd_op 28 8 sd f7cab280 sd_fops 29 9 md f7829b80 md_fops 30 11 sr f75c24c0 sr_bdops 31 65 sd (none) 32 66 sd (none) 33 67 sd (none) 34 68 sd (none) 35 69 sd (none) 36 70 sd (none) 37 71 sd (none) 38 128 sd (none) 39 129 sd (none) 40 130 sd (none) 41 131 sd (none) 42 132 sd (none) 43 133 sd (none) 44 134 sd (none) 45 135 sd (none) 46 253 device-mapper c57a0ac0 dm_blk_dops 47 254 mdp (none) 48 49 Display PCI data: 50 51 crash\u0026gt; dev -p 52 PCI_DEV BU:SL.FN CLASS: VENDOR-DEVICE 53 c00051c0 00:00.0 Host bridge: Intel 440BX - 82443BX Host 54 c0005250 00:01.0 PCI bridge: Intel 440BX - 82443BX AGP 55 c00052e0 00:07.0 ISA bridge: Intel 82371AB PIIX4 ISA 56 c0005370 00:07.1 IDE interface: Intel 82371AB PIIX4 IDE 57 c0005400 00:07.2 USB Controller: Intel 82371AB PIIX4 USB 58 c0005490 00:07.3 Bridge: Intel 82371AB PIIX4 ACPI 59 c0005520 00:11.0 Ethernet controller: 3Com 3C905B 100bTX 60 c00055b0 00:13.0 PCI bridge: DEC DC21152 61 c0005640 01:00.0 VGA compatible controller: NVidia [PCI_DEVICE 28] 62 c00056d0 02:0a.0 SCSI storage controller: Adaptec AIC-7890/1 63 c0005760 02:0e.0 SCSI storage controller: Adaptec AIC-7880U 64 65 Display I/O port and I/O memory usage: 66 67 crash\u0026gt; dev -i 68 RESOURCE RANGE NAME 69 c03036d4 0000-ffff PCI IO 70 c0302594 0000-001f dma1 71 c03025b0 0020-003f pic1 72 c03025cc 0040-005f timer 73 c03025e8 0060-006f keyboard 74 c0302604 0080-008f dma page reg 75 c0302620 00a0-00bf pic2 76 c030263c 00c0-00df dma2 77 c0302658 00f0-00ff fpu 78 c122ff20 0170-0177 ide1 79 c122f240 0213-0213 isapnp read 80 c122ff40 02f8-02ff serial(auto) 81 c122ff00 0376-0376 ide1 82 c03186e8 03c0-03df vga+ 83 c122ff60 03f8-03ff serial(auto) 84 c123851c 0800-083f Intel Corporation 82371AB PIIX4 ACPI 85 c1238538 0840-085f Intel Corporation 82371AB PIIX4 ACPI 86 c122f220 0a79-0a79 isapnp write 87 c122f200 0cf8-0cff PCI conf1 88 c1238858 dc00-dc7f 3Com Corporation 3c905B 100BaseTX [Cyclone] 89 c122fc00 dc00-dc7f 00:11.0 90 c12380c8 dce0-dcff Intel Corporation 82371AB PIIX4 USB 91 c1238d1c e000-efff PCI Bus #02 92 c1237858 e800-e8ff Adaptec AIC-7880U 93 c1237458 ec00-ecff Adaptec AHA-2940U2/W / 7890 94 c1239cc8 ffa0-ffaf Intel Corporation 82371AB PIIX4 IDE 95 96 RESOURCE RANGE NAME 97 c03036f0 00000000-ffffffff PCI mem 98 c0004000 00000000-0009ffff System RAM 99 c03026ac 000a0000-000bffff Video RAM area 100 c03026fc 000c0000-000c7fff Video ROM 101 c0302718 000c9800-000cdfff Extension ROM 102 c0302734 000ce000-000ce7ff Extension ROM 103 c0302750 000ce800-000cffff Extension ROM 104 c03026e0 000f0000-000fffff System ROM 105 c0004040 00100000-07ffdfff System RAM 106 c0302674 00100000-0028682b Kernel code 107 c0302690 0028682c-0031c63f Kernel data 108 c0004060 07ffe000-07ffffff reserved 109 c1239058 ec000000-efffffff Intel Corporation 440BX/ZX - 82443BX/ZX Host 110 bridge 111 c1238d54 f1000000-f1ffffff PCI Bus #02 112 c1239554 f2000000-f5ffffff PCI Bus #01 113 c1237074 f4000000-f5ffffff nVidia Corporation Riva TnT2 [NV5] 114 c1238d38 fa000000-fbffffff PCI Bus #02 115 c1237874 faffe000-faffefff Adaptec AIC-7880U 116 c127ec40 faffe000-faffefff aic7xxx 117 c1237474 fafff000-faffffff Adaptec AHA-2940U2/W / 7890 118 c127eec0 fafff000-faffffff aic7xxx 119 c1239538 fc000000-fdffffff PCI Bus #01 120 c1237058 fc000000-fcffffff nVidia Corporation Riva TnT2 [NV5] 121 c1238874 fe000000-fe00007f 3Com Corporation 3c905B 100BaseTX [Cyclone] 122 c0004080 fec00000-fec0ffff reserved 123 c00040a0 fee00000-fee0ffff reserved 124 c00040c0 ffe00000-ffffffff reserved 125 126 Display disk I/O statistics: 127 128 crash\u0026gt; dev -d 129 MAJOR GENDISK NAME REQUEST_QUEUE TOTAL READ WRITE DRV 130 2 ffff81012d8a5000 fd0 ffff81012dc053c0 12 0 12 0 131 22 ffff81012dc6b000 hdc ffff81012d8ae340 2 2 0 0 132 8 ffff81012dd71000 sda ffff81012d8af040 6 0 6 6 133 8 ffff81012dc77000 sdb ffff81012d8b5740 0 0 0 0 134 8 ffff81012d8d0c00 sdc ffff81012d8ae9c0 0 0 0 0 135 136 Display the available device dumps: 137 138 crash\u0026gt; dev -V 139 INDEX OFFSET SIZE NAME 140 0 0x240 33558464 cxgb4_0000:02:00.4 141 1 0x2001240 33558464 cxgb4_0000:03:00.4 142 143 Extract a specified device dump to file: 144 145 crash\u0026gt; dev -v 0 device_dump_0.bin 146 DEVICE: cxgb4_0000:02:00.4 147 33558464 bytes copied from 0x240 to device_dump_0.bin 148 149 Format and display a device\u0026#39;s dump data to the screen using the \u0026#34;rd\u0026#34; command: 150 151 crash\u0026gt; rd -f 0x240 -32 8 152 240: 040b69e2 00000038 000e0001 00675fd4 .i..8........_g. 153 250: 00000000 21600047 00000000 00000000 ....G.`!........ 154 155 Display a device\u0026#39;s dump data to the screen using the default format: 156 157 crash\u0026gt; dev -v 1 158 DEVICE: cxgb4_0000:03:00.4 159 2001240: 00000038040b69e2 00af985c000e0001 .i..8.......\\... 160 2001250: 2150004700000000 0000000000000000 ....G.P!........ 161 2001260: 0000000000000000 0000000000000000 ................ 162 2001270: 0000000000000000 0002fccc00000001 ................ 163 2001280: 00000000000027b0 0000000000000000 .\u0026#39;.............. 164 ... 8. dis - disassemble 8.1. SYNOPSIS 1dis [-rfludxs][-b [num]] [address | symbol | (expression)] [count] 8.2. DESCRIPTION 1 This command disassembles source code instructions starting (or ending) at 2 a text address that may be expressed by value, symbol or expression: 3 4 -r (reverse) displays all instructions from the start of the 5 routine up to and including the designated address. 6 -f (forward) displays all instructions from the given address 7 to the end of the routine. 8 -l displays source code line number data in addition to the 9 disassembly output. 10 -u address is a user virtual address in the current context; 11 otherwise the address is assumed to be a kernel virtual address. 12 If this option is used, then -r and -l are ignored. 13 -x override default output format with hexadecimal format. 14 -d override default output format with decimal format. 15 -s displays the filename and line number of the source code that 16 is associated with the specified text location, followed by a 17 source code listing if it is available on the host machine. 18 The line associated with the text location will be marked with 19 an asterisk; depending upon gdb\u0026#39;s internal \u0026#34;listsize\u0026#34; variable, 20 several lines will precede the marked location. If a \u0026#34;count\u0026#34; 21 argument is entered, it specifies the number of source code 22 lines to be displayed after the marked location; otherwise 23 the remaining source code of the containing function will be 24 displayed. 25 -b [num] modify the pre-calculated number of encoded bytes to skip after 26 a kernel BUG (\u0026#34;ud2a\u0026#34;) instruction; with no argument, displays 27 the current number of bytes being skipped. (x86 and x86_64 only) 28 address starting hexadecimal text address. 29 symbol symbol of starting text address. On ppc64, the symbol 30 preceded by \u0026#39;.\u0026#39; is used. 31 (expression) expression evaluating to a starting text address. 32 count the number of instructions to be disassembled (default is 1). 33 If no count argument is entered, and the starting address 34 is entered as a text symbol, then the whole routine will be 35 disassembled. The count argument is supported when used with 36 the -r and -f options. 8.3. EXAMPLES 1 Disassemble the sys_signal() routine without, and then with, line numbers: 2 3 crash\u0026gt; dis sys_signal 4 0xc0112c88 \u0026lt;sys_signal\u0026gt;: push %ebp 5 0xc0112c89 \u0026lt;sys_signal+1\u0026gt;: mov %esp,%ebp 6 0xc0112c8b \u0026lt;sys_signal+3\u0026gt;: sub $0x28,%esp 7 0xc0112c8e \u0026lt;sys_signal+6\u0026gt;: mov 0xc(%ebp),%eax 8 0xc0112c91 \u0026lt;sys_signal+9\u0026gt;: mov %eax,0xffffffec(%ebp) 9 0xc0112c94 \u0026lt;sys_signal+12\u0026gt;: movl $0xc0000000,0xfffffff0(%ebp) 10 0xc0112c9b \u0026lt;sys_signal+19\u0026gt;: lea 0xffffffd8(%ebp),%eax 11 0xc0112c9e \u0026lt;sys_signal+22\u0026gt;: push %eax 12 0xc0112c9f \u0026lt;sys_signal+23\u0026gt;: lea 0xffffffec(%ebp),%eax 13 0xc0112ca2 \u0026lt;sys_signal+26\u0026gt;: push %eax 14 0xc0112ca3 \u0026lt;sys_signal+27\u0026gt;: pushl 0x8(%ebp) 15 0xc0112ca6 \u0026lt;sys_signal+30\u0026gt;: call 0xc01124b8 \u0026lt;do_sigaction\u0026gt; 16 0xc0112cab \u0026lt;sys_signal+35\u0026gt;: test %eax,%eax 17 0xc0112cad \u0026lt;sys_signal+37\u0026gt;: jne 0xc0112cb2 \u0026lt;sys_signal+42\u0026gt; 18 0xc0112caf \u0026lt;sys_signal+39\u0026gt;: mov 0xffffffd8(%ebp),%eax 19 0xc0112cb2 \u0026lt;sys_signal+42\u0026gt;: leave 20 0xc0112cb3 \u0026lt;sys_signal+43\u0026gt;: ret 21 22 crash\u0026gt; dis -l sys_signal 23 /usr/src/linux-2.2.5/kernel/signal.c: 1074 24 0xc0112c88 \u0026lt;sys_signal\u0026gt;: push %ebp 25 0xc0112c89 \u0026lt;sys_signal+1\u0026gt;: mov %esp,%ebp 26 0xc0112c8b \u0026lt;sys_signal+3\u0026gt;: sub $0x28,%esp 27 0xc0112c8e \u0026lt;sys_signal+6\u0026gt;: mov 0xc(%ebp),%eax 28 /usr/src/linux-2.2.5/kernel/signal.c: 1078 29 0xc0112c91 \u0026lt;sys_signal+9\u0026gt;: mov %eax,0xffffffec(%ebp) 30 /usr/src/linux-2.2.5/kernel/signal.c: 1079 31 0xc0112c94 \u0026lt;sys_signal+12\u0026gt;: movl $0xc0000000,0xfffffff0(%ebp) 32 /usr/src/linux-2.2.5/kernel/signal.c: 1081 33 0xc0112c9b \u0026lt;sys_signal+19\u0026gt;: lea 0xffffffd8(%ebp),%eax 34 0xc0112c9e \u0026lt;sys_signal+22\u0026gt;: push %eax 35 0xc0112c9f \u0026lt;sys_signal+23\u0026gt;: lea 0xffffffec(%ebp),%eax 36 0xc0112ca2 \u0026lt;sys_signal+26\u0026gt;: push %eax 37 0xc0112ca3 \u0026lt;sys_signal+27\u0026gt;: pushl 0x8(%ebp) 38 0xc0112ca6 \u0026lt;sys_signal+30\u0026gt;: call 0xc01124b8 \u0026lt;do_sigaction\u0026gt; 39 /usr/src/linux-2.2.5/kernel/signal.c: 1083 40 0xc0112cab \u0026lt;sys_signal+35\u0026gt;: test %eax,%eax 41 0xc0112cad \u0026lt;sys_signal+37\u0026gt;: jne 0xc0112cb2 \u0026lt;sys_signal+42\u0026gt; 42 0xc0112caf \u0026lt;sys_signal+39\u0026gt;: mov 0xffffffd8(%ebp),%eax 43 /usr/src/linux-2.2.5/kernel/signal.c: 1084 44 0xc0112cb2 \u0026lt;sys_signal+42\u0026gt;: leave 45 0xc0112cb3 \u0026lt;sys_signal+43\u0026gt;: ret 46 47 Given a return address expression of \u0026#34;do_no_page+65\u0026#34;, find out the 48 function that do_no_page() calls by using the reverse flag: 49 50 crash\u0026gt; dis -r (do_no_page+65) 51 0xc011ea68 \u0026lt;do_no_page\u0026gt;: push %ebp 52 0xc011ea69 \u0026lt;do_no_page+1\u0026gt;: mov %esp,%ebp 53 0xc011ea6b \u0026lt;do_no_page+3\u0026gt;: push %edi 54 0xc011ea6c \u0026lt;do_no_page+4\u0026gt;: push %esi 55 0xc011ea6d \u0026lt;do_no_page+5\u0026gt;: push %ebx 56 0xc011ea6e \u0026lt;do_no_page+6\u0026gt;: mov 0xc(%ebp),%ebx 57 0xc011ea71 \u0026lt;do_no_page+9\u0026gt;: mov 0x10(%ebp),%edx 58 0xc011ea74 \u0026lt;do_no_page+12\u0026gt;: mov 0x14(%ebp),%edi 59 0xc011ea77 \u0026lt;do_no_page+15\u0026gt;: mov 0x28(%ebx),%eax 60 0xc011ea7a \u0026lt;do_no_page+18\u0026gt;: test %eax,%eax 61 0xc011ea7c \u0026lt;do_no_page+20\u0026gt;: je 0xc011ea85 \u0026lt;do_no_page+29\u0026gt; 62 0xc011ea7e \u0026lt;do_no_page+22\u0026gt;: mov 0x18(%eax),%ecx 63 0xc011ea81 \u0026lt;do_no_page+25\u0026gt;: test %ecx,%ecx 64 0xc011ea83 \u0026lt;do_no_page+27\u0026gt;: jne 0xc011eab0 \u0026lt;do_no_page+72\u0026gt; 65 0xc011ea85 \u0026lt;do_no_page+29\u0026gt;: mov $0xffffe000,%eax 66 0xc011ea8a \u0026lt;do_no_page+34\u0026gt;: and %esp,%eax 67 0xc011ea8c \u0026lt;do_no_page+36\u0026gt;: decl 0x30(%eax) 68 0xc011ea8f \u0026lt;do_no_page+39\u0026gt;: jns 0xc011ea9a \u0026lt;do_no_page+50\u0026gt; 69 0xc011ea91 \u0026lt;do_no_page+41\u0026gt;: lock btrl $0x0,0xc022fb60 70 0xc011ea9a \u0026lt;do_no_page+50\u0026gt;: push %edi 71 0xc011ea9b \u0026lt;do_no_page+51\u0026gt;: mov 0x18(%ebp),%esi 72 0xc011ea9e \u0026lt;do_no_page+54\u0026gt;: push %esi 73 0xc011ea9f \u0026lt;do_no_page+55\u0026gt;: push %ebx 74 0xc011eaa0 \u0026lt;do_no_page+56\u0026gt;: mov 0x8(%ebp),%esi 75 0xc011eaa3 \u0026lt;do_no_page+59\u0026gt;: push %esi 76 0xc011eaa4 \u0026lt;do_no_page+60\u0026gt;: call 0xc011e9e4 \u0026lt;do_anonymous_page\u0026gt; 77 0xc011eaa9 \u0026lt;do_no_page+65\u0026gt;: jmp 0xc011eb47 \u0026lt;do_no_page+223\u0026gt; 78 79 Disassemble 10 instructions starting at user virtual address 0x81ec624: 80 81 crash\u0026gt; dis -u 81ec624 10 82 0x81ec624: push %ebp 83 0x81ec625: mov %esp,%ebp 84 0x81ec627: sub $0x18,%esp 85 0x81ec62a: movl $0x1,0x8(%ebp) 86 0x81ec631: mov 0x82f9040,%eax 87 0x81ec636: mov 0x10(%eax),%edx 88 0x81ec639: and $0x100,%edx 89 0x81ec63f: mov 0x14(%eax),%ecx 90 0x81ec642: and $0x0,%ecx 91 0x81ec645: mov %ecx,%eax 92 93 Override the current decimal output radix format: 94 95 crash\u0026gt; dis sys_read 10 -x 96 0xffffffff8001178f \u0026lt;sys_read\u0026gt;: push %r13 97 0xffffffff80011791 \u0026lt;sys_read+0x2\u0026gt;: mov %rsi,%r13 98 0xffffffff80011794 \u0026lt;sys_read+0x5\u0026gt;: push %r12 99 0xffffffff80011796 \u0026lt;sys_read+0x7\u0026gt;: mov $0xfffffffffffffff7,%r12 100 0xffffffff8001179d \u0026lt;sys_read+0xe\u0026gt;: push %rbp 101 0xffffffff8001179e \u0026lt;sys_read+0xf\u0026gt;: mov %rdx,%rbp 102 0xffffffff800117a1 \u0026lt;sys_read+0x12\u0026gt;: push %rbx 103 0xffffffff800117a2 \u0026lt;sys_read+0x13\u0026gt;: sub $0x18,%rsp 104 0xffffffff800117a6 \u0026lt;sys_read+0x17\u0026gt;: lea 0x14(%rsp),%rsi 105 0xffffffff800117ab \u0026lt;sys_read+0x1c\u0026gt;: callq 0xffffffff8000b5b4 \u0026lt;fget_light\u0026gt; 106 107 Disassemble from vfs_read+320 until the end of the function: 108 109 crash\u0026gt; dis -f vfs_read+320 110 0xffffffff8119d4e0 \u0026lt;vfs_read+320\u0026gt;: cmpq $0x0,0x20(%rax) 111 0xffffffff8119d4e5 \u0026lt;vfs_read+325\u0026gt;: jne 0xffffffff8119d3e8 \u0026lt;vfs_read+72\u0026gt; 112 0xffffffff8119d4eb \u0026lt;vfs_read+331\u0026gt;: mov $0xffffffffffffffea,%r12 113 0xffffffff8119d4f2 \u0026lt;vfs_read+338\u0026gt;: jmp 0xffffffff8119d4c3 \u0026lt;vfs_read+291\u0026gt; 114 0xffffffff8119d4f4 \u0026lt;vfs_read+340\u0026gt;: nopl 0x0(%rax) 115 0xffffffff8119d4f8 \u0026lt;vfs_read+344\u0026gt;: callq 0xffffffff8119cc40 \u0026lt;do_sync_read\u0026gt; 116 0xffffffff8119d4fd \u0026lt;vfs_read+349\u0026gt;: mov %rax,%r12 117 0xffffffff8119d500 \u0026lt;vfs_read+352\u0026gt;: jmpq 0xffffffff8119d44c \u0026lt;vfs_read+172\u0026gt; 118 0xffffffff8119d505 \u0026lt;vfs_read+357\u0026gt;: nopl (%rax) 119 0xffffffff8119d508 \u0026lt;vfs_read+360\u0026gt;: mov $0xfffffffffffffff7,%r12 120 0xffffffff8119d50f \u0026lt;vfs_read+367\u0026gt;: jmp 0xffffffff8119d4c3 \u0026lt;vfs_read+291\u0026gt; 121 0xffffffff8119d511 \u0026lt;vfs_read+369\u0026gt;: mov $0xfffffffffffffff2,%r12 122 0xffffffff8119d518 \u0026lt;vfs_read+376\u0026gt;: jmp 0xffffffff8119d4c3 \u0026lt;vfs_read+291\u0026gt; 123 0xffffffff8119d51a \u0026lt;vfs_read+378\u0026gt;: nopw 0x0(%rax,%rax,1) 124 125 Display the source code listing of the mmput() function: 126 127 crash\u0026gt; dis -s mmput 128 FILE: kernel/fork.c 129 LINE: 617 130 131 612 132 613 /* 133 614 * Decrement the use count and release all resources for an mm. 134 615 */ 135 616 void mmput(struct mm_struct *mm) 136 * 617 { 137 618 might_sleep(); 138 619 139 620 if (atomic_dec_and_test(\u0026amp;mm-\u0026gt;mm_users)) { 140 621 uprobe_clear_state(mm); 141 622 exit_aio(mm); 142 623 ksm_exit(mm); 143 624 khugepaged_exit(mm); /* must run before exit_mmap */ 144 625 exit_mmap(mm); 145 626 set_mm_exe_file(mm, NULL); 146 627 if (!list_empty(\u0026amp;mm-\u0026gt;mmlist)) { 147 628 spin_lock(\u0026amp;mmlist_lock); 148 629 list_del(\u0026amp;mm-\u0026gt;mmlist); 149 630 spin_unlock(\u0026amp;mmlist_lock); 150 631 } 151 632 if (mm-\u0026gt;binfmt) 152 633 module_put(mm-\u0026gt;binfmt-\u0026gt;module); 153 634 mmdrop(mm); 154 635 } 155 636 } 156 157 The disassembly of dentry_kill() shows an indirect call to a function 158 whose address is contained within a register. Display the source code 159 associated with the indirect function call: 160 161 crash\u0026gt; dis dentry_kill 162 ... 163 0xffffffff811dcfb4 \u0026lt;dentry_kill+324\u0026gt;:\tcallq *%rax 164 ... 165 crash\u0026gt; dis -s 0xffffffff811dcfb4 166 FILE: fs/dcache.c 167 LINE: 276 168 169 271 spin_unlock(\u0026amp;dentry-\u0026gt;d_lock); 170 272 spin_unlock(\u0026amp;inode-\u0026gt;i_lock); 171 273 if (!inode-\u0026gt;i_nlink) 172 274 fsnotify_inoderemove(inode); 173 275 if (dentry-\u0026gt;d_op \u0026amp;\u0026amp; dentry-\u0026gt;d_op-\u0026gt;d_iput) 174 * 276 dentry-\u0026gt;d_op-\u0026gt;d_iput(dentry, inode); 175 277 else 176 278 iput(inode); 177 279 } else { 178 280 spin_unlock(\u0026amp;dentry-\u0026gt;d_lock); 179 281 } 180 282 } 9. eval - evaluate 9.1. SYNOPSIS 1eval [-b][-l] (expression) | value 9.2. DESCRIPTION 1 This command evaluates an expression or numeric value, and displays its 2 result in hexadecimal, decimal, octal and binary. If the resultant value 3 is an integral number of gigabytes, megabytes, or kilobytes, a short-hand 4 translation of the number will also be shown next to the hexadecimal 5 value. If the most significant bit is set, the decimal display will show 6 both unsigned and signed (negative) values. Expressions must of the format 7 (x operator y), where \u0026#34;x\u0026#34; and \u0026#34;y\u0026#34; may be either numeric values or 8 symbols. The list of operators are: 9 10 + - \u0026amp; | ^ * % / \u0026lt;\u0026lt; \u0026gt;\u0026gt; 11 12 Enclosing the expression within parentheses is optional except when the 13 \u0026#34;|\u0026#34;, \u0026#34;\u0026lt;\u0026lt;\u0026#34; or \u0026#34;\u0026gt;\u0026gt;\u0026#34; operators are used. The single \u0026#34;value\u0026#34; argument may 14 be a number or symbol. Number arguments must be hexadecimal or decimal. 15 A leading \u0026#34;0x\u0026#34; identifies a number as hexadecimal, but is not required 16 when obvious. Numbers may be followed by the letters \u0026#34;k\u0026#34; or \u0026#34;K\u0026#34;, \u0026#34;m\u0026#34; 17 or \u0026#34;M\u0026#34;, and \u0026#34;g\u0026#34; or \u0026#34;G\u0026#34;, which multiplies the value by a factor of 1024, 18 1 megabyte or 1 gigabyte, respectively. Numeric arguments may be preceded 19 by the one\u0026#39;s complement operator ~. 20 21 -b Indicate which bit positions in the resultant value are set. 22 -l Numeric arguments are presumed to be 64-bit values, and the result 23 will be expressed as a 64-bit value. (ignored on 64-bit processors) 24 However, if either operand or the resultant value are 64-bit values, 25 then the result will be also be expressed as a 64-bit value. 26 27 The -b and -l options must precede the expression or value arguments. 9.3. EXAMPLES 1 crash\u0026gt; eval 128m 2 hexadecimal: 8000000 (128MB) 3 decimal: 134217728 4 octal: 1000000000 5 binary: 00001000000000000000000000000000 6 7 crash\u0026gt; eval 128 * 1m 8 hexadecimal: 8000000 (128MB) 9 decimal: 134217728 10 octal: 1000000000 11 binary: 00001000000000000000000000000000 12 13 crash\u0026gt; eval (1 \u0026lt;\u0026lt; 27) 14 hexadecimal: 8000000 (128MB) 15 decimal: 134217728 16 octal: 1000000000 17 binary: 00001000000000000000000000000000 18 19 crash\u0026gt; eval (1 \u0026lt;\u0026lt; 32) 20 hexadecimal: 100000000 (4GB) 21 decimal: 4294967296 22 octal: 40000000000 23 binary: 0000000000000000000000000000000100000000000000000000000000000000 24 25 crash\u0026gt; eval -b 41dc065 26 hexadecimal: 41dc065 27 decimal: 69058661 28 octal: 407340145 29 binary: 00000100000111011100000001100101 30 bits set: 26 20 19 18 16 15 14 6 5 2 0 31 32 crash\u0026gt; eval -lb 64g 33 hexadecimal: 1000000000 (64GB) 34 decimal: 68719476736 35 octal: 1000000000000 36 binary: 0000000000000000000000000001000000000000000000000000000000000000 37 bits set: 36 10. exit - exit this session 10.1. SYNOPSIS 1exit 10.2. DESCRIPTION 1 Bail out of the current crash session. 10.3. NOTE 1 This command is equivalent to the \u0026#34;q\u0026#34; command. 11. extend - extend the crash command set 11.1. SYNOPSIS 1extend [shared-object ...] | [-u [shared-object ...]] 11.2. DESCRIPTION 1 This command dynamically loads or unloads crash extension shared object 2 libraries: 3 4 shared-object load the specified shared object file; more than one 5 one object file may be entered. 6 -u shared-object unload the specified shared object file; if no file 7 arguments are specified, unload all objects. 8 9 If the shared-object filename is not expressed with a fully-qualified 10 pathname, the following directories will be searched in the order shown, 11 and the first instance of the file that is found will be selected: 12 13 1. the current working directory 14 2. the directory specified in the CRASH_EXTENSIONS environment variable 15 3. /usr/lib64/crash/extensions (64-bit architectures) 16 4. /usr/lib/crash/extensions 17 18 If no arguments are entered, the current set of shared object files and 19 a list of their commands will be displayed. The registered commands 20 contained in each shared object file will appear automatically in the 21 \u0026#34;help\u0026#34; command screen. 22 23 An example of a shared object prototype file, and how to compile it 24 into a shared object, is appended below. 11.3. EXAMPLES 1 Load two shared object files: 2 3 crash\u0026gt; extend extlib1.so extlib2.so 4 ./extlib1.so: shared object loaded 5 ./extlib2.so: shared object loaded 6 7 Display the current set of shared object files and their commands: 8 9 crash\u0026gt; extend 10 SHARED OBJECT COMMANDS 11 ./extlib1.so echo util bin 12 ./extlib2.so smp show 13 14 Unload one of the shared object files: 15 16 crash\u0026gt; extend -u extlib1.so 17 ./extlib1.so: shared object unloaded 18 19 Unload all currently-loaded object files: 20 21 crash\u0026gt; extend -u 22 ./extlib2.so: shared object unloaded 23 24CREATING A SHARED OBJECT 25 The extend command loads shared object files using dlopen(3), which in 26 turn calls the shared object\u0026#39;s constructor function. The shared object\u0026#39;s 27 constructor function should register its command set by calling 28 register_extension(), passing it a pointer to an array of one or more 29 structures of the following type: 30 31 struct command_table_entry { 32 char *name; 33 cmd_func_t func; 34 char **help_data, 35 ulong flags; 36 }; 37 38 Each command_table_entry structure contains the ASCII name of a command, 39 the command\u0026#39;s function address, a pointer to an array of help data strings, 40 and a flags field. The help_data field is optional; if it is non-NULL, it 41 should point to an array of character strings used by the \u0026#34;help\u0026#34; 42 command, and during command failures. The flags field currently has two 43 available bit settings, REFRESH_TASK_TABLE, which should be set if it is 44 preferable to reload the current set of running processes just prior to 45 executing the command (on a live system) and MINIMAL, which should be 46 set if the command should be available in minimal mode. Terminate the array 47 of command_table_entry structures with an entry with a NULL command name. 48 49 Below is an example shared object file consisting of just one command, 50 called \u0026#34;echo\u0026#34;, which simply echoes back all arguments passed to it. 51 Note the comments contained within it for further details. Cut and paste 52 the following output into a file, and call it, for example, \u0026#34;echo.c\u0026#34;. 53 Then compiled in either of two manners. Either manually like so: 54 55 gcc -shared -rdynamic -o echo.so echo.c -fPIC -D\u0026lt;machine-type\u0026gt; $(TARGET_CFLAGS) 56 57 where \u0026lt;machine-type\u0026gt; must be one of the MACHINE_TYPE #define\u0026#39;s in defs.h, 58 and where $(TARGET_CFLAGS) is the same as it is declared in the top-level 59 Makefile after a build is completed. Or alternatively, the \u0026#34;echo.c\u0026#34; file 60 can be copied into the \u0026#34;extensions\u0026#34; subdirectory, and compiled automatically 61 like so: 62 63 make extensions 64 65 The echo.so file may be dynamically linked into crash during runtime, or 66 during initialization by putting \u0026#34;extend echo.so\u0026#34; into a .crashrc file 67 located in the current directory, or in the user\u0026#39;s $HOME directory. 68 69---------------------------------- cut here ---------------------------------- 70 71#include \u0026#34;defs.h\u0026#34; /* From the crash source top-level directory */ 72 73void echo_init(void); /* constructor function */ 74void echo_fini(void); /* destructor function (optional) */ 75 76void cmd_echo(void); /* Declare the commands and their help data. */ 77char *help_echo[]; 78 79static struct command_table_entry command_table[] = { 80 { \u0026#34;echo\u0026#34;, cmd_echo, help_echo, 0}, /* One or more commands, */ 81 { NULL }, /* terminated by NULL, */ 82}; 83 84 85void __attribute__((constructor)) 86echo_init(void) /* Register the command set. */ 87{ 88 register_extension(command_table); 89} 90 91/* 92 * This function is called if the shared object is unloaded. 93 * If desired, perform any cleanups here. 94 */ 95void __attribute__((destructor)) 96echo_fini(void) { } 97 98 99/* 100 * Arguments are passed to the command functions in the global args[argcnt] 101 * array. See getopt(3) for info on dash arguments. Check out defs.h and 102 * other crash commands for usage of the myriad of utility routines available 103 * to accomplish what your task. 104 */ 105void 106cmd_echo(void) 107{ 108 int c; 109 110 while ((c = getopt(argcnt, args, \u0026#34;\u0026#34;)) != EOF) { 111 switch(c) 112 { 113 default: 114 argerrs++; 115 break; 116 } 117 } 118 119 if (argerrs) 120 cmd_usage(pc-\u0026gt;curcmd, SYNOPSIS); 121 122 while (args[optind]) 123 fprintf(fp, \u0026#34;%s \u0026#34;, args[optind++]); 124 125 fprintf(fp, \u0026#34;\\n\u0026#34;); 126} 127 128/* 129 * The optional help data is simply an array of strings in a defined format. 130 * For example, the \u0026#34;help echo\u0026#34; command will use the help_echo[] string 131 * array below to create a help page that looks like this: 132 * 133 * NAME 134 * echo - echoes back its arguments 135 * 136 * SYNOPSIS 137 * echo arg ... 138 * 139 * DESCRIPTION 140 * This command simply echoes back its arguments. 141 * 142 * EXAMPLE 143 * Echo back all command arguments: 144 * 145 * crash\u0026gt; echo hello, world 146 * hello, world 147 * 148 */ 149 150char *help_echo[] = { 151 \u0026#34;echo\u0026#34;, /* command name */ 152 \u0026#34;echoes back its arguments\u0026#34;, /* short description */ 153 \u0026#34;arg ...\u0026#34;, /* argument synopsis, or \u0026#34; \u0026#34; if none */ 154 155 \u0026#34; This command simply echoes back its arguments.\u0026#34;, 156 \u0026#34;\\nEXAMPLE\u0026#34;, 157 \u0026#34; Echo back all command arguments:\\n\u0026#34;, 158 \u0026#34; crash\u0026gt; echo hello, world\u0026#34;, 159 \u0026#34; hello, world\u0026#34;, 160 NULL 161}; 12. files - open files 12.1. SYNOPSIS 1files [-d dentry] | [-p inode] | [-c] [-R reference] [pid | taskp] ... 12.2. DESCRIPTION 1 This command displays information about open files of a context. 2 It prints the context\u0026#39;s current root directory and current working 3 directory, and then for each open file descriptor it prints a pointer 4 to its file struct, a pointer to its dentry struct, a pointer to the 5 inode, the file type, and the pathname. If no arguments are entered, 6 the current context is used. The -R option, typically invoked from 7 \u0026#34;foreach files\u0026#34;, searches for references to a supplied number, address, 8 or filename argument, and prints only the essential information leading 9 up to and including the reference. The -d option is not context 10 specific, and only shows the data requested. 11 12 -d dentry given a hexadecimal dentry address, display its inode, 13 super block, file type, and full pathname. 14 -p inode given a hexadecimal inode address, dump all of its pages 15 that are in the page cache. 16 -c for each open file descriptor, prints a pointer to its 17 inode, a pointer to the inode\u0026#39;s i_mapping address_space 18 structure, the number of pages of the inode that are in 19 the page cache, the file type, and the pathname. 20 -R reference search for references to this file descriptor number, 21 filename, dentry, inode, address_space, or file structure 22 address. 23 pid a process PID. 24 taskp a hexadecimal task_struct pointer. 12.3. EXAMPLES 1 Display the open files of the current context: 2 3 crash\u0026gt; files 4 PID: 720 TASK: c67f2000 CPU: 1 COMMAND: \u0026#34;innd\u0026#34; 5 ROOT: / CWD: /var/spool/news/articles 6 FD FILE DENTRY INODE TYPE PATH 7 0 c6b9c740 c7cc45a0 c7c939e0 CHR /dev/null 8 1 c6b9c800 c537bb20 c54d0000 REG /var/log/news/news 9 2 c6df9600 c537b420 c5c36360 REG /var/log/news/errlog 10 3 c74182c0 c6ede260 c6da3d40 PIPE 11 4 c6df9720 c696c620 c69398c0 SOCK 12 5 c6b9cc20 c68e7000 c6938d80 SOCK 13 6 c6b9c920 c7cc45a0 c7c939e0 CHR /dev/null 14 7 c6b9c680 c58fa5c0 c58a1200 REG /var/lib/news/history 15 8 c6df9f00 c6ede760 c6da3200 PIPE 16 9 c6b9c6e0 c58fa140 c5929560 REG /var/lib/news/history.dir 17 10 c7fa9320 c7fab160 c7fafd40 CHR /dev/console 18 11 c6b9c7a0 c58fa5c0 c58a1200 REG /var/lib/news/history 19 12 c377ec60 c58fa5c0 c58a1200 REG /var/lib/news/history 20 13 c4528aa0 c58fa6c0 c52fbb00 REG /var/lib/news/history.pag 21 14 c6df9420 c68e7700 c6938360 SOCK 22 15 c6df9360 c68e7780 c6938120 SOCK 23 16 c6b9c0e0 c68e7800 c6772000 SOCK 24 17 c6b9c200 c6b5f9c0 c6b5cea0 REG /var/lib/news/active 25 21 c6b9c080 c6ede760 c6da3200 PIPE 26 27 Display the files opened by the \u0026#34;crond\u0026#34; daemon, which is PID 462: 28 29 crash\u0026gt; files 462 30 PID: 462 TASK: f7220000 CPU: 2 COMMAND: \u0026#34;crond\u0026#34; 31 ROOT: / CWD: /var/spool 32 FD FILE DENTRY INODE TYPE PATH 33 0 f7534ae0 f7538de0 f7518dc0 CHR /dev/console 34 1 f7368f80 f72c7a40 f72f27e0 FIFO pipe:/[1456] 35 2 f74f3c80 f72c79c0 f72f2600 FIFO pipe:/[1457] 36 3 f7368b60 f72a5be0 f74300c0 REG /var/run/crond.pid 37 4 f7534360 f73408c0 f72c2840 REG /var/log/cron 38 7 f7368ce0 f72c7940 f72f2420 FIFO pipe:/[1458] 39 8 f7295de0 f72c7940 f72f2420 FIFO pipe:/[1458] 40 21 f74f36e0 f747cdc0 f747e840 CHR /dev/null 41 42 The -R option is typically invoked from \u0026#34;foreach files\u0026#34;. This example 43 shows all tasks that have \u0026#34;/dev/pts/4\u0026#34; open: 44 45 crash\u0026gt; foreach files -R pts/4 46 PID: 18633 TASK: c310a000 CPU: 0 COMMAND: \u0026#34;crash\u0026#34; 47 ROOT: / CWD: /home/CVS_pool/crash 48 FD FILE DENTRY INODE TYPE PATH 49 0 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 50 1 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 51 2 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 52 53 PID: 18664 TASK: c2392000 CPU: 1 COMMAND: \u0026#34;less\u0026#34; 54 ROOT: / CWD: /home/CVS_pool/crash 55 FD FILE DENTRY INODE TYPE PATH 56 1 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 57 2 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 58 59 PID: 23162 TASK: c5088000 CPU: 1 COMMAND: \u0026#34;bash\u0026#34; 60 ROOT: / CWD: /home/CVS_pool/crash 61 FD FILE DENTRY INODE TYPE PATH 62 0 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 63 1 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 64 2 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 65 255 c1412850 c2cb96d0 c2cad430 CHR /dev/pts/4 66 67 PID: 23159 TASK: c10fc000 CPU: 1 COMMAND: \u0026#34;xterm\u0026#34; 68 ROOT: / CWD: /homes/anderson/ 69 FD FILE DENTRY INODE TYPE PATH 70 5 c1560da0 c2cb96d0 c2cad430 CHR /dev/pts/4 71 72 Display information about the dentry at address f745fd60: 73 74 crash\u0026gt; files -d f745fd60 75 DENTRY INODE SUPERBLK TYPE PATH 76 f745fd60 f7284640 f73a3e00 REG /var/spool/lpd/lpd.lock 77 78 For each open file, display the number of pages that are in the page cache: 79 80 crash\u0026gt; files -c 1954 81 PID: 1954 TASK: f7a28000 CPU: 1 COMMAND: \u0026#34;syslogd\u0026#34; 82 ROOT: / CWD: / 83 FD INODE I_MAPPING NRPAGES TYPE PATH 84 0 cb3ae868 cb3ae910 0 SOCK socket:/[4690] 85 2 f2721c5c f2721d04 461 REG /var/log/messages 86 3 cbda4884 cbda492c 47 REG /var/log/secure 87 4 e48092c0 e4809368 58 REG /var/log/maillog 88 5 f65192c0 f6519368 48 REG /var/log/cron 89 6 e4809e48 e4809ef0 0 REG /var/log/spooler 90 7 d9c43884 d9c4392c 0 REG /var/log/boot.log 91 92 For the inode at address f59b90fc, display all of its pages that are in 93 the page cache: 94 95 crash\u0026gt; files -p f59b90fc 96 INODE NRPAGES 97 f59b90fc 6 98 99 PAGE PHYSICAL MAPPING INDEX CNT FLAGS 100 ca3353e0 39a9f000 f59b91ac 0 2 82c referenced,uptodate,lru,private 101 ca22cb20 31659000 f59b91ac 1 2 82c referenced,uptodate,lru,private 102 ca220160 3100b000 f59b91ac 2 2 82c referenced,uptodate,lru,private 103 ca1ddde0 2eeef000 f59b91ac 3 2 82c referenced,uptodate,lru,private 104 ca36b300 3b598000 f59b91ac 4 2 82c referenced,uptodate,lru,private 105 ca202680 30134000 f59b91ac 5 2 82c referenced,uptodate,lru,private 13. foreach - display command data for multiple tasks in the system 13.1. SYNOPSIS 1foreach [[pid | taskp | name | state | [kernel | user | gleader]] ...] 2 command [flag] [argument] 13.2. DESCRIPTION 1 This command allows for an examination of various kernel data associated 2 with any, or all, tasks in the system, without having to set the context 3 to each targeted task. 4 5 pid perform the command(s) on this PID. 6 taskp perform the command(s) on task referenced by this hexadecimal 7 task_struct pointer. 8 name perform the command(s) on all tasks with this name. If the 9 task name can be confused with a foreach command name, then 10 precede the name string with a \u0026#34;\\\u0026#34;. If the name string is 11 enclosed within \u0026#34;\u0026#39;\u0026#34; characters, then the encompassed string 12 must be a POSIX extended regular expression that will be used 13 to match task names. 14 user perform the command(s) on all user (non-kernel) threads. 15 gleader perform the command(s) on all user (non-kernel) thread group leaders. 16 kernel perform the command(s) on all kernel threads. 17 active perform the command(s) on the active thread on each CPU. 18 state perform the command(s) on all tasks in the specified state, which 19 may be one of: RU, IN, UN, ST, ZO, TR, SW, DE, WA, PA, ID or NE. 20 21 If none of the task-identifying arguments above are entered, the command 22 will be performed on all tasks. 23 24 command select one or more of the following commands to be run on the tasks 25 selected, or on all tasks: 26 27 bt run the \u0026#34;bt\u0026#34; command (optional flags: -r -t -l -e -R -f -F 28 -o -s -x -d) 29 vm run the \u0026#34;vm\u0026#34; command (optional flags: -p -v -m -R -d -x) 30 task run the \u0026#34;task\u0026#34; command (optional flags: -R -d -x) 31 files run the \u0026#34;files\u0026#34; command (optional flag: -c -R) 32 net run the \u0026#34;net\u0026#34; command (optional flags: -s -S -R -d -x) 33 set run the \u0026#34;set\u0026#34; command 34 ps run the \u0026#34;ps\u0026#34; command (optional flags: -G -s -p -c -t -l -a 35 -g -r -y) 36 sig run the \u0026#34;sig\u0026#34; command (optional flag: -g) 37 vtop run the \u0026#34;vtop\u0026#34; command (optional flags: -c -u -k) 38 39 flag Pass this optional flag to the command selected. 40 argument Pass this argument to the command selected. 41 42 A header containing the PID, task address, cpu and command name will be 43 pre-pended before the command output for each selected task. Consult the 44 help page of each of the command types above for details. 13.3. EXAMPLES 1 Display the stack traces for all tasks: 2 3 crash\u0026gt; foreach bt 4 PID: 4752 TASK: c7680000 CPU: 1 COMMAND: \u0026#34;xterm\u0026#34; 5 #0 [c7681edc] schedule at c01135f6 6 (void) 7 #1 [c7681f34] schedule_timeout at c01131ff 8 (24) 9 #2 [c7681f64] do_select at c0132838 10 (5, c7681fa4, c7681fa0) 11 #3 [c7681fbc] sys_select at c0132dad 12 (5, 8070300, 8070380, 0, 0) 13 #4 [bffffb0c] system_call at c0109944 14 EAX: 0000008e EBX: 00000005 ECX: 08070300 EDX: 08070380 15 DS: 002b ESI: 00000000 ES: 002b EDI: 00000000 16 SS: 002b ESP: bffffadc EBP: bffffb0c 17 CS: 0023 EIP: 402259ee ERR: 0000008e EFLAGS: 00000246 18 19 PID: 557 TASK: c5600000 CPU: 0 COMMAND: \u0026#34;nfsd\u0026#34; 20 #0 [c5601f38] schedule at c01135f6 21 (void) 22 #1 [c5601f90] schedule_timeout at c01131ff 23 (c5600000) 24 #2 [c5601fb8] svc_recv at c805363a 25 (c0096f40, c5602800, 7fffffff, 100, c65c9f1c) 26 #3 [c5601fec] (nfsd module) at c806e303 27 (c5602800, c5602800, c0096f40, 6c6e0002, 50) 28 #4 [c65c9f24] kernel_thread at c010834f 29 (0, 0, ext2_file_inode_operations) 30 31 PID: 824 TASK: c7c84000 CPU: 0 COMMAND: \u0026#34;mingetty\u0026#34; 32 ... 33 34 Display the task_struct structure for each \u0026#34;bash\u0026#34; command: 35 36 crash\u0026gt; foreach bash task 37 ... 38 39 Display the open files for all tasks: 40 41 crash\u0026gt; foreach files 42 ... 43 44 Display the state of tasks whose name contains a match to \u0026#34;event.*\u0026#34;: 45 46 crash\u0026gt; foreach \u0026#39;event.*\u0026#39; task -R state 47 PID: 99 TASK: ffff8804750d5500 CPU: 0 COMMAND: \u0026#34;events/0\u0026#34; 48 state = 1, 49 50 PID: 100 TASK: ffff8804750d4ac0 CPU: 1 COMMAND: \u0026#34;events/1\u0026#34; 51 state = 1, 52 53 PID: 101 TASK: ffff8804750d4080 CPU: 2 COMMAND: \u0026#34;events/2\u0026#34; 54 state = 1, 55 ... 56 57 Display the stack traces for all blocked (TASK_UNINTERRUPTIBLE) tasks: 58 59 crash\u0026gt; foreach UN bt 60 PID: 428 TASK: ffff880036b6c560 CPU: 1 COMMAND: \u0026#34;jbd2/dm-1-8\u0026#34; 61 #0 [ffff880035779a70] __schedule at ffffffff815df272 62 #1 [ffff880035779b08] schedule at ffffffff815dfacf 63 #2 [ffff880035779b18] io_schedule at ffffffff815dfb7f 64 #3 [ffff880035779b38] sleep_on_page at ffffffff81119a4e 65 #4 [ffff880035779b48] __wait_on_bit at ffffffff815e039f 66 #5 [ffff880035779b98] wait_on_page_bit at ffffffff81119bb8 67 #6 [ffff880035779be8] filemap_fdatawait_range at ffffffff81119ccc 68 #7 [ffff880035779cd8] filemap_fdatawait at ffffffff81119d8b 69 #8 [ffff880035779ce8] jbd2_journal_commit_transaction at ffffffff8123a99c 70 #9 [ffff880035779e58] kjournald2 at ffffffff8123ee7b 71 #10 [ffff880035779ee8] kthread at ffffffff8108fb9c 72 #11 [ffff880035779f48] kernel_thread_helper at ffffffff815ebaf4 73 ... 14. fuser - file users 14.1. SYNOPSIS 1fuser [pathname | inode] 14.2. DESCRIPTION 1 This command displays the tasks using specified files or sockets. 2 Tasks will be listed that reference the file as the current working 3 directory, root directory, an open file descriptor, or that mmap the 4 file. If the file is held open in the kernel by the lockd server on 5 behalf of a client discretionary file lock, the client hostname is 6 listed. 7 8 pathname the full pathname of the file. 9 inode the hexadecimal inode address for the file. 14.3. EXAMPLES 1 Display the tasks using file /usr/lib/libkfm.so.2.0.0 2 3 crash\u0026gt; fuser /usr/lib/libkfm.so.2.0.0 4 PID TASK COMM USAGE 5 779 c5e82000 \u0026#34;kwm\u0026#34; mmap 6 808 c5a8e000 \u0026#34;krootwm\u0026#34; mmap 7 806 c5b42000 \u0026#34;kfm\u0026#34; mmap 8 809 c5dde000 \u0026#34;kpanel\u0026#34; mmap 15. gdb - gdb command 15.1. SYNOPSIS 1gdb command ... 15.2. DESCRIPTION 1 This command passes its arguments directly to gdb for processing. 2 This is typically not necessary, but where ambiguities between crash and 3 gdb command names exist, this will force the command to be executed by gdb. 4 5 Alternatively, if \u0026#34;set gdb on\u0026#34; is entered, the session will be run in a 6 mode where all commands are passed directly to gdb. When running in that 7 mode, native crash commands may be executed by preceding them with the 8 \u0026#34;crash\u0026#34; directive. To restore native crash mode, enter \u0026#34;set gdb off\u0026#34;. 15.3. EXAMPLES 1 crash\u0026gt; gdb help 2 List of classes of commands: 3 4 aliases -- Aliases of other commands 5 breakpoints -- Making program stop at certain points 6 data -- Examining data 7 files -- Specifying and examining files 8 internals -- Maintenance commands 9 obscure -- Obscure features 10 running -- Running the program 11 stack -- Examining the stack 12 status -- Status inquiries 13 support -- Support facilities 14 tracepoints -- Tracing of program execution without stopping the program 15 user-defined -- User-defined commands 16 17 Type \u0026#34;help\u0026#34; followed by a class name for a list of commands in that class. 18 Type \u0026#34;help\u0026#34; followed by command name for full documentation. 19 Command name abbreviations are allowed if unambiguous. 16. help - get help 16.1. SYNOPSIS 1help [command | all] [-\u0026lt;option\u0026gt;] 16.2. DESCRIPTION 1 When entered with no argument, a list of all currently available crash 2 commands is listed. If a name of a crash command is entered, a man-like 3 page for the command is displayed. If \u0026#34;all\u0026#34; is entered, help pages 4 for all commands will be displayed. If neither of the above is entered, 5 the argument string will be passed on to the gdb help command. 6 7 A number of internal debug, statistical, and other dumpfile related 8 data is available with the following options: 9 10 -a - alias data 11 -b - shared buffer data 12 -B - build data 13 -c - numargs cache 14 -d - device table 15 -D - dumpfile contents/statistics 16 -e - extension table data 17 -f - filesys table 18 -g - gdb data 19 -h - hash_table data 20 -H - hash_table data (verbose) 21 -k - kernel_table 22 -K - kernel_table (verbose) 23 -L - LKCD page cache environment 24 -M \u0026lt;num\u0026gt; machine specific 25 -m - machdep_table 26 -N - net_table 27 -n - dumpfile contents/statistics 28 -o - offset_table and size_table 29 -p - program_context 30 -r - dump registers from dumpfile header 31 -s - symbol table data 32 -t - task_table 33 -T - task_table plus context_array 34 -v - vm_table 35 -V - vm_table (verbose) 36 -x - text cache 37 -z - help options 17. ipcs - System V IPC facilities 17.1. SYNOPSIS 1ipcs [-smMq] [-n pid|task] [id | addr] 17.2. DESCRIPTION 1 This command provides information on the System V IPC facilities. With no 2 arguments, the command will display kernel usage of all three factilities. 3 4 -s show semaphore arrays. 5 -m show shared memory segments. 6 -M show shared memory segments with additional details. 7 -q show message queues. 8 id show the data associated with this resource ID. 9 addr show the data associated with this virtual address of a 10 shmid_kernel, sem_array or msq_queue. 11 12 For kernels supporting namespaces, the -n option may be used to 13 display the IPC facilities with respect to the namespace of a 14 specified task: 15 16 -n pid a process PID. 17 -n task a hexadecimal task_struct pointer. 17.3. EXAMPLES 1 Display all IPC facilities: 2 3 crash\u0026gt; ipcs 4 SHMID_KERNEL KEY SHMID UID PERMS BYTES NATTCH STATUS 5 ffff880473a28310 00000000 0 0 666 90000 1 6 ffff880473a28490 00000001 32769 0 666 90000 1 7 ffff880473a28250 00000002 65538 0 666 90000 1 8 9 SEM_ARRAY KEY SEMID UID PERMS NSEMS 10 ffff88047200f9d0 00000000 0 0 600 1 11 ffff88046f826910 00000000 32769 0 600 1 12 13 MSG_QUEUE KEY MSQID UID PERMS USED-BYTES MESSAGES 14 ffff8100036bb8d0 000079d7 0 3369 666 16640 104 15 ffff8100036bb3d0 000079d8 32769 3369 666 12960 81 16 ffff810026d751d0 000079d9 65538 3369 666 10880 68 17 18 Display shared memory usage with detailed information: 19 20 crash\u0026gt; ipcs -M 21 SHMID_KERNEL KEY SHMID UID PERMS BYTES NATTCH STATUS 22 ffff880473a28310 00000000 0 0 666 90000 1 23 PAGES ALLOCATED/RESIDENT/SWAPPED: 22/1/0 24 INODE: ffff88047239cd98 25 26 SHMID_KERNEL KEY SHMID UID PERMS BYTES NATTCH STATUS 27 ffff880473a28490 00000001 32769 0 666 90000 1 28 PAGES ALLOCATED/RESIDENT/SWAPPED: 22/1/0 29 INODE: ffff88047239c118 30 31 SHMID_KERNEL KEY SHMID UID PERMS BYTES NATTCH STATUS 32 ffff880473a28250 00000002 65538 0 666 90000 1 33 PAGES ALLOCATED/RESIDENT/SWAPPED: 22/1/0 34 INODE: ffff880470503758 35 36 Display the shared memory data associated with shmid_kernel ffff880473a28250: 37 38 crash\u0026gt; ipcs -M ffff880473a28250 39 SHMID_KERNEL KEY SHMID UID PERMS BYTES NATTCH STATUS 40 ffff880473a28250 00000002 65538 0 666 90000 1 41 PAGES ALLOCATED/RESIDENT/SWAPPED: 22/1/0 42 INODE: ffff880470503758 18. irq - IRQ data 18.1. SYNOPSIS 1irq [[[index ...] | -u ] | -d | -b | -a | -s [-c cpu]] 18.2. DESCRIPTION 1 This command collaborates the data in an irq_desc_t, along with its 2 associated hw_interrupt_type and irqaction structure data, into a 3 consolidated per-IRQ display. For kernel versions 2.6.37 and later 4 the display consists of the irq_desc/irq_data address, its irqaction 5 address(es), and the irqaction name strings. Alternatively, the 6 intel interrupt descriptor table, bottom half data, cpu affinity for 7 in-use irqs, or kernel irq stats may be displayed. If no index value 8 argument(s) nor any options are entered, the IRQ data for all IRQs will 9 be displayed. 10 11 index a valid IRQ index. 12 -u dump data for in-use IRQs only. 13 -d dump the intel interrupt descriptor table. 14 -b dump bottom half data. 15 -a dump cpu affinity for in-use IRQs. 16 -s dump the kernel irq stats; if no cpu specified with -c, the 17 irq stats of all cpus will be displayed. 18 -c cpu only usable with the -s option, dump the irq stats of the 19 specified cpu[s]; cpu can be specified as \u0026#34;1,3,5\u0026#34;, \u0026#34;1-3\u0026#34;, 20 \u0026#34;1,3,5-7,10\u0026#34;, \u0026#34;all\u0026#34;, or \u0026#34;a\u0026#34; (shortcut for \u0026#34;all\u0026#34;). 18.3. EXAMPLES 1 Display the relevant data for IRQ 18 from a pre-2.6.37 kernel: 2 3 crash\u0026gt; irq 18 4 IRQ: 18 5 STATUS: 0 6 HANDLER: c02301e0 \u0026lt;ioapic_level_irq_type\u0026gt; 7 typename: c01f9e0c \u0026#34;IO-APIC-level\u0026#34; 8 startup: c0110234 \u0026lt;unmask_IO_APIC_irq\u0026gt; 9 shutdown: c01101cc \u0026lt;mask_IO_APIC_irq\u0026gt; 10 handle: c0110518 \u0026lt;do_level_ioapic_IRQ\u0026gt; 11 enable: c0110234 \u0026lt;unmask_IO_APIC_irq\u0026gt; 12 disable: c01101cc \u0026lt;mask_IO_APIC_irq\u0026gt; 13 ACTION: c009c6b0 14 handler: c01ce818 \u0026lt;do_aic7xxx_isr\u0026gt; 15 flags: 4000000 (SA_SHIRQ) 16 mask: 0 17 name: c0217780 \u0026#34;aic7xxx\u0026#34; 18 dev_id: c0090078 19 next: c009c770 20 ACTION: c009c770 21 handler: c01ce818 \u0026lt;do_aic7xxx_isr\u0026gt; 22 flags: 4000000 (SA_SHIRQ) 23 mask: 0 24 name: c0217780 \u0026#34;aic7xxx\u0026#34; 25 dev_id: c0091078 26 next: 0 27 DEPTH: 0 28 29 Display the relevant data for IRQ 21 from a 2.6.37 kernel: 30 31 crash\u0026gt; irq 21 32 IRQ IRQ_DESC/_DATA IRQACTION NAME 33 21 ffff88003787f780 ffff8800379a8b40 \u0026#34;ehci_hcd:usb2\u0026#34; 34 ffff8800379cbac0 \u0026#34;uhci_hcd:usb5\u0026#34; 35 ffff8800379cb140 \u0026#34;uhci_hcd:usb7\u0026#34; 36 37 Display the intel interrupt descriptor table entries: 38 39 crash\u0026gt; irq -d 40 [0] divide_error 41 [1] debug 42 [2] nmi 43 [3] int3 44 [4] overflow 45 [5] bounds 46 [6] invalid_op 47 [7] device_not_available 48 [8] double_fault 49 [9] coprocessor_segment_overrun 50 [10] invalid_TSS 51 [11] segment_not_present 52 [12] stack_segment 53 [13] general_protection 54 [14] page_fault 55 [15] spurious_interrupt_bug 56 [16] coprocessor_error 57 [17] alignment_check 58 [18] ignore_int 59 [19] ignore_int 60 [20] ignore_int 61 [21] ignore_int 62 ... 63 64 [250] IRQ0xda_interrupt 65 [251] IRQ0xdb_interrupt 66 [252] IRQ0xdc_interrupt 67 [253] IRQ0xdd_interrupt 68 [254] IRQ0xde_interrupt 69 [255] spurious_interrupt 70 71 Display the bottom half data: 72 73 crash\u0026gt; irq -b 74 SOFTIRQ_VEC ACTION 75 [0] ffffffff81068f60 \u0026lt;tasklet_hi_action\u0026gt; 76 [1] ffffffff81071b80 \u0026lt;run_timer_softirq\u0026gt; 77 [2] ffffffff813e6f30 \u0026lt;net_tx_action\u0026gt; 78 [3] ffffffff813ee370 \u0026lt;net_rx_action\u0026gt; 79 [4] ffffffff81211a60 \u0026lt;blk_done_softirq\u0026gt; 80 [5] ffffffff812122f0 \u0026lt;blk_iopoll_softirq\u0026gt; 81 [6] ffffffff81069090 \u0026lt;tasklet_action\u0026gt; 82 [7] ffffffff81058830 \u0026lt;run_rebalance_domains\u0026gt; 83 [8] ffffffff81087f00 \u0026lt;run_hrtimer_softirq\u0026gt; 84 [9] ffffffff810ca7a0 \u0026lt;rcu_process_callbacks\u0026gt; 85 86 Display the cpu affinity for in-use IRQs: 87 88 crash\u0026gt; irq -a 89 IRQ NAME AFFINITY 90 0 timer 0-23 91 1 i8042 0-23 92 8 rtc0 0-23 93 9 acpi 0-23 94 16 ehci_hcd:usb2,uhci_hcd:usb3,uhci_hcd:usb6 0,6,18 95 17 uhci_hcd:usb4,uhci_hcd:usb7 0-23 96 18 ehci_hcd:usb1,uhci_hcd:usb5,uhci_hcd:usb8,ioc0 0,11,23 97 24 dmar0 0 98 35 pciehp 0-23 99 36 pciehp 0-23 100 37 pciehp 0-23 101 38 pciehp 0-23 102 39 megasas 0-5,12-17 103 40 lpfc:sp 0-5,12-17 104 41 lpfc:fp 0,6-11,18-23 105 42 lpfc:sp 0,6-11,18-23 106 43 lpfc:fp 0,6-11,18-23 107 ... 108 109 80 ioat-msix 0-23 110 81 ioat-msix 0-23 111 82 ioat-msix 0-23 112 83 ioat-msix 0-23 113 84 ioat-msix 0-23 114 85 ioat-msix 0-23 115 86 ioat-msix 0-23 116 87 ioat-msix 0-23 117 88 eth4 0,17 118 119 Display the kernel irq stats: 120 121 crash\u0026gt;irq -c 0,2 -s 122 CPU0 CPU2 123 0: 2068161471 0 IR-IO-APIC-edge timer 124 1: 9 0 IR-IO-APIC-edge i8042 125 8: 1 0 IR-IO-APIC-edge rtc0 126 9: 0 0 IR-IO-APIC-fasteoi acpi 127 16: 36 0 IR-IO-APIC-fasteoi ehci_hcd:usb2 128 ... 129 130 85: 3 0 IR-PCI-MSI-edge ioat-msix 131 86: 3 0 IR-PCI-MSI-edge ioat-msix 132 87: 3 0 IR-PCI-MSI-edge ioat-msix 133 88: 24 295 IR-PCI-MSI-edge eth4 19. kmem - kernel memory 19.1. SYNOPSIS 1kmem [-f|-F|-c|-C|-i|-v|-V|-n|-z|-o|-h] [-p | -m member[,member]] 2 [[-s|-S|-r] [slab] [-I slab[,slab]]] [-g [flags]] [[-P] address]] 19.2. DESCRIPTION 1 This command displays information about the use of kernel memory. 2 3 -f displays the contents of the system free memory headers. 4 also verifies that the page count equals nr_free_pages. 5 -F same as -f, but also dumps all pages linked to that header. 6 -c walks through the page_hash_table and verifies page_cache_size. 7 -C same as -c, but also dumps all pages in the page_hash_table. 8 -i displays general memory usage information 9 -v displays the mapped virtual memory regions allocated by vmalloc(). 10 -V displays the kernel vm_stat table if it exists, or in more recent 11 kernels, the vm_zone_stat, vm_node_stat and vm_numa_stat tables, 12 the cumulative page_states counter values if they exist, and/or 13 the cumulative, vm_event_states counter values if they exist. 14 -n display memory node, memory section, and memory block data 15 and state; the state of each memory section state is encoded 16 as \u0026#34;P\u0026#34;, \u0026#34;M\u0026#34;, \u0026#34;O\u0026#34; and/or \u0026#34;E\u0026#34;, meaning SECTION_MARKED_PRESENT, 17 SECTION_HAS_MEM_MAP, SECTION_IS_ONLINE and SECTION_IS_EARLY. 18 -z displays per-zone memory statistics. 19 -o displays each cpu\u0026#39;s offset value that is added to per-cpu symbol 20 values to translate them into kernel virtual addresses. 21 -h display the address of hugepage hstate array entries, along with 22 their hugepage size, total and free counts, and name. 23 -p displays basic information about each page structure in the system 24 mem_map[] array, made up of the page struct address, its associated 25 physical address, the page.mapping, page.index, page._count and 26 page.flags fields. 27 -m member similar to -p, but displays page structure contents specified by 28 a comma-separated list of one or more struct page members. The 29 \u0026#34;flags\u0026#34; member will always be expressed in hexadecimal format, and 30 the \u0026#34;_count\u0026#34; and \u0026#34;_mapcount\u0026#34; members will always be expressed 31 in decimal format. Otherwise, all other members will be displayed 32 in hexadecimal format unless the output radix is 10 and the member 33 is a signed/unsigned integer. Members that are data structures may 34 be specified either by the data structure\u0026#39;s member name, or expanded 35 to specify a member of the data structure. For example, \u0026#34;-m lru\u0026#34; 36 refers to a list_head data structure, and both the list_head.next 37 and list_head.prev pointer values will be displayed, whereas if 38 \u0026#34;-m lru.next\u0026#34; is specified, just the list_head.next value will 39 be displayed. 40 -s displays basic kmalloc() slab data. 41 -S displays all kmalloc() slab data, including all slab objects, 42 and whether each object is in use or is free. If CONFIG_SLUB, 43 slab data for each per-cpu slab is displayed, along with the 44 address of each kmem_cache_node, its count of full and partial 45 slabs, and a list of all tracked slabs. 46 -r displays the accumulated basic kmalloc() slab data of each 47 root slab cache and its children. The kernel must contain the 48 \u0026#34;slab_root_caches\u0026#34; list_head. (currently only available if 49 CONFIG_SLUB) 50 slab when used with -s, -S or -r, limits the command to only the slab 51 cache of name \u0026#34;slab\u0026#34;. If the slab argument is \u0026#34;list\u0026#34;, then 52 all slab cache names and addresses are listed. 53 -I slab when used with -s, -S or -r, one or more slab cache names in a 54 comma-separated list may be specified as slab caches to ignore. 55 -g displays the enumerator value of all bits in the page structure\u0026#39;s 56 \u0026#34;flags\u0026#34; field. 57 flags when used with -g, translates all bits in this hexadecimal page 58 structure flags value into its enumerator values. 59 -P declares that the following address argument is a physical address. 60 address when used without any flag, the address can be a kernel virtual, 61 or physical address; a search is made through the symbol table, 62 the kmalloc() slab subsystem, the free list, the page_hash_table, 63 the vmalloc() region subsystem, the current set of task_structs 64 and kernel stacks, and the mem_map array. If found in any of 65 those areas, the information will be dumped in the same manner as 66 if the location-specific flags were used; if contained within a 67 curent task_struct or kernel stack, that task\u0026#39;s context will be 68 displayed. 69 address when used with -s or -S, searches the kmalloc() slab subsystem 70 for the slab containing of this virtual address, showing whether 71 it is in use or free. 72 address when used with -f, the address can be either a page pointer, 73 a physical address, or a kernel virtual address; the free_area 74 header containing the page (if any) is displayed. 75 address when used with -p, the address can be either a page pointer, a 76 physical address, or a kernel virtual address; its basic mem_map 77 page information is displayed. 78 address when used with -m, the address can be either a page pointer, a 79 physical address, or a kernel virtual address; the specified 80 members of the associated page struct are displayed. 81 address when used with -c, the address must be a page pointer address; 82 the page_hash_table entry containing the page is displayed. 83 address when used with -l, the address must be a page pointer address; 84 the page address is displayed if it is contained with the list. 85 address when used with -v, the address can be a mapped kernel virtual 86 address or physical address; the mapped region containing the 87 address is displayed. 88 89 All address arguments above must be expressed in hexadecimal format. 19.3. EXAMPLES 1 Display memory usage information: 2 3 crash\u0026gt; kmem -i 4 PAGES TOTAL PERCENTAGE 5 TOTAL MEM 1974231 7.5 GB ---- 6 FREE 208962 816.3 MB 10% of TOTAL MEM 7 USED 1765269 6.7 GB 89% of TOTAL MEM 8 SHARED 365066 1.4 GB 18% of TOTAL MEM 9 BUFFERS 111376 435.1 MB 5% of TOTAL MEM 10 CACHED 1276196 4.9 GB 64% of TOTAL MEM 11 SLAB 120410 470.4 MB 6% of TOTAL MEM 12 13 TOTAL HUGE 524288 2 GB ---- 14 HUGE FREE 524288 2 GB 100% of TOTAL HUGE 15 16 TOTAL SWAP 2498559 9.5 GB ---- 17 SWAP USED 81978 320.2 MB 3% of TOTAL SWAP 18 SWAP FREE 2416581 9.2 GB 96% of TOTAL SWAP 19 20 COMMIT LIMIT 3485674 13.3 GB ---- 21 COMMITTED 850651 3.2 GB 24% of TOTAL LIMIT 22 23 Display and verify free memory data: 24 25 crash\u0026gt; kmem -f 26 NODE 27 0 28 ZONE NAME SIZE FREE MEM_MAP START_PADDR START_MAPNR 29 0 DMA 4096 3372 c4000040 0 0 30 AREA SIZE FREE_AREA_STRUCT BLOCKS PAGES 31 0 4k c02eb004 2 2 32 1 8k c02eb010 3 6 33 2 16k c02eb01c 5 20 34 3 32k c02eb028 4 32 35 4 64k c02eb034 5 80 36 5 128k c02eb040 3 96 37 6 256k c02eb04c 3 192 38 7 512k c02eb058 1 128 39 8 1024k c02eb064 1 256 40 9 2048k c02eb070 5 2560 41 42 ZONE NAME SIZE FREE MEM_MAP START_PADDR START_MAPNR 43 1 Normal 225280 202269 c4044040 1000000 4096 44 AREA SIZE FREE_AREA_STRUCT BLOCKS PAGES 45 0 4k c02eb0b8 1 1 46 1 8k c02eb0c4 2 4 47 2 16k c02eb0d0 0 0 48 3 32k c02eb0dc 1 8 49 4 64k c02eb0e8 1 16 50 5 128k c02eb0f4 0 0 51 6 256k c02eb100 0 0 52 7 512k c02eb10c 0 0 53 8 1024k c02eb118 0 0 54 9 2048k c02eb124 395 202240 55 56 ZONE NAME SIZE FREE MEM_MAP START_PADDR START_MAPNR 57 2 HighMem 819200 748686 c4ee0040 38000000 229376 58 AREA SIZE FREE_AREA_STRUCT BLOCKS PAGES 59 0 4k c02eb16c 10 10 60 1 8k c02eb178 2 4 61 2 16k c02eb184 0 0 62 3 32k c02eb190 2 16 63 4 64k c02eb19c 1 16 64 5 128k c02eb1a8 1 32 65 6 256k c02eb1b4 1 64 66 7 512k c02eb1c0 0 0 67 8 1024k c02eb1cc 0 0 68 9 2048k c02eb1d8 1462 748544 69 70 nr_free_pages: 954327 (verified) 71 72 Dump all the base addresses of each free memory area from above: 73 74 crash\u0026gt; kmem -F 75 NODE 76 0 77 ZONE NAME SIZE FREE MEM_MAP START_PADDR START_MAPNR 78 0 DMA 4096 3372 c4000040 0 0 79 AREA SIZE FREE_AREA_STRUCT 80 0 4k c02eb004 81 c400ded8 82 c4042528 83 AREA SIZE FREE_AREA_STRUCT 84 1 8k c02eb010 85 c400de50 86 c400cee8 87 c40424a0 88 AREA SIZE FREE_AREA_STRUCT 89 2 16k c02eb01c 90 c400dd40 91 c400cf70 92 c40425b0 93 c400f7d0 94 c40028a0 95 AREA SIZE FREE_AREA_STRUCT 96 3 32k c02eb028 97 c4042280 98 c400f8e0 99 c4002680 100 c4000260 101 AREA SIZE FREE_AREA_STRUCT 102 4 64k c02eb034 103 c400d080 104 c4041e40 105 ... 106 107 Dump the mem_map[] array: 108 109 crash\u0026gt; kmem -p 110 PAGE PHYSICAL MAPPING INDEX CNT FLAGS 111 f5c51200 10000 0 0 1 80 slab 112 f5c51220 11000 0 0 1 80 slab 113 f5c51240 12000 0 0 1 80 slab 114 f5c51260 13000 0 0 1 80 slab 115 f5c51280 14000 0 0 1 80 slab 116 f5c512a0 15000 0 0 1 80 slab 117 f5c512c0 16000 0 0 1 80 slab 118 f5c512e0 17000 0 0 1 80 slab 119 f5c51300 18000 0 0 1 80 slab 120 f5c51320 19000 0 0 1 80 slab 121 f5c51340 1a000 0 0 1 80 slab 122 f5c51360 1b000 0 0 1 80 slab 123 f5c51380 1c000 e6c6a754 13b67 2 868 uptodate,lru,active,private 124 f5c513a0 1d000 0 0 1 80 slab 125 f5c513c0 1e000 0 0 1 80 slab 126 f5c513e0 1f000 0 0 1 80 slab 127 f5c51400 20000 e6c6a754 13bbb 2 868 uptodate,lru,active,private 128 f5c51420 21000 0 0 1 80 slab 129 f5c51440 22000 0 0 1 80 slab 130 ... 131 132 Display the \u0026#34;page.lru\u0026#34; list_head structure member in each page: 133 134 crash\u0026gt; kmem -m lru 135 PAGE lru 136 ffffea0000000000 0000000000000000,0000000000000000 137 ffffea0000000040 ffffea0000000060,ffffea0000000060 138 ffffea0000000080 ffffea00000000a0,ffffea00000000a0 139 ffffea00000000c0 ffffea00000000e0,ffffea00000000e0 140 ffffea0000000100 ffffea0000000120,ffffea0000000120 141 ffffea0000000140 ffffea0000000160,ffffea0000000160 142 ffffea0000000180 ffffea00000001a0,ffffea00000001a0 143 ffffea00000001c0 ffffea00000001e0,ffffea00000001e0 144 ffffea0000000200 ffffea0000000220,ffffea0000000220 145 ffffea0000000240 ffffea0000000260,ffffea0000000260 146 ffffea0000000280 ffffea00000002a0,ffffea00000002a0 147 ffffea00000002c0 ffffea00000002e0,ffffea00000002e0 148 ffffea0000000300 ffffea0000000320,ffffea0000000320 149 ffffea0000000340 ffffea0000000360,ffffea0000000360 150 ffffea0000000380 ffffea00000003a0,ffffea00000003a0 151 ffffea00000003c0 ffffea00000003e0,ffffea00000003e0 152 ffffea0000000400 ffff88021e5e41e8,ffffea0000002020 153 ffffea0000000440 dead000000100100,dead000000200200 154 ffffea0000000480 dead000000100100,dead000000200200 155 ffffea00000004c0 dead000000100100,dead000000200200 156 ... 157 158 Find the two pages that link to the page at ffffea0001dafb20 159 via their page.lru list_head\u0026#39;s next and prev pointers: 160 161 crash\u0026gt; kmem -m lru | grep ffffea0001dafb20 162 ffffea000006b500 ffffea0001dafb20,ffffea0001eb4520 163 ffffea0000127d80 ffffea000152b620,ffffea0001dafb20 164 165 Find all of the combined slab/page structures that are used by 166 the kmalloc-8192 slab cache: 167 168 crash\u0026gt; kmem -s kmalloc-8192 169 CACHE OBJSIZE ALLOCATED TOTAL SLABS SSIZE NAME 170 ffff880215802e00 8192 65 80 20 32k kmalloc-8192 171 crash\u0026gt; kmem -m slab_cache | grep ffff880215802e00 172 ffffea0004117800 ffff880215802e00 173 ffffea00041ca600 ffff880215802e00 174 ffffea00044ab200 ffff880215802e00 175 ffffea0004524000 ffff880215802e00 176 ffffea0004591600 ffff880215802e00 177 ffffea00047eac00 ffff880215802e00 178 ffffea0004875800 ffff880215802e00 179 ffffea0008357a00 ffff880215802e00 180 ffffea0008362a00 ffff880215802e00 181 ffffea00083b9400 ffff880215802e00 182 ffffea00083c1000 ffff880215802e00 183 ffffea00083c1e00 ffff880215802e00 184 ffffea00083c2000 ffff880215802e00 185 ffffea00083c2a00 ffff880215802e00 186 ffffea00083d2000 ffff880215802e00 187 ffffea00083d3e00 ffff880215802e00 188 ffffea0008407c00 ffff880215802e00 189 ffffea000848ce00 ffff880215802e00 190 ffffea0008491800 ffff880215802e00 191 ffffea00084bf800 ffff880215802e00 192 193 Use the commands above with a page pointer or a physical address argument: 194 195 crash\u0026gt; kmem -f c40425b0 196 NODE 197 0 198 ZONE NAME SIZE FREE MEM_MAP START_PADDR START_MAPNR 199 0 DMA 4096 3372 c4000040 0 0 200 AREA SIZE FREE_AREA_STRUCT 201 2 16k c02eb01c 202 c40425b0 (c40425b0 is 1st of 4 pages) 203 204 crash\u0026gt; kmem -p c25a9c00 205 PAGE PHYSICAL MAPPING INDEX CNT FLAGS 206 c25a9c00 1fe0000 f429d2e4 21fe3eb 2 800828 uptodate,lru,private 207 208 crash\u0026gt; kmem -p 1fe0000 209 PAGE PHYSICAL MAPPING INDEX CNT FLAGS 210 c25a9c00 1fe0000 f429d2e4 21fe3eb 2 800828 uptodate,lru,private 211 212 Display the mapped memory regions allocated by vmalloc(): 213 214 crash\u0026gt; kmem -v 215 VMAP_AREA VM_STRUCT ADDRESS RANGE SIZE 216 f7048e00 f7048e40 f7dfe000 - f7e00000 8192 217 f7048ec0 f7048f00 f7e00000 - f7e05000 20480 218 f7151fc0 f7159540 f7e06000 - f7e08000 8192 219 f704da80 f704dac0 f7e0a000 - f7e0c000 8192 220 f704d980 f704d9c0 f7e0e000 - f7e10000 8192 221 f724f1c0 f724f200 f7e12000 - f7e14000 8192 222 f704d840 f704d880 f7e14000 - f7e17000 12288 223 f704d400 f704d440 f7e18000 - f7e1d000 20480 224 f73f5840 f73f5880 f7e1e000 - f7e2a000 49152 225 f6334480 f63344c0 f7e2c000 - f7e2e000 8192 226 f635d600 f635d640 f7e4a000 - f7e5b000 69632 227 f41b4700 f5771a40 f7e6e000 - f7e70000 8192 228 f622f6c0 f622f700 f7e71000 - f7e79000 32768 229 f63a9f00 f63a9f40 f7e84000 - f7e87000 12288 230 f63a9d00 f63a9d40 f7e8f000 - f7e91000 8192 231 f5546480 f39db800 f7eb8000 - f7ec2000 40960 232 f5ce9640 f5777e80 f7ec6000 - f7ed1000 45056 233 f63a9b00 f63a9b40 f7ed1000 - f7efd000 180224 234 f63a9800 f63a9840 f7f1d000 - f7f26000 36864 235 f63a9640 f63a9880 f7f43000 - f7f52000 61440 236 f5771f00 f4183840 f7f53000 - f7f64000 69632 237 f5ce9a00 f30c4a00 f7fcf000 - f801e000 323584 238 f63a93c0 f63a9400 f805d000 - f8132000 872448 239 f63a91c0 f63a95c0 f814b000 - f8150000 20480 240 f63a9140 f63a9180 f8151000 - f8352000 2101248 241 f624eb00 f624eb40 f8353000 - f8355000 8192 242 f563eb40 f563eb80 f8356000 - f835e000 32768 243 f63d5ec0 f63d5f00 f8360000 - f8371000 69632 244 f63d5cc0 f6287b80 f83c2000 - f84c3000 1052672 245 ... 246 247 Dump the virtual memory statistics: 248 249 crash\u0026gt; kmem -V 250 VM_ZONE_STAT: 251 NR_FREE_PAGES: 30085 252 NR_ZONE_INACTIVE_ANON: 1985 253 NR_ZONE_ACTIVE_ANON: 338275 254 NR_ZONE_INACTIVE_FILE: 19760 255 NR_ZONE_ACTIVE_FILE: 12018 256 NR_ZONE_UNEVICTABLE: 0 257 NR_ZONE_WRITE_PENDING: 4 258 NR_MLOCK: 0 259 NR_PAGETABLE: 1562 260 NR_KERNEL_STACK_KB: 1728 261 NR_BOUNCE: 0 262 NR_FREE_CMA_PAGES: 0 263 264 VM_NODE_STAT: 265 NR_INACTIVE_ANON: 1985 266 NR_ACTIVE_ANON: 338275 267 NR_INACTIVE_FILE: 19760 268 NR_ACTIVE_FILE: 12018 269 NR_UNEVICTABLE: 0 270 NR_SLAB_RECLAIMABLE: 3111 271 NR_SLAB_UNRECLAIMABLE: 3039 272 NR_ISOLATED_ANON: 0 273 NR_ISOLATED_FILE: 0 274 WORKINGSET_REFAULT: 0 275 WORKINGSET_ACTIVATE: 0 276 WORKINGSET_NODERECLAIM: 0 277 NR_ANON_MAPPED: 338089 278 NR_FILE_MAPPED: 8102 279 NR_FILE_PAGES: 33949 280 NR_FILE_DIRTY: 4 281 NR_WRITEBACK: 0 282 NR_WRITEBACK_TEMP: 0 283 NR_SHMEM: 2171 284 NR_SHMEM_THPS: 0 285 NR_SHMEM_PMDMAPPED: 0 286 NR_ANON_THPS: 86 287 NR_UNSTABLE_NFS: 0 288 NR_VMSCAN_WRITE: 0 289 NR_VMSCAN_IMMEDIATE: 0 290 NR_DIRTIED: 155 291 NR_WRITTEN: 75 292 293 VM_NUMA_STAT: 294 NUMA_HIT: 575409 295 NUMA_MISS: 0 296 NUMA_FOREIGN: 0 297 NUMA_INTERLEAVE_HIT: 12930 298 NUMA_LOCAL: 575409 299 NUMA_OTHER: 0 300 301 VM_EVENT_STATES: 302 PGPGIN: 282492 303 PGPGOUT: 6773 304 PSWPIN: 0 305 PSWPOUT: 0 306 PGALLOC_DMA: 0 307 PGALLOC_DMA32: 693092 308 PGALLOC_NORMAL: 0 309 ... 310 311 Display hugepage hstate information: 312 313 crash\u0026gt; kmem -h 314 HSTATE SIZE FREE TOTAL NAME 315 ffffffff81f7a800 2MB 10 64 hugepages-2048kB 316 317 Determine (and verify) the page cache size: 318 319 crash\u0026gt; kmem -c 320 page_cache_size: 18431 (verified) 321 322 Dump all pages in the page_hash_table: 323 324 crash\u0026gt; kmem -C 325 page_hash_table[0] 326 c0325b40 327 c03a0598 328 c03b4070 329 c0364c28 330 c0357690 331 c02ef338 332 c02d7c60 333 c02c11e0 334 c02a3d70 335 page_hash_table[1] 336 c0394ce8 337 c03c4218 338 c03b4048 339 c0364c00 340 c0357668 341 c02d6e50 342 c02d7dc8 343 c02c0cb8 344 c02db630 345 c02ebad0 346 page_hash_table[2] 347 c037e808 348 c034e248 349 c03b4020 350 c02ec868 351 c03baa60 352 ... 353 page_hash_table[2047] 354 c033a798 355 c0390b48 356 c03b4098 357 c0364890 358 c03576b8 359 c02d2c38 360 c02d7c88 361 c02de5d8 362 363 page_cache_size: 18437 (verified) 364 365 Find the page_hash_table entry containing page c03576b8: 366 367 crash\u0026gt; kmem -c c03576b8 368 page_hash_table[2047] 369 c03576b8 370 371 Display kmalloc() slab data: 372 373 crash\u0026gt; kmem -s 374 CACHE OBJSIZE ALLOCATED TOTAL SLABS SSIZE NAME 375 c02eadc0 232 58 68 4 4k kmem_cache 376 f79c2888 128 0 0 0 4k ip_vs_conn 377 f79c2970 96 0 0 0 4k tcp_tw_bucket 378 f79c2a58 32 12 565 5 4k tcp_bind_bucket 379 f79c2b40 64 0 59 1 4k tcp_open_request 380 f79c2c28 64 1 59 1 4k inet_peer_cache 381 f79c2d10 32 11 339 3 4k ip_fib_hash 382 f79c2df8 160 8 120 5 4k ip_dst_cache 383 f79c2ee0 128 1 30 1 4k arp_cache 384 c8402970 96 30208 37800 945 4k blkdev_requests 385 c8402a58 384 0 0 0 4k nfs_read_data 386 c8402b40 384 0 0 0 4k nfs_write_data 387 c8402c28 96 0 0 0 4k nfs_page 388 c8402d10 20 0 0 0 4k dnotify cache 389 c8402df8 92 3 336 8 4k file lock cache 390 c8402ee0 16 0 0 0 4k fasync cache 391 c84027a0 32 3 339 3 4k uid_cache 392 c84026b8 160 320 624 26 4k skbuff_head_cache 393 c84025d0 832 32 180 20 8k sock 394 c84024e8 132 0 203 7 4k sigqueue 395 c8402400 64 19 472 8 4k cdev_cache 396 c8402318 64 8 236 4 4k bdev_cache 397 c8402230 96 11 120 3 4k mnt_cache 398 c8402148 480 817 848 106 4k inode_cache 399 c8402060 128 1352 1470 49 4k dentry_cache 400 c8403ee0 96 244 440 11 4k filp 401 c8403df8 4096 0 12 12 4k names_cache 402 c8403d10 96 14936 16000 400 4k buffer_head 403 c8403c28 128 25 240 8 4k mm_struct 404 c8403b40 64 393 1298 22 4k vm_area_struct 405 c8403a58 64 30 472 8 4k fs_cache 406 c8403970 416 30 135 15 4k files_cache 407 c8403888 1312 32 99 33 4k signal_act 408 c84037a0 131072 0 0 0 128k size-131072(DMA) 409 c84036b8 131072 1 1 1 128k size-131072 410 c84035d0 65536 0 0 0 64k size-65536(DMA) 411 c84034e8 65536 0 0 0 64k size-65536 412 c8403400 32768 0 0 0 32k size-32768(DMA) 413 c8403318 32768 0 1 1 32k size-32768 414 c8403230 16384 0 0 0 16k size-16384(DMA) 415 c8403148 16384 0 0 0 16k size-16384 416 c8403060 8192 0 0 0 8k size-8192(DMA) 417 c8401ee0 8192 1 2 2 8k size-8192 418 c8401df8 4096 0 0 0 4k size-4096(DMA) 419 c8401d10 4096 30 30 30 4k size-4096 420 c8401c28 2048 0 0 0 4k size-2048(DMA) 421 c8401b40 2048 37 132 66 4k size-2048 422 c8401a58 1024 0 0 0 4k size-1024(DMA) 423 c8401970 1024 301 328 82 4k size-1024 424 c8401888 512 0 0 0 4k size-512(DMA) 425 c84017a0 512 141 168 21 4k size-512 426 c84016b8 256 0 0 0 4k size-256(DMA) 427 c84015d0 256 80 435 29 4k size-256 428 c84014e8 128 0 0 0 4k size-128(DMA) 429 c8401400 128 508 840 28 4k size-128 430 c8401318 64 0 0 0 4k size-64(DMA) 431 c8401230 64 978 1357 23 4k size-64 432 c8401148 32 0 0 0 4k size-32(DMA) 433 c8401060 32 1244 1808 16 4k size-32 434 435 Display all slab data in the \u0026#34;arp_cache\u0026#34; cache: 436 437 crash\u0026gt; kmem -S arp_cache 438 CACHE OBJSIZE ALLOCATED TOTAL SLABS SSIZE NAME 439 f79c2ee0 128 1 30 1 4k arp_cache 440 SLAB MEMORY TOTAL ALLOCATED FREE 441 f729d000 f729d0a0 30 1 29 442 FREE / [ALLOCATED] 443 f729d0a0 (cpu 7 cache) 444 f729d120 (cpu 7 cache) 445 f729d1a0 (cpu 7 cache) 446 f729d220 (cpu 7 cache) 447 f729d2a0 (cpu 7 cache) 448 f729d320 (cpu 7 cache) 449 f729d3a0 (cpu 7 cache) 450 f729d420 (cpu 7 cache) 451 f729d4a0 (cpu 7 cache) 452 f729d520 (cpu 7 cache) 453 f729d5a0 (cpu 7 cache) 454 f729d620 (cpu 7 cache) 455 f729d6a0 (cpu 7 cache) 456 f729d720 (cpu 7 cache) 457 f729d7a0 (cpu 7 cache) 458 f729d820 (cpu 7 cache) 459 f729d8a0 (cpu 7 cache) 460 f729d920 (cpu 7 cache) 461 f729d9a0 (cpu 7 cache) 462 f729da20 (cpu 7 cache) 463 f729daa0 (cpu 7 cache) 464 f729db20 (cpu 7 cache) 465 f729dba0 (cpu 7 cache) 466 f729dc20 (cpu 7 cache) 467 f729dca0 (cpu 7 cache) 468 f729dd20 (cpu 7 cache) 469 f729dda0 (cpu 7 cache) 470 f729de20 (cpu 7 cache) 471 f729dea0 (cpu 3 cache) 472 [f729df20] 473 474 Search the kmalloc() slab subsystem for address c3fbdb60: 475 476 crash\u0026gt; kmem -s c3fbdb60 477 CACHE OBJSIZE ALLOCATED TOTAL SLABS SSIZE NAME 478 c8402970 96 30208 37800 945 4k blkdev_requests 479 SLAB MEMORY TOTAL ALLOCATED FREE 480 c3fbd020 c3fbd0e0 40 40 0 481 FREE / [ALLOCATED] 482 [c3fbdb60] 483 484 Make a generic search (no flags) for the same address c3fbdb60: 485 486 crash\u0026gt; kmem c3fbdb60 487 CACHE OBJSIZE ALLOCATED TOTAL SLABS SSIZE NAME 488 c8402970 96 30208 37800 945 4k blkdev_requests 489 SLAB MEMORY TOTAL ALLOCATED FREE 490 c3fbd020 c3fbd0e0 40 40 0 491 FREE / [ALLOCATED] 492 [c3fbdb60] 493 494 PAGE PHYSICAL MAPPING INDEX CNT FLAGS 495 c410ee74 3fbd000 0 0 1 slab 496 497 Display memory node data (if supported): 498 499 crash\u0026gt; kmem -n 500 NODE SIZE PGLIST_DATA BOOTMEM_DATA NODE_ZONES 501 0 262095 ffff88003d52a000 ---- ffff88003d52a000 502 ffff88003d52a740 503 ffff88003d52ae80 504 ffff88003d52b5c0 505 MEM_MAP START_PADDR START_MAPNR 506 ffffea0000000040 1000 1 507 508 ZONE NAME SIZE MEM_MAP START_PADDR START_MAPNR 509 0 DMA 4095 ffffea0000000040 1000 1 510 1 DMA32 258000 ffffea0000040000 1000000 4096 511 2 Normal 0 0 0 0 512 3 Movable 0 0 0 0 513 514 ------------------------------------------------------------------- 515 516 NR SECTION CODED_MEM_MAP MEM_MAP STATE PFN 517 0 ffff88003d4d9000 ffffea0000000000 ffffea0000000000 PM 0 518 1 ffff88003d4d9020 ffffea0000000000 ffffea0000200000 PM 32768 519 2 ffff88003d4d9040 ffffea0000000000 ffffea0000400000 PM 65536 520 3 ffff88003d4d9060 ffffea0000000000 ffffea0000600000 PM 98304 521 4 ffff88003d4d9080 ffffea0000000000 ffffea0000800000 PM 131072 522 5 ffff88003d4d90a0 ffffea0000000000 ffffea0000a00000 PM 163840 523 6 ffff88003d4d90c0 ffffea0000000000 ffffea0000c00000 PM 196608 524 7 ffff88003d4d90e0 ffffea0000000000 ffffea0000e00000 PM 229376 525 526 MEM_BLOCK NAME PHYSICAL RANGE STATE START_SECTION_NO 527 ffff88003a707c00 memory0 0 - 7ffffff ONLINE 0 528 ffff88003a6e0000 memory1 8000000 - fffffff ONLINE 1 529 ffff88003a6e1000 memory2 10000000 - 17ffffff ONLINE 2 530 ffff88003a6e1400 memory3 18000000 - 1fffffff ONLINE 3 531 ffff88003a6e1800 memory4 20000000 - 27ffffff ONLINE 4 532 ffff88003a6e0400 memory5 28000000 - 2fffffff ONLINE 5 533 ffff88003a6e0800 memory6 30000000 - 37ffffff ONLINE 6 534 ffff88003a6e0c00 memory7 38000000 - 3fffffff ONLINE 7 535 536 Translate a page structure\u0026#39;s flags field contents: 537 538 crash\u0026gt; kmem -g 4080 539 FLAGS: 4080 540 PAGE-FLAG BIT VALUE 541 PG_slab 7 0000080 542 PG_head 14 0004000 543 crash\u0026gt; 20. list - linked list 20.1. SYNOPSIS 1list [[-o] offset][-e end][-[s|S] struct[.member[,member] [-l offset]] -[x|d]] 2 [-r|-B] [-h|-H] start 20.2. DESCRIPTION 1 2 This command dumps the contents of a linked list. The entries in a linked 3 list are typically data structures that are tied together in one of two 4 formats: 5 6 1. A starting address points to a data structure; that structure contains 7 a member that is a pointer to the next structure, and so on. This type 8 of a singly-linked list typically ends when a \u0026#34;next\u0026#34; pointer value 9 contains one of the following: 10 11 (a) a NULL pointer. 12 (b) a pointer to the start address. 13 (c) a pointer to the first item pointed to by the start address. 14 (d) a pointer to its containing structure. 15 16 2. Most Linux lists of data structures are doubly-linked using \u0026#34;list_head\u0026#34; 17 structures that are embedded members of the data structures in the list: 18 19 struct list_head { 20 struct list_head *next, *prev; 21 }; 22 23 The linked list is typically headed by an external, standalone list_head, 24 which is simply initialized to point to itself, signifying that the list 25 is empty: 26 27 #define LIST_HEAD_INIT(name) { \u0026amp;(name), \u0026amp;(name) } 28 #define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name) 29 30 In the case of list_head-linked lists, the \u0026#34;list_head.next\u0026#34; pointer is 31 the address of a list_head structure that is embedded in the next data 32 structure in the list, and not the address of the next data structure 33 itself. The starting point of the list may be: 34 35 (a) an external, standalone, LIST_HEAD(). 36 (b) a list_head that is embedded within a data structure of the same 37 type as the whole linked list. 38 (c) a list_head that is embedded within a data structure that is 39 different than the type of structures in the the linked list. 40 41 The list typically ends when the embedded \u0026#34;list_head.next\u0026#34; pointer of 42 a data structure in the linked list points back to the LIST_HEAD() 43 address. However, some list_head-linked lists have no defined starting 44 point, but just link back onto themselves in a circular manner. 45 46 This command can handle both types of linked list; in both cases the list 47 of addresses that are dumped are the addresses of the data structures 48 themselves. 49 50 Alternatively, the address of a list_head, or other similar list linkage 51 structure whose first member points to the next linkage structure, may be 52 used as the starting address. The caveat with this type of usage is that 53 the list may pass through, and display the address of, an external standalone 54 list head which is not an address of a list linkage structure that is embedded 55 within the data structure of interest. 56 57 The arguments are as follows: 58 59 [-o] offset The offset within the structure to the \u0026#34;next\u0026#34; pointer 60 (default is 0). If non-zero, the offset may be entered 61 in either of two manners: 62 63 1. In \u0026#34;structure.member\u0026#34; format; the \u0026#34;-o\u0026#34; is not necessary. 64 2. A number of bytes; the \u0026#34;-o\u0026#34; is only necessary on processors 65 where the offset value could be misconstrued as a kernel 66 virtual address. 67 68 -e end If the list ends in a manner unlike the typical manners that 69 are described above, an explicit ending address value may be 70 entered. 71 -s struct For each address in list, format and print as this type of 72 structure; use the \u0026#34;struct.member\u0026#34; format in order to display 73 a particular member of the structure. To display multiple 74 members of a structure, use a comma-separated list of members. 75 If any structure member contains an embedded structure or is an 76 array, the output may be restricted to the embedded structure 77 or an array element by expressing the struct argument as 78 \u0026#34;struct.member.member\u0026#34; or \u0026#34;struct.member[index]\u0026#34;; embedded 79 member specifications may extend beyond one level deep by 80 expressing the argument as \u0026#34;struct.member.member.member...\u0026#34;. 81 -S struct Similar to -s, but instead of parsing gdb output, member values 82 are read directly from memory, so the command works much faster 83 for 1-, 2-, 4-, and 8-byte members. 84 -l offset Only used in conjunction with -s, if the start address argument 85 is a pointer to an embedded list head (or any other similar list 86 linkage structure whose first member points to the next linkage 87 structure), the offset to the embedded member may be entered 88 in either of the following manners: 89 90 1. in \u0026#34;structure.member\u0026#34; format. 91 2. a number of bytes. 92 93 -x Override the default output format with hexadecimal format. 94 -d Override the default output format with decimal format. 95 -r For a list linked with list_head structures, traverse the list 96 in the reverse order by using the \u0026#34;prev\u0026#34; pointer instead 97 of \u0026#34;next\u0026#34;. 98 -B Use the algorithm from R. P. Brent to detect loops instead of 99 using a hash table. This algorithm uses a tiny fixed amount of 100 memory and so is especially helpful for longer lists. The output 101 is slightly different than the normal list output as it will 102 print the length of the loop, the start of the loop, and the 103 first duplicate in the list. 104 105 The meaning of the \u0026#34;start\u0026#34; argument, which can be expressed symbolically, 106 in hexadecimal format, or an expression evaluating to an address, depends 107 upon whether the -h or -H option is pre-pended: 108 109 start The address of the first data structure in the list. 110 start When both the -s and -l options are used, the address of an 111 embedded list_head or similar linkage structure whose first 112 member points to the next linkage structure. 113 -H start The address of a list_head structure, typically that of an 114 external, standalone LIST_HEAD(). The list typically ends 115 when the embedded \u0026#34;list_head.next\u0026#34; of a data structure in 116 the linked list points back to this \u0026#34;start\u0026#34; address. 117 -h start The address of a data structure which contains an embedded 118 list_head. The list typically ends when the embedded 119 \u0026#34;list_head.next\u0026#34; of a data structure in the linked list 120 points back to the embedded list_head contained in the data 121 structure whose address is this \u0026#34;start\u0026#34; argument. 122 123WARNING 124 When the \u0026#34;-h start\u0026#34; option is used, it is possible that the list_head-linked 125 list will: 126 127 1. pass through an external standalone LIST_HEAD(), or 128 2. pass through a list_head that is the actual starting list_head, but is 129 contained within a data structure that is not the same type as all of 130 the other data structures in the list. 131 132 When that occurs, the data structure address displayed for that list_head 133 will be incorrect, because the \u0026#34;-h start\u0026#34; option presumes that all 134 list_head structures in the list are contained within the same type of 135 data structure. Furthermore, if the \u0026#34;-s struct[.member[,member]\u0026#34; option 136 is used, it will display bogus data for that particular list_head. 137 138 A similar issue may be encountered when the \u0026#34;start\u0026#34; address is an embedded 139 list_head or similar linkage structure whose first member points to the next 140 linkage structure. When that occurs, the address of any external list head 141 will not be distinguishable from the addresses that are embedded in the data 142 structure of interest. Furthermore, if the \u0026#34;-s\u0026#34; and \u0026#34;-l\u0026#34; options are used, 143 it will display bogus structure data when passing through any external list 144 head structure that is not embedded in the specified data structure type. 20.3. EXAMPLES 1 Note that each task_struct is linked to its parent\u0026#39;s task_struct via the 2 p_pptr member: 3 4 crash\u0026gt; struct task_struct.p_pptr 5 struct task_struct { 6 [136] struct task_struct *p_pptr; 7 } 8 9 That being the case, given a task_struct pointer of c169a000, show its 10 parental hierarchy back to the \u0026#34;init_task\u0026#34; (the \u0026#34;swapper\u0026#34; task): 11 12 crash\u0026gt; list task_struct.p_pptr c169a000 13 c169a000 14 c0440000 15 c50d0000 16 c0562000 17 c0d28000 18 c7894000 19 c6a98000 20 c009a000 21 c0252000 22 23 Given that the \u0026#34;task_struct.p_pptr\u0026#34; offset is 136 bytes, the same 24 result could be accomplished like so: 25 26 crash\u0026gt; list 136 c169a000 27 c169a000 28 c0440000 29 c50d0000 30 c0562000 31 c0d28000 32 c7894000 33 c6a98000 34 c009a000 35 c0252000 36 37 The list of currently-registered file system types are headed up by a 38 struct file_system_type pointer named \u0026#34;file_systems\u0026#34;, and linked by 39 the \u0026#34;next\u0026#34; field in each file_system_type structure. The following 40 sequence displays the structure address followed by the name and 41 fs_flags members of each registered file system type: 42 43 crash\u0026gt; p file_systems 44 file_systems = $1 = (struct file_system_type *) 0xc03adc90 45 crash\u0026gt; list file_system_type.next -s file_system_type.name,fs_flags c03adc90 46 c03adc90 47 name = 0xc02c05c8 \u0026#34;rootfs\u0026#34;, 48 fs_flags = 0x30, 49 c03abf94 50 name = 0xc02c0319 \u0026#34;bdev\u0026#34;, 51 fs_flags = 0x10, 52 c03acb40 53 name = 0xc02c07c4 \u0026#34;proc\u0026#34;, 54 fs_flags = 0x8, 55 c03e9834 56 name = 0xc02cfc83 \u0026#34;sockfs\u0026#34;, 57 fs_flags = 0x10, 58 c03ab8e4 59 name = 0xc02bf512 \u0026#34;tmpfs\u0026#34;, 60 fs_flags = 0x20, 61 c03ab8c8 62 name = 0xc02c3d6b \u0026#34;shm\u0026#34;, 63 fs_flags = 0x20, 64 c03ac394 65 name = 0xc02c03cf \u0026#34;pipefs\u0026#34;, 66 fs_flags = 0x10, 67 c03ada74 68 name = 0xc02c0e6b \u0026#34;ext2\u0026#34;, 69 fs_flags = 0x1, 70 c03adc74 71 name = 0xc02c0e70 \u0026#34;ramfs\u0026#34;, 72 fs_flags = 0x20, 73 c03ade74 74 name = 0xc02c0e76 \u0026#34;hugetlbfs\u0026#34;, 75 fs_flags = 0x20, 76 c03adf8c 77 name = 0xc02c0f84 \u0026#34;iso9660\u0026#34;, 78 fs_flags = 0x1, 79 c03aec14 80 name = 0xc02c0ffd \u0026#34;devpts\u0026#34;, 81 fs_flags = 0x8, 82 c03e93f4 83 name = 0xc02cf1b9 \u0026#34;pcihpfs\u0026#34;, 84 fs_flags = 0x28, 85 e0831a14 86 name = 0xe082f89f \u0026#34;ext3\u0026#34;, 87 fs_flags = 0x1, 88 e0846af4 89 name = 0xe0841ac6 \u0026#34;usbdevfs\u0026#34;, 90 fs_flags = 0x8, 91 e0846b10 92 name = 0xe0841acf \u0026#34;usbfs\u0026#34;, 93 fs_flags = 0x8, 94 e0992370 95 name = 0xe099176c \u0026#34;autofs\u0026#34;, 96 fs_flags = 0x0, 97 e2dcc030 98 name = 0xe2dc8849 \u0026#34;nfs\u0026#34;, 99 fs_flags = 0x48000, 100 101 In some kernels, the system run queue is a linked list headed up by the 102 \u0026#34;runqueue_head\u0026#34;, which is defined like so: 103 104 static LIST_HEAD(runqueue_head); 105 106 The run queue linking is done with the \u0026#34;run_list\u0026#34; member of the task_struct: 107 108 crash\u0026gt; struct task_struct.run_list 109 struct task_struct { 110 [60] struct list_head run_list; 111 } 112 113 Therefore, to view the list of task_struct addresses in the run queue, 114 either of the following commands will work: 115 116 crash\u0026gt; list task_struct.run_list -H runqueue_head 117 f79ac000 118 f7254000 119 f7004000 120 crash\u0026gt; list 60 -H runqueue_head 121 f79ac000 122 f7254000 123 f7004000 124 125 In some kernel versions, the vfsmount structures of the mounted 126 filesystems are linked by the LIST_HEAD \u0026#34;vfsmntlist\u0026#34;, which uses the 127 mnt_list list_head of each vfsmount structure in the list. To dump each 128 vfsmount structure in the list, append the -s option: 129 130 crash\u0026gt; list -H vfsmntlist vfsmount.mnt_list -s vfsmount 131 c3fc9e60 132 struct vfsmount { 133 mnt_hash = { 134 next = 0xc3fc9e60, 135 prev = 0xc3fc9e60 136 }, 137 mnt_parent = 0xc3fc9e60, 138 mnt_mountpoint = 0xc3fc5dc0, 139 mnt_root = 0xc3fc5dc0, 140 mnt_instances = { 141 next = 0xc3f60a74, 142 prev = 0xc3f60a74 143 }, 144 mnt_sb = 0xc3f60a00, 145 mnt_mounts = { 146 next = 0xf7445e08, 147 prev = 0xf7445f88 148 }, 149 mnt_child = { 150 next = 0xc3fc9e88, 151 prev = 0xc3fc9e88 152 }, 153 mnt_count = { 154 counter = 209 155 }, 156 mnt_flags = 0, 157 mnt_devname = 0xc8465b20 \u0026#34;/dev/root\u0026#34;, 158 mnt_list = { 159 next = 0xf7445f9c, 160 prev = 0xc02eb828 161 }, 162 mnt_owner = 0 163 } 164 f7445f60 165 struct vfsmount { 166 ... 167 168 The task_struct of every task in the system is linked into a circular list 169 by its embedded \u0026#34;tasks\u0026#34; list_head. Show the task_struct addresses and the 170 pids of all tasks in the system using \u0026#34;-h\u0026#34; option, starting with the 171 task_struct at ffff88012b98e040: 172 173 crash\u0026gt; list task_struct.tasks -s task_struct.pid -h ffff88012b98e040 174 ffff88012b98e040 175 pid = 14187 176 ffff8801277be0c0 177 pid = 14248 178 ffffffff81a2d020 179 pid = 0 180 ffff88012d7dd4c0 181 pid = 1 182 ffff88012d7dca80 183 pid = 2 184 ffff88012d7dc040 185 pid = 3 186 ffff88012d7e9500 187 pid = 4 188 ... 189 ffff88012961a100 190 pid = 14101 191 ffff880129017580 192 pid = 14134 193 ffff8801269ed540 194 pid = 14135 195 ffff880128256080 196 pid = 14138 197 ffff88012b8f4100 198 pid = 14183 199 200 Similar to the above, display the embedded sched_entity structure\u0026#39;s on_rq 201 member from each task_struct in the system: 202 203 crash\u0026gt; list task_struct.tasks -s task_struct.se.on_rq -h ffff8800b66a0000 204 ffff8800b66a0000 205 se.on_rq = 1, 206 ffff8800b66a0ad0 207 se.on_rq = 0, 208 ffff8800b66a15a0 209 se.on_rq = 0, 210 ffff8800b66a2070 211 se.on_rq = 0, 212 ffff8800b66a2b40 213 se.on_rq = 0, 214 ffff8800b67315a0 215 se.on_rq = 0, 216 ffff8800b6732b40 217 se.on_rq = 0, 218 ... 219 220 The task_struct.tasks example above requires that the -h option be given 221 the address of a task_struct. Alternatively, the -l option can be given 222 the address of a list_head or similar linkage structure whose first member 223 points to the next linkage structure. Again using the task_struct.tasks 224 embedded list_head, dump the \u0026#34;comm\u0026#34; member of all tasks by using -l in 225 conjunction with -s option: 226 227 crash\u0026gt; task -R tasks.next 228 PID: 7044 TASK: ffff88005ac10000 CPU: 2 COMMAND: \u0026#34;crash\u0026#34; 229 tasks.next = 0xffff880109b8e3d0, 230 crash\u0026gt; list 0xffff880109b8e3d0 -l task_struct.tasks -s task_struct.comm 231 ffff880109b8e3d0 232 comm = \u0026#34;kworker/1:2\u0026#34; 233 ffff880109b8be00 234 comm = \u0026#34;bash\u0026#34; 235 ffff88019d26c590 236 comm = \u0026#34;cscope\u0026#34; 237 ffff880109b8b670 238 comm = \u0026#34;kworker/0:1\u0026#34; 239 ffff880109b8cd20 240 comm = \u0026#34;kworker/1:0\u0026#34; 241 ffff88005ac15c40 242 comm = \u0026#34;vi\u0026#34; 243 ffff88005ac11fc0 244 comm = \u0026#34;sleep\u0026#34; 245 ffffffff81c135c0 246 comm = \u0026#34;swapper/0\u0026#34; 247 ffff880212828180 248 comm = \u0026#34;systemd\u0026#34; 249 ... 250 ffff8801288d1830 251 comm = \u0026#34;chrome\u0026#34; 252 ffff8801534dd4b0 253 comm = \u0026#34;kworker/0:0\u0026#34; 254 ffff8801534d8180 255 comm = \u0026#34;kworker/1:1\u0026#34; 256 ffff88010902b670 257 comm = \u0026#34;kworker/2:2\u0026#34; 258 ffff880109b8a750 259 comm = \u0026#34;sudo\u0026#34; 260 ffff88005ac10180 261 comm = \u0026#34;crash\u0026#34; 21. log - dump system message buffer 21.1. SYNOPSIS 1log [-tdma] 21.2. DESCRIPTION 1 This command dumps the kernel log_buf contents in chronological order. The 2 command supports the older log_buf formats, which may or may not contain a 3 timestamp inserted prior to each message, as well as the newer variable-length 4 record format, where the timestamp is contained in each log entry\u0026#39;s header. 5 6 -t Display the message text without the timestamp; only applicable to the 7 variable-length record format. 8 -d Display the dictionary of key/value pair properties that are optionally 9 appended to a message by the kernel\u0026#39;s dev_printk() function; only 10 applicable to the variable-length record format. 11 -m Display the message log level in brackets preceding each message. For 12 the variable-length record format, the level will be displayed in 13 hexadecimal, and depending upon the kernel version, also contains the 14 facility or flags bits. 15 -a Dump the audit logs remaining in kernel audit buffers that have not 16 been copied out to the user-space audit daemon. 21.3. EXAMPLES 1 Dump the kernel message buffer: 2 3 crash\u0026gt; log 4 Linux version 2.2.5-15smp (root@mclinux1) (gcc version egcs-2.91.66 19990 5 314/Linux (egcs-1.1.2 release)) #1 SMP Thu Aug 26 11:04:37 EDT 1999 6 Intel MultiProcessor Specification v1.4 7 Virtual Wire compatibility mode. 8 OEM ID: DELL Product ID: WS 410 APIC at: 0xFEE00000 9 Processor #0 Pentium(tm) Pro APIC version 17 10 Processor #1 Pentium(tm) Pro APIC version 17 11 I/O APIC #2 Version 17 at 0xFEC00000. 12 Processors: 2 13 mapped APIC to ffffe000 (fee00000) 14 mapped IOAPIC to ffffd000 (fec00000) 15 Detected 447696347 Hz processor. 16 Console: colour VGA+ 80x25 17 Calibrating delay loop... 445.64 BogoMIPS 18 ... 19 8K byte-wide RAM 5:3 Rx:Tx split, autoselect/Autonegotiate interface. 20 MII transceiver found at address 24, status 782d. 21 Enabling bus-master transmits and whole-frame receives. 22 Installing knfsd (copyright (C) 1996 okir@monad.swb.de). 23 nfsd_init: initialized fhcache, entries=256 24 ... 25 26 Do the same thing, but also show the log level preceding each message: 27 28 crash\u0026gt; log -m 29 \u0026lt;4\u0026gt;Linux version 2.2.5-15smp (root@mclinux1) (gcc version egcs-2.91.66 19990 30 314/Linux (egcs-1.1.2 release)) #1 SMP Thu Aug 26 11:04:37 EDT 1999 31 \u0026lt;4\u0026gt;Intel MultiProcessor Specification v1.4 32 \u0026lt;4\u0026gt; Virtual Wire compatibility mode. 33 \u0026lt;4\u0026gt;OEM ID: DELL Product ID: WS 410 APIC at: 0xFEE00000 34 \u0026lt;4\u0026gt;Processor #0 Pentium(tm) Pro APIC version 17 35 \u0026lt;4\u0026gt;Processor #1 Pentium(tm) Pro APIC version 17 36 \u0026lt;4\u0026gt;I/O APIC #2 Version 17 at 0xFEC00000. 37 \u0026lt;4\u0026gt;Processors: 2 38 \u0026lt;4\u0026gt;mapped APIC to ffffe000 (fee00000) 39 \u0026lt;4\u0026gt;mapped IOAPIC to ffffd000 (fec00000) 40 \u0026lt;4\u0026gt;Detected 447696347 Hz processor. 41 \u0026lt;4\u0026gt;Console: colour VGA+ 80x25 42 \u0026lt;4\u0026gt;Calibrating delay loop... 445.64 BogoMIPS 43 ... 44 \u0026lt;6\u0026gt; 8K byte-wide RAM 5:3 Rx:Tx split, autoselect/Autonegotiate interface. 45 \u0026lt;6\u0026gt; MII transceiver found at address 24, status 782d. 46 \u0026lt;6\u0026gt; Enabling bus-master transmits and whole-frame receives. 47 \u0026lt;6\u0026gt;Installing knfsd (copyright (C) 1996 okir@monad.swb.de). 48 \u0026lt;7\u0026gt;nfsd_init: initialized fhcache, entries=256 49 ... 50 51 On a system with the variable-length record format, and whose log_buf has been 52 filled and wrapped around, display the log with timestamp data: 53 54 crash\u0026gt; log 55 [ 0.467730] pci 0000:ff:02.0: [8086:2c10] type 00 class 0x060000 56 [ 0.467749] pci 0000:ff:02.1: [8086:2c11] type 00 class 0x060000 57 [ 0.467769] pci 0000:ff:02.4: [8086:2c14] type 00 class 0x060000 58 [ 0.467788] pci 0000:ff:02.5: [8086:2c15] type 00 class 0x060000 59 [ 0.467809] pci 0000:ff:03.0: [8086:2c18] type 00 class 0x060000 60 [ 0.467828] pci 0000:ff:03.1: [8086:2c19] type 00 class 0x060000 61 ... 62 63 Display the same message text as above, without the timestamp data: 64 65 crash\u0026gt; log -t 66 pci 0000:ff:02.0: [8086:2c10] type 00 class 0x060000 67 pci 0000:ff:02.1: [8086:2c11] type 00 class 0x060000 68 pci 0000:ff:02.4: [8086:2c14] type 00 class 0x060000 69 pci 0000:ff:02.5: [8086:2c15] type 00 class 0x060000 70 pci 0000:ff:03.0: [8086:2c18] type 00 class 0x060000 71 pci 0000:ff:03.1: [8086:2c19] type 00 class 0x060000 72 ... 73 74 Display the same message text as above, with appended dictionary data: 75 76 crash\u0026gt; log -td 77 pci 0000:ff:02.0: [8086:2c10] type 00 class 0x060000 78 SUBSYSTEM=pci 79 DEVICE=+pci:0000:ff:02.0 80 pci 0000:ff:02.1: [8086:2c11] type 00 class 0x060000 81 SUBSYSTEM=pci 82 DEVICE=+pci:0000:ff:02.1 83 pci 0000:ff:02.4: [8086:2c14] type 00 class 0x060000 84 SUBSYSTEM=pci 85 DEVICE=+pci:0000:ff:02.4 86 pci 0000:ff:02.5: [8086:2c15] type 00 class 0x060000 87 SUBSYSTEM=pci 88 DEVICE=+pci:0000:ff:02.5 89 pci 0000:ff:03.0: [8086:2c18] type 00 class 0x060000 90 SUBSYSTEM=pci 91 DEVICE=+pci:0000:ff:03.0 92 pci 0000:ff:03.1: [8086:2c19] type 00 class 0x060000 93 SUBSYSTEM=pci 94 DEVICE=+pci:0000:ff:03.1 95 ... 96 97 Dump the kernel audit logs: 98 99 crash\u0026gt; log -a 100 type=1320 audit(1489384479.809:4342): 101 type=1300 audit(1489384479.809:4343): arch=c000003e syscall=0 success=yes 102 exit=0 a0=4 a1=7f84154a2000 a2=400 a3=22 items=0 ppid=2560 pid=2591 auid=0 103 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=ttyS0 ses=1 104 comm=\u0026#34;pidof\u0026#34; exe=\u0026#34;/usr/sbin/killall5\u0026#34; 105 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null) 106 type=1320 audit(1489384479.809:4343): 107 type=1300 audit(1489384479.809:4344): arch=c000003e syscall=3 success=yes 108 exit=0 a0=4 a1=1 a2=8 a3=0 items=0 ppid=2560 pid=2591 auid=0 uid=0 gid=0 109 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=ttyS0 ses=1 comm=\u0026#34;pidof\u0026#34; 110 exe=\u0026#34;/usr/sbin/killall5\u0026#34; 111 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null) 112 type=1320 audit(1489384479.809:4344): 113 type=1300 audit(1489384479.809:4345): arch=c000003e syscall=11 114 success=yes exit=0 a0=7f84154a2000 a1=1000 a2=0 a3=0 items=0 ppid=2560 115 pid=2591 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 116 tty=ttyS0 ses=1 comm=\u0026#34;pidof\u0026#34; exe=\u0026#34;/usr/sbin/killall5\u0026#34; 117 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null) 118 type=1320 audit(1489384479.809:4345): 119 type=1300 audit(1489384479.809:4346): arch=c000003e syscall=2 success=yes 120 exit=4 a0=7ffcfd20f5a0 a1=0 a2=1b6 a3=24 items=1 ppid=2560 pid=2591 auid=0 121 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=ttyS0 ses=1 122 comm=\u0026#34;pidof\u0026#34; exe=\u0026#34;/usr/sbin/killall5\u0026#34; 123 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null) 124 type=1307 audit(1489384479.809:4346): cwd=\u0026#34;/proc\u0026#34; 125 ... 22. mach - machine specific data 22.1. SYNOPSIS 1mach [-m | -c -[xd] | -o] 22.2. DESCRIPTION 1 This command displays data specific to a machine type. 2 3 -m Display the physical memory map (x86, x86_64 and ia64 only). 4 -c Display each cpu\u0026#39;s cpuinfo structure (x86, x86_64 and ia64 only). 5 Display each cpu\u0026#39;s x8664_pda structure (x86_64 only), 6 Display the hwrpb_struct, and each cpu\u0026#39;s percpu_struct (alpha only). 7 -x override default output format with hexadecimal format. 8 -d override default output format with decimal format. 9 -o Display the OPAL console log (ppc64 only). 22.3. EXAMPLES 1 crash\u0026gt; mach 2 MACHINE TYPE: i686 3 MEMORY SIZE: 512 MB 4 CPUS: 2 5 HYPERVISOR: KVM 6 PROCESSOR SPEED: 1993 Mhz 7 HZ: 100 8 PAGE SIZE: 4096 9 KERNEL VIRTUAL BASE: c0000000 10 KERNEL VMALLOC BASE: e0800000 11 KERNEL STACK SIZE: 8192 12 13 Display the system physical memory map: 14 15 crash\u0026gt; mach -m 16 PHYSICAL ADDRESS RANGE TYPE 17 0000000000000000 - 00000000000a0000 E820_RAM 18 00000000000f0000 - 0000000000100000 E820_RESERVED 19 0000000000100000 - 000000001ff75000 E820_RAM 20 000000001ff75000 - 000000001ff77000 E820_NVS 21 000000001ff77000 - 000000001ff98000 E820_ACPI 22 000000001ff98000 - 0000000020000000 E820_RESERVED 23 00000000fec00000 - 00000000fec90000 E820_RESERVED 24 00000000fee00000 - 00000000fee10000 E820_RESERVED 25 00000000ffb00000 - 0000000100000000 E820_RESERVED 26 27 Display the OPAL console log: 28 29 crash\u0026gt; mach -o 30 [ 65.219056911,5] SkiBoot skiboot-5.4.0-218-ge0225cc-df9a248 starting... 31 [ 65.219065872,5] initial console log level: memory 7, driver 5 32 [ 65.219068917,6] CPU: P8 generation processor(max 8 threads/core) 33 [ 65.219071681,7] CPU: Boot CPU PIR is 0x0060 PVR is 0x004d0200 34 [ 65.219074685,7] CPU: Initial max PIR set to 0x1fff 35 [ 65.219607955,5] FDT: Parsing fdt @0xff00000 36 [ 494.026291523,7] BT: seq 0x25 netfn 0x0a cmd 0x48: Message sent to host 37 [ 494.027636927,7] BT: seq 0x25 netfn 0x0a cmd 0x48: IPMI MSG done 23. mod - module information and loading of symbols and debugging data 23.1. SYNOPSIS 1mod -s module [objfile] | -d module | -S [directory] [-D|-t|-r|-R|-o|-g] 23.2. DESCRIPTION 1 With no arguments, this command displays basic information of the currently 2 installed modules, consisting of the module address, name, size, the 3 object file name (if known), and whether the module was compiled with 4 CONFIG_KALLSYMS. 5 6 The arguments are concerned with with the loading or deleting of symbolic 7 and debugging data from a module\u0026#39;s object file. A modules\u0026#39;s object file 8 always contains symbolic data (symbol names and addresses), but contains 9 debugging data only if the module was compiled with the -g CFLAG. In 10 addition, the module may have compiled with CONFIG_KALLSYMS, which means 11 that the module\u0026#39;s symbolic data will have been loaded into the kernel\u0026#39;s 12 address space when it was installed. If the module was not compiled with 13 CONFIG_KALLSYMS, then only the module\u0026#39;s exported symbols will be loaded 14 into the kernel\u0026#39;s address space. Therefore, for the purpose of this 15 command, it should noted that a kernel module may have been compiled in 16 one of following manners: 17 18 1. If the module was built without CONFIG_KALLSYMS and without the -g CFLAG, 19 then the loading of the module\u0026#39;s additional non-exported symbols can 20 be accomplished with this command. 21 2. If the module was built with CONFIG_KALLSYMS, but without the -g CFLAG, 22 then there is no benefit in loading the symbols from the module object 23 file, because all of the module\u0026#39;s symbols will have been loaded into the 24 kernel\u0026#39;s address space when it was installed. 25 3. If the module was built with CONFIG_KALLSYMS and with the the -g CFLAG, 26 then the loading of the module\u0026#39;s debugging data can be accomplished 27 with this command. 28 4. If the module was built without CONFIG_KALLSYMS but with the -g CFLAG, 29 then the loading of the both module\u0026#39;s symbolic and debugging data can 30 be accomplished with this command. 31 32 -s module [objfile] Loads symbolic and debugging data from the object file 33 for the module specified. If no objfile argument is 34 appended, a search will be made for an object file 35 consisting of the module name with a .o or .ko suffix, 36 starting at the /lib/modules/\u0026lt;release\u0026gt; directory on 37 the host system, or if not found there, starting at the 38 directory containing the kernel namelist file. If an 39 objfile argument is appended, then that file will be 40 used. 41 -d module Deletes the symbolic and debugging data of the module 42 specified. 43 -S [directory] Load symbolic and debugging data from the object file 44 for all loaded modules. For each module, a search 45 will be made for an object file consisting of the 46 module name with a .o or .ko suffix, starting at the 47 /lib/modules/\u0026lt;release\u0026gt; directory of the host system, 48 or if not found there, starting at the directory 49 containing the kernel namelist file. If a directory 50 argument is appended, then the search will be restricted 51 to that directory. 52 -D Deletes the symbolic and debugging data of all modules. 53 -t Display the contents of the module\u0026#39;s \u0026#34;taints\u0026#34; bitmask 54 if it is non-zero. When possible, the \u0026#34;taints\u0026#34; bits 55 are translated to symbolic letters of the taint type; 56 otherwise the hexadecimal value is shown. In older 57 kernels, the contents of the \u0026#34;license_gplok\u0026#34; field is 58 displayed in hexadecimal; the field may be either a 59 bitmask or a boolean, depending upon the kernel version. 60 The relevant kernel sources should be consulted for the 61 meaning of the letter(s) or hexadecimal bit value(s). 62 For modules that have a \u0026#34;gpgsig_ok\u0026#34; field that is zero 63 (unsigned), the notation \u0026#34;(U)\u0026#34; is shown. 64 -r Passes the -readnow flag to the embedded gdb module, 65 which will override the two-stage strategy that it uses 66 for reading symbol tables from module object files. 67 -R Reinitialize module data. All currently-loaded symbolic 68 and debugging data will be deleted, and the installed 69 module list will be updated (live system only). 70 -g When used with -s or -S, add a module object\u0026#39;s section 71 start and end addresses to its symbol list. 72 -o Load module symbols with old mechanism. 73 74 If the crash session was invoked with the \u0026#34;--mod \u0026lt;directory\u0026gt;\u0026#34; option, or 75 a CRASH_MODULE_PATH environment variable exists, then /lib/modules/\u0026lt;release\u0026gt; 76 will be overridden as the default directory tree that is searched for module 77 object files. 78 79 After symbolic and debugging data have been loaded, backtraces and text 80 disassembly will be displayed appropriately. Depending upon the processor 81 architecture, data may also printed symbolically with the \u0026#34;p\u0026#34; command; 82 at a minimum, the \u0026#34;rd\u0026#34; command may be used with module data symbols. 83 84 If crash can recognize that the set of modules has changed while running a 85 session on a live kernel, the module data will be reinitialized the next 86 time this command is run; the -r option forces the reinitialization. 23.3. EXAMPLES 1 Display the currently-installed modules: 2 3 crash\u0026gt; mod 4 MODULE NAME SIZE OBJECT FILE 5 c8019000 soundcore 2788 (not loaded) 6 c801b000 soundlow 336 (not loaded) 7 c801d000 sound 59864 (not loaded) 8 c802d000 ad1848 15728 (not loaded) 9 c8032000 uart401 6000 (not loaded) 10 c8035000 cs4232 2472 (not loaded) 11 c8043000 opl3 11048 (not loaded) 12 c8047000 3c59x 18152 (not loaded) 13 c804d000 sunrpc 53796 (not loaded) 14 c805c000 lockd 31528 (not loaded) 15 c8065000 nfsd 151896 (not loaded) 16 c8092000 nfs 29752 (not loaded) 17 18 Display the currently-installed modules on a system where all modules were 19 compiled with CONFIG_KALLSYMS: 20 21 crash\u0026gt; mod 22 MODULE NAME SIZE OBJECT FILE 23 e080d000 jbd 57016 (not loaded) [CONFIG_KALLSYMS] 24 e081e000 ext3 92360 (not loaded) [CONFIG_KALLSYMS] 25 e0838000 usbcore 83168 (not loaded) [CONFIG_KALLSYMS] 26 e0850000 usb-uhci 27532 (not loaded) [CONFIG_KALLSYMS] 27 e085a000 ehci-hcd 20904 (not loaded) [CONFIG_KALLSYMS] 28 e0865000 input 6208 (not loaded) [CONFIG_KALLSYMS] 29 e086a000 hid 22404 (not loaded) [CONFIG_KALLSYMS] 30 e0873000 mousedev 5688 (not loaded) [CONFIG_KALLSYMS] 31 e0878000 keybdev 2976 (not loaded) [CONFIG_KALLSYMS] 32 e08fd000 cdrom 34144 (not loaded) [CONFIG_KALLSYMS] 33 e0909000 ide-cd 35776 (not loaded) [CONFIG_KALLSYMS] 34 e0915000 scsi_mod 117928 (not loaded) [CONFIG_KALLSYMS] 35 e0935000 ide-scsi 12752 (not loaded) [CONFIG_KALLSYMS] 36 e093c000 microcode 5248 (not loaded) [CONFIG_KALLSYMS] 37 e0943000 sr_mod 18136 (not loaded) [CONFIG_KALLSYMS] 38 e0956000 floppy 59056 (not loaded) [CONFIG_KALLSYMS] 39 e0966000 sg 38060 (not loaded) [CONFIG_KALLSYMS] 40 e0971000 ip_tables 16544 (not loaded) [CONFIG_KALLSYMS] 41 e097d000 iptable_filter 2412 (not loaded) [CONFIG_KALLSYMS] 42 e097f000 e1000 76096 (not loaded) [CONFIG_KALLSYMS] 43 e09ba000 autofs 13780 (not loaded) [CONFIG_KALLSYMS] 44 e09c1000 parport 39072 (not loaded) [CONFIG_KALLSYMS] 45 e09ce000 lp 9220 (not loaded) [CONFIG_KALLSYMS] 46 e09d4000 parport_pc 19204 (not loaded) [CONFIG_KALLSYMS] 47 e09e2000 agpgart 59128 (not loaded) [CONFIG_KALLSYMS] 48 e0a1a000 radeon 117156 (not loaded) [CONFIG_KALLSYMS] 49 e2dc7000 sunrpc 91996 (not loaded) [CONFIG_KALLSYMS] 50 e2de1000 lockd 60624 (not loaded) [CONFIG_KALLSYMS] 51 e2df3000 nfs 96880 (not loaded) [CONFIG_KALLSYMS] 52 53 Load the symbolic and debugging data of all modules: 54 55 crash\u0026gt; mod -S 56 MODULE NAME SIZE OBJECT FILE 57 c8019000 soundcore 2788 /lib/modules/2.2.5-15/misc/soundcore.o 58 c801b000 soundlow 336 /lib/modules/2.2.5-15/misc/soundlow.o 59 c801d000 sound 59864 /lib/modules/2.2.5-15/misc/sound.o 60 c802d000 ad1848 15728 /lib/modules/2.2.5-15/misc/ad1848.o 61 c8032000 uart401 6000 /lib/modules/2.2.5-15/misc/uart401.o 62 c8035000 cs4232 2472 /lib/modules/2.2.5-15/misc/cs4232.o 63 c8043000 opl3 11048 /lib/modules/2.2.5-15/misc/opl3.o 64 c8047000 3c59x 18152 /lib/modules/2.2.5-15/net/3c59x.o 65 c804d000 sunrpc 53796 /lib/modules/2.2.5-15/misc/sunrpc.o 66 c805c000 lockd 31528 /lib/modules/2.2.5-15/fs/lockd.o 67 c8065000 nfsd 151896 /lib/modules/2.2.5-15/fs/nfsd.o 68 c8092000 nfs 29752 /lib/modules/2.2.5-15/fs/nfs.o 69 70 Load the symbolic and debugging data of the soundcore module from its 71 known location: 72 73 crash\u0026gt; mod -s soundcore 74 MODULE NAME SIZE OBJECT FILE 75 c8019000 soundcore 2788 /lib/modules/2.2.5-15/misc/soundcore.o 76 77 Delete the current symbolic and debugging data of the soundcore module, 78 and then re-load it from a specified object file: 79 80 crash\u0026gt; mod -d soundcore 81 crash\u0026gt; mod -s soundcore /tmp/soundcore.o 82 MODULE NAME SIZE OBJECT FILE 83 c8019000 soundcore 2788 /tmp/soundcore.o 84 85 After installing a new kernel module on a live system, reinitialize the 86 installed module list: 87 88 crash\u0026gt; !insmod mdacon 89 crash\u0026gt; mod 90 mod: NOTE: modules have changed on this system -- reinitializing 91 MODULE NAME SIZE OBJECT FILE 92 c8019000 soundcore 2788 (not loaded) 93 c801b000 soundlow 336 (not loaded) 94 c801d000 sound 59864 (not loaded) 95 c802d000 ad1848 15728 (not loaded) 96 c8032000 uart401 6000 (not loaded) 97 c8035000 cs4232 2472 (not loaded) 98 c8043000 opl3 11048 (not loaded) 99 c8047000 3c59x 18152 (not loaded) 100 c804d000 sunrpc 53796 (not loaded) 101 c805c000 lockd 31528 (not loaded) 102 c8065000 nfs 29752 (not loaded) 103 c806e000 autofs 9316 (not loaded) 104 c8072000 nfsd 151896 (not loaded) 105 c80a1000 mdacon 3556 (not loaded) 106 107 Display modules that are \u0026#34;tainted\u0026#34;, where in this case 108 where they are proprietary and unsigned: 109 110 crash\u0026gt; mod -t 111 NAME TAINT 112 vxspec P(U) 113 vxportal P(U) 114 fdd P(U) 115 vxfs P(U) 116 vxdmp P(U) 117 vxio P(U) 118 vxglm P(U) 119 vxgms P(U) 120 vxodm P(U) 24. mount - mounted filesystem data 24.1. SYNOPSIS 1mount [-f][-i] [-n pid|task] [mount|vfsmount|superblock|dev|dir|dentry|inode] 24.2. DESCRIPTION 1 This command displays basic information about the currently-mounted 2 filesystems. The per-filesystem dirty inode list or list of open 3 files for the filesystem may also be displayed. 4 5 -f dump dentries and inodes for open files in each filesystem; only 6 supported on kernels prior to Linux 3.13. 7 -i dump all dirty inodes associated with each filesystem; only 8 supported on kernels prior to Linux 2.6.32. 9 10 For kernels supporting namespaces, the -n option may be used to 11 display the mounted filesystems with respect to the namespace of a 12 specified task: 13 14 -n pid a process PID. 15 -n task a hexadecimal task_struct pointer. 16 17 Specific filesystems may be selected using the following forms: 18 19 vfsmount hexadecimal address of a filesystem vfsmount structure. 20 mount hexadecimal address of a filesystem mount structure (Linux 3.3 21 and later). 22 superblock hexadecimal address of a filesystem super_block structure. 23 dev device name of a filesystem. 24 dir directory where a filesystem is mounted. 25 dentry hexadecimal address of an open dentry of a filesystem. 26 inode hexadecimal address of an open inode of a filesystem. 27 28 The first column of the command output displays the filesystem\u0026#39;s vfsmount 29 structure address for kernels prior to Linux 3.3. For Linux 3.3 and later 30 kernels, the first column displays the filesystem\u0026#39;s mount structure address, 31 which contains an embedded vfsmount structure. 24.3. EXAMPLES 1 Display mounted filesystem data: 2 3 crash\u0026gt; mount 4 VFSMOUNT SUPERBLK TYPE DEVNAME DIRNAME 5 c0089ea0 c0088a00 ext2 /dev/root / 6 c0089cf0 c0088c00 proc /proc /proc 7 c0089e10 c0088800 ext2 /dev/sda5 /boot 8 c0089d80 c0088600 ext2 /dev/sda6 /usr 9 c0089f30 c0088400 devpts none /dev/pts 10 c3f4b010 c0088200 ext2 /dev/sda1 /home 11 12 On Linux 3.3 and later kernels, the filesystem\u0026#39;s mount structure address 13 is shown: 14 15 crash\u0026gt; mount 16 MOUNT SUPERBLK TYPE DEVNAME DIRNAME 17 ffff880212fb8200 ffff880212fc0800 rootfs rootfs / 18 ffff88020ffbea00 ffff880212fc2000 proc proc proc 19 ffff880211db7f00 ffff88020e01a800 sysfs sysfs /sys 20 ffff88020ffe1300 ffff880212a40000 devtmpfs devtmpfs /dev 21 ffff88020ff15000 ffff880212bbc800 devpts devpts /dev/pts 22 ffff88020e542800 ffff88020e62b800 tmpfs tmpfs /dev/shm 23 ... 24 25 Display the open files associated with each mounted filesystem: 26 27 crash\u0026gt; mount -f 28 VFSMOUNT SUPERBLK TYPE DEVNAME DIRNAME 29 c7fb2b80 c7fb3200 ext2 /dev/root / 30 OPEN FILES: 31 DENTRY INODE TYPE PATH 32 c6d02200 c6d0f7a0 REG usr/X11R6/lib/libX11.so.6.1 33 c6d02100 c6d0f9e0 REG usr/X11R6/lib/libXext.so.6.3 34 c6d02000 c6d0fc20 REG usr/X11R6/lib/libICE.so.6.3 35 c6d02680 c6d0f320 REG usr/X11R6/bin/xfs 36 c7106580 c70c5440 CHR dev/psaux 37 ... 38 39 Display the dirty inodes associated with each mounted filesystem: 40 41 crash\u0026gt; mount -i 42 VFSMOUNT SUPERBLK TYPE DEVNAME DIRNAME 43 c0089ea0 c0088a00 ext2 /dev/root / 44 DIRTY INODES 45 c7ad4008 46 c2233438 47 c72c4008 48 c7d6b548 49 c3af1a98 50 c7d6b768 51 c3c4e228 52 ... 53 54 Display the mounted filesystem containing inode c5000aa8: 55 56 crash\u0026gt; mount c5000aa8 57 VFSMOUNT SUPERBLK TYPE DEVNAME DIRNAME 58 c0089f30 c0088600 ext2 /dev/sda6 /usr 59 60 Display the mounted filesystem containing inode ffff8801f4245e40: 61 62 crash\u0026gt; mount ffff8801f4245e40 63 MOUNT SUPERBLK TYPE DEVNAME DIRNAME 64 ffff88020ffbea00 ffff880212fc2000 proc proc /proc 25. net - network command 25.1. SYNOPSIS 1net [[-s | -S] [-xd] [-R ref] [pid | task]] [-a] [ -n [pid | task]] [-N addr] 25.2. DESCRIPTION 1 Displays various network related data. 2 3 If no arguments are entered, the list of network devices, names and IP 4 addresses are displayed. For kernels supporting namespaces, the -n option 5 may be used to display the list of network devices with respect to the 6 network namespace of a current context or a task specified by pid or task: 7 8 -n the namespace of the current context. 9 -n pid a process PID. 10 -n task a hexadecimal task_struct pointer. 11 12 The -s and -S options display data with respect to the current context, but 13 may be appended with an argument to show the socket data with respect 14 to a specified task: 15 16 -s display open network socket/sock addresses, their family and type, 17 and for INET and INET6 families, their source and destination 18 addresses and ports. 19 -s pid same as above, for task with process PID pid. 20 -s task same as above, for task with hexadecimal task_struct pointer task. 21 22 -S displays open network socket/sock addresses followed by a dump 23 of both data structures. 24 -S pid same as above, with respect to process PID. 25 -S task same as above, with respect to hexadecimal task_struct pointer. 26 27 The -R option, typically invoked from \u0026#34;foreach net\u0026#34;, and in conjunction 28 with the -s or -S options, searches for references to a socket address, 29 sock address, or a file descriptor; if found, only the referenced fd, socket 30 or sock data will be displayed: 31 32 -R ref socket or sock address, or file descriptor. 33 34 Other options: 35 36 -a display the ARP cache. 37 -N addr translates an IPv4 address expressed as a decimal or hexadecimal 38 value into a standard numbers-and-dots notation. 39 -x override default output format with hexadecimal format. 40 -d override default output format with decimal format. 25.3. EXAMPLES 1 Display the system\u0026#39;s network device list: 2 3 crash\u0026gt; net 4 NET_DEVICE NAME IP ADDRESS(ES) 5 ffff8803741c0000 lo 127.0.0.1 6 fff88037059c0000 eth0 10.226.229.141 7 ffff8803705c0000 eth1 10.226.228.250 8 ffff880374ad6000 usb0 169.254.95.120 9 10 Display the network device list with respect to the network namespace 11 of PID 2618: 12 13 crash\u0026gt; net -n 2618 14 NET_DEVICE NAME IP ADDRESS(ES) 15 ffff880456ee7020 lo 127.0.0.1 16 ffff8804516a1020 eth0 10.1.9.223 17 18 Dump the ARP cache: 19 20 crash\u0026gt; net -a 21 NEIGHBOUR IP ADDRESS HW TYPE HW ADDRESS DEVICE STATE 22 f38d1b00 10.16.64.14 ETHER 00:16:3e:4b:a5:4a eth1 STALE 23 f38d1080 0.0.0.0 UNKNOWN 00 00 00 00 00 00 lo NOARP 24 f38d1bc0 10.16.71.254 ETHER 00:00:0c:07:ac:00 eth1 REACHABLE 25 f38d1200 10.16.64.21 ETHER 00:16:3e:51:d8:09 eth1 REACHABLE 26 27 Display the sockets for PID 2517, using both -s and -S output formats: 28 29 crash\u0026gt; net -s 2517 30 PID: 2517 TASK: c1598000 CPU: 1 COMMAND: \u0026#34;rlogin\u0026#34; 31 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 32 3 c57375dc c1ff1850 INET:STREAM 10.1.8.20-1023 10.1.16.62-513 33 34 crash\u0026gt; net -S 2517 35 PID: 2517 TASK: c1598000 CPU: 1 COMMAND: \u0026#34;rlogin\u0026#34; 36 FD SOCKET SOCK 37 3 c57375dc c1ff1850 38 39 struct socket { 40 state = SS_CONNECTED, 41 flags = 131072, 42 ops = 0xc023f820, 43 inode = 0xc5737540, 44 fasync_list = 0x0, 45 file = 0xc58892b0, 46 sk = 0xc1ff1850, 47 wait = 0xc14d9ed4, 48 type = 1, 49 passcred = 0 \u0026#39;\\000\u0026#39;, 50 tli = 0 \u0026#39;\\000\u0026#39; 51 } 52 struct sock { 53 sklist_next = 0xc1ff12f0, 54 sklist_prev = 0xc216bc00, 55 bind_next = 0x0, 56 bind_pprev = 0xc0918448, 57 daddr = 1041236234, 58 rcv_saddr = 336068874, 59 dport = 258, 60 num = 1023, 61 bound_dev_if = 0, 62 next = 0x0, 63 pprev = 0xc0286dd4, 64 state = 1 \u0026#39;\\001\u0026#39;, 65 zapped = 0 \u0026#39;\\000\u0026#39;, 66 sport = 65283, 67 family = 2, 68 reuse = 0 \u0026#39;\\000\u0026#39;, 69 ... 70 Translate the rcv_saddr from above into dotted-decimal notation: 71 72 crash\u0026gt; net -N 1041236234 73 10.1.16.62 74 75 From \u0026#34;foreach\u0026#34;, find all tasks with references to socket c08ea3cc: 76 77 crash\u0026gt; foreach net -s -R c08ea3cc 78 PID: 2184 TASK: c7026000 CPU: 1 COMMAND: \u0026#34;klines.kss\u0026#34; 79 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 80 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 81 82 PID: 2200 TASK: c670a000 CPU: 1 COMMAND: \u0026#34;kpanel\u0026#34; 83 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 84 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 85 86 PID: 2201 TASK: c648a000 CPU: 1 COMMAND: \u0026#34;kbgndwm\u0026#34; 87 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 88 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 89 90 PID: 19294 TASK: c250a000 CPU: 0 COMMAND: \u0026#34;prefdm\u0026#34; 91 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 92 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 93 94 PID: 2194 TASK: c62dc000 CPU: 1 COMMAND: \u0026#34;kaudioserver\u0026#34; 95 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 96 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 97 98 PID: 2195 TASK: c6684000 CPU: 1 COMMAND: \u0026#34;maudio\u0026#34; 99 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 100 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 101 102 PID: 2196 TASK: c6b58000 CPU: 1 COMMAND: \u0026#34;kwmsound\u0026#34; 103 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 104 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 105 106 PID: 2197 TASK: c6696000 CPU: 0 COMMAND: \u0026#34;kfm\u0026#34; 107 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 108 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 109 110 PID: 2199 TASK: c65ec000 CPU: 0 COMMAND: \u0026#34;krootwm\u0026#34; 111 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 112 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 113 114 PID: 694 TASK: c1942000 CPU: 0 COMMAND: \u0026#34;prefdm\u0026#34; 115 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 116 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 117 118 PID: 698 TASK: c6a2c000 CPU: 1 COMMAND: \u0026#34;X\u0026#34; 119 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 120 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 121 122 PID: 2159 TASK: c4a5a000 CPU: 1 COMMAND: \u0026#34;kwm\u0026#34; 123 FD SOCKET SOCK FAMILY:TYPE SOURCE-PORT DESTINATION-PORT 124 5 c08ea3cc c50d3c80 INET:STREAM 0.0.0.0-1026 0.0.0.0-0 26. p - print the value of an expression 26.1. SYNOPSIS 1p [-x|-d][-u] [expression | symbol[:cpuspec]] 26.2. DESCRIPTION 1 This command passes its arguments on to gdb \u0026#34;print\u0026#34; command for evaluation. 2 3 expression an expression to be evaluated. 4 symbol a kernel symbol. 5 :cpuspec CPU specification for a per-cpu symbol: 6 : CPU of the currently selected task. 7 :a[ll] all CPUs. 8 :#[-#][,...] CPU list(s), e.g. \u0026#34;1,3,5\u0026#34;, \u0026#34;1-3\u0026#34;, 9 or \u0026#34;1,3,5-7,10\u0026#34;. 10 -x override default output format with hexadecimal format. 11 -d override default output format with decimal format. 12 -u the expression evaluates to a user address reference. 13 14 The default output format is decimal, but that can be changed at any time 15 with the two built-in aliases \u0026#34;hex\u0026#34; and \u0026#34;dec\u0026#34;. Alternatively, there 16 are two other built-in aliases, \u0026#34;px\u0026#34; and \u0026#34;pd\u0026#34;, which force the command 17 output to be displayed in hexadecimal or decimal, without changing the 18 default mode. 26.3. EXAMPLES 1 Print the contents of jiffies: 2 3 crash\u0026gt; p jiffies 4 jiffies = $6 = 166532620 5 crash\u0026gt; px jiffies 6 jiffies = $7 = 0x9ed174b 7 crash\u0026gt; pd jiffies 8 jiffies = $8 = 166533160 9 10 Print the contents of the vm_area_struct \u0026#34;init_mm\u0026#34;: 11 12 crash\u0026gt; p init_mm 13 init_mm = $5 = { 14 mmap = 0xc022d540, 15 mmap_avl = 0x0, 16 mmap_cache = 0x0, 17 pgd = 0xc0101000, 18 count = { 19 counter = 0x6 20 }, 21 map_count = 0x1, 22 mmap_sem = { 23 count = { 24 counter = 0x1 25 }, 26 waking = 0x0, 27 wait = 0x0 28 }, 29 context = 0x0, 30 start_code = 0xc0000000, 31 end_code = 0xc022b4c8, 32 start_data = 0x0, 33 end_data = 0xc0250388, 34 start_brk = 0x0, 35 brk = 0xc02928d8, 36 start_stack = 0x0, 37 arg_start = 0x0, 38 arg_end = 0x0, 39 env_start = 0x0, 40 env_end = 0x0, 41 rss = 0x0, 42 total_vm = 0x0, 43 locked_vm = 0x0, 44 def_flags = 0x0, 45 cpu_vm_mask = 0x0, 46 swap_cnt = 0x0, 47 swap_address = 0x0, 48 segments = 0x0 49 } 50 51 If a per-cpu symbol is entered as a argument, its data type 52 and all of its per-cpu addresses are displayed: 53 54 crash\u0026gt; p irq_stat 55 PER-CPU DATA TYPE: 56 irq_cpustat_t irq_stat; 57 PER-CPU ADDRESSES: 58 [0]: ffff88021e211540 59 [1]: ffff88021e251540 60 [2]: ffff88021e291540 61 [3]: ffff88021e2d1540 62 63 To display the contents a per-cpu symbol for CPU 1, append 64 a cpu-specifier: 65 66 crash\u0026gt; p irq_stat:1 67 per_cpu(irq_stat, 1) = $29 = { 68 __softirq_pending = 0, 69 __nmi_count = 209034, 70 apic_timer_irqs = 597509876, 71 irq_spurious_count = 0, 72 icr_read_retry_count = 2, 73 x86_platform_ipis = 0, 74 apic_perf_irqs = 209034, 75 apic_irq_work_irqs = 0, 76 irq_resched_count = 264922233, 77 irq_call_count = 7036692, 78 irq_tlb_count = 4750442, 79 irq_thermal_count = 0, 80 irq_threshold_count = 0 81 } 27. ps - display process status information 27.1. SYNOPSIS 1ps [-k|-u|-G|-y policy] [-s] [-p|-c|-t|-[l|m][-C cpu]|-a|-g|-r|-S|-A] 2 [pid | task | command] ... 27.2. DESCRIPTION 1 This command displays process status for selected, or all, processes 2 in the system. If no arguments are entered, the process data is 3 is displayed for all processes. Specific processes may be selected 4 by using the following identifier formats: 5 6 pid a process PID. 7 task a hexadecimal task_struct pointer. 8 command a command name. If a command name is made up of letters that 9 are all numerical values, precede the name string with a \u0026#34;\\\u0026#34;. 10 If the command string is enclosed within \u0026#34;\u0026#39;\u0026#34; characters, then 11 the encompassed string must be a POSIX extended regular expression 12 that will be used to match task names. 13 14 The process list may be further restricted by the following options: 15 16 -k restrict the output to only kernel threads. 17 -u restrict the output to only user tasks. 18 -G display only the thread group leader in a thread group. 19 -y policy restrict the output to tasks having a specified scheduling policy 20 expressed by its integer value or by its (case-insensitive) name; 21 multiple policies may be entered in a comma-separated list: 22 0 or NORMAL 23 1 or FIFO 24 2 or RR 25 3 or BATCH 26 4 or ISO 27 5 or IDLE 28 6 or DEADLINE 29 30 The process identifier types may be mixed. For each task, the following 31 items are displayed: 32 33 1. the process PID. 34 2. the parent process PID. 35 3. the CPU number that the task ran on last. 36 4. the task_struct address or the kernel stack pointer of the process. 37 (see -s option below) 38 5. the task state (RU, IN, UN, ZO, ST, TR, DE, SW, WA, PA, ID, NE). 39 6. the percentage of physical memory being used by this task. 40 7. the virtual address size of this task in kilobytes. 41 8. the resident set size of this task in kilobytes. 42 9. the command name. 43 44 The default output shows the task_struct address of each process under a 45 column titled \u0026#34;TASK\u0026#34;. This can be changed to show the kernel stack 46 pointer under a column titled \u0026#34;KSTACKP\u0026#34;. 47 48 -s replace the TASK column with the KSTACKP column. 49 50 On SMP machines, the active task on each CPU will be highlighted by an 51 angle bracket (\u0026#34;\u0026gt;\u0026#34;) preceding its information. If the crash variable 52 \u0026#34;offline\u0026#34; is set to \u0026#34;hide\u0026#34;, the active task on an offline CPU will 53 be highlighted by a \u0026#34;-\u0026#34; preceding its information. 54 55 Alternatively, information regarding parent-child relationships, 56 per-task time usage data, argument/environment data, thread groups, 57 or resource limits may be displayed: 58 59 -p display the parental hierarchy of selected, or all, tasks. 60 -c display the children of selected, or all, tasks. 61 -t display the task run time, start time, and cumulative user 62 and system times. 63 -l display the task\u0026#39;s last-run timestamp value, using either the 64 task_struct\u0026#39;s last_run value, the task_struct\u0026#39;s timestamp value 65 or the task_struct\u0026#39;s sched_entity last_arrival value, whichever 66 applies, of selected, or all, tasks; the list is sorted with the 67 most recently-run task (with the largest timestamp) shown first, 68 followed by the task\u0026#39;s current state. 69 -m similar to -l, but the timestamp value is translated into days, 70 hours, minutes, seconds, and milliseconds since the task was 71 last run on a cpu. 72 -C cpus only usable with the -l or -m options, dump the timestamp data 73 in per-cpu blocks, where the cpu[s] can be specified as \u0026#34;1,3,5\u0026#34;, 74 \u0026#34;1-3\u0026#34;, \u0026#34;1,3,5-7,10\u0026#34;, \u0026#34;all\u0026#34;, or \u0026#34;a\u0026#34; (shortcut for \u0026#34;all\u0026#34;). 75 -a display the command line arguments and environment strings of 76 selected, or all, user-mode tasks. 77 -g display tasks by thread group, of selected, or all, tasks. 78 -r display resource limits (rlimits) of selected, or all, tasks. 79 -S display a summary consisting of the number of tasks in a task state. 80 -A display only the active task on each cpu. 27.3. EXAMPLES 1 Show the process status of all current tasks: 2 3 crash\u0026gt; ps 4 PID PPID CPU TASK ST %MEM VSZ RSS COMM 5 \u0026gt; 0 0 3 c024c000 RU 0.0 0 0 [swapper] 6 \u0026gt; 0 0 0 c0dce000 RU 0.0 0 0 [swapper] 7 0 0 1 c0fa8000 RU 0.0 0 0 [swapper] 8 \u0026gt; 0 0 2 c009a000 RU 0.0 0 0 [swapper] 9 1 0 1 c0098000 IN 0.0 1096 476 init 10 2 1 1 c0090000 IN 0.0 0 0 [kflushd] 11 3 1 1 c000e000 IN 0.0 0 0 [kpiod] 12 4 1 3 c000c000 IN 0.0 0 0 [kswapd] 13 5 1 1 c0008000 IN 0.0 0 0 [mdrecoveryd] 14 253 1 2 fbc4c000 IN 0.0 1088 376 portmap 15 268 1 2 fbc82000 IN 0.1 1232 504 ypbind 16 274 268 2 fa984000 IN 0.1 1260 556 ypbind 17 321 1 1 fabf6000 IN 0.1 1264 608 syslogd 18 332 1 1 fa9be000 RU 0.1 1364 736 klogd 19 346 1 2 fae88000 IN 0.0 1112 472 atd 20 360 1 2 faeb2000 IN 0.1 1284 592 crond 21 378 1 2 fafd6000 IN 0.1 1236 560 inetd 22 392 1 0 fb710000 IN 0.1 2264 1468 named 23 406 1 3 fb768000 IN 0.1 1284 560 lpd 24 423 1 1 fb8ac000 IN 0.1 1128 528 rpc.statd 25 434 1 2 fb75a000 IN 0.0 1072 376 rpc.rquotad 26 445 1 2 fb4a4000 IN 0.0 1132 456 rpc.mountd 27 460 1 1 fa938000 IN 0.0 0 0 [nfsd] 28 461 1 1 faa86000 IN 0.0 0 0 [nfsd] 29 462 1 0 fac48000 IN 0.0 0 0 [nfsd] 30 463 1 0 fb4ca000 IN 0.0 0 0 [nfsd] 31 464 1 0 fb4c8000 IN 0.0 0 0 [nfsd] 32 465 1 2 fba6e000 IN 0.0 0 0 [nfsd] 33 466 1 1 fba6c000 IN 0.0 0 0 [nfsd] 34 467 1 2 fac04000 IN 0.0 0 0 [nfsd] 35 468 461 2 fa93a000 IN 0.0 0 0 [lockd] 36 469 468 2 fa93e000 IN 0.0 0 0 [rpciod] 37 486 1 0 fab54000 IN 0.1 1596 880 amd 38 523 1 2 fa84e000 IN 0.1 1884 1128 sendmail 39 538 1 0 fa82c000 IN 0.0 1112 416 gpm 40 552 1 3 fa70a000 IN 0.1 2384 1220 httpd 41 556 552 3 fa776000 IN 0.1 2572 1352 httpd 42 557 552 2 faba4000 IN 0.1 2572 1352 httpd 43 558 552 1 fa802000 IN 0.1 2572 1352 httpd 44 559 552 3 fa6ee000 IN 0.1 2572 1352 httpd 45 560 552 3 fa700000 IN 0.1 2572 1352 httpd 46 561 552 0 fa6f0000 IN 0.1 2572 1352 httpd 47 562 552 3 fa6ea000 IN 0.1 2572 1352 httpd 48 563 552 0 fa67c000 IN 0.1 2572 1352 httpd 49 564 552 3 fa674000 IN 0.1 2572 1352 httpd 50 565 552 3 fa66a000 IN 0.1 2572 1352 httpd 51 582 1 2 fa402000 IN 0.2 2968 1916 xfs 52 633 1 2 fa1ec000 IN 0.2 5512 2248 innd 53 636 1 3 fa088000 IN 0.1 2536 804 actived 54 676 1 0 fa840000 IN 0.0 1060 384 mingetty 55 677 1 1 fa590000 IN 0.0 1060 384 mingetty 56 678 1 2 fa3b8000 IN 0.0 1060 384 mingetty 57 679 1 0 fa5b8000 IN 0.0 1060 384 mingetty 58 680 1 1 fa3a4000 IN 0.0 1060 384 mingetty 59 681 1 2 fa30a000 IN 0.0 1060 384 mingetty 60 683 1 3 fa5d8000 IN 0.0 1052 280 update 61 686 378 1 fa3aa000 IN 0.1 2320 1136 in.rlogind 62 687 686 2 f9e52000 IN 0.1 2136 1000 login 63 688 687 0 f9dec000 IN 0.1 1732 976 bash 64 \u0026gt; 700 688 1 f9d62000 RU 0.0 1048 256 gen12 65 66 Display the parental hierarchy of the \u0026#34;crash\u0026#34; process on a live system: 67 68 crash\u0026gt; ps -p 4249 69 PID: 0 TASK: c0252000 CPU: 0 COMMAND: \u0026#34;swapper\u0026#34; 70 PID: 1 TASK: c009a000 CPU: 1 COMMAND: \u0026#34;init\u0026#34; 71 PID: 632 TASK: c73b6000 CPU: 1 COMMAND: \u0026#34;prefdm\u0026#34; 72 PID: 637 TASK: c5a4a000 CPU: 1 COMMAND: \u0026#34;prefdm\u0026#34; 73 PID: 649 TASK: c179a000 CPU: 0 COMMAND: \u0026#34;kwm\u0026#34; 74 PID: 683 TASK: c1164000 CPU: 0 COMMAND: \u0026#34;kfm\u0026#34; 75 PID: 1186 TASK: c165a000 CPU: 0 COMMAND: \u0026#34;xterm\u0026#34; 76 PID: 1188 TASK: c705e000 CPU: 1 COMMAND: \u0026#34;bash\u0026#34; 77 PID: 4249 TASK: c6b9a000 CPU: 0 COMMAND: \u0026#34;crash\u0026#34; 78 79 Display all children of the \u0026#34;kwm\u0026#34; window manager: 80 81 crash\u0026gt; ps -c kwm 82 PID: 649 TASK: c179a000 CPU: 0 COMMAND: \u0026#34;kwm\u0026#34; 83 PID: 682 TASK: c2d58000 CPU: 1 COMMAND: \u0026#34;kwmsound\u0026#34; 84 PID: 683 TASK: c1164000 CPU: 1 COMMAND: \u0026#34;kfm\u0026#34; 85 PID: 685 TASK: c053c000 CPU: 0 COMMAND: \u0026#34;krootwm\u0026#34; 86 PID: 686 TASK: c13fa000 CPU: 0 COMMAND: \u0026#34;kpanel\u0026#34; 87 PID: 687 TASK: c13f0000 CPU: 1 COMMAND: \u0026#34;kbgndwm\u0026#34; 88 89 Display all threads in a firefox session: 90 91 crash\u0026gt; ps firefox 92 PID PPID CPU TASK ST %MEM VSZ RSS COMM 93 21273 21256 6 ffff81003ec15080 IN 46.3 1138276 484364 firefox 94 21276 21256 6 ffff81003f49e7e0 IN 46.3 1138276 484364 firefox 95 21280 21256 0 ffff81003ec1d7e0 IN 46.3 1138276 484364 firefox 96 21286 21256 6 ffff81000b0d1820 IN 46.3 1138276 484364 firefox 97 21287 21256 2 ffff81000b0d10c0 IN 46.3 1138276 484364 firefox 98 26975 21256 5 ffff81003b5c1820 IN 46.3 1138276 484364 firefox 99 26976 21256 5 ffff810023232820 IN 46.3 1138276 484364 firefox 100 26977 21256 4 ffff810021a11820 IN 46.3 1138276 484364 firefox 101 26978 21256 5 ffff810003159040 IN 46.3 1138276 484364 firefox 102 26979 21256 5 ffff81003a058820 IN 46.3 1138276 484364 firefox 103 104 Display only the thread group leader in the firefox session: 105 106 crash\u0026gt; ps -G firefox 107 PID PPID CPU TASK ST %MEM VSZ RSS COMM 108 21273 21256 0 ffff81003ec15080 IN 46.3 1138276 484364 firefox 109 110 Show the time usage data for pid 10318: 111 112 crash\u0026gt; ps -t 10318 113 PID: 10318 TASK: f7b85550 CPU: 5 COMMAND: \u0026#34;bash\u0026#34; 114 RUN TIME: 1 days, 01:35:32 115 START TIME: 5209 116 UTIME: 95 117 STIME: 57 118 119 Show the process status of PID 1, task f9dec000, and all nfsd tasks: 120 121 crash\u0026gt; ps 1 f9dec000 nfsd 122 PID PPID CPU TASK ST %MEM VSZ RSS COMM 123 1 0 1 c0098000 IN 0.0 1096 476 init 124 688 687 0 f9dec000 IN 0.1 1732 976 bash 125 460 1 1 fa938000 IN 0.0 0 0 [nfsd] 126 461 1 1 faa86000 IN 0.0 0 0 [nfsd] 127 462 1 0 fac48000 IN 0.0 0 0 [nfsd] 128 463 1 0 fb4ca000 IN 0.0 0 0 [nfsd] 129 464 1 0 fb4c8000 IN 0.0 0 0 [nfsd] 130 465 1 2 fba6e000 IN 0.0 0 0 [nfsd] 131 466 1 1 fba6c000 IN 0.0 0 0 [nfsd] 132 467 1 2 fac04000 IN 0.0 0 0 [nfsd] 133 134 Show all kernel threads: 135 136 crash\u0026gt; ps -k 137 PID PPID CPU TASK ST %MEM VSZ RSS COMM 138 0 0 1 c0fac000 RU 0.0 0 0 [swapper] 139 0 0 0 c0252000 RU 0.0 0 0 [swapper] 140 2 1 1 c0fa0000 IN 0.0 0 0 [kflushd] 141 3 1 1 c03de000 IN 0.0 0 0 [kpiod] 142 4 1 1 c03dc000 IN 0.0 0 0 [kswapd] 143 5 1 0 c0092000 IN 0.0 0 0 [mdrecoveryd] 144 336 1 0 c4a9a000 IN 0.0 0 0 [rpciod] 145 337 1 0 c4830000 IN 0.0 0 0 [lockd] 146 487 1 1 c4ba6000 IN 0.0 0 0 [nfsd] 147 488 1 0 c18c6000 IN 0.0 0 0 [nfsd] 148 489 1 0 c0cac000 IN 0.0 0 0 [nfsd] 149 490 1 0 c056a000 IN 0.0 0 0 [nfsd] 150 491 1 0 c0860000 IN 0.0 0 0 [nfsd] 151 492 1 1 c0254000 IN 0.0 0 0 [nfsd] 152 493 1 0 c0a86000 IN 0.0 0 0 [nfsd] 153 494 1 0 c0968000 IN 0.0 0 0 [nfsd] 154 155 Display a summary consisting of the number of tasks in a task state: 156 157 crash\u0026gt; ps -S 158 RU: 5 159 IN: 259 160 UN: 31 161 ZO: 1 162 163 Display only the active task, on each cpu: 164 165 crash\u0026gt; ps -A 166 PID PPID CPU TASK ST %MEM VSZ RSS COMM 167 \u0026gt; 10 2 1 ffff880212969710 IN 0.0 0 0 [migration/1] 168 \u0026gt; 0 0 3 ffff884026d43520 RU 0.0 0 0 [swapper] 169 \u0026gt; 6582 1 2 ffff880f49c52040 RU 0.0 42202472 33368 oracle 170 \u0026gt; 9497 1 0 ffff880549ec2ab0 RU 0.0 42314692 138664 oracle 171 172 Show all tasks sorted by their task_struct\u0026#39;s last_run, timestamp, or 173 sched_entity last_arrival timestamp value, whichever applies: 174 175 crash\u0026gt; ps -l 176 [20811245123] [IN] PID: 37 TASK: f7153030 CPU: 2 COMMAND: \u0026#34;events/2\u0026#34; 177 [20811229959] [IN] PID: 1756 TASK: f2a5a570 CPU: 2 COMMAND: \u0026#34;ntpd\u0026#34; 178 [20800696644] [IN] PID: 1456 TASK: f2b1f030 CPU: 4 COMMAND: \u0026#34;irqbalance\u0026#34; 179 [20617047229] [IN] PID: 2324 TASK: f57f9570 CPU: 5 COMMAND: \u0026#34;flush-253:0\u0026#34; 180 [20617029209] [IN] PID: 49 TASK: f7167030 CPU: 4 COMMAND: \u0026#34;bdi-default\u0026#34; 181 [20438025365] [IN] PID: 345 TASK: f55c7ab0 CPU: 3 COMMAND: \u0026#34;mpt_poll_0\u0026#34; 182 [20103026046] [IN] PID: 728 TASK: f72ba570 CPU: 3 COMMAND: \u0026#34;edac-poller\u0026#34; 183 [20000189409] [IN] PID: 35 TASK: f7153ab0 CPU: 0 COMMAND: \u0026#34;events/0\u0026#34; 184 [20000179905] [IN] PID: 48 TASK: f7167570 CPU: 0 COMMAND: \u0026#34;sync_supers\u0026#34; 185 [19997120354] [IN] PID: 36 TASK: f7153570 CPU: 1 COMMAND: \u0026#34;events/1\u0026#34; 186 [19991059209] [IN] PID: 38 TASK: f715fab0 CPU: 3 COMMAND: \u0026#34;events/3\u0026#34; 187 [19988091608] [IN] PID: 39 TASK: f715f570 CPU: 4 COMMAND: \u0026#34;events/4\u0026#34; 188 [19985076530] [IN] PID: 40 TASK: f715f030 CPU: 5 COMMAND: \u0026#34;events/5\u0026#34; 189 [19982019106] [IN] PID: 41 TASK: f7161ab0 CPU: 6 COMMAND: \u0026#34;events/6\u0026#34; 190 [19982016294] [IN] PID: 29 TASK: f7109ab0 CPU: 6 COMMAND: \u0026#34;ksoftirqd/6\u0026#34; 191 [19838402345] [RU] PID: 2331 TASK: f297f570 CPU: 7 COMMAND: \u0026#34;bash\u0026#34; 192 [19837129436] [IN] PID: 2326 TASK: f2ad5030 CPU: 6 COMMAND: \u0026#34;sshd\u0026#34; 193 [19289476417] [IN] PID: 1772 TASK: f5665570 CPU: 5 COMMAND: \u0026#34;sendmail\u0026#34; 194 ... 195 196 Show the most-recently run tasks on cpu 0 using both the -l and the -m 197 options: 198 199 crash\u0026gt; ps -m -C0 200 CPU: 0 201 [ 0 00:00:00.003] [RU] PID: 1205 TASK: dee03f20 CPU: 0 COMMAND: \u0026#34;insmod\u0026#34; 202 [ 0 00:00:00.006] [RU] PID: 770 TASK: df9e9940 CPU: 0 COMMAND: \u0026#34;rsyslogd\u0026#34; 203 [ 0 00:00:00.009] [IN] PID: 603 TASK: df9bcbc0 CPU: 0 COMMAND: \u0026#34;udevd\u0026#34; 204 [ 0 00:00:00.010] [IN] PID: 348 TASK: df9ecbc0 CPU: 0 COMMAND: \u0026#34;udevd\u0026#34; 205 [ 0 00:00:00.013] [IN] PID: 934 TASK: df9171a0 CPU: 0 COMMAND: \u0026#34;hald\u0026#34; 206 [ 0 00:00:00.023] [IN] PID: 6 TASK: df443f20 CPU: 0 COMMAND: \u0026#34;events/0\u0026#34; 207 [ 0 00:00:00.029] [IN] PID: 15 TASK: df46b280 CPU: 0 COMMAND: \u0026#34;kblockd/0\u0026#34; 208 [ 0 00:00:00.101] [IN] PID: 1168 TASK: dee01940 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 209 [ 0 00:00:01.404] [IN] PID: 272 TASK: dfa48ca0 CPU: 0 COMMAND: \u0026#34;flush-8:0\u0026#34; 210 ... 211 212 crash\u0026gt; ps -l -C0 213 CPU: 0 214 [137146164748] [RU] PID: 1205 TASK: dee03f20 CPU: 0 COMMAND: \u0026#34;insmod\u0026#34; 215 [137142534372] [RU] PID: 770 TASK: df9e9940 CPU: 0 COMMAND: \u0026#34;rsyslogd\u0026#34; 216 [137140168469] [IN] PID: 603 TASK: df9bcbc0 CPU: 0 COMMAND: \u0026#34;udevd\u0026#34; 217 [137138826427] [IN] PID: 348 TASK: df9ecbc0 CPU: 0 COMMAND: \u0026#34;udevd\u0026#34; 218 [137135214599] [IN] PID: 934 TASK: df9171a0 CPU: 0 COMMAND: \u0026#34;hald\u0026#34; 219 [137125651275] [IN] PID: 6 TASK: df443f20 CPU: 0 COMMAND: \u0026#34;events/0\u0026#34; 220 [137119564815] [IN] PID: 15 TASK: df46b280 CPU: 0 COMMAND: \u0026#34;kblockd/0\u0026#34; 221 [137047715027] [IN] PID: 1168 TASK: dee01940 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 222 [135744209052] [IN] PID: 272 TASK: dfa48ca0 CPU: 0 COMMAND: \u0026#34;flush-8:0\u0026#34; 223 ... 224 225 Show the kernel stack pointer of each user task: 226 227 crash\u0026gt; ps -us 228 PID PPID CPU KSTACKP ST %MEM VSZ RSS COMM 229 1 0 0 c009bedc IN 0.0 1096 52 init 230 239 1 0 c15e7ed8 IN 0.2 1332 224 pump 231 280 1 1 c7cbdedc IN 0.2 1092 208 portmap 232 295 1 0 c7481edc IN 0.0 1232 0 ypbind 233 301 295 0 c7c7bf28 IN 0.1 1260 124 ypbind 234 376 1 1 c5053f28 IN 0.0 1316 40 automount 235 381 1 0 c34ddf28 IN 0.2 1316 224 automount 236 391 1 1 c2777f28 IN 0.2 1316 224 automount 237 ... 238 239 Display the argument and environment data for the automount task: 240 241 crash\u0026gt; ps -a automount 242 PID: 3948 TASK: f722ee30 CPU: 0 COMMAND: \u0026#34;automount\u0026#34; 243 ARG: /usr/sbin/automount --timeout=60 /net program /etc/auto.net 244 ENV: SELINUX_INIT=YES 245 CONSOLE=/dev/console 246 TERM=linux 247 INIT_VERSION=sysvinit-2.85 248 PATH=/sbin:/usr/sbin:/bin:/usr/bin 249 LC_MESSAGES=en_US 250 RUNLEVEL=3 251 runlevel=3 252 PWD=/ 253 LANG=ja_JP.UTF-8 254 PREVLEVEL=N 255 previous=N 256 HOME=/ 257 SHLVL=2 258 _=/usr/sbin/automount 259 260 Display the tasks in the thread group containing task c20ab0b0: 261 262 crash\u0026gt; ps -g c20ab0b0 263 PID: 6425 TASK: f72f50b0 CPU: 0 COMMAND: \u0026#34;firefox-bin\u0026#34; 264 PID: 6516 TASK: f71bf1b0 CPU: 0 COMMAND: \u0026#34;firefox-bin\u0026#34; 265 PID: 6518 TASK: d394b930 CPU: 0 COMMAND: \u0026#34;firefox-bin\u0026#34; 266 PID: 6520 TASK: c20aa030 CPU: 0 COMMAND: \u0026#34;firefox-bin\u0026#34; 267 PID: 6523 TASK: c20ab0b0 CPU: 0 COMMAND: \u0026#34;firefox-bin\u0026#34; 268 PID: 6614 TASK: f1f181b0 CPU: 0 COMMAND: \u0026#34;firefox-bin\u0026#34; 269 270 Display the tasks in the thread group for each instance of the 271 program named \u0026#34;multi-thread\u0026#34;: 272 273 crash\u0026gt; ps -g multi-thread 274 PID: 2522 TASK: 1003f0dc7f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 275 PID: 2523 TASK: 10037b13030 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 276 PID: 2524 TASK: 1003e064030 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 277 PID: 2525 TASK: 1003e13a7f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 278 279 PID: 2526 TASK: 1002f82b7f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 280 PID: 2527 TASK: 1003e1737f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 281 PID: 2528 TASK: 10035b4b7f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 282 PID: 2529 TASK: 1003f0c37f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 283 PID: 2530 TASK: 10035597030 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 284 PID: 2531 TASK: 100184be7f0 CPU: 1 COMMAND: \u0026#34;multi-thread\u0026#34; 285 286 Display the resource limits of \u0026#34;bash\u0026#34; task 13896: 287 288 crash\u0026gt; ps -r 13896 289 PID: 13896 TASK: cf402000 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 290 RLIMIT CURRENT MAXIMUM 291 CPU (unlimited) (unlimited) 292 FSIZE (unlimited) (unlimited) 293 DATA (unlimited) (unlimited) 294 STACK 10485760 (unlimited) 295 CORE (unlimited) (unlimited) 296 RSS (unlimited) (unlimited) 297 NPROC 4091 4091 298 NOFILE 1024 1024 299 MEMLOCK 4096 4096 300 AS (unlimited) (unlimited) 301 LOCKS (unlimited) (unlimited) 302 303 Search for task names matching a POSIX regular expression: 304 305 crash\u0026gt; ps \u0026#39;migration*\u0026#39; 306 PID PPID CPU TASK ST %MEM VSZ RSS COMM 307 8 2 0 ffff8802128a2e20 IN 0.0 0 0 [migration/0] 308 10 2 1 ffff880212969710 IN 0.0 0 0 [migration/1] 309 15 2 2 ffff880212989710 IN 0.0 0 0 [migration/2] 310 20 2 3 ffff8802129a9710 IN 0.0 0 0 [migration/3] 28. pte - translate a page table entry 28.1. SYNOPSIS 1pte contents ... 28.2. DESCRIPTION 1 This command translates the hexadecimal contents of a PTE into its physical 2 page address and page bit settings. If the PTE references a swap location, 3 the swap device and offset are displayed. 28.3. EXAMPLES 1 2 crash\u0026gt; pte d8e067 3 PTE PHYSICAL FLAGS 4 d8e067 d8e000 (PRESENT|RW|USER|ACCESSED|DIRTY) 5 6 crash\u0026gt; pte 13f600 7 PTE SWAP OFFSET 8 13f600 /dev/hda2 5104 29. ptob - page to bytes 29.1. SYNOPSIS 1ptob page_number ... 29.2. DESCRIPTION 1 This command translates a page frame number to its byte value. 29.3. EXAMPLES 1 crash\u0026gt; ptob 512a 2 512a: 512a000 30. ptov - physical to virtual per-cpu to virtual 30.1. SYNOPSIS 1ptov [address | offset:cpuspec] 30.2. DESCRIPTION 1 This command translates a hexadecimal physical address into a kernel 2 virtual address. Alternatively, a hexadecimal per-cpu offset and 3 cpu specifier will be translated into kernel virtual addresses for 4 each cpu specified. 5 6 address a physical address 7 offset:cpuspec a per-cpu offset with a CPU specifier: 8 : CPU of the currently selected task. 9 :a[ll] all CPUs. 10 :#[-#][,...] CPU list(s), e.g. \u0026#34;1,3,5\u0026#34;, \u0026#34;1-3\u0026#34;, 11 or \u0026#34;1,3,5-7,10\u0026#34;. 30.3. EXAMPLES 1 Translate physical address 56e000 into a kernel virtual address: 2 3 crash\u0026gt; ptov 56e000 4 VIRTUAL PHYSICAL 5 ffff88000056e000 56e000 6 7 Translate per-cpu offset b0c0 into a kernel virtual address for 8 all cpus: 9 10 crash\u0026gt; ptov b0c0:a 11 PER-CPU OFFSET: b0c0 12 CPU VIRTUAL 13 [0] ffff88021e20b0c0 14 [1] ffff88021e24b0c0 15 [2] ffff88021e28b0c0 16 [3] ffff88021e2cb0c0 31. q - exit this session 31.1. SYNOPSIS 1q 31.2. DESCRIPTION 1 Bail out of the current crash session. 31.3. NOTE 1 This command is equivalent to the \u0026#34;exit\u0026#34; command. 32. rd - read memory 32.1. SYNOPSIS 1rd [-adDsSupxmfNR][-8|-16|-32|-64][-o offs][-e addr][-r file][address|symbol] 2 [count] 32.2. DESCRIPTION 1 This command displays the contents of memory, with the output formatted 2 in several different manners. The starting address may be entered either 3 symbolically or by address. The default output size is the size of a long 4 data type, and the default output format is hexadecimal. When hexadecimal 5 output is used, the output will be accompanied by an ASCII translation. 6 7 -p address argument is a physical address. 8 -u address argument is a user virtual address; only required on 9 processors with common user and kernel virtual address spaces. 10 -m address argument is a xen host machine address. 11 -f address argument is a dumpfile offset. 12 -d display output in signed decimal format (default is hexadecimal). 13 -D display output in unsigned decimal format (default is hexadecimal). 14 -s displays output symbolically when appropriate. 15 -S[S] displays output symbolically when appropriate; if the memory 16 contents reference a slab cache object, the name of the slab cache 17 will be displayed in brackets. If -S is entered twice, and the 18 memory contents reference a slab cache object, both the memory 19 contents and the name of the slab cache will be displayed in 20 brackets. 21 -x do not display ASCII translation at end of each line. 22 -8 display output in 8-bit values. 23 -16 display output in 16-bit values. 24 -32 display output in 32-bit values (default on 32-bit machines). 25 -64 display output in 64-bit values (default on 64-bit machines). 26 -a display output in ASCII characters if the memory contains printable 27 ASCII characters; if no count argument is entered, stop at the first 28 non-printable character. 29 -N display output in network byte order (only valid for 16- and 32-bit 30 values) 31 -R display memory in reverse order; memory will be displayed up to and 32 including the address argument, requiring the count argument to be 33 greater than 1 in order to display memory before the specified 34 address. 35 -o offs offset the starting address by offs. 36 -e addr display memory until reaching specified ending hexadecimal address. 37 -r file dumps raw data to the specified output file; the number of bytes that 38 are copied to the file must be specified either by a count argument 39 or by the -e option. 40 address starting hexadecimal address: 41 1 the default presumes a kernel virtual address. 42 2. -p specifies a physical address. 43 3. -u specifies a user virtual address, but is only necessary on 44 processors with common user and kernel virtual address spaces. 45 symbol symbol of starting address to read. 46 count number of memory locations to display; if entered, it must be the 47 last argument on the command line; if not entered, the count defaults 48 to 1, or unlimited for -a; when used with the -r option, it is the 49 number of bytes to be written to the file. 32.3. EXAMPLES 1 Display the kernel\u0026#39;s version string: 2 3 crash\u0026gt; rd -a linux_banner 4 c082a020: Linux version 2.6.32-119.el6.i686 (mockbuild@hs20-bc2-4.buil 5 c082a05c: d.redhat.com) (gcc version 4.4.4 20100726 (Red Hat 4.4.4-13) 6 c082a098: (GCC) ) #1 SMP Tue Mar 1 18:16:57 EST 2011 7 8 Display the same block of memory, first without symbols, again 9 with symbols, and then with symbols and slab cache references: 10 11 crash\u0026gt; rd f6e31f70 28 12 f6e31f70: f6e31f6c f779c180 c04a4032 00a9dd40 l.....y.2@J.@... 13 f6e31f80: 00000fff c0472da0 f6e31fa4 f779c180 .....-G.......y. 14 f6e31f90: fffffff7 00a9b70f f6e31000 c04731ee .............1G. 15 f6e31fa0: f6e31fa4 00000000 00000000 00000000 ................ 16 f6e31fb0: 00000000 00a9dd40 c0404f17 00000000 ....@....O@..... 17 f6e31fc0: 00a9dd40 00000fff 00a9dd40 00a9b70f @.......@....... 18 f6e31fd0: bf9e2718 ffffffda c040007b 0000007b .\u0026#39;......{.@.{... 19 crash\u0026gt; rd -s f6e31f70 28 20 f6e31f70: f6e31f6c f779c180 kmsg_read 00a9dd40 21 f6e31f80: 00000fff vfs_read+159 f6e31fa4 f779c180 22 f6e31f90: fffffff7 00a9b70f f6e31000 sys_read+60 23 f6e31fa0: f6e31fa4 00000000 00000000 00000000 24 f6e31fb0: 00000000 00a9dd40 syscall_call+7 00000000 25 f6e31fc0: 00a9dd40 00000fff 00a9dd40 00a9b70f 26 f6e31fd0: bf9e2718 ffffffda startup_32+123 0000007b 27 crash\u0026gt; rd -S f6e31f70 28 28 f6e31f70: [size-4096] [filp] kmsg_read 00a9dd40 29 f6e31f80: 00000fff vfs_read+159 [size-4096] [filp] 30 f6e31f90: fffffff7 00a9b70f [size-4096] sys_read+60 31 f6e31fa0: [size-4096] 00000000 00000000 00000000 32 f6e31fb0: 00000000 00a9dd40 syscall_call+7 00000000 33 f6e31fc0: 00a9dd40 00000fff 00a9dd40 00a9b70f 34 f6e31fd0: bf9e2718 ffffffda startup_32+123 0000007b 35 crash\u0026gt; rd -SS f6e31f70 28 36 f6e31f70: [f6e31f6c:size-4096] [f779c180:filp] kmsg_read 00a9dd40 37 f6e31f80: 00000fff vfs_read+159 [f6e31fa4:size-4096] [f779c180:filp] 38 f6e31f90: fffffff7 00a9b70f [f6e31000:size-4096] sys_read+60 39 f6e31fa0: [f6e31fa4:size-4096] 00000000 00000000 00000000 40 f6e31fb0: 00000000 00a9dd40 syscall_call+7 00000000 41 f6e31fc0: 00a9dd40 00000fff 00a9dd40 00a9b70f 42 f6e31fd0: bf9e2718 ffffffda startup_32+123 0000007b 43 44 Read jiffies in hexadecimal and decimal format: 45 46 crash\u0026gt; rd jiffies 47 c0213ae0: 0008cc3a :... 48 49 crash\u0026gt; rd -d jiffies 50 c0213ae0: 577376 51 52 Access the same memory in different sizes: 53 54 crash\u0026gt; rd -64 kernel_version 55 c0226a6c: 35312d352e322e32 2.2.5-15 56 57 crash\u0026gt; rd -32 kernel_version 2 58 c0226a6c: 2e322e32 35312d35 2.2.5-15 59 60 crash\u0026gt; rd -16 kernel_version 4 61 c0226a6c: 2e32 2e32 2d35 3531 2.2.5-15 62 63 crash\u0026gt; rd -8 kernel_version 8 64 c0226a6c: 32 2e 32 2e 35 2d 31 35 2.2.5-15 65 66 Read the range of memory from c009bf2c to c009bf60: 67 68 crash\u0026gt; rd c009bf2c -e c009bf60 69 c009bf2c: c009bf64 c01328c3 c009bf64 c0132838 d....(..d...8(.. 70 c009bf3c: 0000002a 00000004 c57d77e8 00000104 *........w}..... 71 c009bf4c: 0000000b c009a000 7fffffff 00000000 ................ 72 c009bf5c: 00000000 .... 33. repeat - repeat a command 33.1. SYNOPSIS 1repeat [-seconds] command 33.2. DESCRIPTION 1 This command repeats a command indefinitely, optionally delaying a given 2 number of seconds between each command execution. 3 4 -seconds The number of seconds to delay between command executions. 5 This option must precede the command name to be executed. 6 7 Command execution may be stopped with CTRL-C, or if scrolling is in effect, 8 by entering \u0026#34;q\u0026#34;. This command is meant for use on a live system; it is 9 hard to conceive of a reason to use it when debugging a crash dump. 33.3. EXAMPLES 1 Display the value of jiffies once per second: 2 3 crash\u0026gt; repeat -1 p jiffies 4 jiffies = $1 = 155551079 5 jiffies = $2 = 155551180 6 jiffies = $3 = 155551281 7 jiffies = $4 = 155551382 8 jiffies = $5 = 155551483 9 jiffies = $6 = 155551584 10 jiffies = $7 = 155551685 11 jiffies = $8 = 155551786 12 jiffies = $9 = 155551887 13 jiffies = $10 = 155551988 14 jiffies = $11 = 155552089 15 jiffies = $12 = 155552190 16 jiffies = $13 = 155552291 17 jiffies = $14 = 155552392 18 jiffies = $15 = 155552493 19 jiffies = $16 = 155552594 20 jiffies = $17 = 155552695 21 jiffies = $18 = 155552796 22 ... 34. runq - run queue 34.1. SYNOPSIS 1runq [-t] [-T] [-m] [-g] [-c cpu(s)] 34.2. DESCRIPTION 1 With no argument, this command displays the tasks on the run queues 2 of each cpu. 3 4 -t Display the timestamp information of each cpu\u0026#39;s runqueue, which is the 5 rq.clock, rq.most_recent_timestamp or rq.timestamp_last_tick value, 6 whichever applies; following each cpu timestamp is the last_run or 7 timestamp value of the active task on that cpu, whichever applies, 8 along with the task identification. 9 -T Display the time lag of each CPU relative to the most recent runqueue 10 timestamp. 11 -m Display the amount of time that the active task on each cpu has been 12 running, expressed in a format consisting of days, hours, minutes, 13 seconds and milliseconds. 14 -g Display tasks hierarchically by task_group. The task_group line shows 15 the task_group address, the cfs_rq or rt_rq address, the task_group 16 name (if any), and whether the task_group is throttled. 17 -c cpu restrict the output to the run queue data of one or more CPUs, 18 which can be specified using the format \u0026#34;3\u0026#34;, \u0026#34;1,8,9\u0026#34;, \u0026#34;1-23\u0026#34;, 19 or \u0026#34;1,8,9-14\u0026#34;. 34.3. EXAMPLES 1 Display the tasks on an O(1) scheduler run queue: 2 3 crash\u0026gt; runq 4 CPU 0 RUNQUEUE: ffff880001cdb460 5 CURRENT: PID: 2739 TASK: ffff8800320fa7e0 COMMAND: \u0026#34;bash\u0026#34; 6 ACTIVE PRIO_ARRAY: ffff880001cdb4d8 7 [115] PID: 2739 TASK: ffff8800320fa7e0 COMMAND: \u0026#34;bash\u0026#34; 8 PID: 1776 TASK: ffff88003217d820 COMMAND: \u0026#34;syslogd\u0026#34; 9 EXPIRED PRIO_ARRAY: ffff880001cdbdb8 10 [no tasks queued] 11 12 CPU 1 RUNQUEUE: ffff880001ce3460 13 CURRENT: PID: 1779 TASK: ffff88003207a860 COMMAND: \u0026#34;klogd\u0026#34; 14 ACTIVE PRIO_ARRAY: ffff880001ce34d8 15 [115] PID: 1779 TASK: ffff88003207a860 COMMAND: \u0026#34;klogd\u0026#34; 16 EXPIRED PRIO_ARRAY: ffff880001ce3db8 17 [no tasks queued] 18 19 Display the tasks on a CFS run queue: 20 21 crash\u0026gt; runq 22 CPU 0 RUNQUEUE: ffff8800090436c0 23 CURRENT: PID: 588 TASK: ffff88007e4877a0 COMMAND: \u0026#34;udevd\u0026#34; 24 RT PRIO_ARRAY: ffff8800090437c8 25 [no tasks queued] 26 CFS RB_ROOT: ffff880009043740 27 [118] PID: 2110 TASK: ffff88007d470860 COMMAND: \u0026#34;check-cdrom.sh\u0026#34; 28 [118] PID: 2109 TASK: ffff88007f1247a0 COMMAND: \u0026#34;check-cdrom.sh\u0026#34; 29 [118] PID: 2114 TASK: ffff88007f20e080 COMMAND: \u0026#34;udevd\u0026#34; 30 31 CPU 1 RUNQUEUE: ffff88000905b6c0 32 CURRENT: PID: 2113 TASK: ffff88007e8ac140 COMMAND: \u0026#34;udevd\u0026#34; 33 RT PRIO_ARRAY: ffff88000905b7c8 34 [no tasks queued] 35 CFS RB_ROOT: ffff88000905b740 36 [118] PID: 2092 TASK: ffff88007d7a4760 COMMAND: \u0026#34;MAKEDEV\u0026#34; 37 [118] PID: 1983 TASK: ffff88007e59f140 COMMAND: \u0026#34;udevd\u0026#34; 38 [118] PID: 2064 TASK: ffff88007e40f7a0 COMMAND: \u0026#34;udevd\u0026#34; 39 [115] PID: 2111 TASK: ffff88007e4278a0 COMMAND: \u0026#34;kthreadd\u0026#34; 40 41 Display run queue timestamp data: 42 43 crash\u0026gt; runq -t 44 CPU 0: 2680990637359 45 2680986653330 PID: 28228 TASK: ffff880037ca2ac0 COMMAND: \u0026#34;loop\u0026#34; 46 CPU 1: 2680940618478 47 2680940618478 PID: 28167 TASK: ffff880078130040 COMMAND: \u0026#34;bash\u0026#34; 48 CPU 2: 2680990763425 49 2680986785772 PID: 28227 TASK: ffff8800787780c0 COMMAND: \u0026#34;loop\u0026#34; 50 CPU 3: 2680990954469 51 2680986059540 PID: 28226 TASK: ffff880078778b00 COMMAND: \u0026#34;loop\u0026#34; 52 53 Display the amount of time the active task on each cpu has been running: 54 55 crash\u0026gt; runq -m 56 CPU 0: [0 00:00:00.014] PID: 5275 TASK: f5dbcaa0 COMMAND: \u0026#34;sh\u0026#34; 57 CPU 1: [0 00:00:00.002] PID: 5203 TASK: f5c7baa0 COMMAND: \u0026#34;cat\u0026#34; 58 CPU 2: [0 00:00:00.014] PID: 7971 TASK: f5c6c550 COMMAND: \u0026#34;khelper\u0026#34; 59 CPU 3: [0 00:00:00.002] PID: 0 TASK: f4ccd000 COMMAND: \u0026#34;swapper\u0026#34; 60 61 Display tasks hierarchically by task_group: 62 63 crash\u0026gt; runq -g 64 CPU 0 65 CURRENT: PID: 14734 TASK: ffff88010626f500 COMMAND: \u0026#34;sh\u0026#34; 66 ROOT_TASK_GROUP: ffffffff81ed93e0 RT_RQ: ffff880028216808 67 [ 0] TASK_GROUP: ffff88022c6bbc00 RT_RQ: ffff880139fc9800 (THROTTLED) 68 [ 0] PID: 14750 TASK: ffff88013a4dd540 COMMAND: \u0026#34;rtloop99\u0026#34; 69 [ 1] PID: 14748 TASK: ffff88013bbca040 COMMAND: \u0026#34;rtloop98\u0026#34; 70 [ 1] TASK_GROUP: ffff88012b0fb400 RT_RQ: ffff880089029000 71 [ 1] PID: 14752 TASK: ffff880088abf500 COMMAND: \u0026#34;rtloop98\u0026#34; 72 [ 54] PID: 14749 TASK: ffff880037a4e080 COMMAND: \u0026#34;rtloop45\u0026#34; 73 [ 98] PID: 14746 TASK: ffff88012678c080 COMMAND: \u0026#34;rtloop1\u0026#34; 74 ROOT_TASK_GROUP: ffffffff81ed93e0 CFS_RQ: ffff8800282166e8 75 [120] PID: 14740 TASK: ffff88013b1e6080 COMMAND: \u0026#34;sh\u0026#34; 76 [120] PID: 14738 TASK: ffff88012678d540 COMMAND: \u0026#34;sh\u0026#34; 77 [120] PID: 14734 TASK: ffff88010626f500 COMMAND: \u0026#34;sh\u0026#34; [CURRENT] 78 TASK_GROUP: ffff884052bc9800 CFS_RQ: ffff8831e4a1b000 (THROTTLED) 79 [120] PID: 14732 TASK: ffff88013bbcb500 COMMAND: \u0026#34;sh\u0026#34; 80 [120] PID: 14728 TASK: ffff8800b3496080 COMMAND: \u0026#34;sh\u0026#34; 81 [120] PID: 14730 TASK: ffff880037833540 COMMAND: \u0026#34;sh\u0026#34; 82 TASK_GROUP: ffff884058f1d000 CFS_RQ: ffff88120a101600 (THROTTLED) 83 [120] PID: 14726 TASK: ffff880138d42aa0 COMMAND: \u0026#34;sh\u0026#34; 84 ... 85 86 Display tasks hierarchically by task_group for cpu 3 only: 87 88 crash\u0026gt; runq -g -c3 89 CPU 3 90 CURRENT: PID: 2948 TASK: ffff88022af2a100 COMMAND: \u0026#34;bash\u0026#34; 91 INIT_TASK_GROUP: ffffffff81e1a780 RT_RQ: ffff880028216148 92 [no tasks queued] 93 INIT_TASK_GROUP: ffffffff81e1a780 CFS_RQ: ffff880028216028 94 [120] PID: 2948 TASK: ffff88022af2a100 COMMAND: \u0026#34;bash\u0026#34; [CURRENT] 95 TASK_GROUP: ffff88012b880800 CFS_RQ: ffff88012c5d1000 \u0026lt;libvirt\u0026gt; 96 TASK_GROUP: ffff88012c078000 CFS_RQ: ffff88012c663e00 \u0026lt;qemu\u0026gt; 97 TASK_GROUP: ffff88022c7f4c00 CFS_RQ: ffff88012bb56000 \u0026lt;guest2\u0026gt; 98 TASK_GROUP: ffff88022b621400 CFS_RQ: ffff88012b012000 \u0026lt;vcpu0\u0026gt; 99 [120] PID: 3248 TASK: ffff88012a9d4100 COMMAND: \u0026#34;qemu-kvm\u0026#34; 36. search - search memory 36.1. SYNOPSIS 1search [-s start] [ -[kKV] | -u | -p | -t | -T ] [-e end | -l length] [-m mask] 2 [-x count] -[cwh] [value | (expression) | symbol | string] ... 36.2. DESCRIPTION 1 This command searches for a given value within a range of user virtual, kernel 2 virtual, or physical memory space. If no end nor length value is entered, 3 then the search stops at the end of user virtual, kernel virtual, or physical 4 address space, whichever is appropriate. 5 6 An optional mask value may be entered to mask off \u0026#34;don\u0026#39;t care\u0026#34; bits. 7 8 -s start Start the search at this hexadecimal user or kernel virtual 9 address, physical address, or kernel symbol. The start address 10 must be appropriate for the memory type specified; if no memory 11 type is specified, the default is kernel virtual address space. 12 -k If no start address is specified, start the search at the base 13 of kernel virtual address space. This option is the default. 14 -K Same as -k, except that mapped kernel virtual memory that was 15 allocated by vmalloc(), module memory, or virtual mem_map regions 16 will not be searched. 17 -V Same as -k, except that unity-mapped kernel virtual memory and 18 mapped kernel-text/static-data (x86_64 and ia64) will not be 19 searched. 20 -u If no start address is specified, start the search at the base 21 of the current context\u0026#39;s user virtual address space. If a start 22 address is specified, then this option specifies that the start 23 address is a user virtual address. 24 -p If no start address is specified, start the search at the base 25 of physical address space. If a start address is specified, 26 then this option specifies that the start address is a physical 27 address. 28 -t Search only the kernel stack pages of every task. If one or more 29 matches are found in a task\u0026#39;s kernel stack, precede the output 30 with a task-identifying header. 31 -T Same as -t, except only the active task(s) are considered. 32 -e end Stop the search at this hexadecimal user or kernel virtual 33 address, kernel symbol, or physical address. The end address 34 must be appropriate for the memory type specified. 35 -l length Length in bytes of address range to search. 36 -m mask Ignore the bits that are set in the hexadecimal mask value. 37 -c Search for character string values instead of unsigned longs. If 38 the string contains any space(s), it must be encompassed by double 39 quotes. 40 -w Search for unsigned hexadecimal ints instead of unsigned longs. 41 This is only meaningful on 64-bit systems in order to search both 42 the upper and lower 32-bits of each 64-bit long for the value. 43 -h Search for unsigned hexadecimal shorts instead of unsigned longs. 44 -x count Display the memory contents before and after any found value. The 45 before and after memory context will consist of \u0026#34;count\u0026#34; memory 46 items of the same size as the \u0026#34;value\u0026#34; argument. This option is 47 not applicable with the -c option. 48 value Search for this hexadecimal long, unless modified by the -c, -w, 49 or -h options. 50(expression) Search for the value of this expression; the expression value must 51 not overflow the designated size when -h or -w are used; not 52 applicable when used with the -c option. 53 symbol Search for this symbol value; the symbol value must not overflow 54 the designated size when -h or -w are used; not applicable when 55 used with the -c option. 56 string Search for character string values; if the string contains any 57 space(s), it must be encompassed by double quotes; only applicable 58 with the -c option. 59 60 If -k, -K, -V, -u, -p or -t are not used, then the search defaults to kernel 61 virtual address space. The starting address must be long-word aligned. 62 Address ranges that start in user space and end in kernel space are not 63 accepted. 36.3. EXAMPLES 1 Search the current context\u0026#39;s address space for all instances of 0xdeadbeef: 2 3 crash\u0026gt; search -u deadbeef 4 81aba5c: deadbeef 5 81abaa8: deadbeef 6 bfffc698: deadbeef 7 bffff390: deadbeef 8 9 Search all kernel memory above the kernel text space for all instances 10 of 0xabcd occurring in the lower 16-bits of each 32-bit word: 11 12 crash\u0026gt; search -s _etext -m ffff0000 abcd 13 c071481c: abcd 14 c0c2b0fc: 804abcd 15 c0cf5e74: 7489abcd 16 c17c0b44: c012abcd 17 c1dac730: 3dbeabcd 18 c226d0e8: ffffabcd 19 c23ed5dc: abcd 20 c3022544: 3dbeabcd 21 c3069b58: 3dbeabcd 22 c3e86e84: aabcd 23 c3e88ed0: aabcd 24 c3e8ee5c: aabcd 25 c3e9df50: aabcd 26 c3e9e930: aabcd 27 c440a778: 804abcd 28 c486eb44: 3dbeabcd 29 c578f0fc: 804abcd 30 c6394f90: 8ababcd 31 c65219f0: 3abcd 32 c661399c: abcd 33 c68514ac: 8abcd 34 c7e036bc: 3dbeabcd 35 c7e12568: 5abcd 36 c7e1256c: 5abcd 37 38 Search the 4K page at c532c000 for all instances of 0xffffffff: 39 40 crash\u0026gt; search -s c532c000 -l 4096 ffffffff 41 c532c33c: ffffffff 42 c532c3fc: ffffffff 43 44 Search the static kernel data area for all instances of c2d400eb: 45 46 crash\u0026gt; search -s _etext -e _edata c2d400eb 47 c022b550: c2d400eb 48 c022b590: c2d400eb 49 c022b670: c2d400eb 50 c022b6e0: c2d400eb 51 c022b7b0: c2d400eb 52 c022b7e0: c2d400eb 53 c022b8b0: c2d400eb 54 55 Search physical memory for all instances of 0xbabe occurring in the 56 upper 16 bits of each 32-bit word: 57 58 crash\u0026gt; search -p babe0000 -m ffff 59 2a1dc4: babe671e 60 2b6928: babe3de1 61 2f99ac: babe0d54 62 31843c: babe70b9 63 3ba920: babeb5d7 64 413ce4: babe7540 65 482747c: babe2600 66 48579a4: babe2600 67 4864a68: babe2600 68 ... 69 70 Search physical memory for all instances of 0xbabe occurring in the 71 upper 16 bits of each 32-bit word on a 64-bit system: 72 73 crash\u0026gt; search -p babe0000 -m ffff -w 74 102e248: babe1174 75 11d2f90: babe813d 76 122d3ad70: babe6b27 77 124d8cd30: babe3dc8 78 124d8eefc: babef981 79 124d8f060: babe3dc8 80 124d8f17c: babefc81 81 ... 82 83 Search kernel memory for all instances of 32-bit value 0xbabe1174 84 on a 64-bit system: 85 86 crash\u0026gt; search -k -w babe1174 87 ffff88000102e248: babe1174 88 ffffffff8102e248: babe1174 89 90 Search kernel memory for two strings: 91 92 crash\u0026gt; search -k -c \u0026#34;can\u0026#39;t allocate memory\u0026#34; \u0026#34;Failure to\u0026#34; 93 ffff8800013ddec1: can\u0026#39;t allocate memory for key lists..\u0026lt;3\u0026gt;%s %s: error con 94 ffff8801258be748: Failure to install fence: %d..\u0026lt;3\u0026gt;[drm:%s] *ERROR* Failed 95 ffff880125f07ec9: can\u0026#39;t allocate memory..\u0026lt;3\u0026gt;ACPI: Invalid data..Too many d 96 ffffffff813ddec1: can\u0026#39;t allocate memory for key lists..\u0026lt;3\u0026gt;%s %s: error con 97 98 Search the kernel stacks of all tasks for those that contain the inode 99 address ffff81002c0a3050: 100 101 crash\u0026gt; search -t ffff81002c0a3050 102 PID: 4876 TASK: ffff81003e9f5860 CPU: 7 COMMAND: \u0026#34;automount\u0026#34; 103 ffff8100288fbe98: ffff81002c0a3050 104 105 PID: 4880 TASK: ffff81003ce967a0 CPU: 0 COMMAND: \u0026#34;automount\u0026#34; 106 ffff81002c0fbdd8: ffff81002c0a3050 107 ffff81002c0fbe78: ffff81002c0a3050 108 109 When a kernel symbol or an (expression) is used an argument, both the 110 resultant value and the input string are displayed: 111 112 crash\u0026gt; search anon_inode_inode (__down_interruptible+191) 113 ffff81000222a728: ffffffff80493d60 (anon_inode_inode) 114 ffff810005a1e918: ffffffff800649d6 (__down_interruptible+191) 115 ffff810005a1e9d0: ffffffff800649d6 (__down_interruptible+191) 116 ffff810005a1eb48: ffffffff800649d6 (__down_interruptible+191) 117 ffff81000b409c60: ffffffff80493d60 (anon_inode_inode) 118 ffff81000c155b98: ffffffff80493d60 (anon_inode_inode) 119 ffff8100194fac70: ffffffff80493d60 (anon_inode_inode) 120 ffff81001daa1008: ffffffff80493d60 (anon_inode_inode) 121 ffff810028b95830: ffffffff800649d6 (__down_interruptible+191) 122 ffff81002cea0c70: ffffffff80493d60 (anon_inode_inode) 123 ffff810031327268: ffffffff80493d60 (anon_inode_inode) 124 ffff810031327270: ffffffff800649d6 (__down_interruptible+191) 125 ffff810034b1ccd0: ffffffff800649d6 (__down_interruptible+191) 126 ffff8100399565a8: ffffffff80493d60 (anon_inode_inode) 127 ffff81003a278cd0: ffffffff800649d6 (__down_interruptible+191) 128 ffff81003cc23e08: ffffffff800649d6 (__down_interruptible+191) 37. set - set a process context or internal crash variable 37.1. SYNOPSIS 1set [[-a] [pid | taskp] | [-c cpu] | -p] | [crash_variable [setting]] | -v 37.2. DESCRIPTION 1 This command either sets a new context, or gets the current context for 2 display. The context can be set by the use of: 3 4 pid a process PID. 5 taskp a hexadecimal task_struct pointer. 6 -a sets the pid or task as the active task on its cpu (dumpfiles only). 7 -c cpu sets the context to the active task on a cpu (dumpfiles only). 8 -p sets the context to the panic task, or back to the crash task on 9 a live system. 10 -v display the current state of internal crash variables. 11 12 If no argument is entered, the current context is displayed. The context 13 consists of the PID, the task pointer, the CPU, and task state. The task 14 state shows the bits found in both the task_struct state and exit_state 15 fields. 16 17 This command may also be used to set internal crash variables. If no value 18 argument is entered, the current value of the crash variable is shown. These 19 are the crash variables, acceptable arguments, and purpose: 20 21 scroll on | off controls output scrolling. 22 scroll less /usr/bin/less as the output scrolling program. 23 scroll more /bin/more as the output scrolling program. 24 scroll CRASHPAGER use CRASHPAGER environment variable as the 25 output scrolling program. 26 radix 10 | 16 sets output radix to 10 or 16. 27 refresh on | off controls internal task list refresh. 28 print_max number set maximum number of array elements to print. 29 print_array on | off if on, set gdb\u0026#39;s printing of arrays to \u0026#34;pretty\u0026#34; 30 format, with one line per element. 31 console device-name sets debug console device. 32 debug number sets crash debug level. 33 core on | off if on, drops core when the next error message 34 is displayed. 35 hash on | off controls internal list verification. 36 silent on | off turns off initialization messages; turns off 37 crash prompt during input file execution. 38 (scrolling is turned off if silent is on) 39 edit vi | emacs set line editing mode (from .crashrc file only). 40 namelist filename name of kernel (from .crashrc file only). 41 zero_excluded on | off controls whether excluded pages, or pages that 42 are missing from an incomplete dumpfile, should 43 return zero-filled memory when read. 44 null-stop on | off if on, gdb\u0026#39;s printing of character arrays will 45 stop at the first NULL encountered. 46 gdb on | off if on, the crash session will be run in a mode 47 where all commands will be passed directly to 48 gdb, and the command prompt will change to 49 \u0026#34;gdb\u0026gt;\u0026#34;; when running in this mode, native crash 50 commands may be executed by preceding them with 51 the \u0026#34;crash\u0026#34; directive. 52 scope text-addr sets the text scope for viewing the definition 53 of data structures; the \u0026#34;text-addr\u0026#34; argument 54 must be a kernel or module text address, which 55 may be expressed symbolically or as a hexadecimal 56 value. 57 offline show | hide show or hide command output that is associated 58 with offline cpus. 59 redzone on | off if on, CONFIG_SLUB object addresses displayed by 60 the kmem command will point to the SLAB_RED_ZONE 61 padding inserted at the beginning of the object. 62 error default | redirect | filename set the destination of error messages. 63 \u0026#34;default\u0026#34;: error messages are always displayed 64 on the console; if the output of a command is 65 piped to an external command or redirected 66 to a file, the error messages are also sent 67 to the pipe or file. 68 \u0026#34;redirect\u0026#34;: if the output of a command is piped 69 to an external command or redirected to a file, 70 error messages are only sent to the pipe or 71 file; otherwise they are displayed on the 72 console. 73 \u0026#34;filename\u0026#34;: error messages are only sent to the 74 specified filename; they are not displayed on 75 the console and are not sent to a pipe or file. 76 77 Internal variables may be set in four manners: 78 79 1. entering the set command in $HOME/.crashrc. 80 2. entering the set command in .crashrc in the current directory. 81 3. executing an input file containing the set command. 82 4. during runtime with this command. 83 84 During initialization, $HOME/.crashrc is read first, followed by the 85 .crashrc file in the current directory. Set commands in the .crashrc file 86 in the current directory override those in $HOME/.crashrc. Set commands 87 entered with this command or by runtime input file override those 88 defined in either .crashrc file. Multiple set command arguments or argument 89 pairs may be entered in one command line. 37.3. EXAMPLES 1 Set the current context to task c2fe8000: 2 3 crash\u0026gt; set c2fe8000 4 PID: 15917 5 COMMAND: \u0026#34;bash\u0026#34; 6 TASK: c2fe8000 7 CPU: 0 8 STATE: TASK_INTERRUPTIBLE 9 10 Set the context back to the panicking task: 11 12 crash\u0026gt; set -p 13 PID: 698 14 COMMAND: \u0026#34;gen12\u0026#34; 15 TASK: f9d78000 16 CPU: 2 17 STATE: TASK_RUNNING (PANIC) 18 19 Turn off output scrolling: 20 21 crash\u0026gt; set scroll off 22 scroll: off (/usr/bin/less) 23 24 Show the current state of crash internal variables: 25 26 crash\u0026gt; set -v 27 scroll: on (/usr/bin/less) 28 radix: 10 (decimal) 29 refresh: on 30 print_max: 256 31 print_array: off 32 console: /dev/pts/2 33 debug: 0 34 core: off 35 hash: on 36 silent: off 37 edit: vi 38 namelist: vmlinux 39 zero_excluded: off 40 null-stop: on 41 gdb: off 42 scope: (not set) 43 offline: show 44 redzone: on 45 error: default 46 47 Show the current context: 48 49 crash\u0026gt; set 50 PID: 1525 51 COMMAND: \u0026#34;bash\u0026#34; 52 TASK: c1ede000 53 CPU: 0 54 STATE: TASK_INTERRUPTIBLE 38. sig - task signal handling 38.1. SYNOPSIS 1sig [[-l] | [-s sigset]] | [-g] [pid | taskp] ... 38.2. DESCRIPTION 1 This command displays signal-handling data of one or more tasks. Multiple 2 task or PID numbers may be entered; if no arguments are entered, the signal 3 handling data of the current context will be displayed. The default display 4 shows: 5 6 1. A formatted dump of the \u0026#34;sig\u0026#34; signal_struct structure referenced by 7 the task_struct. For each defined signal, it shows the sigaction 8 structure address, the signal handler, the signal sigset_t mask 9 (also expressed as a 64-bit hexadecimal value), and the flags. 10 2. Whether the task has an unblocked signal pending. 11 3. The contents of the \u0026#34;blocked\u0026#34; and \u0026#34;signal\u0026#34; sigset_t structures 12 from the task_struct/signal_struct, both of which are represented 13 as a 64-bit hexadecimal value. 14 4. For each queued signal, private and/or shared, if any, its signal 15 number and associated siginfo structure address. 16 17 The -l option lists the signal numbers and their name(s). The -s option 18 translates a 64-bit hexadecimal value representing the contents of a 19 sigset_t structure into the signal names whose bits are set. 20 21 pid a process PID. 22 taskp a hexadecimal task_struct pointer. 23 -g displays signal information for all threads in a task\u0026#39;s 24 thread group. 25 -l displays the defined signal numbers and names. 26 -s sigset translates a 64-bit hexadecimal value representing a sigset_t 27 into a list of signal names associated with the bits set. 38.3. EXAMPLES 1 Dump the signal-handling data of PID 8970: 2 3 crash\u0026gt; sig 8970 4 PID: 8970 TASK: f67d8560 CPU: 1 COMMAND: \u0026#34;procsig\u0026#34; 5 SIGNAL_STRUCT: f6018680 COUNT: 1 6 SIG SIGACTION HANDLER MASK FLAGS 7 [1] f7877684 SIG_DFL 0000000000000000 0 8 [2] f7877698 SIG_DFL 0000000000000000 0 9 ... 10 [8] f7877710 SIG_DFL 0000000000000000 0 11 [9] f7877724 SIG_DFL 0000000000000000 0 12 [10] f7877738 804867a 0000000000000000 80000000 (SA_RESETHAND) 13 [11] f787774c SIG_DFL 0000000000000000 0 14 [12] f7877760 804867f 0000000000000000 10000004 (SA_SIGINFO|SA_RESTART) 15 [13] f7877774 SIG_DFL 0000000000000000 0 16 ... 17 [31] f78778dc SIG_DFL 0000000000000000 0 18 [32] f78778f0 SIG_DFL 0000000000000000 0 19 [33] f7877904 SIG_DFL 0000000000000000 0 20 [34] f7877918 804867f 0000000000000000 10000004 (SA_SIGINFO|SA_RESTART) 21 [35] f787792c SIG_DFL 0000000000000000 0 22 [36] f7877940 SIG_DFL 0000000000000000 0 23 ... 24 [58] f7877af8 SIG_DFL 0000000000000000 0 25 [59] f7877b0c SIG_DFL 0000000000000000 0 26 [60] f7877b20 SIG_DFL 0000000000000000 0 27 [61] f7877b34 SIG_DFL 0000000000000000 0 28 [62] f7877b48 SIG_DFL 0000000000000000 0 29 [63] f7877b5c SIG_DFL 0000000000000000 0 30 [64] f7877b70 804867f 0000000000000000 10000004 (SA_SIGINFO|SA_RESTART) 31 SIGPENDING: no 32 BLOCKED: 8000000200000800 33 PRIVATE_PENDING 34 SIGNAL: 0000000200000800 35 SIGQUEUE: SIG SIGINFO 36 12 f51b9c84 37 34 f51b9594 38 SHARED_PENDING 39 SIGNAL: 8000000000000800 40 SIGQUEUE: SIG SIGINFO 41 12 f51b9188 42 64 f51b9d18 43 64 f51b9500 44 45 Dump the signal-handling data for all tasks in the thread group containing 46 PID 2578: 47 48 crash\u0026gt; sig -g 2578 49 PID: 2387 TASK: f617d020 CPU: 0 COMMAND: \u0026#34;slapd\u0026#34; 50 SIGNAL_STRUCT: f7dede00 COUNT: 6 51 SIG SIGACTION HANDLER MASK FLAGS 52 [1] c1f60c04 a258a7 0000000000000000 10000000 (SA_RESTART) 53 [2] c1f60c18 a258a7 0000000000000000 10000000 (SA_RESTART) 54 [3] c1f60c2c SIG_DFL 0000000000000000 0 55 [4] c1f60c40 SIG_DFL 0000000000000000 0 56 [5] c1f60c54 a258a7 0000000000000000 10000000 (SA_RESTART) 57 [6] c1f60c68 SIG_DFL 0000000000000000 0 58 [7] c1f60c7c SIG_DFL 0000000000000000 0 59 [8] c1f60c90 SIG_DFL 0000000000000000 0 60 [9] c1f60ca4 SIG_DFL 0000000000000000 0 61 [10] c1f60cb8 a25911 0000000000000000 10000000 (SA_RESTART) 62 ... 63 [64] c1f610f0 SIG_DFL 0000000000000000 0 64 SHARED_PENDING 65 SIGNAL: 0000000000000000 66 SIGQUEUE: (empty) 67 68 PID: 2387 TASK: f617d020 CPU: 0 COMMAND: \u0026#34;slapd\u0026#34; 69 SIGPENDING: no 70 BLOCKED: 0000000000000000 71 PRIVATE_PENDING 72 SIGNAL: 0000000000000000 73 SIGQUEUE: (empty) 74 75 PID: 2392 TASK: f6175aa0 CPU: 0 COMMAND: \u0026#34;slapd\u0026#34; 76 SIGPENDING: no 77 BLOCKED: 0000000000000000 78 PRIVATE_PENDING 79 SIGNAL: 0000000000000000 80 SIGQUEUE: (empty) 81 82 PID: 2523 TASK: f7cd4aa0 CPU: 1 COMMAND: \u0026#34;slapd\u0026#34; 83 SIGPENDING: no 84 BLOCKED: 0000000000000000 85 PRIVATE_PENDING 86 SIGNAL: 0000000000000000 87 SIGQUEUE: (empty) 88 89 ... 90 91 Translate the sigset_t mask value, cut-and-pasted from the signal handling 92 data from signals 1 and 10 above: 93 94 crash\u0026gt; sig -s 800A000000000201 95 SIGHUP SIGUSR1 SIGRTMAX-14 SIGRTMAX-12 SIGRTMAX 96 97 List the signal numbers and their names: 98 99 crash\u0026gt; sig -l 100 [1] SIGHUP 101 [2] SIGINT 102 [3] SIGQUIT 103 [4] SIGILL 104 [5] SIGTRAP 105 [6] SIGABRT/SIGIOT 106 [7] SIGBUS 107 [8] SIGFPE 108 [9] SIGKILL 109 [10] SIGUSR1 110 [11] SIGSEGV 111 [12] SIGUSR2 112 [13] SIGPIPE 113 [14] SIGALRM 114 [15] SIGTERM 115 [16] SIGSTKFLT 116 [17] SIGCHLD/SIGCLD 117 [18] SIGCONT 118 [19] SIGSTOP 119 [20] SIGTSTP 120 [21] SIGTTIN 121 [22] SIGTTOU 122 [23] SIGURG 123 [24] SIGXCPU 124 [25] SIGXFSZ 125 [26] SIGVTALRM 126 [27] SIGPROF 127 [28] SIGWINCH 128 [29] SIGIO/SIGPOLL 129 [30] SIGPWR 130 [31] SIGSYS 131 [32] SIGRTMIN 132 [33] SIGRTMIN+1 133 [34] SIGRTMIN+2 134 [35] SIGRTMIN+3 135 [36] SIGRTMIN+4 136 [37] SIGRTMIN+5 137 [38] SIGRTMIN+6 138 [39] SIGRTMIN+7 139 [40] SIGRTMIN+8 140 [41] SIGRTMIN+9 141 [42] SIGRTMIN+10 142 [43] SIGRTMIN+11 143 [44] SIGRTMIN+12 144 [45] SIGRTMIN+13 145 [46] SIGRTMIN+14 146 [47] SIGRTMIN+15 147 [48] SIGRTMIN+16 148 [49] SIGRTMAX-15 149 [50] SIGRTMAX-14 150 [51] SIGRTMAX-13 151 [52] SIGRTMAX-12 152 [53] SIGRTMAX-11 153 [54] SIGRTMAX-10 154 [55] SIGRTMAX-9 155 [56] SIGRTMAX-8 156 [57] SIGRTMAX-7 157 [58] SIGRTMAX-6 158 [59] SIGRTMAX-5 159 [60] SIGRTMAX-4 160 [61] SIGRTMAX-3 161 [62] SIGRTMAX-2 162 [63] SIGRTMAX-1 163 [64] SIGRTMAX 39. struct - structure contents 39.1. SYNOPSIS 1struct struct_name[.member[,member]][-o][-l offset][-rfuxdp] 2 [address | symbol][:cpuspec] [count | -c count] 39.2. DESCRIPTION 1 This command displays either a structure definition, or a formatted display 2 of the contents of a structure at a specified address. When no address is 3 specified, the structure definition is shown along with the structure size. 4 A structure member may be appended to the structure name in order to limit 5 the scope of the data displayed to that particular member; when no address 6 is specified, the member\u0026#39;s offset and definition are shown. 7 8 struct_name name of a C-code structure used by the kernel. 9 .member name of a structure member; to display multiple members of a 10 structure, use a comma-separated list of members. If any 11 member contains an embedded structure, or the member is an 12 array, the output may be restricted to just the embedded 13 structure or an array element by expressing the member argument 14 as \u0026#34;member.member\u0026#34; or \u0026#34;member[index]\u0026#34;; embedded member 15 specifications may extend beyond one level deep, by expressing 16 the member argument as \u0026#34;member.member.member...\u0026#34;. 17 -o show member offsets when displaying structure definitions; 18 if used with an address or symbol argument, each member will 19 be preceded by its virtual address. 20 -l offset if the address argument is a pointer to a structure member that 21 is contained by the target data structure, typically a pointer 22 to an embedded list_head, the offset to the embedded member may 23 be entered in either of the following manners: 24 1. in \u0026#34;structure.member\u0026#34; format. 25 2. a number of bytes. 26 -r raw dump of structure data. 27 -f address argument is a dumpfile offset. 28 -u address argument is a user virtual address in the current 29 context. 30 -x override default output format with hexadecimal format. 31 -d override default output format with decimal format. 32 -p if a structure member is a pointer value, show the member\u0026#39;s 33 data type on the output line; and on the subsequent line(s), 34 dereference the pointer, display the pointer target\u0026#39;s symbol 35 value in brackets if appropriate, and if possible, display the 36 target data; requires an address argument. 37 address hexadecimal address of a structure; if the address points 38 to an embedded list_head structure contained within the 39 target data structure, then the \u0026#34;-l\u0026#34; option must be used. 40 symbol symbolic reference to the address of a structure. 41 :cpuspec CPU specification for a per-cpu address or symbol: 42 : CPU of the currently selected task. 43 :a[ll] all CPUs. 44 :#[-#][,...] CPU list(s), e.g. \u0026#34;1,3,5\u0026#34;, \u0026#34;1-3\u0026#34;, 45 or \u0026#34;1,3,5-7,10\u0026#34;. 46 count count of structures to dump from an array of structures; 47 if used, this must be the last argument entered. 48 -c count \u0026#34;-c\u0026#34; is only required if \u0026#34;count\u0026#34; is not the last argument 49 entered or if a negative number is entered; if a negative 50 value is entered, the (positive) \u0026#34;count\u0026#34; structures that 51 lead up to and include the target structure will be displayed. 52 53 Structure data, sizes, and member offsets are shown in the current output 54 radix unless the -x or -d option is specified. 55 56 Please note that in the vast majority of cases, the \u0026#34;struct\u0026#34; command 57 name may be dropped; if the structure name does not conflict with any crash 58 or gdb command name, then the \u0026#34;struct_name[.member]\u0026#34; argument will be 59 recognized as a structure name, and this command automatically executed. 60 See the NOTE below. 39.3. EXAMPLES 1 Display the vm_area_struct at address c1e44f10: 2 3 crash\u0026gt; struct vm_area_struct c1e44f10 4 struct vm_area_struct { 5 vm_mm = 0xc2857750, 6 vm_start = 0x8048000, 7 vm_end = 0x80a5000, 8 vm_next = 0xc1e44a10, 9 vm_page_prot = { 10 pgprot = 0x25 11 }, 12 vm_flags = 0x1875, 13 vm_avl_height = 0x2, 14 vm_avl_left = 0xc30fe200, 15 vm_avl_right = 0xc30fed00, 16 vm_next_share = 0x0, 17 vm_pprev_share = 0xc1e44a30, 18 vm_ops = 0xc0215ca0, 19 vm_offset = 0x0, 20 vm_file = 0xc0bfdc70, 21 vm_pte = 0 22 } 23 24 Display the definition and size of a vm_area_struct structure. This first 25 example below displays just the structure and size. The second example 26 uses the -o option to also display member offsets. Both examples were 27 run with the output radix set to 10 (decimal): 28 29 crash\u0026gt; struct vm_area_struct 30 struct vm_area_struct { 31 struct mm_struct *vm_mm; 32 long unsigned int vm_start; 33 long unsigned int vm_end; 34 struct vm_area_struct *vm_next; 35 pgprot_t vm_page_prot; 36 short unsigned int vm_flags; 37 short int vm_avl_height; 38 struct vm_area_struct *vm_avl_left; 39 struct vm_area_struct *vm_avl_right; 40 struct vm_area_struct *vm_next_share; 41 struct vm_area_struct **vm_pprev_share; 42 struct vm_operations_struct *vm_ops; 43 long unsigned int vm_offset; 44 struct file *vm_file; 45 long unsigned int vm_pte; 46 } 47 SIZE: 56 48 49 crash\u0026gt; struct vm_area_struct -o 50 struct vm_area_struct { 51 [0] struct mm_struct *vm_mm; 52 [4] long unsigned int vm_start; 53 [8] long unsigned int vm_end; 54 [12] struct vm_area_struct *vm_next; 55 [16] pgprot_t vm_page_prot; 56 [20] short unsigned int vm_flags; 57 [22] short int vm_avl_height; 58 [24] struct vm_area_struct *vm_avl_left; 59 [28] struct vm_area_struct *vm_avl_right; 60 [32] struct vm_area_struct *vm_next_share; 61 [36] struct vm_area_struct **vm_pprev_share; 62 [40] struct vm_operations_struct *vm_ops; 63 [44] long unsigned int vm_offset; 64 [48] struct file *vm_file; 65 [52] long unsigned int vm_pte; 66 } 67 SIZE: 56 68 69 Display the definition and offset of the pgd member of an mm_struct: 70 71 crash\u0026gt; struct mm_struct.pgd 72 struct mm_struct { 73 [80] pgd_t *pgd; 74 } 75 76 Display the pgd member of the mm_struct at address ffff810022e7d080: 77 78 crash\u0026gt; struct mm_struct.pgd ffff810022e7d080 79 pgd = 0xffff81000e3ac000 80 81 Display the pgd_t pointed to by the mm_struct.pgd pointer above, forcing 82 the output to be expressed in hexadecimal: 83 84 crash\u0026gt; mm_struct.pgd ffff810022e7d080 -px 85 pgd_t *pgd = 0xffff81000e3ac000 86 -\u0026gt; { 87 pgd = 0x2c0a6067 88 } 89 90 Display the thread_info structure pointed to by the thread_info 91 member of the task_struct at ffff8100181190c0: 92 93 crash\u0026gt; task_struct.thread_info ffff8100181190c0 -p 94 struct thread_info *thread_info = 0xffff810023c06000 95 -\u0026gt; { 96 task = 0xffff8100181190c0, 97 exec_domain = 0xffffffff802f78e0, 98 flags = 128, 99 status = 1, 100 cpu = 3, 101 preempt_count = 0, 102 addr_limit = { 103 seg = 18446604435732824064 104 }, 105 restart_block = { 106 fn = 0xffffffff80095a52 \u0026lt;do_no_restart_syscall\u0026gt;, 107 arg0 = 0, 108 arg1 = 0, 109 arg2 = 0, 110 arg3 = 0 111 } 112 } 113 114 Display the flags and virtual members of 4 contigous page structures 115 in the mem_map page structure array: 116 117 crash\u0026gt; page.flags,virtual c101196c 4 118 flags = 0x8000, 119 virtual = 0xc04b0000 120 121 flags = 0x8000, 122 virtual = 0xc04b1000 123 124 flags = 0x8000, 125 virtual = 0xc04b2000 126 127 flags = 0x8000, 128 virtual = 0xc04b3000 129 130 Display the array of tcp_sl_timer structures declared by tcp_slt_array[]: 131 132 crash\u0026gt; struct tcp_sl_timer tcp_slt_array 4 133 struct tcp_sl_timer { 134 count = { 135 counter = 0x0 136 }, 137 period = 0x32, 138 last = 0x1419e4, 139 handler = 0xc0164854 \u0026lt;tcp_syn_recv_timer\u0026gt; 140 } 141 struct tcp_sl_timer { 142 count = { 143 counter = 0x2 144 }, 145 period = 0x753, 146 last = 0x14a6df, 147 handler = 0xc01645b0 \u0026lt;tcp_keepalive\u0026gt; 148 } 149 struct tcp_sl_timer { 150 count = { 151 counter = 0x0 152 }, 153 period = 0x2ee, 154 last = 0x143134, 155 handler = 0xc016447c \u0026lt;tcp_twkill\u0026gt; 156 } 157 struct tcp_sl_timer { 158 count = { 159 counter = 0x0 160 }, 161 period = 0x64, 162 last = 0x143198, 163 handler = 0xc0164404 \u0026lt;tcp_bucketgc\u0026gt; 164 } 165 166 Without using the \u0026#34;struct\u0026#34; command name, display the the \u0026#34;d_child\u0026#34; 167 list_head member from a dentry structure: 168 169 crash\u0026gt; dentry.d_child 0xe813cb4 170 d_child = { 171 next = 0x3661344, 172 prev = 0xdea4bc4 173 }, 174 175 Display the child dentry structure referenced by the \u0026#34;next\u0026#34; pointer above. 176 Since the \u0026#34;next\u0026#34; address of 0x3661344 above is a pointer to an embedded 177 list_head structure within the child dentry structure, the -l option 178 is required: 179 180 crash\u0026gt; dentry -l dentry.d_child 0x3661344 181 struct dentry { 182 d_count = { 183 counter = 1 184 }, 185 d_flags = 0, 186 d_inode = 0xf9aa604, 187 d_parent = 0x11152b1c, 188 d_hash = { 189 next = 0x11fb3fc0, 190 prev = 0x11fb3fc0 191 }, 192 d_lru = { 193 next = 0x366133c, 194 prev = 0x366133c 195 }, 196 d_child = { 197 next = 0x36613cc, 198 prev = 0xe813cd4 199 }, 200 d_subdirs = { 201 next = 0x366134c, 202 prev = 0x366134c 203 }, 204 d_alias = { 205 next = 0xf9aa614, 206 prev = 0xf9aa614 207 }, 208 d_mounted = 0, 209 d_name = { 210 name = 0x3661384 \u0026#34;boot.log\u0026#34;, 211 len = 8, 212 hash = 1935169207 213 }, 214 d_time = 1515870810, 215 d_op = 0x0, 216 d_sb = 0x11fc9c00, 217 d_vfs_flags = 0, 218 d_fsdata = 0x0, 219 d_extra_attributes = 0x0, 220 d_iname = \u0026#34;boot.log\\000\u0026#34; 221 } 222 223 Display the virtual address of each member of the task_struct at 224 ffff8100145d2080: 225 226 crash\u0026gt; task_struct -o ffff8100145d2080 227 struct task_struct { 228 [ffff8100145d2080] volatile long int state; 229 [ffff8100145d2088] struct thread_info *thread_info; 230 [ffff8100145d2090] atomic_t usage; 231 [ffff8100145d2098] long unsigned int flags; 232 [ffff8100145d20a0] int lock_depth; 233 [ffff8100145d20a4] int load_weight; 234 [ffff8100145d20a8] int prio; 235 [ffff8100145d20ac] int static_prio; 236 [ffff8100145d20b0] int normal_prio; 237 [ffff8100145d20b8] struct list_head run_list; 238 [ffff8100145d20c8] struct prio_array *array; 239 ... 240 241 Display the embedded sched_entity structure\u0026#39;s on_rq member and 242 the third pid_link structure in the embedded pids[] array of the 243 task_struct at ffff88011653e250: 244 245 crash\u0026gt; task_struct.se.on_rq,pids[2] ffff88011653e250 246 se.on_rq = 1, 247 pids[2] = { 248 node = { 249 next = 0xffff88011653aff0, 250 pprev = 0xffff88011653a860 251 }, 252 pid = 0xffff88010d07ed00 253 } 254 255 For an example of displaying per-cpu variables, consider the 256 struct hd_struct.dkstats member, which is a percpu pointer to 257 a disk_stats structure: 258 259 crash\u0026gt; struct hd_struct.dkstats 260 struct hd_struct { 261 [1232] struct disk_stats *dkstats; 262 } 263 264 Taking an hd_struct at address ffff8802450e2848, display all 265 of the per-cpu disk_stats structures that it references: 266 267 crash\u0026gt; struct hd_struct.dkstats ffff8802450e2848 268 dkstats = 0x60fdb48026c8 269 crash\u0026gt; struct disk_stats 0x60fdb48026c8:a 270 [0]: ffffe8fefe6026c8 271 struct disk_stats { 272 sectors = {451376, 80468}, 273 ios = {6041, 971}, 274 merges = {386, 390}, 275 ticks = {194877, 56131}, 276 io_ticks = 12371, 277 time_in_queue = 309163 278 } 279 [1]: ffffe8fefe8026c8 280 struct disk_stats { 281 sectors = {0, 0}, 282 ios = {0, 0}, 283 merges = {7, 242}, 284 ticks = {0, 0}, 285 io_ticks = 23, 286 time_in_queue = 581 287 } 288 [2]: ffffe8fefea026c8 289 struct disk_stats { 290 sectors = {0, 0}, 291 ios = {0, 0}, 292 merges = {4, 112}, 293 ticks = {0, 0}, 294 io_ticks = 11, 295 time_in_queue = 305 296 } 297 [3]: ffffe8fefec026c8 298 struct disk_stats { 299 sectors = {0, 0}, 300 ios = {0, 0}, 301 merges = {5, 54}, 302 ticks = {0, 0}, 303 io_ticks = 17, 304 time_in_queue = 41 305 } 39.4. NOTE 1 If the structure name does not conflict with any crash command name, the 2 \u0026#34;struct\u0026#34; command may be dropped. Accordingly, the examples above could 3 also have been accomplished like so: 4 5 crash\u0026gt; vm_area_struct c1e44f10 6 crash\u0026gt; vm_area_struct 7 crash\u0026gt; vm_area_struct -o 8 crash\u0026gt; mm_struct.pgd ffff810022e7d080 9 crash\u0026gt; mm_struct.pgd 10 crash\u0026gt; tcp_sl_timer tcp_slt_array 4 11 12 Lastly, the short-cut \u0026#34;*\u0026#34; pointer-to command may also be used to negate 13 the need to enter the \u0026#34;struct\u0026#34; command name (enter \u0026#34;help *\u0026#34; for details). 40. swap - swap device information 40.1. SYNOPSIS 1swap 40.2. DESCRIPTION 1 This command displays information for each configured swap device. 2 3EXAMPLE 4 crash\u0026gt; swap 5 SWAP_INFO_STRUCT TYPE SIZE USED PCT PRI FILENAME 6 ffff880153d45f40 PARTITION 7192568k 1200580k 16% -1 /dev/dm-1 41. sym - translate a symbol to its virtual address, or vice-versa 41.1. SYNOPSIS 1sym [-l] | [-M] | [-m module] | [-p|-n] | [-q string] | [symbol | vaddr] 41.2. DESCRIPTION 1 This command translates a symbol to its virtual address, or a static 2 kernel virtual address to its symbol -- or to a symbol-plus-offset value, 3 if appropriate. Additionally, the symbol type is shown in parentheses, 4 and if the symbol is a known text value, the file and line number are shown. 5 6 -l dumps all symbols and their values. 7 -M dumps the current set of module symbols. 8 -m module dumps the current set of symbols for a specified module. 9 -p display the target symbol and the previous symbol. 10 -n display the target symbol and the next symbol. 11 -q string searches for all symbols containing \u0026#34;string\u0026#34;. 12 symbol a kernel text or data symbol. 13 vaddr a kernel virtual address. 14 15 If the \u0026#34;symbol\u0026#34;, \u0026#34;vaddr\u0026#34; or \u0026#34;string\u0026#34; argument resolves to a module 16 symbol, then the module name will be displayed in brackets following the 17 symbol value. 41.3. EXAMPLES 1 Translate data symbol jiffies to its value, and vice-versa: 2 3 crash\u0026gt; sym jiffies 4 c0213ae0 (D) jiffies 5 6 crash\u0026gt; sym c0213ae0 7 c0213ae0 (D) jiffies 8 9 Translate a text address to its symbolic value and source file: 10 11 crash\u0026gt; sym c0109944 12 c0109944 (T) system_call+0x34 ../linux-2.2.5/arch/i386/kernel/signal.c: 723 13 14 Dump the whole symbol table: 15 16 crash\u0026gt; sym -l 17 c0100000 (T) _stext 18 c0100000 (A) _text 19 c0100000 (t) startup_32 20 c0100000 (T) stext 21 c01000a4 (t) checkCPUtype 22 c0100139 (t) is486 23 c0100148 (t) is386 24 c01001b1 (t) L6 25 c01001b3 (t) ready 26 c01001b4 (t) check_x87 27 c01001da (t) setup_idt 28 c01001f7 (t) rp_sidt 29 c0100204 (T) stack_start 30 c010020c (t) int_msg 31 c0100220 (t) ignore_int 32 c0100242 (t) idt_descr 33 c0100244 (T) idt 34 c010024a (t) gdt_descr 35 c010024c (T) gdt 36 c0101000 (T) swapper_pg_dir 37 c0102000 (T) pg0 38 c0103000 (T) empty_bad_page 39 c0104000 (T) empty_bad_page_table 40 c0105000 (T) empty_zero_page 41 ... 42 43 Find all symbols containing the string \u0026#34;pipe\u0026#34;: 44 45 crash\u0026gt; sym -q pipe 46 c010ec60 (T) sys_pipe 47 c012f660 (t) pipe_read 48 c012f7b8 (t) pipe_write 49 c012f9c0 (t) pipe_lseek 50 c012f9d0 (t) bad_pipe_r 51 c012f9dc (t) bad_pipe_w 52 c012f9e8 (t) pipe_ioctl 53 c012fa18 (t) pipe_poll 54 c012fb00 (t) pipe_release 55 c012fb48 (t) pipe_read_release 56 c012fb5c (t) pipe_write_release 57 c012fb70 (t) pipe_rdwr_release 58 c012fba0 (t) pipe_read_open 59 c012fbb0 (t) pipe_write_open 60 c012fbc0 (t) pipe_rdwr_open 61 c012fbec (t) get_pipe_inode 62 c012fcc4 (T) do_pipe 63 c023a920 (D) read_pipe_fops 64 c023a960 (D) write_pipe_fops 65 c023a9a0 (D) rdwr_pipe_fops 66 c023a9e0 (D) pipe_inode_operations 67 68 Dump the symbols of the uart401 module, both before, and then after, 69 the complete set of symbols are loaded with the \u0026#34;mod -s\u0026#34; command: 70 71 crash\u0026gt; sym -m uart401 72 c8032000 MODULE START: uart401 73 c8032138 (?) uart401intr 74 c803235c (?) attach_uart401 75 c8032638 (?) probe_uart401 76 c80326d4 (?) unload_uart401 77 c8033770 MODULE END: uart401 78 crash\u0026gt; mod -s uart401 79 MODULE NAME SIZE OBJECT FILE 80 c8032000 uart401 6000 /lib/modules/2.2.14/misc/uart401.o 81 crash\u0026gt; sym -m uart401 82 c8032000 MODULE START: uart401 83 c8032050 (t) my_notifier_call 84 c8032084 (t) uart401_status 85 c8032098 (t) uart401_cmd 86 c80320a8 (t) uart401_read 87 c80320bc (t) uart401_write 88 c80320cc (t) uart401_input_loop 89 c8032138 (T) uart401intr 90 c8032168 (t) uart401_open 91 c80321c8 (t) uart401_close 92 c80321f4 (t) uart401_out 93 c80322ac (t) uart401_start_read 94 c80322b4 (t) uart401_end_read 95 c80322bc (t) uart401_kick 96 c80322c4 (t) uart401_buffer_status 97 c80322cc (t) enter_uart_mode 98 c803235c (T) attach_uart401 99 c803259c (t) reset_uart401 100 c8032638 (T) probe_uart401 101 c80326d4 (T) unload_uart401 102 c8032760 (T) init_module 103 c80327cc (T) cleanup_module 104 c8032b00 (d) sound_notifier 105 c8032b0c (d) detected_devc 106 c8032b20 (d) std_synth_info 107 c8032bc0 (d) std_midi_synth 108 c8033600 (d) uart401_operations 109 c80336c4 (D) io 110 c80336c8 (D) irq 111 c80336e0 (b) hw_info.508 112 c8033770 MODULE END: uart401 113 114 Display the value of jiffies, along with the next and previous symbols: 115 116 crash\u0026gt; sym -np jiffies 117 c023027c (D) prof_shift 118 c0230280 (D) jiffies 119 c02302a0 (D) task 120 121 Translate a symbol value to its name and module: 122 123 crash\u0026gt; sym f88878d1 124 f88878d1 (t) ext3_readdir [ext3] 125 crash\u0026gt; 42. sys - system data 42.1. SYNOPSIS 1sys [-c [name|number]] [-t] [-i] config 42.2. DESCRIPTION 1 This command displays system-specific data. If no arguments are entered, 2 the same system data shown during crash invocation is shown. 3 4 -c [name|number] If no name or number argument is entered, dump all 5 sys_call_table entries. If a name string is entered, 6 search the table for all entries containing the string. 7 If a number is entered, the table entry associated with 8 that number is displayed. If the current output radix 9 has been set to 16, the system call numbers will be 10 displayed in hexadecimal. 11 config If the kernel was configured with CONFIG_IKCONFIG, then 12 dump the in-kernel configuration data. 13 -t Display kernel taint information. If the \u0026#34;tainted_mask\u0026#34; 14 symbol exists, show its hexadecimal value and translate 15 each bit set to the symbolic letter of the taint type. 16 On older kernels with the \u0026#34;tainted\u0026#34; symbol, only its 17 hexadecimal value is shown. The relevant kernel sources 18 should be consulted for the meaning of the letter(s) or 19 hexadecimal bit value(s). 20 -panic Panic a live system. Requires write permission to 21 /dev/mem. Results in the crash context causing an 22 \u0026#34;Attempted to kill the idle task!\u0026#34; panic. (The dump 23 will indicate that the crash context has a PID of 0). 24 -i Dump the DMI string data if available in the kernel. 42.3. EXAMPLES 1 Display essential system information: 2 3 crash\u0026gt; sys 4 KERNEL: vmlinux.4 5 DUMPFILE: lcore.cr.4 6 CPUS: 4 7 DATE: Mon Oct 11 18:48:55 1999 8 UPTIME: 10 days, 14:14:39 9 LOAD AVERAGE: 0.74, 0.23, 0.08 10 TASKS: 77 11 NODENAME: test.mclinux.com 12 RELEASE: 2.2.5-15smp 13 VERSION: #24 SMP Mon Oct 11 17:41:40 CDT 1999 14 MACHINE: i686 (500 MHz) 15 MEMORY: 1 GB 16 17 Dump the system configuration data (if CONFIG_IKCONFIG): 18 19 crash\u0026gt; sys config 20 # 21 # Automatically generated make config: don\u0026#39;t edit 22 # Linux kernel version: 2.6.16 23 # Mon Apr 10 07:58:06 2006 24 # 25 CONFIG_X86_64=y 26 CONFIG_64BIT=y 27 CONFIG_X86=y 28 CONFIG_SEMAPHORE_SLEEPERS=y 29 CONFIG_MMU=y 30 CONFIG_RWSEM_GENERIC_SPINLOCK=y 31 CONFIG_GENERIC_CALIBRATE_DELAY=y 32 CONFIG_X86_CMPXCHG=y 33 CONFIG_EARLY_PRINTK=y 34 CONFIG_GENERIC_ISA_DMA=y 35 CONFIG_GENERIC_IOMAP=y 36 CONFIG_ARCH_MAY_HAVE_PC_FDC=y 37 CONFIG_DMI=y 38 ... 39 40 Display the kernel taint information, in this case where both the 41 TAINT_WARN and TAINT_PROPRIETARY_MODULE bits have been set: 42 43 crash\u0026gt; sys -t 44 TAINTED_MASK: 201 PW 45 46 Dump the system call table: 47 48 crash\u0026gt; sys -c 49 NUM SYSTEM CALL FILE AND LINE NUMBER 50 0 sys_ni_syscall ../kernel/sys.c: 48 51 1 sys_exit ../kernel/exit.c: 404 52 2 sys_fork ../arch/i386/kernel/process.c: 771 53 3 sys_read ../fs/read_write.c: 117 54 4 sys_write ../fs/read_write.c: 146 55 5 sys_open ../fs/open.c: 754 56 6 sys_close ../fs/open.c: 839 57 7 sys_waitpid ../kernel/exit.c: 503 58 8 sys_creat ../fs/open.c: 789 59 9 sys_link ../fs/namei.c: 1213 60 10 sys_unlink ../fs/namei.c: 1074 61 11 sys_execve ../arch/i386/kernel/process.c: 806 62 ... 63 64 Find the system call number of the select system call: 65 66 crash\u0026gt; sys -c select 67 NUM SYSTEM CALL FILE AND LINE NUMBER 68 65 sys_select ../fs/select.c: 259 69 70 If the current output radix has been set to 16, the system call numbers 71 will be displayed in hexadecimal. 72 73 Dump the DMI string data: 74 75 crash\u0026gt; sys -i 76 DMI_BIOS_VENDOR: LENOVO 77 DMI_BIOS_VERSION: G4ET37WW (1.12 ) 78 DMI_BIOS_DATE: 05/29/2012 79 DMI_SYS_VENDOR: LENOVO 80 DMI_PRODUCT_NAME: 2429BQ1 81 DMI_PRODUCT_VERSION: ThinkPad T530 82 DMI_PRODUCT_SERIAL: R9R91HZ 83 DMI_PRODUCT_UUID: 568DFA01-5180-11CB-B851-BD06085ADDB0 84 DMI_BOARD_VENDOR: LENOVO 85 DMI_BOARD_NAME: 2429BQ1 86 DMI_BOARD_VERSION: Not Available 87 DMI_BOARD_SERIAL: 1ZLV127F17M 88 DMI_BOARD_ASSET_TAG: Not Available 89 DMI_CHASSIS_VENDOR: LENOVO 90 DMI_CHASSIS_TYPE: 10 91 DMI_CHASSIS_VERSION: Not Available 92 DMI_CHASSIS_SERIAL: R9R91HZ 93 DMI_CHASSIS_ASSET_TAG: RH0004111 43. task - task_struct and thread_info contents 43.1. SYNOPSIS 1task [-R member[,member]] [-dx] [pid | taskp] ... 43.2. DESCRIPTION 1 This command dumps a formatted display of the contents of a task\u0026#39;s 2 task_struct and thread_info structures. Multiple task or PID numbers 3 may be entered; if no arguments are entered, the task_struct and 4 thread_info structures of the current context are displayed. The -R option, 5 which may also be invoked indirectly via \u0026#34;foreach task\u0026#34;, pares the output 6 down to one or more structure members. 7 8 pid a process PID. 9 taskp a hexadecimal task_struct pointer. 10 -R member a comma-separated list of one or more task_struct and/or 11 thread_info structure members. If any member contains an embedded 12 structure, or is an array, the output may be restricted to the 13 embedded structure or an array element by expressing the member 14 argument as \u0026#34;member.member\u0026#34; or \u0026#34;member[index]\u0026#34;; embedded member 15 specifications may extend beyond one level deep, by expressing the 16 member argument as \u0026#34;member.member.member...\u0026#34;. 17 -x override default output format with hexadecimal format. 18 -d override default output format with decimal format. 43.3. EXAMPLES 1 Dump the task_struct and thread_info structures of the current context 2 in hexadecimal format: 3 4 crash\u0026gt; task -x 5 PID: 3176 TASK: f2451550 CPU: 1 COMMAND: \u0026#34;memtest\u0026#34; 6 struct task_struct { 7 state = 0x0, 8 stack = 0xf05b6000, 9 usage = { 10 counter = 0x2 11 }, 12 flags = 0x402040, 13 ptrace = 0x0, 14 lock_depth = 0xffffffff, 15 prio = 0x78, 16 static_prio = 0x78, 17 normal_prio = 0x78, 18 rt_priority = 0x0, 19 ... 20 perf_event_ctxp = {0x0, 0x0}, 21 memcg_batch = { 22 do_batch = 0x0, 23 memcg = 0x0, 24 bytes = 0x0, 25 memsw_bytes = 0x0 26 } 27 } 28 29 struct thread_info { 30 task = 0xf2451550, 31 exec_domain = 0xc0a60860, 32 flags = 0x88, 33 status = 0x0, 34 cpu = 0x1, 35 preempt_count = 0x4010000, 36 addr_limit = { 37 seg = 0xc0000000 38 }, 39 restart_block = { 40 ... 41 42 Display the ngroups and groups task_struct members for PID 2958: 43 44 crash\u0026gt; task -R ngroups,groups 2958 45 PID: 2958 TASK: c6718000 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 46 ngroups = 6, 47 groups = {504, 8, 9, 1000, 1007, 1006, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 49 50 Display the embedded sched_entity structure\u0026#39;s on_rq member: 51 52 crash\u0026gt; task -R se.on_rq 53 PID: 6529 TASK: ffff880116538790 CPU: 1 COMMAND: \u0026#34;bash\u0026#34; 54 se.on_rq = 1, 55 56 Display the 3rd pid_link structure in the embedded pids[] array: 57 58 crash\u0026gt; task -R pids[2] 59 PID: 6529 TASK: ffff880116538790 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 60 pids[2] = { 61 node = { 62 next = 0xffff8801165391b0, 63 pprev = 0xffff880209d011b0 64 }, 65 pid = 0xffff8801f0876e00 66 } 67 68 NOTE: When this command is invoked directly (i.e., not from \u0026#34;foreach\u0026#34;), it 69 is not necessary to include the \u0026#34;-R\u0026#34; before the task_struct/thread_info 70 member name(s). 44. tree - display radix tree, XArray or red-black tree 44.1. SYNOPSIS 1tree [-t [radix|xarray|rbtree]] [-r offset] [-[s|S] struct[.member[,member]]] 2 -[x|d] [-o offset] [-l] [-p] [-N] start 44.2. DESCRIPTION 1 This command dumps the contents of a radix tree, an XAarray, or a red-black 2 tree. The arguments are as follows: 3 4 -t type The type of tree to dump; the type string can be one of 5 \u0026#34;radix\u0026#34;, \u0026#34;rbtree\u0026#34;, or \u0026#34;xarray\u0026#34;, or alternatively, \u0026#34;ra\u0026#34;, 6 \u0026#34;rb\u0026#34; or \u0026#34;x\u0026#34; are acceptable. If not specified, rbtree is the 7 default type. 8 -r offset If the \u0026#34;start\u0026#34; argument is the address of a data structure that 9 contains an radix_tree_root, xarray or rb_root structure, then this 10 is the offset to that structure member. If the offset is non-zero, 11 then this option is required. The offset may be entered in either 12 of two manners: 13 1. In \u0026#34;structure.member\u0026#34; format. 14 2. A number of bytes. 15 -o offset For red-black trees only, the offset of the rb_node within its 16 containing data structure; if the offset is non-zero, then this 17 option is required. The offset may be entered in either of two 18 manners: 19 1. In \u0026#34;structure.member\u0026#34; format. 20 2. A number of bytes. 21 This option is not applicable to radix trees. 22 -s struct For each entry in a tree, format and print it as this type of data 23 structure; use the \u0026#34;struct.member\u0026#34; format in order to display a 24 particular member of the structure. To display multiple members 25 of a structure, use a comma-separated list of members. If any 26 structure member contains an embedded structure or is an array, the 27 the output may be restricted to the embedded structure or an array 28 element by expressing the member argument as \u0026#34;struct.member.member\u0026#34; 29 or \u0026#34;struct.member[index]\u0026#34;; embedded member specifications may 30 extend beyond one level deep by expressing the struct argument as 31 \u0026#34;struct.member.member.member...\u0026#34;. 32 -S struct Similar to -s, but instead of parsing gdb output, member values 33 are read directly from memory, so the command works much faster 34 for 1-, 2-, 4-, and 8-byte members. 35 -l For red-black trees, dump the tree sorted in linear order starting 36 with the leftmost node and progressing to the right. This option 37 does not apply to radix trees. 38 -p Display the node\u0026#39;s position information, showing the relationship 39 between it and the root. For red-black trees, a position that 40 indicates \u0026#34;root/l/r\u0026#34; means that the node is the right child 41 of the left child of the root node. For radix trees and xarrays, 42 the index, the height, and the slot index values are shown with 43 respect to the root. 44 -x Override default output format with hexadecimal format. 45 -d Override default output format with decimal format. 46 47 The meaning of the \u0026#34;start\u0026#34; argument, which can be expressed either in 48 hexadecimal format or symbolically, depends upon whether the -N option 49 is prepended: 50 51 start The address of a radix_tree_root, xarray or rb_root structure, or 52 the address of a structure containing the radix_tree_root, xarray 53 or rb_root structure; if the latter, then the \u0026#34;-r offset\u0026#34; option 54 must be used if the member offset of the root structure is 55 non-zero. 56 57 -N start The address of a radix_tree_node, xa_node or rb_node structure, 58 bypassing the radix_tree_root, xarray, or rb_root that points 59 to it. 44.3. EXAMPLES 1 The vmap_area_root is a standalone rb_root structure. Display the 2 virtual addresses of each vmap_area in its red-black tree: 3 4 crash\u0026gt; whatis vmap_area_root 5 struct rb_root vmap_area_root; 6 crash\u0026gt; tree -t rbtree -o vmap_area.rb_node vmap_area_root 7 ffff880128c508c0 8 ffff88012cb68140 9 ffff88012c9afec0 10 ffff88012d65c440 11 ... 12 13 Display the vmap_area\u0026#39;s va_start and va_end members of each of 14 the entries above expressing the vmap_area.rb_node offset as a 15 number of bytes: 16 17 crash\u0026gt; tree -t rbtree -o 24 vmap_area_root -s vmap_area.va_start,va_end 18 ffff880128c508c0 19 va_start = 0xffffc90014900000 20 va_end = 0xffffc90014921000 21 ffff88012cb68140 22 va_start = 0xffffc900110c0000 23 va_end = 0xffffc900110d1000 24 ffff88012c9afec0 25 va_start = 0xffffc90000640000 26 va_end = 0xffffc90000642000 27 ffff88012d65c440 28 va_start = 0xffffc90000620000 29 va_end = 0xffffc90000622000 30 ... 31 32 Alternatively, use the -N option with the rb_node address contained 33 in the vmap_area_root structure: 34 35 crash\u0026gt; p vmap_area_root 36 vmap_area_root = $8 = { 37 rb_node = 0xffff880128c508d8 38 } 39 crash\u0026gt; tree -t rbtree -o vmap_area.rb_node -N 0xffff880128c508d8 40 ffff880128c508c0 41 ffff88012cb68140 42 ffff88012c9afec0 43 ffff88012d65c440 44 45 Display the virtual address of each vm_area_struct in the red-black 46 tree that has its root inside an mm_struct located at ffff880128b5a300. 47 The vm_area_struct.vm_rb rb_node member has an offset of 0x38 bytes: 48 49 crash\u0026gt; tree -t rbtree -r mm_struct.mm_rb ffff880128b5a300 -o 0x38 50 ffff88012a0de080 51 ffff880123e3ac78 52 ffff880123e3a700 53 ffff88012b2837c8 54 ... 55 ffff880128c02ed0 56 ffff8801292e7958 57 ffff880123e3a318 58 ffff880123e3ad40 59 60 Add the -p option to the command above to show position information: 61 62 crash\u0026gt; tree -t rbtree -r mm_struct.mm_rb ffff880128b5a300 -o 0x38 -p 63 ffff88012a0de080 64 position: root 65 ffff880123e3ac78 66 position: root/l 67 ffff880123e3a700 68 position: root/l/l 69 ffff88012b2837c8 70 position: root/l/l/l 71 ... 72 ffff880128c02ed0 73 position: root/r/r/l/r 74 ffff8801292e7958 75 position: root/r/r/l/r/r 76 ffff880123e3a318 77 position: root/r/r/r 78 ffff880123e3ad40 79 position: root/r/r/r/r 80 81 Given an mm_struct address of 0xffff880074b5be80, list the VMA tree in linear 82 order from the leftmost node progressing to the right using the -l option: 83 84 crash\u0026gt; tree -ls vm_area_struct.vm_start -o vm_area_struct.vm_rb \\ 85 -r mm_struct.mm_rb 0xffff880074b5be80 | paste - - 86 ffff88001f2c50e0\tvm_start = 0x400000 87 ffff88001f2c5290\tvm_start = 0xceb000 88 ffff880074bfc6c0\tvm_start = 0xcec000 89 ffff88001f2c4bd0\tvm_start = 0xd10000 90 ffff880074bfc948\tvm_start = 0x1fe9000 91 ffff880036e54510\tvm_start = 0x7ff6aa296000 92 ffff88001f2c5bd8\tvm_start = 0x7ff6aa298000 93 ffff880036e54af8\tvm_start = 0x7ff6aa497000 94 ffff880036e54f30\tvm_start = 0x7ff6aa498000 95 ffff88000e06aa20\tvm_start = 0x7ff6aa499000 96 ffff88000e06b368\tvm_start = 0x7ff6ab95f000 97 ... 98 ffff88001f2c5e60\tvm_start = 0x7ff6bc1af000 99 ffff88001f2c4ca8\tvm_start = 0x7ff6bc1b6000 100 ffff88001f2c5008\tvm_start = 0x7ff6bc200000 101 ffff88001f2c5d88\tvm_start = 0x7ff6bc205000 102 ffff880074bfd6c8\tvm_start = 0x7ff6bc206000 103 ffff88001f2c4288\tvm_start = 0x7ff6bc207000 104 ffff88001f2c4510\tvm_start = 0x7ffc7a5fc000 105 ffff88001f2c5b00\tvm_start = 0x7ffc7a6d1000 106 107 Compared to the top/down root/leaves order: 108 109 crash\u0026gt; tree -s vm_area_struct.vm_start -o vm_area_struct.vm_rb \\ 110 -r mm_struct.mm_rb 0xffff880074b5be80 | paste - - 111 ffff88001f2c5a28\tvm_start = 0x7ff6bbbb9000 112 ffff88001f2c55f0\tvm_start = 0x7ff6bb252000 113 ffff88000e06a360\tvm_start = 0x7ff6ac6c3000 114 ffff88001f2c4bd0\tvm_start = 0xd10000 115 ffff88001f2c5290\tvm_start = 0xceb000 116 ffff88001f2c50e0\tvm_start = 0x400000 117 ffff880074bfc6c0\tvm_start = 0xcec000 118 ffff88000e06b368\tvm_start = 0x7ff6ab95f000 119 ffff88001f2c5bd8\tvm_start = 0x7ff6aa298000 120 ffff880074bfc948\tvm_start = 0x1fe9000 121 ffff880036e54510\tvm_start = 0x7ff6aa296000 122 ffff880036e54f30\tvm_start = 0x7ff6aa498000 123 ffff880036e54af8\tvm_start = 0x7ff6aa497000 124 ffff88000e06aa20\tvm_start = 0x7ff6aa499000 125 ffff88000e06ae58\tvm_start = 0x7ff6ac1df000 126 ffff88000e06ba28\tvm_start = 0x7ff6abefc000 127 ffff88000e06a6c0\tvm_start = 0x7ff6ac41b000 128 ffff88001f2c4000\tvm_start = 0x7ff6bac75000 129 ffff88000e06bd88\tvm_start = 0x7ff6b2d00000 130 ffff88000e06b440\tvm_start = 0x7ff6b28de000 131 ... 132 ffff880074bfd6c8\tvm_start = 0x7ff6bc206000 133 ffff88001f2c4510\tvm_start = 0x7ffc7a5fc000 134 ffff88001f2c5b00\tvm_start = 0x7ffc7a6d1000 135 136 Display a list of the page structs in the radix tree of an address_space 137 structure located at ffff88012d364de0: 138 139 crash\u0026gt; tree -t radix -r address_space.page_tree ffff88012d364de0 140 ffffea00040d12c0 141 ffffea00040d9a60 142 ffffea00040d9b08 143 ffffea000407eda8 144 ffffea0004084288 145 ... 146 ffffea000407bc70 147 ffffea00040baf48 148 ffffea0004043f48 149 ffffea000407de58 150 151 Add the -p option to the command above to show position information: 152 153 crash\u0026gt; tree -t radix -r address_space.page_tree ffff88012d364de0 -p 154 ffffea00040d12c0 155 index: 0 position: root/0/0 156 ffffea00040d9a60 157 index: 1 position: root/0/1 158 ffffea00040d9b08 159 index: 2 position: root/0/2 160 ffffea000407eda8 161 index: 3 position: root/0/3 162 ffffea0004084288 163 index: 4 position: root/0/4 164 ... 165 ffffea000407bc70 166 index: 217 position: root/3/25 167 ffffea00040baf48 168 index: 218 position: root/3/26 169 ffffea0004043f48 170 index: 219 position: root/3/27 171 ffffea000407de58 172 index: 220 position: root/3/28 173 174 Alternatively, take the address of the radix_tree_node from the 175 radix_tree_root structure in the address_space structure above, 176 and display the tree with the -N option: 177 178 crash\u0026gt; struct address_space.page_tree ffff88012d364de0 179 page_tree = { 180 height = 0x2, 181 gfp_mask = 0x20, 182 rnode = 0xffff8801238add71 183 } 184 crash\u0026gt; tree -t radix -N 0xffff8801238add71 185 ffffea00040d12c0 186 ffffea00040d9a60 187 ffffea00040d9b08 188 ffffea000407eda8 189 ffffea0004084288 190 ffffea00040843a0 191 ... 192 193 Using the same radix tree as above, display the flags and _count 194 members of each page struct in the list, and force the output format 195 to be hexadecimal: 196 197 crash\u0026gt; tree -t radix -N 0xffff8801238add71 -s page.flags,_count -x 198 ffffea00040d12c0 199 flags = 0x4000000002006c 200 _count = { 201 counter = 0x7 202 } 203 ffffea00040d9a60 204 flags = 0x4000000002006c 205 _count = { 206 counter = 0x7 207 } 208 ffffea00040d9b08 209 flags = 0x4000000002006c 210 _count = { 211 counter = 0x7 212 } 213 ffffea000407eda8 214 flags = 0x4000000002006c 215 _count = { 216 counter = 0x7 217 } 218 ... 219 220 In more recent kernels, the XArray facility has replaced radix trees. 221 Display a list of the page structs in the XArray of an address_space 222 structure located at 0xffff94c235e76828, where the i_pages field is 223 an embedded xarray structure: 224 225 crash\u0026gt; tree -t xarray -r address_space.i_pages 0xffff94c235e76828 226 fffffcc005aa8380 227 fffffcc005cafa80 228 fffffcc005a79c80 229 fffffcc005ccad80 230 fffffcc005a72ec0 231 fffffcc005e27c00 232 fffffcc005ce3100 233 fffffcc005ff8dc0 234 fffffcc005c9a100 235 fffffcc005a49e40 236 fffffcc005c95a80 237 238 Add the -p option to the command above to show position information: 239 240 crash\u0026gt; tree -t xarray -r address_space.i_pages 0xffff94c235e76828 -p 241 fffffcc005aa8380 242 index: 90 position: root/1/26 243 fffffcc005cafa80 244 index: 91 position: root/1/27 245 fffffcc005a79c80 246 index: 92 position: root/1/28 247 fffffcc005ccad80 248 index: 93 position: root/1/29 249 fffffcc005a72ec0 250 index: 94 position: root/1/30 251 fffffcc005e27c00 252 index: 95 position: root/1/31 253 fffffcc005ce3100 254 index: 96 position: root/1/32 255 fffffcc005ff8dc0 256 index: 97 position: root/1/33 257 fffffcc005c9a100 258 index: 98 position: root/1/34 259 fffffcc005a49e40 260 index: 99 position: root/1/35 261 fffffcc005c95a80 262 index: 100 position: root/1/36 263 264 Alternatively, take the value found in the xa_head field from 265 the xarray structure, and display the tree with the -N option: 266 267 crash\u0026gt; address_space.i_pages 0xffff94c235e76828 268 i_pages = { 269 ... [ xa_lock field not shown ] ... 270 xa_flags = 1, 271 xa_head = 0xffff94c23c1566ca 272 } 273 crash\u0026gt; tree -t x -N 0xffff94c23c1566ca 274 fffffcc005aa8380 275 fffffcc005cafa80 276 fffffcc005a79c80 277 fffffcc005ccad80 278 fffffcc005a72ec0 279 fffffcc005e27c00 280 fffffcc005ce3100 281 fffffcc005ff8dc0 282 fffffcc005c9a100 283 fffffcc005a49e40 284 fffffcc005c95a80 285 286 Using the same xarray command as above, display the flags and _refcount 287 members of each page struct in the list, and force the output format 288 to be hexadecimal: 289 290 crash\u0026gt; tree -t x -N 0xffff94c23c1566ca -s page.flags,_refcount -x 291 fffffcc005aa8380 292 flags = 0x57ffffc0000014 293 _refcount = { 294 counter = 0x1 295 } 296 fffffcc005cafa80 297 flags = 0x57ffffc0000014 298 _refcount = { 299 counter = 0x1 300 } 301 fffffcc005a79c80 302 flags = 0x57ffffc0000014 303 _refcount = { 304 counter = 0x1 305 } 306 fffffcc005ccad80 307 flags = 0x57ffffc0000014 308 _refcount = { 309 counter = 0x1 310 } 311 fffffcc005a72ec0 312 flags = 0x57ffffc0000014 313 _refcount = { 314 counter = 0x1 315 } 316 fffffcc005e27c00 317 flags = 0x57ffffc0000014 318 _refcount = { 319 counter = 0x1 320 } 321 fffffcc005ce3100 322 flags = 0x57ffffc0000014 323 _refcount = { 324 counter = 0x1 325 } 326 fffffcc005ff8dc0 327 flags = 0x57ffffc0000014 328 _refcount = { 329 counter = 0x1 330 } 331 fffffcc005c9a100 332 flags = 0x57ffffc0000014 333 _refcount = { 334 counter = 0x1 335 } 336 fffffcc005a49e40 337 flags = 0x57ffffc0000014 338 _refcount = { 339 counter = 0x1 340 } 341 fffffcc005c95a80 342 flags = 0x57ffffc0000014 343 _refcount = { 344 counter = 0x1 345 } 45. timer - timer queue data 45.1. SYNOPSIS 1timer [-r][-C cpu] 45.2. DESCRIPTION 1 This command displays the timer queue entries, both old- and new-style, 2 in chronological order. In the case of the old-style timers, the 3 timer_table array index is shown; in the case of the new-style timers, 4 the timer_list address is shown. On later kernels, the timer data is 5 per-cpu. 6 7 -r Display hrtimer timer queue entries, both old- and new-style, in 8 chronological order. In the case of the old-style hrtimers, the 9 expiration time is a single value; in the new-style hrtimers, the 10 expiration time is a range. 11 -C cpu Restrict the output to one or more CPUs, where multiple cpu[s] can 12 be specified, for example, as \u0026#34;1,3,5\u0026#34;, \u0026#34;1-3\u0026#34;, or \u0026#34;1,3,5-7,10\u0026#34;. 45.3. EXAMPLES 1 Display the timer queue on an SMP system: 2 3 crash\u0026gt; timer 4 JIFFIES 5 4296291038 6 ... 7 TIMER_BASES[1][BASE_STD]: ffff9801aba5aa00 8 EXPIRES TTE TIMER_LIST FUNCTION 9 4296282997 -8041 ffff9801aba55ce0 ffffffff83a3bda0 \u0026lt;mce_timer_fn\u0026gt; 10 4296283104 -7934 ffff97fd84bd35e0 ffffffff83ac6b70 \u0026lt;delayed_work_timer_fn\u0026gt; 11 4296291061 23 ffffa6b283967de0 ffffffff83b29880 \u0026lt;process_timeout\u0026gt; 12 4296291112 74 ffff9800c9b62ad8 ffffffff83e6b550 \u0026lt;cursor_timer_handler\u0026gt; 13 4296291345 307 ffff980186d5ef88 ffffffff84146b80 \u0026lt;tcp_keepalive_timer\u0026gt; 14 4296291484 446 ffff9801a7c54740 ffffffff84147f50 \u0026lt;tcp_write_timer\u0026gt; 15 4296291997 959 ffffffffc073f880 ffffffff83ac6b70 \u0026lt;delayed_work_timer_fn\u0026gt; 16 4296296213 5175 ffffa6b28339be18 ffffffff83b29880 \u0026lt;process_timeout\u0026gt; 17 4296304383 13345 ffff980194ca72a8 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 18 4296305724 14686 ffff980194ca6918 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 19 4296306036 14998 ffff980194ca6d58 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 20 4296306883 15845 ffff980194ca7e58 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 21 4296307588 16550 ffff9801aaa27e58 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 22 4296307625 16587 ffff980194ca6a28 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 23 4296313542 22504 ffff980194ca7c38 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 24 4296317680 26642 ffff9800c9149c58 ffffffff840da870 \u0026lt;neigh_timer_handler\u0026gt; 25 4296317744 26706 ffff9801a5354468 ffffffff83ac6b70 \u0026lt;delayed_work_timer_fn\u0026gt; 26 4296343322 52284 ffff980194ca63c8 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 27 4296343581 52543 ffff980194ca7088 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 28 4296343597 52559 ffff9801aaa274c8 ffffffff8412e4e0 \u0026lt;tw_timer_handler\u0026gt; 29 4296714205 423167 ffffffff84caf3c0 ffffffff83ac6b70 \u0026lt;delayed_work_timer_fn\u0026gt; 30 TIMER_BASES[1][BASE_DEF]: ffff9801aba5bc80 31 EXPIRES TTE TIMER_LIST FUNCTION 32 4296291264 226 ffffffff855eb238 ffffffff83c08fb0 \u0026lt;writeout_period\u0026gt; 33 4296319997 28959 ffffffffc06ede40 ffffffff83ac6b70 \u0026lt;delayed_work_timer_fn\u0026gt; 34 4296506084 215046 ffff9801aba629c8 ffffffff83ac5ea0 \u0026lt;idle_worker_timeout\u0026gt; 35 ... 36 37 Display a new-style hrtimer queue: 38 39 crash\u0026gt; timer -r 40 ... 41 CPU: 2 HRTIMER_CPU_BASE: ffff9801aba9cf00 42 CLOCK: 0 HRTIMER_CLOCK_BASE: ffff9801aba9cf40 [ktime_get] 43 CURRENT 44 1623742000000 45 SOFTEXPIRES EXPIRES TTE HRTIMER FUNCTION 46 1623741000000 1623741000000 -1000000 ffff9801aba9d540 ffffffff83b3c8e0 \u0026lt;tick_sched_timer\u0026gt; 47 1624024000000 1624024000000 282000000 ffff9801aba9d720 ffffffff83b7e7a0 \u0026lt;watchdog_timer_fn\u0026gt; 48 1626000939806 1626010929804 2268929804 ffffa6b28399fa40 ffffffff83b2c1e0 \u0026lt;hrtimer_wakeup\u0026gt; 49 1627576915615 1627576915615 3834915615 ffff9801a5727978 ffffffff83b365c0 \u0026lt;posix_timer_fn\u0026gt; 50 1627637194488 1627647194487 3905194487 ffffa6b283977db0 ffffffff83b2c1e0 \u0026lt;hrtimer_wakeup\u0026gt; 51 1629937423000 1629937423000 6195423000 ffff9801a9af2900 ffffffff83cf3d30 \u0026lt;timerfd_tmrproc\u0026gt; 52 53 CLOCK: 1 HRTIMER_CLOCK_BASE: ffff9801aba9cf80 [ktime_get_real] 54 CURRENT 55 1558362388334558243 56 SOFTEXPIRES EXPIRES TTE HRTIMER FUNCTION 57 1558362389331238000 1558362389331288000 996729757 ffffa6b28574bcf0 ffffffff83b2c1e0 \u0026lt;hrtimer_wakeup\u0026gt; 58 1558364372000000000 1558364372000000000 1983665441757 ffff9801a3513278 ffffffff83b365c0 \u0026lt;posix_timer_fn\u0026gt; 59 60 CLOCK: 2 HRTIMER_CLOCK_BASE: ffff9801aba9cfc0 [ktime_get_boottime] 61 (empty) 62 ... 46. union - union contents 46.1. SYNOPSIS 1union union_name[.member[,member]] [-o][-l offset][-rfuxdp] 2 [address | symbol][:cpuspec] [count | -c count] 46.2. DESCRIPTION 1 This command displays either a union definition, or a formatted display 2 of the contents of a union at a specified address. When no address is 3 specified, the union definition is shown along with the union size. 4 A union member may be appended to the structure name in order to limit 5 the scope of the data displayed to that particular member; when no address 6 is specified, the member\u0026#39;s offset (always 0) and definition are shown. 7 8 union_name name of a C-code union used by the kernel. 9 .member name of a union member; to display multiple members of a 10 union, use a comma-separated list of members. If any member 11 contains an embedded structure, or the member is an array, the 12 output may be restricted to just the embedded structure or an 13 array element by expressing the argument as \u0026#34;member.member\u0026#34; 14 or \u0026#34;member[index]\u0026#34;; embedded member specifications may extend 15 beyond one level deep, by expressing the member argument as 16 \u0026#34;member.member.member...\u0026#34;. 17 -o show member offsets when displaying union definitions; the 18 offset is always 0 unless used with an address or symbol 19 argument, in which case each member will be preceded by its 20 virtual address. 21 -l offset if the address argument is a pointer to a list_head structure 22 that is embedded in the target union structure, the offset 23 to the list_head member may be entered in either of the 24 following manners: 25 1. in \u0026#34;structure.member\u0026#34; format. 26 2. a number of bytes. 27 -r raw dump of union data. 28 -f address argument is a dumpfile offset. 29 -x override default output format with hexadecimal format. 30 -d override default output format with decimal format. 31 -p if a union member is a pointer value, show the member\u0026#39;s 32 data type on the output line; and on the subsequent line(s), 33 dereference the pointer, display the pointer target\u0026#39;s symbol 34 value in brackets if appropriate, and if possible, display the 35 target data; requires an address argument. 36 -u address argument is a user virtual address in the current 37 context. 38 address hexadecimal address of a union; if the address points 39 to an embedded list_head structure contained within the 40 target union structure, then the \u0026#34;-l\u0026#34; option must be used. 41 symbol symbolic reference to the address of a union. 42 :cpuspec CPU specification for a per-cpu address or symbol: 43 : CPU of the currently selected task. 44 :a[ll] all CPUs. 45 :#[-#][,...] CPU list(s), e.g. \u0026#34;1,3,5\u0026#34;, \u0026#34;1-3\u0026#34;, 46 or \u0026#34;1,3,5-7,10\u0026#34;. 47 count count of unions to dump from an array of unions; if used, 48 this must be the last argument entered. 49 -c count \u0026#34;-c\u0026#34; is only required if \u0026#34;count\u0026#34; is not the last argument 50 entered or if a negative number is entered; if a negative 51 value is entered, the (positive) \u0026#34;count\u0026#34; structures that 52 lead up to and include the target structure will be displayed. 53 54 Union data, sizes, and member offsets are shown in the current output radix 55 unless the -x or -d option is specified. 56 57 Please note that in the vast majority of cases, the \u0026#34;union\u0026#34; command 58 name may be dropped; if the union name does not conflict with any crash 59 or gdb command name, then the \u0026#34;union_name[.member]\u0026#34; argument will be 60 recognized as a union name, and this command automatically executed. 61 See the NOTE below. 46.3. EXAMPLES 1 2 Display the bdflush_param union definition, and then an instance of it: 3 4 crash\u0026gt; union bdflush_param 5 union bdflush_param { 6 struct { 7 int nfract; 8 int ndirty; 9 int nrefill; 10 int nref_dirt; 11 int dummy1; 12 int age_buffer; 13 int age_super; 14 int dummy2; 15 int dummy3; 16 } b_un; 17 unsigned int data[9]; 18 } 19 20 SIZE: 36 (0x24) 21 22 crash\u0026gt; union bdflush_param bdf_prm 23 union bdflush_param { 24 b_un = { 25 nfract = 40, 26 ndirty = 500, 27 nrefill = 64, 28 nref_dirt = 256, 29 dummy1 = 15, 30 age_buffer = 3000, 31 age_super = 500, 32 dummy2 = 1884, 33 dummy3 = 2 34 }, 35 data = {40, 500, 64, 256, 15, 3000, 500, 1884, 2} 36 } 46.4. NOTE 1 If the union name does not conflict with any crash command name, the 2 \u0026#34;union\u0026#34; command may be dropped. Accordingly, the examples above could 3 also have been accomplished like so: 4 5 crash\u0026gt; bdflush_param 6 crash\u0026gt; bdflush_param bdf_prm 7 8 Lastly, the short-cut \u0026#34;*\u0026#34; (pointer-to) command may also be used to negate 9 the need to enter the \u0026#34;union\u0026#34; command name (enter \u0026#34;help *\u0026#34; for details). 47. vm - virtual memory 47.1. SYNOPSIS 1vm [-p | -P vma | -M mm | -v | -m | -x | -d | [-R reference] [pid | task]] 2 [-f vm_flags] 47.2. DESCRIPTION 1 This command displays basic virtual memory information of a context, 2 consisting of a pointer to its mm_struct and page dirctory, its RSS and 3 total virtual memory size; and a list of pointers to each vm_area_struct, 4 its starting and ending address, vm_flags value, and file pathname. If no 5 arguments are entered, the current context is used. Additionally, the -p 6 option translates each virtual page of each VM area to its physical address. 7 The -R option, typically invoked from \u0026#34;foreach vm\u0026#34;, searches for references 8 to a supplied number, address, or filename argument, and prints only the 9 essential information leading up to and including the reference. 10 Alternatively, the -m or -v options may be used to dump the task\u0026#39;s mm_struct 11 or all of its vm_area_structs respectively. The -p, -v, -m, -R and -f 12 options are all mutually exclusive. 13 14 -p translate each virtual page to its physical address, or if 15 the page is not mapped, its swap device and offset, or 16 filename and offset. 17 -P vma similar to -p, but only translate the pages belonging to the 18 specified VM area of a context. 19 -M mm if the mm_struct address has been removed from the task_struct 20 of an exiting task, the virtual memory data cannot be displayed. 21 However, if the address can be determined from the kernel stack, 22 it can be entered manually in order to try to resurrect the 23 virtual memory data of the task. 24 -R reference search for references to this number or filename. 25 -m dump the mm_struct assocated with the task. 26 -v dump all of the vm_area_structs associated with the task. 27 -x override the default output format for the -m or -v options 28 with hexadecimal format. 29 -d override the default output format for the -m or -v options 30 with decimal format. 31 -f vm_flags translate the bits of a FLAGS (vm_flags) value. 32 pid a process PID. 33 task a hexadecimal task_struct pointer. 47.3. EXAMPLES 1 Display the virtual memory data of the current context: 2 3 crash\u0026gt; vm 4 PID: 30986 TASK: c0440000 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 5 MM PGD RSS TOTAL_VM 6 c303fe20 c4789000 88k 1728k 7 VMA START END FLAGS FILE 8 c0d1f540 8048000 80ad000 1875 /bin/bash 9 c0d1f400 80ad000 80b3000 1873 /bin/bash 10 c0d1f880 80b3000 80ec000 77 11 c0d1f0c0 40000000 40012000 875 /lib/ld-2.1.1.so 12 c0d1f700 40012000 40013000 873 /lib/ld-2.1.1.so 13 c0d1fe00 40013000 40014000 77 14 c0d1f580 40014000 40016000 73 15 c0d1f280 4001a000 4004b000 75 /usr/lib/libncurses.so.4.2 16 c0d1f100 4004b000 40054000 73 /usr/lib/libncurses.so.4.2 17 c0d1f600 40054000 40057000 73 18 c0d1f9c0 40057000 40059000 75 /lib/libdl-2.1.1.so 19 c0d1f800 40059000 4005a000 73 /lib/libdl-2.1.1.so 20 c0d1fd00 4005a000 40140000 75 /lib/libc-2.1.1.so 21 c0d1fe40 40140000 40145000 73 /lib/libc-2.1.1.so 22 c0d1f780 40145000 40148000 73 23 c0d1f140 40148000 40150000 75 /lib/libnss_files-2.1.1.so 24 c0d1fa80 40150000 40151000 73 /lib/libnss_files-2.1.1.so 25 c0d1fb00 40151000 4015a000 75 /lib/libnss_nisplus-2.1.1.so 26 c5f754e0 4015a000 4015b000 73 /lib/libnss_nisplus-2.1.1.so 27 c0d1fec0 4015b000 4016d000 75 /lib/libnsl-2.1.1.so 28 c5f75460 4016d000 4016e000 73 /lib/libnsl-2.1.1.so 29 c5f75420 4016e000 40170000 73 30 c5f753e0 40170000 40178000 75 /lib/libnss_nis-2.1.1.so 31 c5f753a0 40178000 40179000 73 /lib/libnss_nis-2.1.1.so 32 c0d1f240 bfffc000 c0000000 177 33 34 Display the virtual memory data along with page translations for PID 386: 35 36 crash\u0026gt; vm -p 386 37 PID: 386 TASK: c11cc000 CPU: 0 COMMAND: \u0026#34;atd\u0026#34; 38 MM PGD RSS TOTAL_VM 39 c7e30560 c10e5000 104k 1112k 40 VMA START END FLAGS FILE 41 c0fbe6a0 8048000 804b000 1875 /usr/sbin/atd 42 VIRTUAL PHYSICAL 43 8048000 20e1000 44 8049000 17c6000 45 804a000 1f6f000 46 VMA START END FLAGS FILE 47 c61e0ba0 804b000 804d000 1873 /usr/sbin/atd 48 VIRTUAL PHYSICAL 49 804b000 254d000 50 804c000 6a9c000 51 VMA START END FLAGS FILE 52 c61e04e0 804d000 8050000 77 53 VIRTUAL PHYSICAL 54 804d000 219d000 55 804e000 2617000 56 804f000 SWAP: /dev/sda8 OFFSET: 24225 57 VMA START END FLAGS FILE 58 c61e0720 40000000 40012000 875 /lib/ld-2.1.1.so 59 VIRTUAL PHYSICAL 60 40000000 FILE: /lib/ld-2.1.1.so OFFSET: 0 61 40001000 FILE: /lib/ld-2.1.1.so OFFSET: 1000 62 40002000 FILE: /lib/ld-2.1.1.so OFFSET: 2000 63 40003000 FILE: /lib/ld-2.1.1.so OFFSET: 3000 64 40004000 FILE: /lib/ld-2.1.1.so OFFSET: 4000 65 40005000 FILE: /lib/ld-2.1.1.so OFFSET: 5000 66 ... 67 68 Although the -R option is typically invoked from \u0026#34;foreach vm\u0026#34;, it can be 69 executed directly. This example displays all VM areas with vm_flags of 75: 70 71 crash\u0026gt; vm -R 75 72 PID: 694 TASK: c0c76000 CPU: 1 COMMAND: \u0026#34;crash\u0026#34; 73 MM PGD RSS TOTAL_VM 74 c6c43110 c0fe9000 8932k 10720k 75 VMA START END FLAGS FILE 76 c322c0d0 40019000 4004a000 75 /usr/lib/libncurses.so.4.2 77 c67537c0 40056000 40071000 75 /lib/libm-2.1.1.so 78 c6753d00 40072000 40074000 75 /lib/libdl-2.1.1.so 79 c6753540 40075000 40081000 75 /usr/lib/libz.so.1.1.3 80 c6753740 40085000 4016b000 75 /lib/libc-2.1.1.so 81 82 One reason to use -R directly is to pare down the output associated with 83 the -p option on a task with a huge address space. This example displays 84 the page data associated with virtual address 40121000: 85 86 crash\u0026gt; vm -R 40121000 87 PID: 694 TASK: c0c76000 CPU: 0 COMMAND: \u0026#34;crash\u0026#34; 88 MM PGD RSS TOTAL_VM 89 c6c43110 c0fe9000 8928k 10720k 90 VMA START END FLAGS FILE 91 c6753740 40085000 4016b000 75 /lib/libc-2.1.1.so 92 VIRTUAL PHYSICAL 93 40121000 FILE: /lib/libc-2.1.1.so OFFSET: 9c000 94 95 Display the mm_struct for PID 4777: 96 97 crash\u0026gt; vm -m 4777 98 PID: 4777 TASK: c0896000 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 99 struct mm_struct { 100 mmap = 0xc6caa1c0, 101 mmap_avl = 0x0, 102 mmap_cache = 0xc6caabc0, 103 pgd = 0xc100a000, 104 count = { 105 counter = 0x1 106 }, 107 map_count = 0x14, 108 mmap_sem = { 109 count = { 110 counter = 0x1 111 }, 112 waking = 0x0, 113 wait = 0x0 114 }, 115 context = 0x0, 116 start_code = 0x8048000, 117 end_code = 0x809c6f7, 118 start_data = 0x0, 119 end_data = 0x80a2090, 120 start_brk = 0x80a5420, 121 brk = 0x80b9000, 122 start_stack = 0xbffff9d0, 123 arg_start = 0xbffffad1, 124 arg_end = 0xbffffad7, 125 env_start = 0xbffffad7, 126 env_end = 0xbffffff2, 127 rss = 0xf6, 128 total_vm = 0x1a3, 129 locked_vm = 0x0, 130 def_flags = 0x0, 131 cpu_vm_mask = 0x0, 132 swap_cnt = 0x23d, 133 swap_address = 0x0, 134 segments = 0x0 135 } 136 137 Display all of the vm_area_structs for task c47d4000: 138 139 crash\u0026gt; vm -v c47d4000 140 PID: 4971 TASK: c47d4000 CPU: 1 COMMAND: \u0026#34;login\u0026#34; 141 struct vm_area_struct { 142 vm_mm = 0xc4b0d200, 143 vm_start = 0x8048000, 144 vm_end = 0x804d000, 145 vm_next = 0xc3e3abd0, 146 vm_page_prot = { 147 pgprot = 0x25 148 }, 149 vm_flags = 0x1875, 150 vm_avl_height = 0x1, 151 vm_avl_left = 0x0, 152 vm_avl_right = 0x0, 153 vm_next_share = 0x0, 154 vm_pprev_share = 0xc3e3abf0, 155 vm_ops = 0xc02392a0, 156 vm_offset = 0x0, 157 vm_file = 0xc1e23660, 158 vm_pte = 0x0 159 } 160 struct vm_area_struct { 161 vm_mm = 0xc4b0d200, 162 vm_start = 0x804d000, 163 vm_end = 0x804e000, 164 vm_next = 0xc3e3a010, 165 vm_page_prot = { 166 pgprot = 0x25 167 }, 168 vm_flags = 0x1873, 169 vm_avl_height = 0x2, 170 vm_avl_left = 0xc3e3a810, 171 vm_avl_right = 0xc3e3a010, 172 vm_next_share = 0xc3e3a810, 173 vm_pprev_share = 0xc3699c14 174 ... 175 176 Translate a FLAGS value: 177 178 crash\u0026gt; vm -f 3875 179 3875: (READ|EXEC|MAYREAD|MAYWRITE|MAYEXEC|DENYWRITE|EXECUTABLE|LOCKED) 180 181 Display the page translations of the VM area at address f5604f2c: 182 183 crash\u0026gt; vm -P f5604f2c 184 PID: 5508 TASK: f56a9570 CPU: 0 COMMAND: \u0026#34;crond\u0026#34; 185 VMA START END FLAGS FILE 186 f5604f2c f5b000 f67000 8000075 /lib/libnss_files-2.12.so 187 VIRTUAL PHYSICAL 188 f5b000 3fec1000 189 f5c000 3d3a4000 190 f5d000 FILE: /lib/libnss_files-2.12.so OFFSET: 2000 191 f5e000 FILE: /lib/libnss_files-2.12.so OFFSET: 3000 192 f5f000 FILE: /lib/libnss_files-2.12.so OFFSET: 4000 193 f60000 3fd31000 194 f61000 3fd32000 195 f62000 FILE: /lib/libnss_files-2.12.so OFFSET: 7000 196 f63000 FILE: /lib/libnss_files-2.12.so OFFSET: 8000 197 f64000 3ff35000 198 f65000 FILE: /lib/libnss_files-2.12.so OFFSET: a000 199 f66000 FILE: /lib/libnss_files-2.12.so OFFSET: b000 48. vtop - virtual to physical 48.1. SYNOPSIS 1vtop [-c [pid | taskp]] [-u|-k] address ... 48.2. DESCRIPTION 1 This command translates a user or kernel virtual address to its physical 2 address. Also displayed is the PTE translation, the vm_area_struct data 3 for user virtual addresses, the mem_map page data associated with the 4 physical page, and the swap location or file location if the page is 5 not mapped. The -u and -k options specify that the address is a user 6 or kernel virtual address; -u and -k are not necessary on processors whose 7 virtual addresses self-define themselves as user or kernel. User addresses 8 are translated with respect to the current context unless the -c option 9 is used. Kernel virtual addresses are translated using the swapper_pg_dir 10 as the base page directory unless the -c option is used. 11 12 -u The address is a user virtual address; only required 13 on processors with overlapping user and kernel virtual 14 address spaces. 15 -k The address is a kernel virtual address; only required 16 on processors with overlapping user and kernel virtual 17 address spaces. 18 -c [pid | taskp] Translate the virtual address from the page directory 19 of the specified PID or hexadecimal task_struct pointer. 20 However, if this command is invoked from \u0026#34;foreach vtop\u0026#34;, 21 the pid or taskp argument should NOT be entered; the 22 address will be translated using the page directory of 23 each task specified by \u0026#34;foreach\u0026#34;. 24 address A hexadecimal user or kernel virtual address. 48.3. EXAMPLES 1 Translate user virtual address 80b4000: 2 3 crash\u0026gt; vtop 80b4000 4 VIRTUAL PHYSICAL 5 80b4000 660f000 6 7 PAGE DIRECTORY: c37f0000 8 PGD: c37f0080 =\u0026gt; e0d067 9 PMD: c37f0080 =\u0026gt; e0d067 10 PTE: c0e0d2d0 =\u0026gt; 660f067 11 PAGE: 660f000 12 13 PTE PHYSICAL FLAGS 14 660f067 660f000 (PRESENT|RW|USER|ACCESSED|DIRTY) 15 16 VMA START END FLAGS FILE 17 c773daa0 80b4000 810c000 77 18 19 PAGE PHYSICAL INODE OFFSET CNT FLAGS 20 c0393258 660f000 0 17000 1 uptodate 21 22 Translate kernel virtual address c806e000, first using swapper_pg_dir 23 as the page directory base, and secondly, using the page table base 24 of PID 1359: 25 26 crash\u0026gt; vtop c806e000 27 VIRTUAL PHYSICAL 28 c806e000 2216000 29 30 PAGE DIRECTORY: c0101000 31 PGD: c0101c80 =\u0026gt; 94063 32 PMD: c0101c80 =\u0026gt; 94063 33 PTE: c00941b8 =\u0026gt; 2216063 34 PAGE: 2216000 35 36 PTE PHYSICAL FLAGS 37 2216063 2216000 (PRESENT|RW|ACCESSED|DIRTY) 38 39 PAGE PHYSICAL INODE OFFSET CNT FLAGS 40 c02e9370 2216000 0 0 1 41 42 crash\u0026gt; vtop -c 1359 c806e000 43 VIRTUAL PHYSICAL 44 c806e000 2216000 45 46 PAGE DIRECTORY: c5caf000 47 PGD: c5cafc80 =\u0026gt; 94063 48 PMD: c5cafc80 =\u0026gt; 94063 49 PTE: c00941b8 =\u0026gt; 2216063 50 PAGE: 2216000 51 52 PTE PHYSICAL FLAGS 53 2216063 2216000 (PRESENT|RW|ACCESSED|DIRTY) 54 55 PAGE PHYSICAL INODE OFFSET CNT FLAGS 56 c02e9370 2216000 0 0 1 57 58 Determine swap location of user virtual address 40104000: 59 60 crash\u0026gt; vtop 40104000 61 VIRTUAL PHYSICAL 62 40104000 (not mapped) 63 64 PAGE DIRECTORY: c40d8000 65 PGD: c40d8400 =\u0026gt; 6bbe067 66 PMD: c40d8400 =\u0026gt; 6bbe067 67 PTE: c6bbe410 =\u0026gt; 58bc00 68 69 PTE SWAP OFFSET 70 58bc00 /dev/sda8 22716 71 72 VMA START END FLAGS FILE 73 c7200ae0 40104000 40b08000 73 74 75 SWAP: /dev/sda8 OFFSET: 22716 49. waitq - list tasks queued on a wait queue 49.1. SYNOPSIS 1waitq [ symbol ] | [ struct.member struct_addr ] | [ address ] 49.2. DESCRIPTION 1 This command walks the wait queue list displaying the tasks which 2 are blocked on the specified wait queue. The command differentiates 3 between the old- and new-style wait queue structures used by the kernel. 4 It can be invoked with the following argument types: 5 6 symbol a global symbol of a wait queue. 7 struct.member struct_addr a structure name and wait queue member combination 8 followed by the structure\u0026#39;s hexadecimal address. 9 address a hexadecimal wait queue pointer. 49.3. EXAMPLES 1 2 Find out if any tasks are blocked on the \u0026#34;buffer_wait\u0026#34; wait queue: 3 4 crash\u0026gt; waitq buffer_wait 5 wait queue \u0026#34;buffer_wait\u0026#34; (c02927f0) is empty 6 7 See who is blocked on the \u0026#34;wait_chldexit\u0026#34; queue of task c5496000: 8 9 crash\u0026gt; waitq task_struct.wait_chldexit c5496000 10 PID: 30879 TASK: c5496000 CPU: 0 COMMAND: \u0026#34;bash\u0026#34; 11 12 Display the task list waiting on a known task queue: 13 14 crash\u0026gt; waitq c3534098 15 PID: 13691 TASK: c3534000 CPU: 1 COMMAND: \u0026#34;bash\u0026#34; 50. whatis - search symbol table for data or type information 50.1. SYNOPSIS 1whatis [[-o] [struct | union | typedef | symbol]] | 2 [[-r [size|range]] [-m member]] 50.2. DESCRIPTION 1 This command displays the definition of structures, unions, typedefs or 2 text/data symbols: 3 4 struct a structure name. The output is the same as if the \u0026#34;struct\u0026#34; 5 command was used. 6 union a union name. The output is the same as if the \u0026#34;union\u0026#34; command 7 was used. 8 -o display the offsets of structure/union members. 9 typedef a typedef name. If the typedef translates to a structure or union 10 the output is the same as if the \u0026#34;struct\u0026#34; or \u0026#34;union\u0026#34; command 11 was used. If the typedef is a primitive datatype, the one-line 12 declaration is displayed. 13 symbol a kernel symbol. 14 15 Alternatively, a search can be made for data structures of a given size or 16 size range, that contain a member of a given type, or contain a pointer to 17 given type. The -r and -m options may be used alone or in conjunction with 18 one another: 19 20 -r size search for structures of this exact size. 21 -r range search for structures of a range of sizes, expressed as \u0026#34;low-high\u0026#34;. 22 -m member search for structures that contain a member of this data type, or 23 that contain a pointer to this data type; if a structure contains 24 another structure, the members of the embedded structure will also 25 be subject to the search. The member argument may also be expressed 26 as a substring of a member\u0026#39;s data type. 50.3. EXAMPLES 1 Display the definition of a linux_binfmt structure: 2 3 crash\u0026gt; whatis linux_binfmt 4 struct linux_binfmt { 5 struct list_head lh; 6 struct module *module; 7 int (*load_binary)(struct linux_binprm *); 8 int (*load_shlib)(struct file *); 9 int (*core_dump)(struct coredump_params *); 10 unsigned long min_coredump; 11 } 12 SIZE: 56 13 14 Display the same structure with member offsets: 15 16 crash\u0026gt; whatis -o linux_binfmt 17 struct linux_binfmt { 18 [0] struct list_head lh; 19 [16] struct module *module; 20 [24] int (*load_binary)(struct linux_binprm *); 21 [32] int (*load_shlib)(struct file *); 22 [40] int (*core_dump)(struct coredump_params *); 23 [48] unsigned long min_coredump; 24 } 25 SIZE: 56 26 27 Since a kmem_bufctl_t is typedef\u0026#39;d to be a kmem_bufctl_s structure, the 28 output of the following two commands is identical: 29 30 crash\u0026gt; whatis kmem_bufctl_s 31 struct kmem_bufctl_s { 32 union { 33 struct kmem_bufctl_s *buf_nextp; 34 kmem_slab_t *buf_slabp; 35 void *buf_objp; 36 } u; 37 }; 38 39 crash\u0026gt; whatis kmem_bufctl_t 40 struct kmem_bufctl_s { 41 union { 42 struct kmem_bufctl_s *buf_nextp; 43 kmem_slab_t *buf_slabp; 44 void *buf_objp; 45 } u; 46 }; 47 SIZE: 4 (0x4) 48 49 Display the type data of sys_read() and jiffies text and data symbols: 50 51 crash\u0026gt; whatis sys_read 52 ssize_t sys_read(unsigned int, char *, size_t); 53 54 crash\u0026gt; whatis jiffies 55 long unsigned int jiffies; 56 57 Display definition of a kdev_t typedef: 58 59 crash\u0026gt; whatis kdev_t 60 typedef short unsigned int kdev_t; 61 SIZE: 2 (0x2) 62 63 Display all structures which have a size of 192 bytes: 64 65 crash\u0026gt; whatis -r 192 66 SIZE TYPE 67 192 _intel_private 68 192 blkcg_gq 69 192 clock_event_device 70 192 cper_sec_proc_generic 71 192 dentry 72 192 dst_ops 73 192 ehci_itd 74 192 ethtool_rxnfc 75 192 fb_ops 76 192 file_lock 77 192 inode_operations 78 192 input_device_id 79 192 ip_vs_stats 80 192 numa_group 81 192 parallel_data 82 192 pcie_port_service_driver 83 192 pebs_record_hsw 84 192 pnp_driver 85 192 regmap_config 86 192 sched_entity 87 192 tcp_timewait_sock 88 192 timerfd_ctx 89 192 tpm_vendor_specific 90 192 urb 91 92 Display all structures that contain members that point to 93 an mm_struct: 94 95 crash\u0026gt; whatis -m mm_struct 96 SIZE TYPE 97 16 tlb_state 98 24 flush_tlb_info 99 24 ftrace_raw_xen_mmu_pgd 100 24 futex_key 101 24 map_info 102 32 ftrace_raw_xen_mmu_alloc_ptpage 103 32 ftrace_raw_xen_mmu_pte_clear 104 40 ftrace_raw_xen_mmu_flush_tlb_others 105 40 ftrace_raw_xen_mmu_ptep_modify_prot 106 40 ftrace_raw_xen_mmu_set_pte_at 107 40 mm_slot 108 64 mm_walk 109 64 rmap_item 110 104 userfaultfd_ctx 111 128 mmu_gather 112 216 vm_area_struct 113 256 linux_binprm 114 2616 rq 115 2936 task_struct 116 117 Display all structures sized from 256 to 512 bytes that 118 contain members that point to a task_struct: 119 120 crash\u0026gt; whatis -r 256-512 -m task_struct 121 SIZE TYPE 122 256 file 123 256 od_cpu_dbs_info_s 124 264 srcu_notifier_head 125 272 protection_domain 126 288 clk_notifier 127 288 fsnotify_group 128 296 quota_info 129 312 tty_port 130 320 workqueue_struct 131 344 trace_array 132 344 uart_state 133 352 cpufreq_policy 134 352 elf_thread_core_info 135 376 perf_event_context 136 384 rcu_data 137 400 cgroup 138 408 subsys_private 139 424 hvc_struct 140 496 psmouse 51. wr - write memory 51.1. SYNOPSIS 1wr [-u|-k|-p] [-8|-16|-32|-64] [address|symbol] value 51.2. DESCRIPTION 1 This command modifies the contents of memory. The starting address may be 2 entered either symbolically or by address. The default modification size 3 is the size of a long data type. Write permission must exist on the 4 /dev/mem. When writing to memory on a live system, this command should 5 obviously be used with great care. 6 7 -u address argument is a user virtual address. 8 -k address argument is a kernel virtual address. 9 -p address argument is a physical address. 10 -8 write data in an 8-bit value. 11 -16 write data in a 16-bit value. 12 -32 write data in a 32-bit values (default on 32-bit machines). 13 -64 write data in a 64-bit values (default on 64-bit machines). 14 address address to write. The address is considered virtual unless the 15 -p option is used. If a virtual address is specified, the 16 -u or -k options are necessary only if the address space cannot 17 be determined from the address value itself. If a user virtual 18 address is specified, the address space of the current context 19 implied. The address must be expressed in hexadecimal format. 20 symbol symbol of starting address to write. 21 value the value of the data to write. 51.3. EXAMPLES 1 Turn on a debug flag: 2 3 crash\u0026gt; wr my_debug_flag 1 ","date":"December 3, 2023","img":"https://kingdix10.github.io/covers/travel_map_compass_123078_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/debug/kdump_crash/help/","series":[{"title":"内核调试","url":"/zh-cn/series/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"}],"smallImg":"","tags":[{"title":"kdump crash","url":"/zh-cn/tags/kdump-crash/"},{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"}],"timestamp":1701561600,"title":"Crash帮助信息"},{"categories":[{"title":"内核调试","url":"/zh-cn/categories/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"},{"title":"kdump crash","url":"/zh-cn/categories/kdump-crash/"}],"content":" 1. Crash命令介绍 虽然使用硬件设备来调试有很多优点和方便之处，但是我一直希望代码是可以自己调试自己的，从而避免使用一些昂贵的外部的的设备。\ncrash version: 8.0.2 gdb version: 10.2共51个命令。\n1* files mod sbitmapq union 2alias foreach mount search vm 3ascii fuser net set vtop 4bpf gdb p sig waitq 5bt help ps struct whatis 6btop ipcs pte swap wr 7dev irq ptob sym q 8dis kmem ptov sys 9eval list rd task 10exit log repeat timer 11extend mach runq tree 1.1. Symbolic display of kernel text or data【7】 这些命令利用gdb的能力来显示内核数据结构。\nindex Command Description 1 struct 查看结构体信息 2 union 类似struct，查看union信息 3 * 代替struct或者union 4 p 显示变量/符号等的内容 5 whatis 查找符号/数据结构信息 6 sym 查看内核及模块的符号的虚拟地址 7 dis 查看反汇编信息 1.2. System state【25】 系统范围或按任务为单位的各种内核子系统相关命令。\nindex Command Description 1 bt 分析调用栈 2 dev 查看设备节点信息 3 files 查看进程打开的文件 4 fuser 查看文件或socket正在被哪些进程使用 5 irq 查看irq相关信息 6 kmem 查看内核内存信息 7 log 查看内核日志信息 8 mach machine相关数据 9 mod 查看模块信息、符号和调试数据 10 mount 查看被挂载的文件系统信息 11 net 显示网络信息 12 ps 查看系统中的进程状态 13 pte 查看页表项 14 runq 查看cpu运行队列 15 sig 查看任务的所有信号信息 16 swap 查看swap设备信息 17 sys 查看系统信息 18 task 查看任务的task_struct和thread_info信息 19 timer 查看定时器队列数据 20 vm 查看上下文的虚拟内存信息，比如task_struct、mm_struct 21 vtop 将内核或者用户虚拟地址转为物理地址，映射不存在时转为swap或文件信息 22 waitq 查看在等待队列中睡眠的进程 23 tree 遍历radix tree、XArray或red-black tree的内容 24 ipcs 查看进程间通信信息 25 sbitmapq 查看sbitmap_queue数据结构的信息 1.3. Utility functions【9】 不同用途的辅助命令。\nindex Command Description 1 ascii 十六进制转字符串 2 btop bytes to page，十六进制地址转页帧号 3 eval 计算表达式 4 list 遍历列表 5 ptob page to bytes，页帧号转字节数据 6 ptov 将物理地址或者percpu地址转换为内核虚拟地址 7 search 在内存里搜索指定的内容 8 rd 读取指定地址的内容 9 wr 向指定地址写入数据 1.4. Session Control Commands【10】 crash会话控制命令\nindex Command Description 1 alias 查看别名列表或为命令设置别名 2 bpf 显示eBPF程序信息 3 exit 退出crash 4 extend 加载或卸载crash插件 5 foreach 遍历指定的进程并执行命令 6 gdb 将参数传递到gdb 7 help 帮助信息 8 q exit的别名 9 repeat 周期执行某个命令 10 set 设置进程上下文或crash内部变量 使用举例 bt 1bt 2bt [pid] # 查看指定进程的栈，可以指定多个 3bt [task_struct addr] # 查看指定进程的栈，可以指定多个，也可于pid一起使用 4bt -l # 查看符号对应的文件行号 5bt -s # 查看符号和指令偏移（默认进制显示） 6bt -sx # 查看符号和指令偏移（x表示十六进制） 7bt -sd # 查看符号和指令偏移（d表示十进制） 8bt -a # 查看所有CPU的栈 9bt -c 0,1,4-7 # 查看CPU0和1上的栈 10bt -g # 查看线程组中所有线程的调用栈 11bt -f # 查看栈帧的所有数据 12bt -F # 查看栈帧的所有数据，如果可以，将数据显示为符号 13bt -FF # 查看栈帧的所有数据，如果可以，同时显示数据对应的符号 dis 1dis [sym] # 反汇编指定函数 2dis [addr] 3dis [sym+offset] # 反汇编指定偏移 4dis -r [sym+offset] # 反汇编从函数开始到指定偏移量之间的代码 5dis -d [sym] # 十进制显示 6dis -x [sym] # 十六进制显示 7dis -s [sym] # 显示源码 8dis -l [sym] # 显示文件行号 9dis -u # 用户空间地址 p 1p -x [sym] # 十六进制显示 2px [sym] 3p -d [sym] # 十进制显示 4pd [sym] 5p -u [sym] # 用户空间地址 6p irq_stat: # 显示当前CPU上的perCPU变量 7p irq_stat:a # 显示所有CPU上的perCPU变量 8p irq_stat:1,3,5-7,10 # 显示指定CPU上的perCPU变量 log 1显示内核dmesg信息 2log 3 4显示内核demsg信息，将时间显示为人可读的形式，如：[Fri May 27 17:36:11 PDT 2022] 5log -T 6 7显示的内核log中去除左边的时间戳信息 8log -t 9log | grep xxx irq 1查看系统所有中断的使用信息，如虚拟中断号，中断的irq_desc，注册的irqaction以及名字 2irq 3 4查看实际使用的中断的信息，去除哪些没有被申请的虚拟中断号 5irq -u 6 7查看中断向量表，适用于intel处理器 8irq -d 9 10查看注册的软中断 11irq -b 12 13查看中断的cpu亲和性值 14irq -a 15 16查看系统中断的使用和统计信息，类似cat /proc/interrupts 17irq -s 18 19如果想查看指定cpu上统计信息：irq -s -c a 或 irq -s -c 1,3,6-9 2. 相关链接 https://crash-utility.github.io/crash_whitepaper.html https://blog.csdn.net/u014001096/article/details/134492262 https://blog.csdn.net/u014001096/article/details/134492286 ","date":"December 3, 2023","img":"https://kingdix10.github.io/covers/vintage_retro_camera_126517_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/debug/kdump_crash/crash_cmd_set/","series":[{"title":"内核调试","url":"/zh-cn/series/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"内核调试","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"},{"title":"kdump crash","url":"/zh-cn/tags/kdump-crash/"},{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"}],"timestamp":1701561600,"title":"Crash命令介绍"},{"categories":[{"title":"工具","url":"/zh-cn/categories/%E5%B7%A5%E5%85%B7/"}],"content":"1apt install jupyter-core 或者\n1python3 -m pip install jupyter 转换：\n1jupyter nbconvert --to markdown xxx.ipynb ","date":"December 3, 2023","img":"https://kingdix10.github.io/covers/walls_floor_light_50837_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/jupyter_to_markdown/","series":[{"title":"工具","url":"/zh-cn/series/%E5%B7%A5%E5%85%B7/"}],"smallImg":"","tags":[{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"}],"timestamp":1701561600,"title":"jupyter转Markdown"},{"categories":[{"title":"linux命令","url":"/zh-cn/categories/linux%E5%91%BD%E4%BB%A4/"},{"title":"网络工具","url":"/zh-cn/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"}],"content":" nmap 1nmap -sVn 192.168.31.* 2 3nmap -sVn 192.168.31.* -oN out.txt 4 5nmap -sV -sC -Pn 192.168.31.* 6 7nmap -sV -sC -Pn 192.168.31.* -oN out.txt 8 9nmap -sV -sC -Pn 192.168.31.* -oG out.txt 10 11nmap -sV -sC -Pn 192.168.31.* -oX out.xml 12 13nmap -sV -sC -Pn 192.168.31.* -oX out.xml --script=banner,vuln 14 15nmap -sV -sC -Pn 192.168.31.* -oX out.xml --script=banner,vuln --script-args=banner.timeout=10,vuln.timeout=10 16 17nmap -sV -sC -Pn 192.168.31.* -oX out.xml --script=banner,vuln --script-args=banner.timeout=10,vuln.timeout=10 --script-args=banner.path=/usr/share/nmap/scripts/http-title.nse,vuln.cvss-threshold=7 ip 1ip addr 2ip route ssh ssh-keygen -f \u0026ldquo;/home/wsy/.ssh/known_hosts\u0026rdquo; -R \u0026ldquo;[localhost]:20092\u0026rdquo; ssh-copy-id wdn@10.23.21.11\nhttps://zhuanlan.zhihu.com/p/521768041\nzerotier 1curl -s https://install.zerotier.com | sudo bash 2sudo zerotier-cli join ${ZTID} resolvconf 百度公共DNS：180.76.76.76\n近期安装debian9操作系统后，在/etc/resolv.conf配置DNS地址后，进行网络重启或者重启服务器都会导致DNS配置丢失，查阅资料得知 /etc/resolv.conf中的DNS配置从/etc/resolvconf/resolv.conf.d/head中加载而来,所以每次修改resolv.conf后重启失效。可以用一下办法彻底解决该问题。\n1.安装resolvconf\napt-get install resolvconf 2.启动该服务\nservice resolvconf start //启动服务 sevice resolvconf status //查看服务状态 3.编辑/etc/resolvconf/resolv.conf.d/目录下的head文件\nvim /etc/resolvconf/resolv.conf.d/head nameserver 8.8.8.8 //配置DNS服务器地址\nresolvconf -u service networking restart //重启网络服务 4.查看/etc/resolv.conf配置，里面就会有你刚刚设置的DNS\ncat /etc/resolv.conf 至此DNS配置已永久生效，重启网络或者重启服务器该配置都不会丢失。\n","date":"December 3, 2023","img":"https://kingdix10.github.io/covers/texture_background_color_72786_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/linux/shell/cmd_network/","series":[{"title":"linux命令","url":"/zh-cn/series/linux%E5%91%BD%E4%BB%A4/"}],"smallImg":"","tags":[{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"},{"title":"linux命令","url":"/zh-cn/tags/linux%E5%91%BD%E4%BB%A4/"}],"timestamp":1701561600,"title":"linux常用命令-网络"},{"categories":[{"title":"启动流程","url":"/zh-cn/categories/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"content":" 保证内核启动安全的几种方式 禁止修改cmdline 禁止修改根文件系统 使能内核地址空间布局随机化(KASLR) ","date":"December 3, 2023","img":"https://kingdix10.github.io/covers/code_text_colorful_140555_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/misc/kernel_boot_security/","series":[{"title":"启动流程","url":"/zh-cn/series/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"启动流程","url":"/zh-cn/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"timestamp":1701561600,"title":"保证内核启动安全的几种方式"},{"categories":[{"title":"Windows","url":"/zh-cn/categories/windows/"},{"title":"环境搭建","url":"/zh-cn/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"开发环境","url":"/zh-cn/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"content":" 1. 现象 Windows上输入python3 test.py后，脚本没有执行。 单独输入python3，会启动Microsoft Store，搜索Python3。\n2. 原因 在开始菜单搜索Python3，打开文件位置后，显示在 C:\\Users\\username\\AppData\\Local\\Microsoft\\WindowsApps\\python3.exe 同时目录下还有python.exe C:\\Users\\username\\AppData\\Local\\Microsoft\\WindowsApps\\python.exe\n而搜索py，打开文件位置，显示在 C:\\Windows\\py.exe\n实际的python安装路径，在C:\\Programs\\Python\\Python310。这个目录下，只有python.exe,\n3. 解决方法 安装python时，勾选添加到PATH环境变量。会将C:\\Programs\\Python\\Python311添加到系统或用户环境变量。 然后在C:\\Programs\\Python\\Python310下，复制python.exe为python3.exe。\n","date":"December 3, 2023","img":"https://kingdix10.github.io/covers/dots_light_background_50767_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/win/win_python3/","series":[{"title":"开发环境","url":"/zh-cn/series/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"smallImg":"","tags":[{"title":"Windows","url":"/zh-cn/tags/windows/"},{"title":"Python3","url":"/zh-cn/tags/python3/"}],"timestamp":1701561600,"title":"解决Windows不能使用python3.10的问题"},{"categories":[{"title":"内核基础","url":"/zh-cn/categories/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"}],"content":" 1. 后缀说明 acquire操作指的是在这条语句之后的所有内存操作只准在这条语句之后，不准被提前到这条语句之前。 release操作指的是在这条语句之前的所有内存操作只准在这条语句之前，不准被延后到这条语句之后。 relaxed操作指的是不保证任何的内存顺序。\n2. 读写 1atomic_read(const atomic_t *v) 2atomic_read_acquire(const atomic_t *v) 3 4atomic_set(atomic_t *v, int i) 5atomic_set_release(atomic_t *v, int i) col1 col2 (const atomic_t *v) (atomic_t *v, int i) atomic_read atomic_set atomic_read_acquire atomic_set_release 3. 加减 col1 col2 col3 col3 (int i, atomic_t *v) (int i, atomic_t *v) (atomic_t *v) (atomic_t *v) atomic_add atomic_sub atomic_inc atomic_dec atomic_add_return atomic_sub_return atomic_inc_return atomic_dec_return atomic_add_return_acquire atomic_sub_return_acquire atomic_inc_return_acquire atomic_dec_return_acquire atomic_add_return_release atomic_sub_return_release atomic_inc_return_release atomic_dec_return_release atomic_add_return_relaxed atomic_sub_return_relaxed atomic_inc_return_relaxed atomic_dec_return_relaxed atomic_fetch_add atomic_fetch_sub atomic_fetch_inc atomic_fetch_dec atomic_fetch_add_acquire atomic_fetch_sub_acquire atomic_fetch_inc_acquire atomic_fetch_dec_acquire atomic_fetch_add_release atomic_fetch_sub_release atomic_fetch_inc_release atomic_fetch_dec_release atomic_fetch_add_relaxed atomic_fetch_sub_relaxed atomic_fetch_inc_relaxed atomic_fetch_dec_relaxed atomic_add：无返回值。 atomic_add_return：返回变化后的值。 atomic_fetch_add：返回变化前的值。 4. 位操作 col1 col2 col3 col3 (int i, atomic_t *v) (int i, atomic_t *v) (int i, atomic_t *v) (int i, atomic_t *v) atomic_and atomic_andnot atomic_or atomic_xor atomic_fetch_and atomic_fetch_andnot atomic_fetch_or atomic_fetch_xor atomic_fetch_and_acquire atomic_fetch_andnot_acquire atomic_fetch_or_acquire atomic_fetch_xor_acquire atomic_fetch_and_release atomic_fetch_andnot_release atomic_fetch_or_release atomic_fetch_xor_release atomic_fetch_and_relaxed atomic_fetch_andnot_relaxed atomic_fetch_or_relaxed atomic_fetch_xor_relaxed 5. 交换 col1 col2 col3 (atomic_t *v, int i) (atomic_t *v, int old, int new) (atomic_t *v, int *old, int new) atomic_xchg atomic_cmpxchg atomic_try_cmpxchg atomic_xchg_acquire atomic_cmpxchg_acquire atomic_try_cmpxchg_acquire atomic_xchg_release atomic_cmpxchg_release atomic_try_cmpxchg_release atomic_xchg_relaxed atomic_cmpxchg_relaxed atomic_try_cmpxchg_relaxed 6. 对比 1atomic_sub_and_test(int i, atomic_t *v) 2atomic_dec_and_test(atomic_t *v) 3atomic_inc_and_test(atomic_t *v) 4 5atomic_add_negative(int i, atomic_t *v) 6atomic_fetch_add_unless(atomic_t *v, int a, int u) 7atomic_add_unless(atomic_t *v, int a, int u) 8atomic_inc_not_zero(atomic_t *v) 9atomic_inc_unless_negative(atomic_t *v) 10atomic_dec_unless_positive(atomic_t *v) 11atomic_dec_if_positive(atomic_t *v) 7. xchg/cmpxchg 用于非atomic类型的变量，比如unsigned int。\n在Linux内核中，xchg、xchg_acquire、xchg_release和xchg_relaxed是四个互斥原子操作函数。它们的区别如下：\nxchg函数：是最基础的互斥原子操作函数，用于交换给定内存位置的值与一个新值，并返回原始值。在此过程中，不会对内存的访问模型（如内存屏障）进行显式的约束。 xchg_acquire函数：是xchg函数的一种变体，它在交换值的同时也会提供一个acquire内存屏障，确保该原子操作之前的内存访问在该原子操作之前完成，而该原子操作之后的内存访问将不会越过该原子操作。 xchg_release函数：是xchg函数的另一种变体，它在交换值的同时也会提供一个release内存屏障，确保该原子操作之后的内存访问在该原子操作之后开始，并且该原子操作之前的内存访问不会越过该原子操作。 xchg_relaxed函数：是xchg函数的松散变体，它在交换值的过程中不提供任何内存屏障。这意味着对该原子操作之前和之后的内存访问没有明确的约束，可能会出现乱序执行或内存重排序。因此，xchg_relaxed通常用于对内存访问保持较低的一致性要求的情况下，以获得较高的性能。 总之，xchg_acquire和xchg_release函数提供了显式的内存屏障，用于明确约束原子操作之前和之后的内存访问序列。而xchg函数和xchg_relaxed函数则没有提供这样的约束，可以在一定程度上提高性能，但可能会牺牲一致性。因此，在选择使用这些函数时，需要根据具体的需求权衡性能和一致性。\ncol1 col2 col3 col2 col3 (ptr, \u0026hellip;) (ptr, \u0026hellip;) (ptr, oldp, \u0026hellip;) (ptr, \u0026hellip;) (ptr, oldp, \u0026hellip;) xchg cmpxchg try_cmpxchg cmpxchg64 try_cmpxchg64 xchg_acquire cmpxchg_acquire try_cmpxchg_acquire cmpxchg64_acquire try_cmpxchg64_acquire xchg_release cmpxchg_release try_cmpxchg_release cmpxchg64_release try_cmpxchg64_release xchg_relaxed cmpxchg_relaxed try_cmpxchg_relaxed cmpxchg64_relaxed try_cmpxchg64_relaxed 1cmpxchg_local(ptr, ...) 2cmpxchg64_local(ptr, ...) 1sync_cmpxchg(ptr, ...) 2cmpxchg_double(ptr, ...) 3cmpxchg_double_local(ptr, ...) 8. 参考资料 原子操作 | SuperSong的博客 (songyoulin.github.io)\n","date":"August 30, 2023","img":"https://kingdix10.github.io/covers/keyboard_backlight_light_159518_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/misc/atomic/","series":[{"title":"内核基础","url":"/zh-cn/series/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"atomic","url":"/zh-cn/tags/atomic/"}],"timestamp":1693353600,"title":"linux atomic接口简介"},{"categories":[{"title":"设备模型","url":"/zh-cn/categories/%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"}],"content":" 1. module_init是什么 module_init是Linux内核开发和驱动开发中非常常见的宏，其定义在 include/linux/module.h中，可以看到，module_init的实现会根据是否定义MODULE而有所不同。MODULE决定了我们编写的驱动，是与内核编译到一起，还是单独编译为ko。\n1.1. MODULE的定义 MODULE是通过在编译时，通过编译器的参数来传入的。如下是Makefile中的内容，在编译ko时，会使用如下两个编译选项，如果是链接到内核，则不会使用如下选项。\n1/// Makefile 2KBUILD_AFLAGS_MODULE := -DMODULE 3KBUILD_CFLAGS_MODULE := -DMODULE 如果想看编译某个文件时是否由 -DMODULE选项，可以直接查看编译生成 .xxx.o.cmd文件。\n下面先分析MODULE未使能的情况。\n2. MODULE未使能 MODULE未定义的情况下，module_init是一种特殊的initcall。initcall是内核用于声明初始化函数以及控制函数调用顺序的机制。 initcall有多个级别，module_init实际就是device_initcall，其级别为6。initcall最终会声明一个initcall_t静态变量，链接时放到内核的 .init.data段。\n1/// include/linux/module.h 2#ifndef MODULE 3/** 4 * module_init() - driver initialization entry point 5 * @x: function to be run at kernel boot time or module insertion 6 * 7 * module_init() will either be called during do_initcalls() (if 8 * builtin) or at module insertion time (if a module). There can only 9 * be one per module. 10 */ 11#define module_init(x) __initcall(x); 12 13/** 14 * module_exit() - driver exit entry point 15 * @x: function to be run when driver is removed 16 * 17 * module_exit() will wrap the driver clean-up code 18 * with cleanup_module() when used with rmmod when 19 * the driver is a module. If the driver is statically 20 * compiled into the kernel, module_exit() has no effect. 21 * There can only be one per module. 22 */ 23#define module_exit(x) __exitcall(x); 24 25#else /* MODULE */ 26/// ... ... 2.1. initcall分析 首先通过 arch64-linux-gnu-nm -n vmlinux | grep -E -C 2 '_initcall.*(_start|_end)$'来看一下编译的最终结果。\n1ffff8000094fc228 d __setup_debug_boot_weak_hash_enable 2ffff8000094fc240 d __initcall__kmod_ptrace__414_42_trace_init_flags_sys_enterearly 3ffff8000094fc240 D __initcall_start 4ffff8000094fc240 D __setup_end 5ffff8000094fc244 d __initcall__kmod_ptrace__416_66_trace_init_flags_sys_exitearly 6-- 7ffff8000094fc2a8 d __initcall__kmod_earlycon__376_41_efi_earlycon_remap_fbearly 8ffff8000094fc2ac d __initcall__kmod_dummy_timer__364_37_dummy_timer_registerearly 9ffff8000094fc2b0 D __initcall0_start 10ffff8000094fc2b0 d __initcall__kmod_core__527_975_bpf_jit_charge_init0 11ffff8000094fc2b4 d __initcall__kmod_shm__486_153_ipc_ns_init0 12-- 13ffff8000094fc2bc d __initcall__kmod_pci__516_6911_pci_realloc_setup_params0 14ffff8000094fc2c0 d __initcall__kmod_inet_fragment__696_216_inet_frag_wq_init0 15ffff8000094fc2c4 D __initcall1_start 16ffff8000094fc2c4 d __initcall__kmod_fpsimd__388_2058_fpsimd_init1 17ffff8000094fc2c8 d __initcall__kmod_process__462_734_tagged_addr_init1 18-- 19ffff8000094fc3cc d __initcall__kmod_genetlink__620_1498_genl_init1 20ffff8000094fc3d0 d __initcall__kmod_trace_boot__394_671_trace_boot_init1s 21ffff8000094fc3d4 D __initcall2_start 22ffff8000094fc3d4 d __initcall__kmod_debug_monitors__391_139_debug_monitors_init2 23ffff8000094fc3d8 d __initcall__kmod_index__322_194_pi_init2 24-- 25ffff8000094fc460 d __initcall__kmod_rpmsg_core__351_710_rpmsg_init2 26ffff8000094fc464 d __initcall__kmod_kobject_uevent__622_814_kobject_uevent_init2 27ffff8000094fc468 D __initcall3_start 28ffff8000094fc468 d __initcall__kmod_setup__397_281_reserve_memblock_reserved_regions3 29ffff8000094fc46c d __initcall__kmod_vdso__390_363_aarch32_alloc_vdso_pages3 30-- 31ffff8000094fc4a8 d __initcall__kmod_dmi_id__332_259_dmi_id_init3 32ffff8000094fc4ac d __initcall__kmod_platform__462_596_of_platform_default_populate_init3s 33ffff8000094fc4b0 D __initcall4_start 34ffff8000094fc4b0 d __initcall__kmod_setup__399_406_topology_init4 35ffff8000094fc4b4 d __initcall__kmod_mte__458_603_register_mte_tcf_preferred_sysctl4 36-- 37ffff8000094fc694 d __initcall__kmod_vgaarb__423_1564_vga_arb_device_init4s 38ffff8000094fc698 d __initcall__kmod_watchdog__465_479_watchdog_init4s 39ffff8000094fc69c D __initcall5_start 40ffff8000094fc69c d __initcall__kmod_debug_monitors__389_63_create_debug_debugfs_entry5 41ffff8000094fc6a0 d __initcall__kmod_resource__402_2029_iomem_init_inode5 42-- 43ffff8000094fc784 d __initcall__kmod_acpi__398_141_acpi_reserve_resources5s 44ffff8000094fc788 d __initcall__kmod_initramfs__399_762_populate_rootfsrootfs 45ffff8000094fc788 D __initcallrootfs_start 46ffff8000094fc78c D __initcall6_start 47ffff8000094fc78c d __initcall__kmod_setup__401_440_register_arm64_panic_block6 48ffff8000094fc790 d __initcall__kmod_cpuinfo__334_359_cpuinfo_regs_init6 49-- 50ffff8000094fcd40 d __initcall__kmod_9pnet_virtio__634_831_p9_virtio_init6 51ffff8000094fcd44 d __initcall__kmod_dns_resolver__330_382_init_dns_resolver6 52ffff8000094fcd48 D __initcall7_start 53ffff8000094fcd48 d __initcall__kmod_mounts__426_40_kernel_do_mounts_initrd_sysctls_init7 54ffff8000094fcd4c d __initcall__kmod_panic__390_97_kernel_panic_sysctls_init7 55-- 56ffff8000094fce6c d __initcall__kmod_core__606_6212_regulator_init_complete7s 57ffff8000094fce70 d __initcall__kmod_platform__464_603_of_platform_sync_state_init7s 58ffff8000094fce74 D __con_initcall_start 59ffff8000094fce74 d __initcall__kmod_vt__408_3548_con_initcon 60ffff8000094fce74 D __initcall_end 61ffff8000094fce78 d __initcall__kmod_hvc_console__376_246_hvc_console_initcon 62ffff8000094fce7c d __initcall__kmod_8250__387_690_univ8250_console_initcon 63ffff8000094fce80 D __con_initcall_end 64ffff8000094fce80 D __initramfs_start 以 __initcall__kmod_cpuinfo__334_359_cpuinfo_regs_init6为例来说明一下module_init的效果。\n__initcall__kmod_cpuinfo__334_359_cpuinfo_regs_init6是一个initcall_t类型的静态变量，变量名称可以由 __initcall_name(initcall, __initcall_id(fn), id)得出。\n将变量名拆分开来可得：__ initcall __ [kmod_cpuinfo __ 334 _ 359 _ cpuinfo_regs_init] 6，[]内的内容由 __initcall_id(fn)生成，其格式为 \u0026lt;modname\u0026gt;__\u0026lt;counter\u0026gt;_\u0026lt;line\u0026gt;_\u0026lt;fn\u0026gt;：\nmodname：__KBUILD_MODNAME，来自于 scripts/Makefile.lib:127: -D__KBUILD_MODNAME=kmod_$(call name-fix-token,$(modname))，kmod_是固定的，__KBUILD_MODNAME在这里是kmod_cpuinfo。 counter：来自于 __COUNTER__，是编译器内部定义的计数器，每使用一次 __COUNTER__，其值为自动加一，这里是334。 line：这个是声明所在的行号，对应的源码为 arch/arm64/kernel/cpuinfo.c:359:device_initcall(cpuinfo_regs_init);，这里是359。 fn：函数名，这里是cpuinfo_regs_init。 除去 []内的部分，变量名的其他部分由 __initcall_name生成，其格式为 __\u0026lt;prefix\u0026gt;__\u0026lt;iid\u0026gt;\u0026lt;id\u0026gt;：\nprefix：固定为initcall iid：__initcall_id(fn)生成的内容 id：__define_initcall的第二个参数 2.2. initcall的源码 下面是 include/linux/init.h的源码，上边是以未定义CONFIG_LTO_CLANG和CONFIG_HAVE_ARCH_PREL32_RELOCATIONS来分析的。\n1/// include/linux/init.h 2#ifndef MODULE 3 4#ifndef __ASSEMBLY__ 5 6/* 7 * initcalls are now grouped by functionality into separate 8 * subsections. Ordering inside the subsections is determined 9 * by link order. 10 * For backwards compatibility, initcall() puts the call in 11 * the device init subsection. 12 * 13 * The `id\u0026#39; arg to __define_initcall() is needed so that multiple initcalls 14 * can point at the same handler without causing duplicate-symbol build errors. 15 * 16 * Initcalls are run by placing pointers in initcall sections that the 17 * kernel iterates at runtime. The linker can do dead code / data elimination 18 * and remove that completely, so the initcall sections have to be marked 19 * as KEEP() in the linker script. 20 */ 21 22/* Format: \u0026lt;modname\u0026gt;__\u0026lt;counter\u0026gt;_\u0026lt;line\u0026gt;_\u0026lt;fn\u0026gt; */ 23#define __initcall_id(fn) \\ 24 __PASTE(__KBUILD_MODNAME, \\ 25 __PASTE(__, \\ 26 __PASTE(__COUNTER__, \\ 27 __PASTE(_, \\ 28 __PASTE(__LINE__, \\ 29 __PASTE(_, fn)))))) 30 31/* Format: __\u0026lt;prefix\u0026gt;__\u0026lt;iid\u0026gt;\u0026lt;id\u0026gt; */ 32#define __initcall_name(prefix, __iid, id) \\ 33 __PASTE(__, \\ 34 __PASTE(prefix, \\ 35 __PASTE(__, \\ 36 __PASTE(__iid, id)))) 37 38#ifdef CONFIG_LTO_CLANG 39/* 40 * With LTO, the compiler doesn\u0026#39;t necessarily obey link order for 41 * initcalls. In order to preserve the correct order, we add each 42 * variable into its own section and generate a linker script (in 43 * scripts/link-vmlinux.sh) to specify the order of the sections. 44 */ 45#define __initcall_section(__sec, __iid) \\ 46 #__sec \u0026#34;.init..\u0026#34; #__iid 47 48/* 49 * With LTO, the compiler can rename static functions to avoid 50 * global naming collisions. We use a global stub function for 51 * initcalls to create a stable symbol name whose address can be 52 * taken in inline assembly when PREL32 relocations are used. 53 */ 54#define __initcall_stub(fn, __iid, id) \\ 55 __initcall_name(initstub, __iid, id) 56 57#define __define_initcall_stub(__stub, fn) \\ 58 int __init __stub(void); \\ 59 int __init __stub(void) \\ 60 { \\ 61 return fn(); \\ 62 } \\ 63 __ADDRESSABLE(__stub) 64#else 65#define __initcall_section(__sec, __iid) \\ 66 #__sec \u0026#34;.init\u0026#34; 67 68#define __initcall_stub(fn, __iid, id) fn 69 70#define __define_initcall_stub(__stub, fn) \\ 71 __ADDRESSABLE(fn) 72#endif 73 74#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS 75#define ____define_initcall(fn, __stub, __name, __sec) \\ 76 __define_initcall_stub(__stub, fn) \\ 77 asm(\u0026#34;.section \\\u0026#34;\u0026#34; __sec \u0026#34;\\\u0026#34;, \\\u0026#34;a\\\u0026#34; \\n\u0026#34; \\ 78 __stringify(__name) \u0026#34;: \\n\u0026#34; \\ 79 \u0026#34;.long \u0026#34; __stringify(__stub) \u0026#34; - . \\n\u0026#34; \\ 80 \u0026#34;.previous \\n\u0026#34;); \\ 81 static_assert(__same_type(initcall_t, \u0026amp;fn)); 82#else 83#define ____define_initcall(fn, __unused, __name, __sec) \\ 84 static initcall_t __name __used \\ 85 __attribute__((__section__(__sec))) = fn; 86#endif 87 88#define __unique_initcall(fn, id, __sec, __iid) \\ 89 ____define_initcall(fn, \\ 90 __initcall_stub(fn, __iid, id), \\ 91 __initcall_name(initcall, __iid, id), \\ 92 __initcall_section(__sec, __iid)) 93 94#define ___define_initcall(fn, id, __sec) \\ 95 __unique_initcall(fn, id, __sec, __initcall_id(fn)) 96 97#define __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id) 98 99/* 100 * Early initcalls run before initializing SMP. 101 * 102 * Only for built-in code, not modules. 103 */ 104#define early_initcall(fn) __define_initcall(fn, early) 105 106/* 107 * A \u0026#34;pure\u0026#34; initcall has no dependencies on anything else, and purely 108 * initializes variables that couldn\u0026#39;t be statically initialized. 109 * 110 * This only exists for built-in code, not for modules. 111 * Keep main.c:initcall_level_names[] in sync. 112 */ 113#define pure_initcall(fn) __define_initcall(fn, 0) 114 115#define core_initcall(fn) __define_initcall(fn, 1) 116#define core_initcall_sync(fn) __define_initcall(fn, 1s) 117#define postcore_initcall(fn) __define_initcall(fn, 2) 118#define postcore_initcall_sync(fn) __define_initcall(fn, 2s) 119#define arch_initcall(fn) __define_initcall(fn, 3) 120#define arch_initcall_sync(fn) __define_initcall(fn, 3s) 121#define subsys_initcall(fn) __define_initcall(fn, 4) 122#define subsys_initcall_sync(fn) __define_initcall(fn, 4s) 123#define fs_initcall(fn) __define_initcall(fn, 5) 124#define fs_initcall_sync(fn) __define_initcall(fn, 5s) 125#define rootfs_initcall(fn) __define_initcall(fn, rootfs) 126#define device_initcall(fn) __define_initcall(fn, 6) 127#define device_initcall_sync(fn) __define_initcall(fn, 6s) 128#define late_initcall(fn) __define_initcall(fn, 7) 129#define late_initcall_sync(fn) __define_initcall(fn, 7s) 130 131#define __initcall(fn) device_initcall(fn) 132 133#define __exitcall(fn) \\ 134 static exitcall_t __exitcall_##fn __exit_call = fn 135 136#define console_initcall(fn) ___define_initcall(fn, con, .con_initcall) 137/// ... ... 2.3. rootfs_initcall是什么 rootfs_initcall在5s之后，rootfs_initcall指向的函数也会在do_basic_setup中被调用到。rootfs要从存储介质中读取文件系统镜像，需要在执行rootfs_initcall指向的函数之前，将存储介质准备好，比如：\n1/// drivers/mmc/core/core.c 2subsys_initcall(mmc_init); 2.4. console_initcall 为了能尽早输出日志，内核将console相关的initcall单独存放，由console_initcall声明。相关初始化函数在console_init中调用。console_init则在start_kernel中尽量选择较早的时机调用。\n1/// kernel/printk/printk.c 2/* 3 * Initialize the console device. This is called *early*, so 4 * we can\u0026#39;t necessarily depend on lots of kernel help here. 5 * Just do some early initializations, and do the complex setup 6 * later. 7 */ 8void __init console_init(void) 9{ 10 int ret; 11 initcall_t call; 12 initcall_entry_t *ce; 13 14 /* Setup the default TTY line discipline. */ 15 n_tty_init(); 16 17 /* 18 * set up the console device so that later boot sequences can 19 * inform about problems etc.. 20 */ 21 ce = __con_initcall_start; 22 trace_initcall_level(\u0026#34;console\u0026#34;); 23 while (ce \u0026lt; __con_initcall_end) { 24 call = initcall_from_entry(ce); 25 trace_initcall_start(call); 26 ret = call(); 27 trace_initcall_finish(call, ret); 28 ce++; 29 } 30} 2.5. 链接脚本中initcall段 initcall声明的变量会放到以 .initcall开头命名的段中，每个级别对应一个 .initcall段，而这些段又会按顺序放到 .init.data段中。\n1/// include/asm-generic/vmlinux.lds.h 2#define INIT_CALLS_LEVEL(level)\t\\ 3 __initcall##level##_start = .;\t\\ 4 KEEP(*(.initcall##level##.init))\t\\ 5 KEEP(*(.initcall##level##s.init))\t\\ 6 7#define INIT_CALLS\t\\ 8 __initcall_start = .;\t\\ 9 KEEP(*(.initcallearly.init))\t\\ 10 INIT_CALLS_LEVEL(0)\t\\ 11 INIT_CALLS_LEVEL(1)\t\\ 12 INIT_CALLS_LEVEL(2)\t\\ 13 INIT_CALLS_LEVEL(3)\t\\ 14 INIT_CALLS_LEVEL(4)\t\\ 15 INIT_CALLS_LEVEL(5)\t\\ 16 INIT_CALLS_LEVEL(rootfs)\t\\ 17 INIT_CALLS_LEVEL(6)\t\\ 18 INIT_CALLS_LEVEL(7)\t\\ 19 __initcall_end = .; 20 21#define CON_INITCALL\t\\ 22 __con_initcall_start = .;\t\\ 23 KEEP(*(.con_initcall.init))\t\\ 24 __con_initcall_end = .; 1/// arch/arm64/kernel/vmlinux.lds.S 2.init.data : { 3 INIT_DATA 4 INIT_SETUP(16) 5 INIT_CALLS 6 CON_INITCALL 7 INIT_RAM_FS 8 *(.init.altinstructions .init.bss) /* from the EFI stub */ 9} 10.exit.data : { 11 EXIT_DATA 12} 2.6. initcall的执行时机 由initcall指定的函数会在do_pre_smp_initcalls和do_basic_setup执行。do_pre_smp_initcalls执行early_initcall指定的函数，这个是在多核处理器和调度系统初始化之前执行的。do_basic_setup会按initcall的级别，依次执行指定的函数。由于lds中没有根据函数名排序，同级别initcall指定的函数的执行顺序会由链接时initcall的布局决定。多次编译的顺序也可能不同。\n1/// init/main.c 2static noinline void __init kernel_init_freeable(void) 3{ 4 /// ... ... 5 rcu_init_tasks_generic(); 6 do_pre_smp_initcalls(); 7 lockup_detector_init(); 8 9 smp_init(); 10 sched_init_smp(); 11 12 padata_init(); 13 page_alloc_init_late(); 14 /* Initialize page ext after all struct pages are initialized. */ 15 if (!early_page_ext_enabled()) 16 page_ext_init(); 17 18 do_basic_setup(); 19 /// ... ... 20} 2.7. initcall调试 调用initcall函数时，如果打开了initcall_debug，内核会以KERN_DEBUG等级打印trace信息。\n可以通过向bootargs内添加initcall_debug来打开initcall_debug。\n1# cat /proc/sys/kernel/printk 26\t4\t1\t7 3# cat /proc/cmdline 4console=ttyAMA0 nokaslr crashkernel=512M-1G:64M,1G-:128M loglevel=6 initcall_debug no_console_suspend root=/dev/vda rw init=/linuxrc 打开后，启动信息可以看到类似如下信息，如果启动过程中，loglevel比debug等级要低，可以使用dmesg命令查看。\n1[ 0.051543][ T1] calling trace_init_flags_sys_enter+0x0/0x30 @ 1 2[ 0.051631][ T1] initcall trace_init_flags_sys_enter+0x0/0x30 returned 0 after 0 usecs 3[ 0.051728][ T1] calling trace_init_flags_sys_exit+0x0/0x30 @ 1 4[ 0.051748][ T1] initcall trace_init_flags_sys_exit+0x0/0x30 returned 0 after 0 usecs 5[ 0.051766][ T1] calling cpu_suspend_init+0x0/0x68 @ 1 6[ 0.051801][ T1] initcall cpu_suspend_init+0x0/0x68 returned 0 after 0 usecs 7[ 0.051814][ T1] calling asids_init+0x0/0x110 @ 1 8[ 0.051910][ T1] initcall asids_init+0x0/0x110 returned 0 after 0 usecs 9[ 0.051927][ T1] calling spawn_ksoftirqd+0x0/0x60 @ 1 10[ 0.052809][ T1] initcall spawn_ksoftirqd+0x0/0x60 returned 0 after 4000 usecs 11[ 0.052840][ T1] calling init_signal_sysctls+0x0/0x50 @ 1 12[ 0.052894][ T1] initcall init_signal_sysctls+0x0/0x50 returned 0 after 0 usecs 13[ 0.052912][ T1] calling init_umh_sysctls+0x0/0x50 @ 1 14[ 0.052963][ T1] initcall init_umh_sysctls+0x0/0x50 returned 0 after 0 usecs 在安装驱动，比如insmod hello.ko时，也会有类似的信息，比如：\n1[ 39.313554][ T141] calling hello_init+0x0/0xff8 [hello] @ 141 2[ 39.314090][ T141] initcall hello_init+0x0/0xff8 [hello] returned 0 after 105 usecs 3. MODULE使能 Linux中有些模块既可以链接到内核，也可以选择编译为ko，而这些模块的初始化函数可能是以initcall方式指定的。为了两者相互兼容，会把initcall定义为module_init。\n下面分析module_init的实现，源码见《module_init源码》\n__copy(initfn)：从initfn复制函数属性，从gcc-9开始支持。 __attribute__((alias(#initfn)))：为init_module创建别名，指向原来的initfn。 ___ADDRESSABLE(init_module, __initdata)：声明一个initcall_t变量，并放到 .init.data段，变量名类似 __UNIQUE_ID___addressable_init_module326。 __inittest：代码中没有找到调用的地方，但是从v2.6.0对module_init的注释来看，猜测是为了防止编译器警告。\n1/* These macros create a dummy inline: gcc 2.9x does not count alias 2 as usage, hence the `unused function\u0026#39; warning when __init functions 3 are declared static. We use the dummy __*_module_inline functions 4 both to kill the warning and check the type of the init/cleanup 5 function. */ init_module是initfn的别名，其地址也是相同的，但是initfn通常会是static函数，而init_module是一个global函数。\n1Disassembly of section .init.text: 2 30000000000000000 \u0026lt;init_module\u0026gt;: 4hello_init(): 5 0: d503201f nop 6 4: d503201f nop 1/// t代表static，T代表global 20000000000000000 00000000000000c8 t hello_init 30000000000000000 00000000000000c8 T init_module 3.1. module_init源码 1/// include/linux/module.h 2/// ... ... 3#else /* MODULE */ 4 5/* 6 * In most cases loadable modules do not need custom 7 * initcall levels. There are still some valid cases where 8 * a driver may be needed early if built in, and does not 9 * matter when built as a loadable module. Like bus 10 * snooping debug drivers. 11 */ 12#define early_initcall(fn) module_init(fn) 13#define core_initcall(fn) module_init(fn) 14#define core_initcall_sync(fn) module_init(fn) 15#define postcore_initcall(fn) module_init(fn) 16#define postcore_initcall_sync(fn) module_init(fn) 17#define arch_initcall(fn) module_init(fn) 18#define subsys_initcall(fn) module_init(fn) 19#define subsys_initcall_sync(fn) module_init(fn) 20#define fs_initcall(fn) module_init(fn) 21#define fs_initcall_sync(fn) module_init(fn) 22#define rootfs_initcall(fn) module_init(fn) 23#define device_initcall(fn) module_init(fn) 24#define device_initcall_sync(fn) module_init(fn) 25#define late_initcall(fn) module_init(fn) 26#define late_initcall_sync(fn) module_init(fn) 27 28#define console_initcall(fn) module_init(fn) 29 30/* Each module must use one module_init(). */ 31#define module_init(initfn) \\ 32 static inline initcall_t __maybe_unused __inittest(void) \\ 33 { return initfn; } \\ 34 int init_module(void) __copy(initfn) \\ 35 __attribute__((alias(#initfn))); \\ 36 ___ADDRESSABLE(init_module, __initdata); 37 38/* This is only required if you want to be unloadable. */ 39#define module_exit(exitfn) \\ 40 static inline exitcall_t __maybe_unused __exittest(void) \\ 41 { return exitfn; } \\ 42 void cleanup_module(void) __copy(exitfn) \\ 43 __attribute__((alias(#exitfn))); \\ 44 ___ADDRESSABLE(cleanup_module, __exitdata); 45 46#endif 1/// include/linux/init.h 2#define __initdata __section(\u0026#34;.init.data\u0026#34;) 1/// include/linux/compiler.h 2/* 3 * Force the compiler to emit \u0026#39;sym\u0026#39; as a symbol, so that we can reference 4 * it from inline assembler. Necessary in case \u0026#39;sym\u0026#39; could be inlined 5 * otherwise, or eliminated entirely due to lack of references that are 6 * visible to the compiler. 7 */ 8#define ___ADDRESSABLE(sym, __attrs) \\ 9 static void * __used __attrs \\ 10 __UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)\u0026amp;sym; 3.2. init_module的执行时机 命令行下使用 insmod或 modprobe安装模块，最终系统调用为 init_module或 finit_module。 可以使用 strace insmod test.ko查看使用的具体的系统调用。\n系统调用init_module和finit_module用来从用户态加载ko文件，man 2 init_module可以看到两者的介绍。init_module接收一个ELF文件的路径，而finit_module接收一个文件描述符。\n1/// kernel/module/main.c 2SYSCALL_DEFINE3(init_module, void __user *, umod, 3 unsigned long, len, const char __user *, uargs) 4{ 5 /// ... ... 6 return load_module(\u0026amp;info, uargs, 0); 7} 8 9SYSCALL_DEFINE3(finit_module, int, fd, const char __user *, uargs, int, flags) 10{ 11 /// ... ... 12 return load_module(\u0026amp;info, uargs, flags); 13} init_module和finit_module最后都会调到load_module，load_module的流程如下：\n4. 参考资料 gcc __COUNTER__ copy (function) alias (\u0026ldquo;target\u0026rdquo;) __attribute__((alias)) 变量属性 __attribute__((alias)) 函数属性 linux 内核驱动中__attribute__((alias(#x)))别名问题 ","date":"July 20, 2023","img":"https://kingdix10.github.io/covers/scheme_glow_blue_140190_1280x720.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.1/devicemodel/initcall/","series":[{"title":"设备驱动模型","url":"/zh-cn/series/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"内核驱动","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"},{"title":"linux-6.1","url":"/zh-cn/tags/linux-6.1/"}],"timestamp":1689811200,"title":"Linux内核驱动模型（三）驱动初始化"},{"categories":[{"title":"设备模型","url":"/zh-cn/categories/%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"}],"content":" 1. sysfs中的bus/class/device/driver 首先通过实例来看bus/class/device/driver的关系。下图绘制的是qemu启动ARM64后，sysfs中platform总线下部分目录和文件的关系。\n框图说明：\n每个方框表示sysfs中的一个目录或文件 实线由父目录指向子目录 虚线由软链接指向实际的文件或目录 总结：\nbus_register注册的bus会在/sys/bus目录下生成子目录。 device_add添加的device会在/sys/devices下生成子目录。 注册的driver会在/sys/bus所属的总线目录（如platform）下的drivers生成子目录。 class_register注册的class会在/sys/class下生成子目录。 driver有正在由其驱动的device，driver对应的目录下会有device的链接。 device需要有驱动自身的driver，device目录下会有名为driver的文件链接到driver目录。 device需要挂在bus下，/sys/bus下device所属的总线目录（如platform）下的devices会有对应device目录的链接。 device会有所属的class，/sys/class具体的class目录下，也会有device的连接。 同是挂在platform总线下的不同设备，可以属于不同的class。 2. 设备模型的初始化 1/// drivers/base/init.c 2/** 3 * driver_init - initialize driver model. 4 * 5 * Call the driver model init functions to initialize their 6 * subsystems. Called early from init/main.c. 7 */ 8void __init driver_init(void) 9{ 10 /* These are the core pieces */ 11 bdi_init(\u0026amp;noop_backing_dev_info); 12 devtmpfs_init(); 13 devices_init(); /// 初始化devices_kset/dev_kobj/sysfs_dev_block_kobj/sysfs_dev_char_kobj 14 buses_init(); /// 初始化bus_kset/system_kset 15 classes_init(); /// 初始化class_kset 16 firmware_init(); 17 hypervisor_init(); 18 19 /* These are also core pieces, but must come after the 20 * core core pieces. 21 */ 22 of_core_init(); /// 初始of_kset 23 platform_bus_init(); /// 注册platform_bus和platform_bus_type 24 auxiliary_bus_init(); 25 cpu_dev_init(); 26 memory_dev_init(); 27 node_dev_init(); 28 container_dev_init(); 29} 2.1. 全局变量 设备模型的初始化主要就是完成一些全局变量的初始化。\n说明：\nbus_register会调用bus_create_file来为bus创建uevent文件，属性由uevent_attr指定，文件操作函数由bus_attr_uevent指定。 bus_ktype的release函数是bus_release，sysfs_ops是bus_sysfs_ops，show和store函数分别为bus_attr_show和bus_attr_store dirver_ktype与bus_type类似 bus_kset由kset_create_and_add创建，uevent_ops为bus_uevent_ops devices_kset由kset_create_and_add创建，uevent_ops为device_uevent_ops bus_kset和devices_kset的parent都为NULL system_kset由kset_create_and_add创建，parent为devices_kset，uevent_ops为NULL bus_kset、devices_kset和system_kset的ktype都是默认的kset_ktype dev_kobj由kobject_create_and_add，作为sysfs_dev_block_kobj和sysfs_dev_char_kobj的parent sysfs_dev_block_kobj和sysfs_dev_char_kobj由kobject_create_and_add创建，parent都是dev_kobj class的dev_kobj成员会根据需要指向sysfs_dev_block_kobj或sysfs_dev_char_kobj，或者是自定义的kobject 3. bus/class/device/driver详解 通过《sysfs中的bus/class/device/driver》可以简单了解bus/class/device/driver间的关系，下面从内核源码的角度进行分析。\n如下是数据结构之间关系的简要说明，详细内容见后续章节分析。\nbus部分说明：\nbus_type使用subsys_private记录私有数据，subsys_private内嵌kset 内嵌kset的ktype指向全局变量bus_ktype 内嵌kset的kset指向全局变量bus_kset subsys_private记录kset_create_and_add创建的devices_kset和drivers_kset devices_kset和drivers_kset的parent指向subsys_private内嵌kset内的kobj subsys_private的klist_drivers记录挂在bus下的driver subsys_private的klist_devices记录挂在bus下的device class部分说明：\nclass使用subsys_private记录私有数据，subsys_private内嵌kset 内嵌kset的ktype指向全局变量class_ktype 内嵌kset的kset指向全局变量class_kset subsys_private的klist_devices记录属于该class的device driver部分说明：\ndevice_driver使用driver_private记录私有数据，driver_private内嵌kobject 内嵌kobject的ktype指向全局变量driver_ktype 内嵌kobject的kset指向bus-\u0026gt;p的drivers_kset driver_private的klist_devices记录与该device_driver匹配的device device部分说明：\ndevice内嵌kobject 内嵌kobject的ktype指向全局变量device_ktype 内嵌kobject的kset指向全局变量devices_ktype device使用device_private记录私有数据 device_private的knode_driver链接到device_driver的链表中 device_private的knode_bus链接到bus的链表中 device_private的knode_class链接到class的链表中 3.1. bus的注册 向系统注册总线是通过bus_register完成的，其主要工作如下：\n将kobj的kset和ktype分别指向bus_kset和bus_ktype。 调用kset_register将bus对应的kset添加到系统。 bus_create_file在sysfs中创建uevent文件，操作函数由bus_attr_uevent指定。 创建priv-\u0026gt;devices_kset和priv-\u0026gt;drivers_kset。 初始一些列表头和锁。 add_probe_files向sysfs添加drivers_autoprobe和drivers_probe文件。 bus_add_groups添加属性组。 3.2. driver的注册 driver注册时，需要指定是在哪个bus下。以platform总线为例，注册platform_driver需要调用platform_driver_register，函数内部会将bus设为platform_bus_type。\n1/// include/linux/platform_device.h 2/* 3 * use a macro to avoid include chaining to get THIS_MODULE 4 */ 5#define platform_driver_register(drv) \\ 6 __platform_driver_register(drv, THIS_MODULE) 7 8/// drivers/base/platform.c 9/** 10 * __platform_driver_register - register a driver for platform-level devices 11 * @drv: platform driver structure 12 * @owner: owning module/driver 13 */ 14int __platform_driver_register(struct platform_driver *drv, 15 struct module *owner) 16{ 17 drv-\u0026gt;driver.owner = owner; 18 drv-\u0026gt;driver.bus = \u0026amp;platform_bus_type; 19 20 return driver_register(\u0026amp;drv-\u0026gt;driver); 21} 22EXPORT_SYMBOL_GPL(__platform_driver_register); 3.2.1. driver_register 可以看到，向系统注册驱动是由driver_register来完成的，其主要流程如下：\n通过driver_find来查看所属bus下是否由同名驱动，如果有，则证明已经注册过，不需要再进行注册。 bus_add_driver向bus上添加驱动 driver_add_groups向sysfs添加driver的属性组 kobject_uevent向用户态上报KOBJ_ADD事件 3.2.2. bus_add_driver bus_add_driver流程如下：\nbus_get增加bus内kset的引用计数 申请struct driver_private数据，记录到priv，并关联priv和driver 关联driver和bus，priv-\u0026gt;kobj.kset = bus-\u0026gt;p-\u0026gt;drivers_kset kobject_init_and_add向系统添加priv-\u0026gt;kobj，指定类型为driver_ktype 将driver添加到bus的列表中，klist_add_tail(\u0026amp;priv-\u0026gt;knode_bus, \u0026amp;bus-\u0026gt;p-\u0026gt;klist_drivers) 如果bus使能了drivers_autoprobe，调用driver_attach尝试匹配driver和device module_add_driver向module添加driver driver_create_file在sysfs创建uevent driver_add_groups添加bus的属性组 如果driver没有指定suppress_bind_attrs，调用add_bind_files在sysfs创建bind/unbind文件。 3.3. device的注册 和device相关的函数主要有device_initialize和device_add，device_initialize负责device结构体的初始化，device_add负责向系统添加设备，并与bus/driver/class关联。\n3.3.1. device_add device_add主要流程如下：\nget_device增加device内嵌kobject的引用计数，防止操作过程中设备被删除 device_private_init创建device私有数据并初始化，记录到dev-\u0026gt;p 设置名字 get_device(dev-\u0026gt;parent)增加父设备的引用计数 get_device_parent找到父设备的kobject，如果不为空，则赋值给dev-\u0026gt;kobj.parent kobject_add(\u0026amp;dev-\u0026gt;kobj, dev-\u0026gt;kobj.parent, NULL)向系统添加dev-\u0026gt;kobj，parent为dev-\u0026gt;kobj.parent device_platform_notify完成一些通知工作 device_create_file在sysfs创建uevent文件 device_add_class_symlinks创建sysfs中device和class的的链接文件 device_add_attrs添加属性组，包括class/device_type等 调用bus_add_device dpm_sysfs_add向sysfs添加device power manage相关文件 device_pm_add根据需要决定是否将设备添加到dpm_list链表 如果dev-\u0026gt;devt的MAJOR不为0，向sysfs添加dev文件，并创建devtmpfs节点 如果device挂载在bus下，blocking_notifier_call_chain向通知链发送BUS_NOTIFY_ADD_DEVICE通知 kobject_uevent向用户态报告KOBJ_ADD 关联device和fwnode bus_probe_device，Automatically probe for a driver if the bus allows it 如果device有父设备，将device添加到父设备的链表中 如果device有所属的class，则关联device和class，见后续章节。 put_device减小device的引用计数 3.3.2. bus_add_device 如果device有所属的bus，则执行如下操作：\n增加bus的引用计数 向sysfs添加bus的属性组 在sysfs创建bus-\u0026gt;p-\u0026gt;devices_kset-\u0026gt;kobj和dev-\u0026gt;kobj的链接 在sysfs创建dev-\u0026gt;kobj和dev-\u0026gt;bus-\u0026gt;p-\u0026gt;subsys.kobj的链接 将device添加到bus的链表中 3.4. class的注册以及device和class的关联 3.4.1. class的注册 1/// include/linux/device/class.h 2/* This is a #define to keep the compiler from merging different 3 * instances of the __key variable */ 4#define class_register(class)\t\\ 5({\t\\ 6\tstatic struct lock_class_key __key;\t\\ 7\t__class_register(class, \u0026amp;__key);\t\\ 8}) __class_register负责向系统注册class，其主要流程如下：\n初始化class的设备列表klist_devices和interfaces列表 初始化mutex 设置class名 如果没有指定cls-\u0026gt;dev_kobj，将其设置为sysfs_dev_char_kobj 根据需要，设置class的kset为class_kset 设置class的ktype为class_ktype kset_register注册cls-\u0026gt;p-\u0026gt;subsys class_add_groups在sysfs创建属性组 class_put减小cls-\u0026gt;p-\u0026gt;subsys的引用计数，kset_register时引用计数为1，此时将其减为0 3.4.2. device和class的关联 如果device有所属的class，device_add会完成device和class的关联：\n将设备添加到class的链表中 如果class有class_interface，遍历class-\u0026gt;p-\u0026gt;interfaces，调用class_intf-\u0026gt;add_dev 在实际编码中，由如下两种方式来实现device和class的关联\ndevice_create时，指定class 创建device后，手动指定dev-\u0026gt;class，然后调用device_register或device_add ","date":"July 12, 2023","img":"https://kingdix10.github.io/covers/dunes_sand_texture_151004_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.1/devicemodel/device_model/","series":[{"title":"设备驱动模型","url":"/zh-cn/series/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"内核驱动","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"},{"title":"linux-6.1","url":"/zh-cn/tags/linux-6.1/"}],"timestamp":1689120000,"title":"Linux内核驱动模型（四）核心结构体"},{"categories":[{"title":"设备模型","url":"/zh-cn/categories/%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"}],"content":" 1. DT和FDT 设备树（Device Tree，DT）是一种层次结构的文本数据表示方式，用于描述硬件设备的配置信息。扁平设备树（Flattened Device Tree，FDT），也叫平坦设备树，是设备树的一种二进制表示形式，提高了在嵌入式系统中的传输和解析效率。\nDT和FDT在使用方式、传输方式和效率方面存在一些差异，但都是为了帮助操作系统内核正确地初始化和管理硬件设备。下面是DT和FDT的区别：\n数据表示方式：\n设备树（DT）：设备树使用的是一种层次结构的数据表示方式，通过树状结构的节点和子节点描述设备之间的关系。每个节点包含设备的属性、寄存器、中断等信息。 扁平设备树（FDT）：扁平设备树是设备树的一种二进制表示形式，通过将设备树的层次结构转换为线性的、平坦的二进制数据来实现。FDT更易于在嵌入式系统中传输和解析。 传输和解析效率：\n设备树（DT）：设备树作为一种文本格式，相对容易编写和阅读。然而，设备树的传输和解析可能相对较慢，特别是在资源受限的环境中。 扁平设备树（FDT）：FDT以二进制形式存储设备树，提高了传输和解析的效率。FDT在嵌入式系统中更受欢迎，特别是在引导加载程序和设备驱动程序中。 使用场景：\n设备树（DT）：设备树通常在内核启动过程中使用，用于传递硬件设备的信息给操作系统内核。设备树描述了硬件设备的配置和布局，使内核能够正确地初始化和管理这些设备。 扁平设备树（FDT）：FDT作为设备树的序列化形式，主要用于传输和解析设备树数据。FDT更方便在引导加载程序和嵌入式系统中的传输和解析操作。 2. FDT的反扁平化(unflatten) 在ARM和ARM64的setup_arch中，会调用unflatten_device_tree来是FDT反扁平化，就是将FDT转换为以struct device_node为节点的树状结构。其他架构可能会调用unflatten_and_copy_device_tree来实现FDT的反扁平化。\n2.1. unflatten_device_tree initial_boot_params记录从Bootloader传入的fdt的指针，在early_init_dt_verify中赋值。\n1/** 2 * unflatten_device_tree - create tree of device_nodes from flat blob 3 * 4 * unflattens the device-tree passed by the firmware, creating the 5 * tree of struct device_node. It also fills the \u0026#34;name\u0026#34; and \u0026#34;type\u0026#34; 6 * pointers of the nodes so the normal device-tree walking functions 7 * can be used. 8 */ 9void __init unflatten_device_tree(void) 10{ 11 __unflatten_device_tree(initial_boot_params, NULL, \u0026amp;of_root, 12 early_init_dt_alloc_memory_arch, false); 13 14 /* Get pointer to \u0026#34;/chosen\u0026#34; and \u0026#34;/aliases\u0026#34; nodes for use everywhere */ 15 of_alias_scan(early_init_dt_alloc_memory_arch); 16 17 unittest_unflatten_overlay_base(); 18} 2.2. __unflatten_device_tree __unflatten_device_tree先调用一次unflatten_dt_nodes来获取需要占用的内存区域的大小。 然后为其申请内存，再次调用unflatten_dt_nodes，进行真正的反扁平化。\nunflatten_dt_nodes针对fdt中的每个节点调用populate_node，来创建device_node并生成树状结构。最后再通过reverse_nodes来反转子节点。\nunflatten_dt_nodes代码在drivers/of/fdt.c，感兴趣的可以自己分析。\n1/** 2 * __unflatten_device_tree - create tree of device_nodes from flat blob 3 * @blob: The blob to expand 4 * @dad: Parent device node 5 * @mynodes: The device_node tree created by the call 6 * @dt_alloc: An allocator that provides a virtual address to memory 7 * for the resulting tree 8 * @detached: if true set OF_DETACHED on @mynodes 9 * 10 * unflattens a device-tree, creating the tree of struct device_node. It also 11 * fills the \u0026#34;name\u0026#34; and \u0026#34;type\u0026#34; pointers of the nodes so the normal device-tree 12 * walking functions can be used. 13 * 14 * Return: NULL on failure or the memory chunk containing the unflattened 15 * device tree on success. 16 */ 17void *__unflatten_device_tree(const void *blob, 18 struct device_node *dad, 19 struct device_node **mynodes, 20 void *(*dt_alloc)(u64 size, u64 align), 21 bool detached) 22{ 23 /// ... ... 24 25 /* First pass, scan for size */ 26 size = unflatten_dt_nodes(blob, NULL, dad, NULL); 27 if (size \u0026lt;= 0) 28 return NULL; 29 30 size = ALIGN(size, 4); 31 pr_debug(\u0026#34; size is %d, allocating...\\n\u0026#34;, size); 32 33 /* Allocate memory for the expanded device tree */ 34 mem = dt_alloc(size + 4, __alignof__(struct device_node)); 35 if (!mem) 36 return NULL; 37 38 memset(mem, 0, size); 39 40 *(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef); 41 42 pr_debug(\u0026#34; unflattening %p...\\n\u0026#34;, mem); 43 44 /* Second pass, do actual unflattening */ 45 ret = unflatten_dt_nodes(blob, mem, dad, mynodes); 46 47 /// ... ... 48} 3. device_node的层次关系 经过反扁平化后，device_node间的关系如下图：\nof_root是根节点，其child指向子节点，形成一个单链表。子节点的parent指向父节点。兄弟节点使用slibling关联。\n每个device_node都会有struct property数组，proterty间形成单链表，每个proterty都包含属性名、长度、值。\n每个device_node内嵌的fwnode的ops指向全局变量of_fwnode_ops。 of_fwnode_ops中的函数指针会通过如下宏来调用，这些宏被调用的地方主要在drivers/base/property.c和drivers/base/core.c，具体函数可以通过git grep -In -p fwnode_call_ drivers/查看。\n1/// include/linux/fwnode.h 2#define fwnode_has_op(fwnode, op)\t\\ 3 (!IS_ERR_OR_NULL(fwnode) \u0026amp;\u0026amp; (fwnode)-\u0026gt;ops \u0026amp;\u0026amp; (fwnode)-\u0026gt;ops-\u0026gt;op) 4 5#define fwnode_call_int_op(fwnode, op, ...)\t\\ 6 (fwnode_has_op(fwnode, op) ?\t\\ 7 (fwnode)-\u0026gt;ops-\u0026gt;op(fwnode, ## __VA_ARGS__) : (IS_ERR_OR_NULL(fwnode) ? -EINVAL : -ENXIO)) 8 9#define fwnode_call_bool_op(fwnode, op, ...)\t\\ 10 (fwnode_has_op(fwnode, op) ?\t\\ 11 (fwnode)-\u0026gt;ops-\u0026gt;op(fwnode, ## __VA_ARGS__) : false) 12 13#define fwnode_call_ptr_op(fwnode, op, ...)\t\\ 14 (fwnode_has_op(fwnode, op) ?\t\\ 15 (fwnode)-\u0026gt;ops-\u0026gt;op(fwnode, ## __VA_ARGS__) : NULL) 16#define fwnode_call_void_op(fwnode, op, ...)\t\\ 17 do {\t\\ 18 if (fwnode_has_op(fwnode, op))\t\\ 19 (fwnode)-\u0026gt;ops-\u0026gt;op(fwnode, ## __VA_ARGS__);\t\\ 20 } while (false) ","date":"July 12, 2023","img":"https://kingdix10.github.io/covers/iridescent_colorful_lines_130978_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.1/devicemodel/fdt/fdt_dt/","series":[{"title":"设备驱动模型","url":"/zh-cn/series/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"内核驱动","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"},{"title":"linux-6.1","url":"/zh-cn/tags/linux-6.1/"}],"timestamp":1689120000,"title":"Linux内核驱动模型（一）设备树展开"},{"categories":[{"title":"启动流程","url":"/zh-cn/categories/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"content":" 1. U-Boot获取布局内存 U-Boot在启动过程中，默认内存布局通常在.config中定义。\n1CONFIG_SYS_SDRAM_BASE=0x240000000 2CONFIG_SYS_DDR_SIZE=0xC0000000 在DDR控制器初始化完成之后，就要确定系统中有多少可用内存，这通常是由dram_init_banksize来实现的，而不同的板级文件会实现不同的dram_init_banksize，这也就决定了不同的板级可以定义不同的获取内存布局的方法。这里介绍一种从dtb中获取内存布局的实现，这可以通过简单的调用fdtdec_setup_memory_banksize来实现。而在使能了CONFIG_OF_LIBFDT的情况下，U-Boot又会通过fdt_fixup_memory_banks来为内核dtb添加或修改memory节点，这样就可以只在U-Boot中定义memory信息，内核dtb省略memory定义，从而可以使其更加简洁通用。相信这也是后续U-Boot推荐使用的方式。\n这里涉及的函数逻辑都比较简单，下面简单介绍一下。\n1.1. fdtdec_setup_memory_banksize：从dtb获取内存布局 fdtdec_setup_memory_banksize的逻辑很简单，就是从dtb中解析memory节点，然后将内存的start和size填充到gd-\u0026gt;bd-\u0026gt;bi_dram数组。\n1.2. arch_fixup_fdt：转换gd-\u003ebd-\u003ebi_dram arch_fixup_fdt是一个处理器或板级相关的函数，默认实现为一个空的weak函数。这里以ARM的实现举例。\nbi_dram本质是一个结构体数组，而fdt_fixup_memory_banks的参数是start数组和size数组，arch_fixup_fdt完成一个简单的转换。\n1\tstruct {\t/* RAM configuration */ 2\tphys_addr_t start; 3\tphys_size_t size; 4\t} bi_dram[CONFIG_NR_DRAM_BANKS]; 1.3. fdt_fixup_memory_banks：修改内核dtb fdt_fixup_memory_banks的主要逻辑如下：\n找到内核dtb的memory节点，如果没有则创建一个memory节点 设置节点的属性为device_type 将所有的memory的start和size信息写到内核dtb 这里需要注意的是，如果内核dtb中已有memory节点，fdt_fixup_memory_banks只修改第一个memory节点。\n2. 函数源码 U-Boot版本：v2023.04\n2.1. dram_init_banksize 如下只是dram_init_banksize的一个示例，不同的板级会不同的实现。\n1int dram_init_banksize(void) 2{ 3\treturn fdtdec_setup_memory_banksize(); 4} 2.2. fdtdec_setup_memory_banksize 1/** 2 * fdtdec_setup_memory_banksize() - decode and populate gd-\u0026gt;bd-\u0026gt;bi_dram 3 * 4 * Decode the /memory \u0026#39;reg\u0026#39; property to determine the address and size of the 5 * memory banks. Use this data to populate the global data board info with the 6 * phys address and size of memory banks. 7 * 8 * This function should be called from a boards dram_init_banksize(). This 9 * helper function allows for boards to query the device tree for memory bank 10 * information instead of hard coding the information in cases where it cannot 11 * be detected automatically. 12 * 13 * Return: 0 if OK, -EINVAL if the /memory node or reg property is missing or 14 * invalid 15 */ 16 17int fdtdec_setup_memory_banksize(void) 18{ 19\tint bank, ret, reg = 0; 20\tstruct resource res; 21\tofnode mem = ofnode_null(); 22 23\tmem = get_next_memory_node(mem); 24\tif (!ofnode_valid(mem)) { 25\tdebug(\u0026#34;%s: Missing /memory node\\n\u0026#34;, __func__); 26\treturn -EINVAL; 27\t} 28 29\tfor (bank = 0; bank \u0026lt; CONFIG_NR_DRAM_BANKS; bank++) { 30\tret = ofnode_read_resource(mem, reg++, \u0026amp;res); 31\tif (ret \u0026lt; 0) { 32\treg = 0; 33\tmem = get_next_memory_node(mem); 34\tif (!ofnode_valid(mem)) 35\tbreak; 36 37\tret = ofnode_read_resource(mem, reg++, \u0026amp;res); 38\tif (ret \u0026lt; 0) 39\tbreak; 40\t} 41 42\tif (ret != 0) 43\treturn -EINVAL; 44 45\tgd-\u0026gt;bd-\u0026gt;bi_dram[bank].start = (phys_addr_t)res.start; 46\tgd-\u0026gt;bd-\u0026gt;bi_dram[bank].size = 47\t(phys_size_t)(res.end - res.start + 1); 48 49\tdebug(\u0026#34;%s: DRAM Bank #%d: start = 0x%llx, size = 0x%llx\\n\u0026#34;, 50\t__func__, bank, 51\t(unsigned long long)gd-\u0026gt;bd-\u0026gt;bi_dram[bank].start, 52\t(unsigned long long)gd-\u0026gt;bd-\u0026gt;bi_dram[bank].size); 53\t} 54 55\treturn 0; 56} 2.3. arch_fixup_fdt 源码文件：arch/arm/lib/bootm-fdt.c\n1int arch_fixup_fdt(void *blob) 2{ 3\t__maybe_unused int ret = 0; 4#if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_OF_LIBFDT) 5\tstruct bd_info *bd = gd-\u0026gt;bd; 6\tint bank; 7\tu64 start[CONFIG_NR_DRAM_BANKS]; 8\tu64 size[CONFIG_NR_DRAM_BANKS]; 9 10\tfor (bank = 0; bank \u0026lt; CONFIG_NR_DRAM_BANKS; bank++) { 11\tstart[bank] = bd-\u0026gt;bi_dram[bank].start; 12\tsize[bank] = bd-\u0026gt;bi_dram[bank].size; 13#ifdef CONFIG_ARMV7_NONSEC 14\tret = armv7_apply_memory_carveout(\u0026amp;start[bank], \u0026amp;size[bank]); 15\tif (ret) 16\treturn ret; 17#endif 18\t} 19 20#ifdef CONFIG_OF_LIBFDT 21\tret = fdt_fixup_memory_banks(blob, start, size, CONFIG_NR_DRAM_BANKS); 22\tif (ret) 23\treturn ret; 24#endif 25 26#ifdef CONFIG_ARMV8_SPIN_TABLE 27\tret = spin_table_update_dt(blob); 28\tif (ret) 29\treturn ret; 30#endif 31 32#if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_ARMV8_PSCI) || \\ 33\tCONFIG_IS_ENABLED(SEC_FIRMWARE_ARMV8_PSCI) 34\tret = psci_update_dt(blob); 35\tif (ret) 36\treturn ret; 37#endif 38#endif 39 40#ifdef CONFIG_FMAN_ENET 41\tret = fdt_update_ethernet_dt(blob); 42\tif (ret) 43\treturn ret; 44#endif 45\treturn 0; 46} 2.4. fdt_fixup_memory_banks 1/** 2 * fdt_fixup_memory_banks - Update DT memory node 3 * @blob: Pointer to DT blob 4 * @start: Pointer to memory start addresses array 5 * @size: Pointer to memory sizes array 6 * @banks: Number of memory banks 7 * 8 * Return: 0 on success, negative value on failure 9 * 10 * Based on the passed number of banks and arrays, the function is able to 11 * update existing DT memory nodes to match run time detected/changed memory 12 * configuration. Implementation is handling one specific case with only one 13 * memory node where multiple tuples could be added/updated. 14 * The case where multiple memory nodes with a single tuple (base, size) are 15 * used, this function is only updating the first memory node without removing 16 * others. 17 */ 18int fdt_fixup_memory_banks(void *blob, u64 start[], u64 size[], int banks) 19{ 20\tint err, nodeoffset; 21\tint len, i; 22\tu8 tmp[MEMORY_BANKS_MAX * 16]; /* Up to 64-bit address + 64-bit size */ 23 24\tif (banks \u0026gt; MEMORY_BANKS_MAX) { 25\tprintf(\u0026#34;%s: num banks %d exceeds hardcoded limit %d.\u0026#34; 26\t\u0026#34; Recompile with higher MEMORY_BANKS_MAX?\\n\u0026#34;, 27\t__FUNCTION__, banks, MEMORY_BANKS_MAX); 28\treturn -1; 29\t} 30 31\terr = fdt_check_header(blob); 32\tif (err \u0026lt; 0) { 33\tprintf(\u0026#34;%s: %s\\n\u0026#34;, __FUNCTION__, fdt_strerror(err)); 34\treturn err; 35\t} 36 37\t/* find or create \u0026#34;/memory\u0026#34; node. */ 38\tnodeoffset = fdt_find_or_add_subnode(blob, 0, \u0026#34;memory\u0026#34;); 39\tif (nodeoffset \u0026lt; 0) 40\treturn nodeoffset; 41 42\terr = fdt_setprop(blob, nodeoffset, \u0026#34;device_type\u0026#34;, \u0026#34;memory\u0026#34;, 43\tsizeof(\u0026#34;memory\u0026#34;)); 44\tif (err \u0026lt; 0) { 45\tprintf(\u0026#34;WARNING: could not set %s %s.\\n\u0026#34;, \u0026#34;device_type\u0026#34;, 46\tfdt_strerror(err)); 47\treturn err; 48\t} 49 50\tfor (i = 0; i \u0026lt; banks; i++) { 51\tif (start[i] == 0 \u0026amp;\u0026amp; size[i] == 0) 52\tbreak; 53\t} 54 55\tbanks = i; 56 57\tif (!banks) 58\treturn 0; 59 60\tlen = fdt_pack_reg(blob, tmp, start, size, banks); 61 62\terr = fdt_setprop(blob, nodeoffset, \u0026#34;reg\u0026#34;, tmp, len); 63\tif (err \u0026lt; 0) { 64\tprintf(\u0026#34;WARNING: could not set %s %s.\\n\u0026#34;, 65\t\u0026#34;reg\u0026#34;, fdt_strerror(err)); 66\treturn err; 67\t} 68\treturn 0; 69} ","date":"July 11, 2023","img":"https://kingdix10.github.io/covers/wall_brick_neon_150470_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/03-boot/u-boot/uboot_mem/","series":[{"title":"u-boot","url":"/zh-cn/series/u-boot/"}],"smallImg":"","tags":[{"title":"启动流程","url":"/zh-cn/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"u-boot","url":"/zh-cn/tags/u-boot/"},{"title":"内存管理","url":"/zh-cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}],"timestamp":1689033600,"title":"U-Boot从dtb获取内存布局并传递到内核"},{"categories":[{"title":"内存管理","url":"/zh-cn/categories/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}],"content":"ARM64的可配置的页面大小和虚拟地址位数是由ARM硬件决定的，不同的ARM版本，可选择的页面大小和地址位数也不一样。比如52位虚拟地址和物理地址是在ARMv8.2及之后的架构才支持的，ARMv8.2提供了两种重要的拓展：大虚拟寻址（LVA）和大物理寻址（LPA）。Linux从5.4开始支持ARM64的52位虚拟地址和物理地址。\n在代码里，可以根据arch/arm64/Kconfig找到相应的组合，相应的页表级数也可由此得出。\n1config PGTABLE_LEVELS 2 int 3 default 2 if ARM64_16K_PAGES \u0026amp;\u0026amp; ARM64_VA_BITS_36 4 default 2 if ARM64_64K_PAGES \u0026amp;\u0026amp; ARM64_VA_BITS_42 5 default 3 if ARM64_64K_PAGES \u0026amp;\u0026amp; (ARM64_VA_BITS_48 || ARM64_VA_BITS_52) 6 default 3 if ARM64_4K_PAGES \u0026amp;\u0026amp; ARM64_VA_BITS_39 7 default 3 if ARM64_16K_PAGES \u0026amp;\u0026amp; ARM64_VA_BITS_47 8 default 4 if !ARM64_64K_PAGES \u0026amp;\u0026amp; ARM64_VA_BITS_48 PAGE_SIZE VA_BITS PGTABLE_LEVELS 4K 39 3 4K 48 4 16K 36 2 16K 47 3 16K 48 4 64K 42 2 64K 48 3 64K 52 3 ","date":"July 10, 2023","img":"https://kingdix10.github.io/covers/leaves_patterns_texture_127524_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/mm/arm64_pgtable/","series":[{"title":"内存管理","url":"/zh-cn/series/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"},{"title":"ARM64","url":"/zh-cn/tags/arm64/"}],"timestamp":1688947200,"title":"Linux ARM64页面大小和虚拟地址位数"},{"categories":[{"title":"内核基础","url":"/zh-cn/categories/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"}],"content":" adr_l adrp得到一个大小为4KB的页的基址，而且在该页中有全局变量sym的地址；ADRP就是讲该页的基址存到寄存器dst中； add指令会算出sym的地址，:lo12:\\\\sym是一个偏移量；这样就得到了sym的地址dst。\narch/arm64/include/asm/assembler.h\n1/* 2 * Pseudo-ops for PC-relative adr/ldr/str \u0026lt;reg\u0026gt;, \u0026lt;symbol\u0026gt; where 3 * \u0026lt;symbol\u0026gt; is within the range +/- 4 GB of the PC. 4 */ 5\t/* 6\t* @dst: destination register (64 bit wide) 7\t* @sym: name of the symbol 8\t*/ 9\t.macro\tadr_l, dst, sym 10\tadrp\t\\dst, \\sym 11\tadd\t\\dst, \\dst, :lo12:\\sym 12\t.endm 13 14\t/* 15\t* @dst: destination register (32 or 64 bit wide) 16\t* @sym: name of the symbol 17\t* @tmp: optional 64-bit scratch register to be used if \u0026lt;dst\u0026gt; is a 18\t* 32-bit wide register, in which case it cannot be used to hold 19\t* the address 20\t*/ 21\t.macro\tldr_l, dst, sym, tmp= 22\t.ifb\t\\tmp 23\tadrp\t\\dst, \\sym 24\tldr\t\\dst, [\\dst, :lo12:\\sym] 25\t.else 26\tadrp\t\\tmp, \\sym 27\tldr\t\\dst, [\\tmp, :lo12:\\sym] 28\t.endif 29\t.endm 30 31\t/* 32\t* @src: source register (32 or 64 bit wide) 33\t* @sym: name of the symbol 34\t* @tmp: mandatory 64-bit scratch register to calculate the address 35\t* while \u0026lt;src\u0026gt; needs to be preserved. 36\t*/ 37\t.macro\tstr_l, src, sym, tmp 38\tadrp\t\\tmp, \\sym 39\tstr\t\\src, [\\tmp, :lo12:\\sym] 40\t.endm ","date":"July 10, 2023","img":"https://kingdix10.github.io/covers/paint_grunge_green_124502_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/misc/asm_macors/","series":[{"title":"内核基础","url":"/zh-cn/series/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1688947200,"title":"Linux内核常见ARM64汇编宏"},{"categories":[{"title":"设备模型","url":"/zh-cn/categories/%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"}],"content":" 1. device_node tree到device tree device_node的层次结构建立之后，并没有struct device生成，那我们实现的驱动probe函数又是如何获取设备的呢？ 这就需要有一个从device_node创建struct device的过程，这个过程并没有一个统一的函数来实现，而是各个总线的在初始化时，主动扫描设备树，根据device_node创建自己需要的设备。下边以platform总线为例说明。\nof_platform_default_populate_init通过arch_initcall_sync加入到内核的 .init段，在内核初始化时被调用。\n1.1. of_device_alloc of_platform_device_create_pdata调用of_device_alloc来获取新建的 struct platform_device，这里先分析of_device_alloc。\nof_device_alloc主要完成如下工作：\n调用platform_device_alloc分配 struct platform_device 填充platform_device的resource数组，这是dts里为设备指定的资源 device的of_node指向device_node，fwnode指向device_node的fwnode 默认父设备为platform_bus，platform_bus下可以挂普通设备和总线设备，如果是挂在二级总线下的设备，parent不为platform_bus。后续会根据parent来形成树形结构。 1/// drivers/of/platform.c 2/** 3 * of_device_alloc - Allocate and initialize an of_device 4 * @np: device node to assign to device 5 * @bus_id: Name to assign to the device. May be null to use default name. 6 * @parent: Parent device. 7 */ 8struct platform_device *of_device_alloc(struct device_node *np, 9 const char *bus_id, 10 struct device *parent) 11{ 12 struct platform_device *dev; 13 int rc, i, num_reg = 0; 14 struct resource *res, temp_res; 15 16 dev = platform_device_alloc(\u0026#34;\u0026#34;, PLATFORM_DEVID_NONE); 17 if (!dev) 18 return NULL; 19 20 /* count the io resources */ 21 while (of_address_to_resource(np, num_reg, \u0026amp;temp_res) == 0) 22 num_reg++; 23 24 /* Populate the resource table */ 25 if (num_reg) { 26 res = kcalloc(num_reg, sizeof(*res), GFP_KERNEL); 27 if (!res) { 28 platform_device_put(dev); 29 return NULL; 30 } 31 32 dev-\u0026gt;num_resources = num_reg; 33 dev-\u0026gt;resource = res; 34 for (i = 0; i \u0026lt; num_reg; i++, res++) { 35 rc = of_address_to_resource(np, i, res); 36 WARN_ON(rc); 37 } 38 } 39 40 /// device的of_node指向device_node，fwnode指向device_node的fwnode 41 dev-\u0026gt;dev.of_node = of_node_get(np); 42 dev-\u0026gt;dev.fwnode = \u0026amp;np-\u0026gt;fwnode; 43 dev-\u0026gt;dev.parent = parent ? : \u0026amp;platform_bus; 44 45 if (bus_id) 46 dev_set_name(\u0026amp;dev-\u0026gt;dev, \u0026#34;%s\u0026#34;, bus_id); 47 else 48 of_device_make_bus_id(\u0026amp;dev-\u0026gt;dev); 49 50 return dev; 51} 52EXPORT_SYMBOL(of_device_alloc); of_device_alloc之后，device和device_node的关系图如下： 1.2. of_platform_device_create_pdata of_platform_device_create_pdata主要完成如下工作：\nof_device_alloc分配platform_device 将bus设置为platform_bus_type 通过of_device_add调用device_add将设备添加到系统，device_add会关联parent和device，建立完整的树状结构 1/** 2 * of_platform_device_create_pdata - Alloc, initialize and register an of_device 3 * @np: pointer to node to create device for 4 * @bus_id: name to assign device 5 * @platform_data: pointer to populate platform_data pointer with 6 * @parent: Linux device model parent device. 7 * 8 * Return: Pointer to created platform device, or NULL if a device was not 9 * registered. Unavailable devices will not get registered. 10 */ 11static struct platform_device *of_platform_device_create_pdata( 12 struct device_node *np, 13 const char *bus_id, 14 void *platform_data, 15 struct device *parent) 16{ 17 struct platform_device *dev; 18 19 if (!of_device_is_available(np) || 20 of_node_test_and_set_flag(np, OF_POPULATED)) 21 return NULL; 22 23 dev = of_device_alloc(np, bus_id, parent); 24 if (!dev) 25 goto err_clear_flag; 26 27 dev-\u0026gt;dev.coherent_dma_mask = DMA_BIT_MASK(32); 28 if (!dev-\u0026gt;dev.dma_mask) 29 dev-\u0026gt;dev.dma_mask = \u0026amp;dev-\u0026gt;dev.coherent_dma_mask; 30 dev-\u0026gt;dev.bus = \u0026amp;platform_bus_type; 31 dev-\u0026gt;dev.platform_data = platform_data; 32 of_msi_configure(\u0026amp;dev-\u0026gt;dev, dev-\u0026gt;dev.of_node); 33 34 if (of_device_add(dev) != 0) { 35 platform_device_put(dev); 36 goto err_clear_flag; 37 } 38 39 return dev; 40 41err_clear_flag: 42 of_node_clear_flag(np, OF_POPULATED); 43 return NULL; 44} 1.3. 添加platform_device的另一种方式 值得一提的是，除了platform设备除了在初始化时通过解析设备树添加，还可以通过如下函数手动添加：\n1/// include/linux/platform_device.h 2platform_device_register_full 3platform_device_register_resndata 4platform_device_register_simple 5platform_device_register_data 6platform_device_add 比如如下代码：\n1#include \u0026lt;linux/module.h\u0026gt; 2#include \u0026lt;linux/platform_device.h\u0026gt; 3 4/// ... ... 5 6static struct platform_driver pdrv = { 7 .probe = pdev_probe, 8 .remove = pdev_remove, 9 .driver = { 10 .name = \u0026#34;pdev-demo\u0026#34;, 11 }, 12}; 13 14static struct platform_device *pdev; 15 16static int __init pdev_init(void) 17{ 18 int ret; 19 20 pdev = platform_device_register_simple(\u0026#34;pdev-demo\u0026#34;, 0, NULL, 0); 21 if (IS_ERR(pdev)) { 22 return PTR_ERR(pdev); 23 } 24 25 ret = platform_driver_register(\u0026amp;pdrv); 26 27 return ret; 28} 29 30static void __exit pdev_exit(void) 31{ 32 platform_driver_unregister(\u0026amp;pdrv); 33 platform_device_unregister(pdev); 34} 35 36module_init(pdev_init); 37module_exit(pdev_exit); 2. 设备和驱动的匹配：of_match_table 设备和驱动的匹配是靠总线的match函数来实现的，如果驱动要匹配来自设备树的设备，需要调用of_driver_match_device，比如platform总线的match函数platform_match，内部就直接调用了of_driver_match_device。当然，除了匹配设备树，还可以匹配其他信息，比如设备名称和驱动名称。\n1/// include/linux/of_device.h 2/** 3 * of_driver_match_device - Tell if a driver\u0026#39;s of_match_table matches a device. 4 * @drv: the device_driver structure to test 5 * @dev: the device structure to match against 6 */ 7static inline int of_driver_match_device(struct device *dev, 8 const struct device_driver *drv) 9{ 10 return of_match_device(drv-\u0026gt;of_match_table, dev) != NULL; 11} 3. 其他总线上的device_node tree到device tree 可以通过 git grep -Iw -p --heading of_driver_match_device drivers/来搜索会从设备树中匹配设备的总线，要调用这些总线的match函数，都需要提前将device_node tree为device tree，这个转换不一定是像platform总线在系统初始化时完成。比如i2c总线，这个转换是在注册i2c_adapter时，通过i2c_register_adapter调用of_i2c_register_devices来完成的。当然，注册的设备也不再是 struct platform_device，而是 struct i2c_client。至于其他总线，可以自行分析。\n1drivers/base/platform.c 21331=static int platform_match(struct device *dev, struct device_driver *drv) 31341: if (of_driver_match_device(dev, drv)) 4drivers/bus/moxtet.c 586=static int moxtet_match(struct device *dev, struct device_driver *drv) 692: if (of_driver_match_device(dev, drv)) 7drivers/bus/sunxi-rsb.c 8133=static int sunxi_rsb_device_match(struct device *dev, struct device_driver *drv) 9135: return of_driver_match_device(dev, drv); 10drivers/gpu/drm/drm_mipi_dsi.c 1150=static int mipi_dsi_device_match(struct device *dev, struct device_driver *drv) 1255: if (of_driver_match_device(dev, drv)) 13drivers/hsi/hsi_core.c 1440=static int hsi_bus_match(struct device *dev, struct device_driver *driver) 1542: if (of_driver_match_device(dev, driver)) 16drivers/net/phy/mdio_bus.c 17979=static int mdio_bus_match(struct device *dev, struct device_driver *drv) 18989: if (of_driver_match_device(dev, drv)) 19drivers/rpmsg/rpmsg_core.c 20475=static int rpmsg_dev_match(struct device *dev, struct device_driver *drv) 21492: return of_driver_match_device(dev, drv); 22drivers/slimbus/core.c 2333=static int slim_device_match(struct device *dev, struct device_driver *drv) 2439: if (of_driver_match_device(dev, drv)) 25drivers/soc/qcom/apr.c 26341=static int apr_device_match(struct device *dev, struct device_driver *drv) 27348: if (of_driver_match_device(dev, drv)) 28drivers/spi/spi.c 29363=static int spi_match_device(struct device *dev, struct device_driver *drv) 30373: if (of_driver_match_device(dev, drv)) 31drivers/spmi/spmi.c 3246=static int spmi_device_match(struct device *dev, struct device_driver *drv) 3348: if (of_driver_match_device(dev, drv)) 34drivers/tty/serdev/core.c 3586=static int serdev_device_match(struct device *dev, struct device_driver *drv) 3695: return of_driver_match_device(dev, drv); 37drivers/usb/common/ulpi.c 3837=static int ulpi_match(struct device *dev, struct device_driver *driver) 3948: return of_driver_match_device(dev, driver); linux acpi如何识别设备 在Linux系统中，ACPI（Advanced Configuration and Power Interface）是一种用于操作系统与硬件平台之间进行电源管理和配置的标准接口。ACPI定义了如何在操作系统中枚举、配置和管理硬件设备，包括电源管理设备、事件驱动设备等。\n对于通用硬件错误源（Generic Hardware Error Source，GHES）设备的识别，Linux内核通过ACPI表（如HEST，Hardware Error Source Table）来进行。HEST表描述了硬件错误源的信息，包括错误类型、错误状态等。Linux内核中的ACPI子系统会解析HEST表，并据此创建相应的错误处理设备。\n具体来说，Linux内核中的ACPI子系统通过以下步骤识别GHES设备：\n解析HEST表：在系统启动时，内核会解析HEST表，获取硬件错误源的信息。HEST表通常包含多个错误源描述，每个描述对应一个GHES设备。\n创建错误处理设备：对于HEST表中的每个GHES描述，内核会创建一个对应的错误处理设备。这些设备通常是platform_device类型的设备，表示一个通用的硬件错误源。\n注册错误处理设备：创建的设备会被注册到设备系统中，以便用户空间程序可以通过设备文件（如/dev/mem）或设备驱动来访问和控制这些设备。\n处理错误事件：一旦GHES设备检测到硬件错误事件，它会将事件信息通知给内核的错误处理子系统。内核会根据事件的类型和严重程度，采取相应的错误处理措施，如记录错误信息、重置设备、触发系统崩溃等。\n需要注意的是，具体的设备识别和错误处理过程可能会因硬件平台、操作系统版本和内核配置的不同而有所差异。因此，在实际应用中，建议参考相关的硬件文档、操作系统文档和内核源代码，以获取更详细和准确的信息。\n1/// linux-6.6/drivers/acpi/apei/hest.c 2static int __init hest_parse_ghes(struct acpi_hest_header *hest_hdr, void *data) 3{ 4\tstruct platform_device *ghes_dev; 5\tstruct ghes_arr *ghes_arr = data; 6\tint rc, i; 7 8\tif (!is_generic_error(hest_hdr)) 9\treturn 0; 10 11\tif (!((struct acpi_hest_generic *)hest_hdr)-\u0026gt;enabled) 12\treturn 0; 13\tfor (i = 0; i \u0026lt; ghes_arr-\u0026gt;count; i++) { 14\tstruct acpi_hest_header *hdr; 15\tghes_dev = ghes_arr-\u0026gt;ghes_devs[i]; 16\thdr = *(struct acpi_hest_header **)ghes_dev-\u0026gt;dev.platform_data; 17\tif (hdr-\u0026gt;source_id == hest_hdr-\u0026gt;source_id) { 18\tpr_warn(FW_WARN HEST_PFX \u0026#34;Duplicated hardware error source ID: %d.\\n\u0026#34;, 19\thdr-\u0026gt;source_id); 20\treturn -EIO; 21\t} 22\t} 23\tghes_dev = platform_device_alloc(\u0026#34;GHES\u0026#34;, hest_hdr-\u0026gt;source_id); 24\tif (!ghes_dev) 25\treturn -ENOMEM; 26 27\trc = platform_device_add_data(ghes_dev, \u0026amp;hest_hdr, sizeof(void *)); 28\tif (rc) 29\tgoto err; 30 31\trc = platform_device_add(ghes_dev); 32\tif (rc) 33\tgoto err; 34\tghes_arr-\u0026gt;ghes_devs[ghes_arr-\u0026gt;count++] = ghes_dev; 35 36\treturn 0; 37err: 38\tplatform_device_put(ghes_dev); 39\treturn rc; 40} ","date":"July 10, 2023","img":"https://kingdix10.github.io/covers/gold_background_lines_72322_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.1/devicemodel/fdt/dt_to_dt/","series":[{"title":"设备驱动模型","url":"/zh-cn/series/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"内核驱动","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"},{"title":"linux-6.1","url":"/zh-cn/tags/linux-6.1/"}],"timestamp":1688947200,"title":"Linux内核驱动模型（二）设备树转换"},{"categories":[{"title":"设备模型","url":"/zh-cn/categories/%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"}],"content":" 1. 数据结构简介 内核版本：linux-6.1\n内核文档：Everything you never wanted to know about kobjects, ksets, and ktypes — The Linux Kernel documentation\n在Linux内核中，kobject、kset和kobj_type是用于管理和表示kobject的数据结构。kobject是设备驱动模型的基石，sysfs和uevent也与kobject密切相关。\n1.1. kobject struct kobject表示一个对象，包含了一些基本属性，通常会内嵌在其他结构体中来表示不同的实例。每个kobject都会在sysfs中呈现出一个目录。\n1/// include/linux/kobject.h 2struct kobject { 3 const char *name; /// 名字，可以唯一标识该对象，对应sysfs目录名 4 struct list_head entry; /// 链接到所属的kset，链表头尾kset.list 5 struct kobject *parent; /// 指向父kobject，形成sysfs中的目录层级关系。通常来说，父kobject会内嵌到其他结构体中 6 struct kset *kset; /// 所属的kset 7 const struct kobj_type *ktype; /// 用于定义kobject的行为 8 /// 对应sysfs目录，后续在kobject下添加的文件（比如属性）会放到这个目录， 9 /// 每个文件也是一个kernfs_node，通过rbtree连接到kobject-\u0026gt;sd 10 struct kernfs_node *sd; /* sysfsdirectory entry */ 11 struct kref kref; /// 引用计数，用于管理kobject的生命周期 12#ifdef CONFIG_DEBUG_KOBJECT_RELEASE 13 struct delayed_work release; 14#endif 15 unsigned int state_initialized:1; /// 是否完成初始化 16 unsigned int state_in_sysfs:1; /// 是否添加到sysfs中 17 unsigned int state_add_uevent_sent:1; /// 当发送KOBJ_ADD消息时置位，表示已经向用户空间发送ADD消息 18 unsigned int state_remove_uevent_sent:1;/// 当发送KOBJ_REMOVE消息时置位，表示已经向用户空间发送REMOVE消息 19 unsigned int uevent_suppress:1; /// 如果为1，表示忽略所有上报的uevent事件 20}; kobject主要提供如下功能：\n构成层次结构：通过parent指针，可以将所有Kobject以层次结构的形式组合起来。 生命周期管理：使用引用计数（reference count），来记录Kobject被引用的次数，并在引用次数变为0时把它释放。 和sysfs虚拟文件系统配合，将每一个Kobject及其特性，以文件的形式，开放到用户空间。 没有一个结构会嵌入多于一个kobject结构，如果这么做了，关于这个对象的引用计数肯定会一团糟，你的code也会充满bug，所以千万不要这么做。\n实际上，kobject对自身实现什么功能并不感兴趣，它存在的意义在于把高级的对象链接到设备模型上。因此内核代码很少去创建一个单独的kobject对象，相反，kobject用于控制对大型域相关对象的访问（通过container_of）。\n1.2. kset struct kset继承了 struct kobject，用于管理一个kobject集合，与kobject可以形成层次关系。kset对应sysfs中的一个子目录，kobject对应的目录在所属的kset对应的目录之下。\n1/// include/linux/kobject.h 2/** 3 * struct kset - a set of kobjects of a specific type, belonging to a specific subsystem. 4 * 5 * A kset defines a group of kobjects. They can be individually 6 * different \u0026#34;types\u0026#34; but overall these kobjects all want to be grouped 7 * together and operated on in the same manner. ksets are used to 8 * define the attribute callbacks and other common events that happen to 9 * a kobject. 10 * 11 * @list: the list of all kobjects for this kset 12 * @list_lock: a lock for iterating over the kobjects 13 * @kobj: the embedded kobject for this kset (recursion, isn\u0026#39;t it fun...) 14 * @uevent_ops: the set of uevent operations for this kset. These are 15 * called whenever a kobject has something happen to it so that the kset 16 * can add new environment variables, or filter out the uevents if so 17 * desired. 18 */ 19struct kset { 20 struct list_head list; /// 链接属于该kset的kobject 21 spinlock_t list_lock; /// 用于保护list 22 struct kobject kobj; /// 继承kobject 23 /// uevent操作函数集合。当kobject发生某些事件时，会调用这些操作， 24 /// 以便kset可以添加新的环境变量，或者在需要时过滤掉uevents。 25 const struct kset_uevent_ops *uevent_ops; 26} __randomize_layout; 1.3. kobj_ktype struct kobj_ktype表示一类kobject，用于管理kobject的生命周期，控制kobject的行为。\n1/// include/linux/kobject.h 2struct kobj_type { 3 void (*release)(struct kobject *kobj); 4 const struct sysfs_ops *sysfs_ops; 5 const struct attribute_group **default_groups; 6 const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); 7 const void *(*namespace)(struct kobject *kobj); 8 void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); 9}; release：用于释放kobject占用的资源。当kobject的引用计数减为0时，会调用该函数来释放对象的资源。 sysfs_ops：sysfs_ops结构体指针。 default_attrs：指向默认属性组的数组，用于向sysfs注册文件，每个属性对应sysfs中的一个文件。 namespace：为kobject提供命名空间，通常用于创建sysfs目录结构，以便在sysfs文件系统中按照一定层次组织kobject。 release_ns：释放kobject的命名空间。当kobject的引用计数减为0时，调用该函数来释放命名空间。 1.4. sysfs_ops kobject和sysfs是紧密结合的。struct sysfs_ops提供了用于操作sysfs目录和文件的函数指针。用户可以通过sysfs文件系统与内核空间进行通信，获取内核模块、驱动程序的信息，或者进行一些配置。\n1/// include/linux/sysfs.h 2struct sysfs_ops { 3 ssize_t (*show)(struct kobject *, struct attribute *, char *); 4 ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t); 5}; show: 用于读取sysfs文件内容时的回调函数，用户空间读取sysfs文件时调用。 store: 用于写入sysfs文件时的回调函数，用户空间写入sysfs文件时调用。 通过这些函数指针，struct sysfs_ops可以为sysfs文件提供自定义的读写操作和其他操作。这样，驱动程序、子系统和内核模块可以通过sysfs文件系统与用户空间进行通信，并提供相关的系统和设备信息。\nshow和store的第二个参数为 struct attribute指针，但其实show和store通常并不会直接操作 struct attribute。而是将 struct attribute包含在其他结构体之内，用show和store去操作更高一级的结构体，这又是内核面向对象编程思想的一种提现。\n1static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr, 2 char *buf) 3{ 4 struct device_attribute *dev_attr = to_dev_attr(attr); 5 struct device *dev = kobj_to_dev(kobj); 6 ssize_t ret = -EIO; 7 8 if (dev_attr-\u0026gt;show) 9 ret = dev_attr-\u0026gt;show(dev, dev_attr, buf); 10 if (ret \u0026gt;= (ssize_t)PAGE_SIZE) { 11 printk(\u0026#34;dev_attr_show: %pS returned bad count\\n\u0026#34;, 12 dev_attr-\u0026gt;show); 13 } 14 return ret; 15} 16 17static ssize_t dev_attr_store(struct kobject *kobj, struct attribute *attr, 18 const char *buf, size_t count) 19{ 20 struct device_attribute *dev_attr = to_dev_attr(attr); 21 struct device *dev = kobj_to_dev(kobj); 22 ssize_t ret = -EIO; 23 24 if (dev_attr-\u0026gt;store) 25 ret = dev_attr-\u0026gt;store(dev, dev_attr, buf, count); 26 return ret; 27} 28 29static const struct sysfs_ops dev_sysfs_ops = { 30 .show\t= dev_attr_show, 31 .store\t= dev_attr_store, 32}; 2. 数据结构关系 kobject、kset和kobj_type关系如下：\nkset进行组织和管理kobject对象，一个kset可以包含多个kobject对象。 kobj_type可以定义不同的对象操作函数，kobject通过指向具体的kobj_type来指定所需的操作。 kset和kobj_type没有直接的关系，但kset可以通过内嵌的kobject指向所需的kobj_type。 2.1. 默认kobj_type kobject.c中提供了两个默认的kobj_type，dynamic_kobj_ktype和kset_type。当创建一个kobject时，默认会指定ktype为dynamic_kobj_ktype。而创建一个kset时，默认kset内部的kobject的ktype会指向kset_type。\ndynamic_kobj_ktype和kset_type的sysfs_ops都指向了kobj_sys_ops。\n2.2. kobject、kset和kobj_type的关系 内核 sturct device的内嵌了 struct kobject。以建立 sturct device层次关系的过程为例来说明三者之间的关系是如何建立的。 内核启动过程中，会在devices_init中通过调用kset_create_and_add来创建devices_set。而device_ktype是静态数据。\n1devices_kset = kset_create_and_add(\u0026#34;devices\u0026#34;, \u0026amp;device_uevent_ops, NULL); 下图中以dev1_kobj表示内嵌在 sturct device的结构体：\ndevice_initialize时指定dev1_kobj的kset为devices_kset。 device_initialize调用kobject_init初始化dev1_kobj，设置dev1_kobj-\u0026gt;ktype为device_ktype。 device_add调用kobject_add来将dev1_kobj添加到dev1_kobj-\u0026gt;kset的list中，也就是devices_kset的list。 2.3. kobject初始化函数调用关系 kobject相关函数介绍在Kernel objects manipulation，也可以在Linux Kernel Document Index直接搜索kobject。\n这里介绍几个函数：\nkobject_init：初始化kobj各个字段的值，指定kobj的ktype，将引用计数初始化为1。 kobject_add：设置name和parent，增加parent的引用计数，调用kobj_kset_join，在sysfs创建目录。 kobj_set_join：如果kobj-\u0026gt;set不为空，将kobj添加到kobj-\u0026gt;set的list。 kobject_uevent：用于通知用户空间。kset_register会调用kobject_uevent来上报KOBJ_ADD事件。 2.4. kobject引用计数和生命周期 kobject的关键功能之一为包含kobject的对象提供引用计数。只要引用计数不为0，则kobject或包含kobject的对象必须继续存在。\nkobject_init将引用计数设置为1。 在使用一个kobject或包含kobject的对象之前，需要使用kobject_get来将kobject的引用计数加1，确保kobject或包含kobject的对象不会被意外销毁。 当对象不再被使用时，使用kobject_put来将引用计数减1，当引用计数被减为0时，会自动调用kobj_type的release函数来释放kobject或对象资源。 2.5. kobject与uevent uevent用来将kobject或保护kobject的对象发生变化时通知用户空间，这些变化由kobject_action指定。对于自定义的改动，内核不建议新加一个kobject_action，而是使用KOBJ_CHANGE。\nkobject_add默认不会向用户态报告，但kset_register会向用户态报告KOBJ_ADD。\n1/* 2 * The actions here must match the index to the string array 3 * in lib/kobject_uevent.c 4 * 5 * Do not add new actions here without checking with the driver-core 6 * maintainers. Action strings are not meant to express subsystem 7 * or device specific properties. In most cases you want to send a 8 * kobject_uevent_env(kobj, KOBJ_CHANGE, env) with additional event 9 * specific variables added to the event environment. 10 */ 11enum kobject_action { 12 KOBJ_ADD, 13 KOBJ_REMOVE, 14 KOBJ_CHANGE, 15 KOBJ_MOVE, 16 KOBJ_ONLINE, 17 KOBJ_OFFLINE, 18 KOBJ_BIND, 19 KOBJ_UNBIND, 20}; https://blog.csdn.net/qq_16777851/article/details/81368580\n","date":"July 10, 2023","img":"https://kingdix10.github.io/covers/lines_obliquely_stripes_123801_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.1/devicemodel/kobject/kobject/","series":[{"title":"设备驱动模型","url":"/zh-cn/series/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"内核驱动","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"},{"title":"linux-6.1","url":"/zh-cn/tags/linux-6.1/"},{"title":"数据结构","url":"/zh-cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"timestamp":1688947200,"title":"Linux内核数据结构kobject/kset/ktype"},{"categories":[{"title":"启动流程","url":"/zh-cn/categories/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"content":" 1. get_ram_size get_ram_size只适用于CONFIG_SYS_DDR_SIZE=2^n。\n1int dram_init(void) 2{ 3 gd-\u0026gt;ram_size = get_ram_size((long *)CONFIG_SYS_SDRAM_BASE, 4 CONFIG_SYS_DDR_SIZE); 5 return 0; 6} 2. 多核启动之spintable U-Boo中需要开启ARMV8_MULTIENTRY，另外CPU_RELEASE_ADDR的值要与内核dtb的cpu-release-addr保持一致。\n1#define CPU_RELEASE_ADDR 0x100000 3. FIT FIT，支持打包多份dtb、randisk、内核镜像，指定每个镜像的地址，且支持压缩，支持多份config U-Boot启动时，可以根据U-Boot的dtb，找到FIT中对应的config，加载config指定的镜像\n1/// func: fit_image_load 2if (IMAGE_ENABLE_BEST_MATCH \u0026amp;\u0026amp; !fit_uname_config) { 3 cfg_noffset = fit_conf_find_compat(fit, gd_fdt_blob()); 4} else { 5 cfg_noffset = fit_conf_get_node(fit, 6 fit_uname_config); 7} 可以使用dfu工具将生成的.idb文件，下载的memory的某个地址（没有特殊要求，例如0x100000），然后使用bootm命令即可启动，步骤包括：\n使用iminfo命令，查看memory中存在的images和configurations。 使用bootm命令，执行默认配置，或者指定配置。 使用默认配置启动的话，可以直接使用bootm： bootm 0x100000 选择其它配置的话，可以指定配置名: bootm 0x100000#config@2\n内存区域划分要求\n内核镜像加载地址不能冲掉U-Boot代码段 内核reserve内存区域和FIT镜像指定的镜像加载地址不能冲突 3.1. Ramdisk its文件中，rootfs压缩格式需要是none。\n1/// fit_image_load 2if (image_type == IH_TYPE_RAMDISK \u0026amp;\u0026amp; comp != IH_COMP_NONE) 3 puts(\u0026#34;WARNING: \u0026#39;compression\u0026#39; nodes for ramdisks are deprecated,\u0026#34; 4 \u0026#34; please fix your .its file!\\n\u0026#34;); 4. Ramdisk重定位 默认情况下，uboot会对Ramdisk进行重定位，可以使用如下方式取消重定位。\n1setenv initrd_high 0xffffffffffffffff 5. Reserve内存 bootm时，uboot会读取内核dtb的reserve区域调用lmb_add进行reserve 核心函数：lmb_add_region 默认最对可reserve内存区域为8，#define MAX_LMB_REGIONS 8(u-boot/include/lmb.h)\n6. OF_PLATDATA OF_PLATDATA适用于SPL和TPL对体积要求比较严格，不能使用完整的DM情况。原理是将设备树内的数据转换为c代码后，将数据直接与可执行文件链接到一起，再在设备的probe函数中解析。这样在spl中，就不存在dtb格式的数据，而是用填充到udev私有数据对应的结构体中。\n官方文档: u-boot/doc/driver-model/of-plat.rst\n依赖：swig工具\ndts中的节点，address-cells和size-cells需要为2（2020.07版，其他版本未知）\n1#address-cells = \u0026lt;2\u0026gt;; 2#size-cells = \u0026lt;2\u0026gt;; 自动生成的用于描述dts中节点属性的结构体\n1include/generated/dt-structs-gen.h 2struct dtd_XXXX 相关配置项\n1CONFIG_SPL_DM 2 3CONFIG_SPL_OF_PLATDATA 4CONFIG_TPL_OF_PLATDATA 5 6 7CONFIG_IS_ENABLED(OF_PLATDATA) 8// 判断CONFIG_SPL_OF_PLATDATA或CONFIG_TPL_OF_PLATDATA是否使能 9// 没有CONFIG_OF_PLATDATA宏 6.1. 使用示例 1U_BOOT_DRIVER(dmc_rk3399) = { 2 .name = \u0026#34;rockchip_rk3399_dmc\u0026#34;, 3 .id = UCLASS_RAM, 4 .of_match = rk3399_dmc_ids, 5 .ops = \u0026amp;rk3399_dmc_ops, 6#if defined(CONFIG_TPL_BUILD) || \\ 7 (!defined(CONFIG_TPL) \u0026amp;\u0026amp; defined(CONFIG_SPL_BUILD)) 8 .ofdata_to_platdata = rk3399_dmc_ofdata_to_platdata, 9#endif 10 .probe = rk3399_dmc_probe, 11 .priv_auto_alloc_size = sizeof(struct dram_info), 12#if defined(CONFIG_TPL_BUILD) || \\ 13 (!defined(CONFIG_TPL) \u0026amp;\u0026amp; defined(CONFIG_SPL_BUILD)) 14 .platdata_auto_alloc_size = sizeof(struct rockchip_dmc_plat), 15#endif 16}; 7. 设备树解析示例 如果在初始化设备树前调用of接口解析，会导致卡死。\n1/// doc/driver-model/design.rst 2To reduce the size of SPL and TPL, only the nodes with pre-relocation properties 3(\u0026#39;u-boot,dm-pre-reloc\u0026#39;, \u0026#39;u-boot,dm-spl\u0026#39; or \u0026#39;u-boot,dm-tpl\u0026#39;) are keept in their 4device trees (see README.SPL for details); the remaining nodes are always bound. dts文件\n1/ { 2 demo-node { 3 #address-cells = \u0026lt;1\u0026gt;; 4 #size-cells = \u0026lt;0\u0026gt;; 5 u-boot,dm-spl; /* 在SPL中保留 */ 6 7 key-word = \u0026lt;28\u0026gt;; 8 }; 9}; C语言解析代码\n1int get_demo_node_value(const void *fdt) 2{ 3 int demo_node = fdt_path_offset(fdt, \u0026#34;/demo-node\u0026#34;); 4 int val; 5 6 if (demo_node \u0026lt; 0) 7 return demo_node; 8 9 val = fdtdec_get_int(fdt, demo_node, \u0026#34;key-word\u0026#34;, -1); 10 if (val \u0026lt; 0) 11 return -1; 12 13 return val; 14} ","date":"July 10, 2023","img":"https://kingdix10.github.io/covers/spots_stains_colorful_147593_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/03-boot/u-boot/uboot_misc_note/","series":[{"title":"u-boot","url":"/zh-cn/series/u-boot/"}],"smallImg":"","tags":[{"title":"启动流程","url":"/zh-cn/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"u-boot","url":"/zh-cn/tags/u-boot/"}],"timestamp":1688947200,"title":"U-Boot杂项记录"},{"categories":[{"title":"磁盘管理","url":"/zh-cn/categories/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"},{"title":"linux命令","url":"/zh-cn/categories/linux%E5%91%BD%E4%BB%A4/"}],"content":" 1. 简介 Linux磁盘及文件系统扩容/缩容涉及的命令:\ndf parted，K、M、G以1000为基，要使用1024为基准的单位，需要用KiB、MiB、GiB、TiB fdisk e2fsck resize2fs，\u0026lsquo;K\u0026rsquo;, \u0026lsquo;M\u0026rsquo;, \u0026lsquo;G\u0026rsquo;, \u0026lsquo;T\u0026rsquo;，无论大小写，都是1024为基，也可以使用s来以512 bytes的sector为基。 mkfs 命令执行需要root权限，可以切换到root用户或者在命令前加sudo执行。\n使用过程中需要注意单位是以1000还是1024为基准，如parted的默认使用的单位跟resize2fs就是不同的。\n2. 扩大文件系统 在将两个分区合并为一个分区，或者是增大虚拟机磁盘空间大小后，需要调整文件系统大小才能使用增加的空间。\n如果文件系统已经被挂载，使用umount命令卸载 用parted或fdisk调整分区大小 e2fsck -f /dev/part_name检查文件系统 使用resize2fs /dev/part_name part_size修改文件系统大小，调整文件系统大小，如果比超过了分区大小，会提示失败 使用mount重新挂载文件系统 2.1. 根文件系统扩容 需要用启动盘进入系统，使用启动盘的根文件系统启动，此时命令行通常为busybox，之后的扩容步骤与普通文件系统的扩容一致。\n3. 文件系统和磁盘分区缩容 如果文件系统已经被挂载，使用umount命令卸载 e2fschk -f /dev/xxx检查文件系统 确定文件系统缩小后的值，可以用resize2fs -P /dev/xxx查看，输出值乘以4k(4 * 1024)就是文件系统最小大小，也可以卸载前用df查看。 resize2fs /dev/xxx [size]，调整文件系统大小，size要比已占用的稍大。 用parted或fdisk调整分区大小，操作过程会提示可能丢失数据，无需关心 如果是虚拟磁盘，这是将空闲空间划分为一个新的分区，如/dev/sda3，之后可以dd if=/dev/zero of=/dev/sda3来清空磁盘，关闭虚拟机后，可以进入虚拟机磁盘工具压缩虚拟磁盘文件大小。详细过程参考《VMware和Hyper-V回收虚拟磁盘空间》。\n3.1. 演示 基本步骤汇总\n1umount /path/to/mountpoint 2e2fsck -f /dev/xxx 3# 查看文件系统最小占用空间 4resize2fs -P /dev/xxx 5# 压缩文件系统 6resize2fs /dev/xxx xxG 7# 进入parted命令行，调整分区大小，为空出来的空间创建分区 8parted /dev/xxx 9 10# 退出parted命令行，使用dd清零 11dd if=/dev/zero of=/dev/yyy bs=1M 下边只是命令演示，请根据实际大小调整数据\n1$ sudo e2fsck -f /dev/sdb1 2e2fsck 1.45.5 (07-Jan-2020) 3Pass 1: Checking inodes, blocks, and sizes 4Pass 2: Checking directory structure 5Pass 3: Checking directory connectivity 6Pass 4: Checking reference counts 7Pass 5: Checking group summary information 8share: 614244/30523392 files (0.1% non-contiguous), 9399143/122070056 blocks 9 10## 获取文件系统最小值 11$ sudo resize2fs -P /dev/sdb1 12resize2fs 1.45.5 (07-Jan-2020) 13Estimated minimum size of the filesystem: 8022240 14 15# 8022240 * 4k ~= 30.6G 16# 压缩文件系统 17resize2fs /dev/sdb1 31G 18 19# 使用parted命令行，调整分区大小，使用前可以使用unit修改单位 20# 只做命令演示，请根据实际大小调整数据 21sudo parted /dev/sdb1 22(parted) print # 打印当前分区 23# ... .. 24 25Number Start End Size File system Name Flags 26 1 1049kB 67.1MB 66.1MB ext4 primary 27 28(parted) resizepart 1 # 修改分区1的大小 29End? [67.1MB]? 128MiB 30(parted) q # 退出parted 31 32# 完成后确认uuid，一般不会改变 33sudo blkid 34 35# 使用mount或者修改/etc/fstab挂载文件系统 ","date":"July 10, 2023","img":"https://kingdix10.github.io/covers/lines_obliquely_stripes_123801_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/02-dev_env/resizefs/","series":[{"title":"linux命令","url":"/zh-cn/series/linux%E5%91%BD%E4%BB%A4/"}],"smallImg":"","tags":[{"title":"磁盘管理","url":"/zh-cn/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"},{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"}],"timestamp":1688947200,"title":"磁盘和文件系统扩容/缩容"},{"categories":[{"title":"4412","url":"/zh-cn/categories/4412/"},{"title":"启动流程","url":"/zh-cn/categories/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"content":" 1. 两种大小的BL1是怎么回事 关于4412的BL1，有说8k的，也有说15k的，到底哪一个是对的呢？\n这要追溯一下4412的版本，Exynos4412一共有两个版本，一个是Exynos 4412，另一个是Exynos 4412 Prime。网上大多数文章都是基于8k来介绍BL1的。我只在关于Exynos4412 SoC的启动分析 | 点滴汇聚 (chasinglulu.github.io)和Exynos4412 的启动过程详解（四）看到过关于Exynos 4412 Prime的介绍，但是没到找到对应的官方资料。两者的主要差异就在于BL1的大小。Exynos 4412 Prime可以支持15k的BL1，也向后兼容，支持8k的BL1。\ndesc 8k size 15k size ProductID, iROM version, function pointer 0x0202_0000 0x0202_0000 iROM stack 0x0202_0100 1.75K 0x0202_0100 1.75K iROM ZI/RW 0x0202_0800 3KiB 0x0202_0800 3K BL1 0x0202_1400 8K 0x0202_1400 15K BL2+padding 0x0202_3400 16K 0x0202_5000 16K free space 0x0202_7400 0x0202_9000 END 0x0206_0000 0x0206_0000 1.1. 维基百科给出的介绍\n这里摘抄一下维基百科介绍：\n2011年推出的Exynos 4210才是Exynos系列的第一款产品，它之前被人熟知的名字是Orion（猎户座）。Exynos 4210采用45nm制程，拥有两枚主频为1.2 GHz的Cortex-A9通用处理核心，拥有32/32 KB I/D Cache, 1 MB L2 Cache，并且集成ARM Mali-400 MP图形处理核心。在视频方面，Exynos 4210支持单路WXGA和双路WSVGA视频输出，支持HDMI v1.3a高清标准，可以拍摄1080p、30fps标准高清视频；Exynos 4210提供了6.4GB/s的内存带宽，支持LPDDR2/DDR2/DDR3内存。代表产品有三星Galaxy Tab 7.7、Galaxy S II（i9100）、Galaxy Note和魅族MX等。 2011年9月发布的Exynos 4212在Exynos 4210的基础上再加改进：首先制程变为32nm，比起之前的45nm能够节省超过50%的能源。而且虽然同样为Cortex-A9架构，但Exynos 4212主频升至1.5GHz，比起4210更为强劲，3D性能约为后者的2倍，可用在手机及平板电脑上。 2012年初，三星正式推出了自家的首款四核移动处理器Exynos 4412。这款新Exynos四核处理器，拥有32nm HKMG（高K金属栅极技术）制程，支持双通道LPDDR2 1066。新的32nm HKMG技术可以帮助降低功耗，按照官方的说法，和其前代比会减低20% 的功耗。三星Exynos 4412四核处理器仍然集成Mali-400MP图形处理器，但三星公司已将这颗图形处理器主频由此前的266MHz提升至400MHz，新闻稿指出会比现有的双核机型整体性能提升60%，图像处理提升 50%。2012年5月，首款采用Exynos 4412处理器的智能手机三星Galaxy S III正式上市，以及于6月上市的魅族MX四核版和12月上市的纽曼N2。\nSoC CPU GPU 内存技术 供货时间 应用设备 型号 制程 指令集 架构 核心 频率 (GHz) Exynos 4 Dual 45 nm``(Exynos 4210) ^[7]^ 45 nm ARMv7 Cortex-A9 2 1.2 或1.4 Exynos 4 Dual 32 nm``(Exynos 4212) ^[7]^ 32 nm HKMG Cortex-A9 2 1.5 Mali-400MP4^[10]^ (quad-core) @ 400 MHz; 16 GFLOPS Exynos 4 Quad^[13]^`` (Exynos 4412) ^[14]^ 32 nm HKMG Cortex-A9 4 1.4 ARM Mali-400MP4^[15]^ (quad-core) @ 440 MHz ; 17.6 GFLOPS Exynos 4 Quad^[13]^`` (Exynos 4412 Prime) ^[14]^ 32 nm HKMG Cortex-A9 4 1.6 ARM Mali-400MP4^[15]^ (quad-core) @ 533 MHz; 21.32 GFLOPS 2. Exynos4412的启动流程 关于Exynos4412的启动模式、启动流程、文件布局等，在Android_Exynos4412_iROM_Secure_Booting_Guide_Ver.1.00.00.pdf介绍的很清楚。\n关于文件布局，Exynos 4412对BL1进行了限定，如果是使用官方的BL1，则BL2也需要满足指定的要求。如果是自制的BL1，只需要关心BL1的限定即可，BL2可以根据自制的BL1来进行布局。官方给出的布局是BL1+BL1+u-boot+tzsw。\nBL1和BL2在存储介质中的block小结。\nSD(8k) eMMC(8k) SD(15k) eMMC(15k) BL1 1~16 0~15 1~30 0~29 BL2 17~48 16~47 31~62 30~61 3. 函数介绍 三星提供了一组从外部介质加载数据的函数，可以在BL1或BL2中直接使用，相关介绍在Android_Exynos4412_iROM_Secure_Booting_Guide_Ver.1.00.00.pdf。\n看一下文档中提到的注意事项：\n在启动时提供给SDMMC和eMMC的时钟是20Mhz，MPLL是这些时钟的源头。 如果SDMMC和eMMC被选中为启动设备，那么iROM中SDMMC或eMMC拷贝函数在BL1和BL2阶段是可以使用的。如果你要使用这两函数，那么在使用前请不要修改SDMMC或eMMC的时钟。 另外不要修改SDMMC或eMMC相关的PLL时钟配置。如果你修改了SDMMC或eMMC相关的时钟配置，那么正确的拷贝我们无法保证。\naddr name 0x02020030 SDMMC_ReadBlocks 0x0202003C LoadBL2FromEmmc43Ch0 0x02020044 MSH_ReadFromFIFO_eMMC 0x02020048 MSH_EndBootOp_eMMC 0x02020070 LoadImageFromUsb 这里特别说明一下MSH_ReadFromFIFO_eMMC和MSH_EndBootOp_eMMC。\nMSH_EndBootOp_eMMC是从eMMC中复制数据到指定位置，这个函数首先从eMMC偏移为0的位置读取，再次调用时，会以上一次读取的结尾为偏移再进行读取。\nMSH_EndBootOp_eMMC是所有读取动作完成后调用的。Exynos4412要求启动时从eMMC的boot分区读取数据，个人猜测这个函数是用来将eMMC的读写分区切换到userdata的。如果要烧录boot分区，可以用U-Boot的 mmc partconf命令来切换要读写的物理分区或设置eMMC上电后的默认读写分区。\n如设置为boot0分区启动：\n1mmc partconf 0 1 1 1 3.1. SDMMC_ReadBlocks 这个接口功能是从SD或MMC类型设备拷贝数据到目的地址中；\n返回1=True，0=False；参数(u32 SrcBlock，u32 NumofSrcBlock，void * DstByte)\nSrcBlock：start block number.(0 ~ n)拷贝起始块的编号从0开始\nNumofSrcBlock：拷贝块的数目\nDstByte：目的地址(System Memory)\n3.2. LoadBL2FromEmmc43Ch0 这个接口从emmc 4.3拷贝BL2启动区数据到内部RAM；\n返回1=True，0=False；参数(u32 SrcBlock，u32 * DstByte )\n0x02020040 Emmc43_EndBootOp_eMMC 这个接口结束emmc 4.3启动模式；\n返回和参数都是void\n3.3. MSH_ReadFromFIFO_eMMC 这个接口从emmc 4.4拷贝启动区数据到目的地址；\n返回1=True，0=False；参数(u32 uNumofBlocks，void * uDstAddr)\nuNumofBlocks：传输的总块数，1块=512B\nuDstAddr：目的地址(System Memory)\n3.4. MSH_EndBootOp_eMMC 这个接口结束emmc 4.4启动模式；\n返回和参数都是void，这个函数会等待上面读函数的结束。\n3.5. LoadImageFromUsb 这个接口从USB拷贝数据，如果在iROM中枚举成功，这个功能就能用；\n返回1=True，0=False；参数void\n","date":"June 5, 2023","img":"https://kingdix10.github.io/covers/vintage_retro_camera_126517_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/exynos4412/exynos4412/","series":[{"title":"4412","url":"/zh-cn/series/4412/"}],"smallImg":"","tags":[{"title":"4412","url":"/zh-cn/tags/4412/"},{"title":"启动流程","url":"/zh-cn/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"timestamp":1685923200,"title":"Exynos4412启动介绍"},{"categories":[{"title":"4412","url":"/zh-cn/categories/4412/"}],"content":" 1. 自制BL1 参考Android_Exynos4412_iROM_Secure_Booting_Guide_Ver.1.00.00.pdf，Exynos4412会自动把BL加载到0x0202_1400运行。所以BL1的入口地址需要设置为0x0202_1400，这样才能保证位置相关码可以正常执行。\nExynos4412内部的BL0会对BL1进行校验，BL1的头部为16字节的校验码，这个校验码是根据头部之后，其余的（8k-16）字节的数据计算出来的，工具源码可以参考mkbl1。对于编译生成的文件不足8k的情况，要将其用0填充到8k。当然，这里是以非安全启动方式来说明的。\n编写源码时，要在对面中预留16字节的占位符，比如：\n1.word 0x0 2.word 0x0 3.word 0x0 4.word 0x0 5 6 .global _start 7_start: 8 ldr sp, =0x02040000 9 bl _main 至于15k的BL1文件如何制作，我没有找到资料。\n1.1. mkbl1源码 1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;string.h\u0026gt; 3 4#define BL1_SIZE 8 * 1024 5#define HEAD_SIZE 16 6 7static unsigned int calc_checksum(unsigned char *buf, unsigned int buf_size) 8{ 9 unsigned int checksum = 0; 10 int i; 11 12 for(i = HEAD_SIZE; i \u0026lt; buf_size; i++) { 13 checksum += buf[i] \u0026amp; 0xff; 14 } 15 16 return checksum; 17} 18 19static unsigned int calc_header(unsigned char *head, unsigned int checksum) 20{ 21 int i; 22 23 memset(head, 0x00, HEAD_SIZE); 24 25 head[3] = (0x1f \u0026gt;\u0026gt; 24) \u0026amp; 0xff; 26 head[2] = (0x1f \u0026gt;\u0026gt; 16) \u0026amp; 0xff; 27 head[1] = (0x1f \u0026gt;\u0026gt; 8 ) \u0026amp; 0xff; 28 head[0] = (0x1f \u0026gt;\u0026gt; 0 ) \u0026amp; 0xff; 29 30 head[7] = (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xff; 31 head[6] = (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xff; 32 head[5] = (checksum \u0026gt;\u0026gt; 8 ) \u0026amp; 0xff; 33 head[4] = (checksum \u0026gt;\u0026gt; 0 ) \u0026amp; 0xff; 34 35 head[0] ^= 0xbc; 36 head[1] ^= 0xca; 37 head[2] ^= 0xba; 38 head[3] ^= 0xcb; 39 head[4] ^= 0xcb; 40 head[5] ^= 0xce; 41 head[6] ^= 0xcd; 42 head[7] ^= 0xdf; 43 head[8] ^= 0xb7; 44 head[9] ^= 0xba; 45 head[10] ^= 0xbe; 46 head[11] ^= 0xbb; 47 head[12] ^= 0xba; 48 head[13] ^= 0xad; 49 head[14] ^= 0xdf; 50 head[15] ^= 0xdf; 51 52 for(i = 1; i \u0026lt; HEAD_SIZE; i++)\t{ 53 head[i] ^= head[i-1]; 54 } 55} 56 57int main(int argc, char *argv[]) 58{ 59 unsigned char head[HEAD_SIZE]; 60 unsigned char buffer[BL1_SIZE]; 61 62 char *infile; 63 char *outfile = \u0026#34;E4412bl1.bin\u0026#34;; 64 FILE *fin, *fout; 65 66 int filesize; 67 unsigned int checksum; 68 69 if (argc \u0026lt; 2 || 0 == strcmp(argv[1], \u0026#34;?\u0026#34;) || 0 == strcmp(argv[1], \u0026#34;help\u0026#34;)) { 70 printf(\u0026#34;Usage: %s \u0026lt;infile\u0026gt; [outfile=E4412bl1.bin]\\n\u0026#34;, argv[0]); 71 return -1; 72 } 73 74 infile = argv[1]; 75 if (argc \u0026gt; 2)\t{ 76 outfile = argv[2]; 77 } 78 79 fin = fopen(infile, \u0026#34;rb\u0026#34;); 80 if (!fin) { 81 printf(\u0026#34;Can not open file \u0026#39;%s\u0026#39;\\n\u0026#34;, infile); 82 return -1; 83 } 84 85 fseek(fin, 0L, SEEK_END); 86 filesize = ftell(fin); 87 if (filesize \u0026gt; BL1_SIZE) { 88 printf(\u0026#34;file %s size is %d, larger than %d!\\n\u0026#34;, infile, filesize, BL1_SIZE); 89 fclose(fin); 90 return -1; 91 } 92 fseek(fin, 0L, SEEK_SET); 93 94 // clear buffer in BL1_SIZE 95 memset(buffer, 0x00, sizeof(buffer)); 96 97 if (filesize != fread(buffer, 1, filesize, fin)) { 98 printf(\u0026#34;Can\u0026#39;t read %s\\n\u0026#34;, infile); 99 fclose(fin); 100 return -1; 101 } 102 fclose(fin); 103 104 fout = fopen(outfile, \u0026#34;wb\u0026#34;); 105 if (fout == NULL) { 106 printf(\u0026#34;Can not open file \u0026#39;%s\u0026#39;\\n\u0026#34;, outfile); 107 return -1; 108 } 109 110 checksum = calc_checksum(buffer, filesize); 111 calc_header(head, checksum); 112 113 printf(\u0026#34;checksum is 0x%08X of %d bytes\\n\u0026#34;, checksum, filesize); 114 printf(\u0026#34;input [%s], output [%s]\\n\u0026#34;, infile, outfile); 115 116 fwrite(buffer, 1, BL1_SIZE, fout); 117 fseek(fout, 0L, SEEK_SET); 118 // write header 119 fwrite(head, 1, sizeof(head), fout); 120 121 fflush(fout); 122 fclose(fout); 123 124 return 0; 125} ","date":"June 5, 2023","img":"https://kingdix10.github.io/covers/travel_map_compass_123078_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/exynos4412/mkbl1/","series":[{"title":"4412","url":"/zh-cn/series/4412/"}],"smallImg":"","tags":[{"title":"4412","url":"/zh-cn/tags/4412/"}],"timestamp":1685923200,"title":"Exynos4412自制BL1"},{"categories":[{"title":"4412","url":"/zh-cn/categories/4412/"}],"content":" 1. 自制BL2 在官方提供的BL1或自制的BL1基础上，可以自制BL2。如果是使用U-Boot，编译时生成u-booot-spl.bin也是制作BL2的原材料。 如果是自制的BL1，BL2可以根据BL1随心定制。如果是在官方提供的BL1基础上进行开发，BL2要求为16k，其中最后2k使用0填充。可执行文件的大下不能超过(14k-4)字节，其中14k的最后4个字节是存储校验值的。相较于BL1的校验值，BL2的校验简单的多，只是把前（14k-4）的内容按字节进行累加即可。\n这样生成的BL2在Exynos4412和Exynos 4412 Prime上是都可以使用的。当然，这里要求是非安全启动方式。\n1.1. mkbl2源码 网上有C语言版本，懒得整理就用Python来实现了。\n1#!/usr/bin/env python3 2# -*- coding:utf-8 -*- 3 4import os 5import sys 6import argparse 7 8BL2_HEAD_SIZE = 4 9BL2_SIZE = 14 * 1024 10PAD_SIZE = 2 * 1024 11BL2_CHKSUM_OFFSET = BL2_SIZE - BL2_HEAD_SIZE 12 13def main(args): 14 filename = args.file 15 output_file = args.output 16 17 data = None 18 try: 19 with open(filename, \u0026#39;rb\u0026#39;) as f: 20 data = f.read() 21 except Exception as e: 22 logging.error(e) 23 sys.exit(1) 24 25 zero = 0 26 if len(data) \u0026lt; BL2_CHKSUM_OFFSET: 27 data += zero.to_bytes(BL2_CHKSUM_OFFSET - len(data), byteorder=\u0026#39;little\u0026#39;) 28 29 data = data[:BL2_CHKSUM_OFFSET] 30 31 chk_sum = 0 32 for d in data: 33 chk_sum += d 34 35 data += chk_sum.to_bytes(4, byteorder=\u0026#39;little\u0026#39;) 36 data += zero.to_bytes(PAD_SIZE, byteorder=\u0026#39;little\u0026#39;) 37 38 with open(output_file, \u0026#39;wb\u0026#39;) as f: 39 f.write(data) 40 41if __name__ == \u0026#39;__main__\u0026#39;: 42 parser = argparse.ArgumentParser() 43 44 parser.add_argument(\u0026#39;-o\u0026#39;, \u0026#39;--output\u0026#39;, required=True, type=str, help=\u0026#39;output file\u0026#39;) 45 parser.add_argument(\u0026#39;file\u0026#39;, type=str, help=\u0026#39;file\u0026#39;) 46 47 args = parser.parse_args() 48 49 main(args) ","date":"June 5, 2023","img":"https://kingdix10.github.io/covers/lines_plexus_neon_128926_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/exynos4412/mkbl2/","series":[{"title":"4412","url":"/zh-cn/series/4412/"}],"smallImg":"","tags":[{"title":"4412","url":"/zh-cn/tags/4412/"}],"timestamp":1685923200,"title":"Exynos4412自制BL2"},{"categories":[{"title":"时间子系统","url":"/zh-cn/categories/%E6%97%B6%E9%97%B4%E5%AD%90%E7%B3%BB%E7%BB%9F/"}],"content":" 1. timekeeping timekeeping是时间子系统用于从clocksource获取时间，维护墙上时间、单调递增时间、启动时间的模块，timekeeping提供了各种时间的获取接口。其核心数据为tk_core，实现了对timekeeper的加锁访问。\n1/* 2 * The most important data for readout fits into a single 64 byte 3 * cache line. 4 */ 5static struct { 6 seqcount_raw_spinlock_t seq; 7 struct timekeeper timekeeper; 8} tk_core ____cacheline_aligned = { 9 .seq = SEQCNT_RAW_SPINLOCK_ZERO(tk_core.seq, \u0026amp;timekeeper_lock), 10}; 11 12static struct timekeeper shadow_timekeeper; timekeeping_init主要就是在对tk_core.timekeeper进行初始化。下面是timekeeping_init函数总体流程\nread_persistent_wall_and_boot_offset读取wall_time和boot_offest。默认为0。1 验证wall_time和boot_offset是否正确，不正确则设置为0 计算wall_to_mono 获取锁，开始修改tk ntp_init（Network Time Protocol） clocksource_default_clock获取默认clock并enable，clocksource默认为clocksource_jiffies，在probe timer后会切换clocksource tk_setup_internals、tk_set_xtime、tk_set_wall_to_mono和timekeeping_update设置tk 释放锁 2. 计算墙上时间、启动时间差值 wall_time墙上时间：自然时间，也就是真实世界的时间。timekeeper里用xtime表示。\nboot_time：系统启动的时间\n1boot_offset = wall_time - boot_time 2wall_time + wall_to_mono = boot_time read_persistent_wall_and_boot_offset读取时钟，这个函数是一个 __weak的函数，默认设置wall_time和boot_offset为0，如果支持rtc时钟，可以读取rtc时钟里的值。\n校验wall_time的正确性，如果时间格式正确，而且不为0，则表示有断电不失效的时钟，则设置persistent_clock_exists为true，否则，wall_time必须为0。\n校验完wall_time后，再检查boot_offset是否正确，boot_offset不能比wall_time还要晚。\nwall_to_mono，将墙上时间转为单调递增时间。单调递增时间是即从某个时间点开始到现在过去的时间。用户不能修改这个时间，但是当系统进入休眠（suspend）时，时间也不会增加的。更改系统时间也不会对mono时间产生影响。\n接下来就是比较重要的初始化timekeeper的部分了。\n3. timekeeper初始化 tk_core.timekeeper受自旋锁timekeeper_lock和读写顺序锁tk_core.seq保护。\n首先需要获取锁。\nntp_init，ntp（Network Time Protocol，网络时间协议）相关初始化，暂不分析。\n3.1. 默认时钟源 clocksource_default_clock用于获取默认时钟源，这是一个 __weak函数，默认使用clocksource_jiffies作为时钟源，精度很低，如果有更精确的时钟源，可以重新实现此函数。这里设置一个时钟源，是为了防止调用获取时间的接口时出现问题。后续有新的时钟源注册时，会替换掉低精度的时钟源。\n1/* 2 * The Jiffies based clocksource is the lowest common 3 * denominator clock source which should function on 4 * all systems. It has the same coarse resolution as 5 * the timer interrupt frequency HZ and it suffers 6 * inaccuracies caused by missed or lost timer 7 * interrupts and the inability for the timer 8 * interrupt hardware to accurately tick at the 9 * requested HZ value. It is also not recommended 10 * for \u0026#34;tick-less\u0026#34; systems. 11 */ 12static struct clocksource clocksource_jiffies = { 13 .name = \u0026#34;jiffies\u0026#34;, 14 .rating = 1, /* lowest valid rating*/ 15 .uncertainty_margin = 32 * NSEC_PER_MSEC, 16 .read = jiffies_read, 17 .mask = CLOCKSOURCE_MASK(32), 18 .mult = TICK_NSEC \u0026lt;\u0026lt; JIFFIES_SHIFT, /* details above */ 19 .shift = JIFFIES_SHIFT, 20 .max_cycles = 10, 21}; 获取时钟源后，如果该时钟源有enable回调，则需要调用该函数来使能。\n3.2. tk_setup_internals tk_setup_internals来初始化tk_core.timekeeper的一些内部成员。\n其中比较中要的是tkr_mono和tkr_raw，使用默认时钟对这两个成员初始化，用于给获取时间的接口提供时钟源，比如ktime_get接口。在后续有更高精度的时钟之后，会进行更新。\n3.3. 设置时间 tk_set_xtime墙上时间\n根据之前计算出的wall_time设置tk_core.timekeeper的xtime_sec和tkr_mono.xtime_nsec。\ntk-\u0026gt;raw_sec = 0，这是CLOCK_MONOTONIC_RAW\n根据之前计算出的wall_to_mono，调用tk_set_wall_to_mono设置一些offs_real和offs_tai，这些offset在调用时间获取接口时会用到。\n1static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm) 2{ 3 struct timespec64 tmp; 4 5 /* 6 * Verify consistency of: offset_real = -wall_to_monotonic 7 * before modifying anything 8 */ 9 set_normalized_timespec64(\u0026amp;tmp, -tk-\u0026gt;wall_to_monotonic.tv_sec, 10 -tk-\u0026gt;wall_to_monotonic.tv_nsec); 11 WARN_ON_ONCE(tk-\u0026gt;offs_real != timespec64_to_ktime(tmp)); 12 tk-\u0026gt;wall_to_monotonic = wtm; 13 set_normalized_timespec64(\u0026amp;tmp, -wtm.tv_sec, -wtm.tv_nsec); 14 tk-\u0026gt;offs_real = timespec64_to_ktime(tmp); 15 tk-\u0026gt;offs_tai = ktime_add(tk-\u0026gt;offs_real, ktime_set(tk-\u0026gt;tai_offset, 0)); 16} 4. timekeeping_update timekeeping_update是最终完成各种时间基准初始化的函数。\n1/* must hold timekeeper_lock */ 2static void timekeeping_update(struct timekeeper *tk, unsigned int action) 3{ 4 if (action \u0026amp; TK_CLEAR_NTP) { 5 tk-\u0026gt;ntp_error = 0; 6 ntp_clear(); 7 } 8 9 tk_update_leap_state(tk); 10 tk_update_ktime_data(tk); 11 12 update_vsyscall(tk); 13 update_pvclock_gtod(tk, action \u0026amp; TK_CLOCK_WAS_SET); 14 15 tk-\u0026gt;tkr_mono.base_real = tk-\u0026gt;tkr_mono.base + tk-\u0026gt;offs_real; 16 update_fast_timekeeper(\u0026amp;tk-\u0026gt;tkr_mono, \u0026amp;tk_fast_mono); 17 update_fast_timekeeper(\u0026amp;tk-\u0026gt;tkr_raw, \u0026amp;tk_fast_raw); 18 19 if (action \u0026amp; TK_CLOCK_WAS_SET) 20 tk-\u0026gt;clock_was_set_seq++; 21 /* 22 * The mirroring of the data to the shadow-timekeeper needs 23 * to happen last here to ensure we don\u0026#39;t over-write the 24 * timekeeper structure on the next update with stale data 25 */ 26 if (action \u0026amp; TK_MIRROR) 27 memcpy(\u0026amp;shadow_timekeeper, \u0026amp;tk_core.timekeeper, 28 sizeof(tk_core.timekeeper)); 29} tk_update_leap_state闰秒调整\n4.1. tk_update_ktime_data：tkr_mono和tkr_raw设置 tk-\u0026gt;tkr_mono.base\ntk-\u0026gt;tkr_raw.base\ntk-\u0026gt;ktime_sec\ntk-\u0026gt;tkr_mono.base_real = tk-\u0026gt;tkr_mono.base + tk-\u0026gt;offs_real\n4.2. update_fast_timekeeper 除了tkr_mono和tkr_raw两个struct tk_read_base，linux内核还定义了两个struct tk_fast，tk_fast_mono和tk_fast_raw。这两个是用来实现NMI safe的。\n1/** 2 * struct tk_fast - NMI safe timekeeper 3 * @seq: Sequence counter for protecting updates. The lowest bit 4 * is the index for the tk_read_base array 5 * @base: tk_read_base array. Access is indexed by the lowest bit of 6 * @seq. 7 * 8 * See @update_fast_timekeeper() below. 9 */ 10struct tk_fast { 11 seqcount_latch_t seq; 12 struct tk_read_base base[2]; 13}; 1/* 2 * Boot time initialization which allows local_clock() to be utilized 3 * during early boot when clocksources are not available. local_clock() 4 * returns nanoseconds already so no conversion is required, hence mult=1 5 * and shift=0. When the first proper clocksource is installed then 6 * the fast time keepers are updated with the correct values. 7 */ 8define FAST_TK_INIT \\ 9 { \\ 10 .clock = \u0026amp;dummy_clock, \\ 11 .mask = CLOCKSOURCE_MASK(64), \\ 12 .mult = 1, \\ 13 .shift = 0, \\ 14 } 15 16static struct tk_fast tk_fast_mono ____cacheline_aligned = { 17 .seq = SEQCNT_LATCH_ZERO(tk_fast_mono.seq), 18 .base[0] = FAST_TK_INIT, 19 .base[1] = FAST_TK_INIT, 20}; 21 22static struct tk_fast tk_fast_raw ____cacheline_aligned = { 23 .seq = SEQCNT_LATCH_ZERO(tk_fast_raw.seq), 24 .base[0] = FAST_TK_INIT, 25 .base[1] = FAST_TK_INIT, 26}; 可以对比一下，访问tkr_mono和tkr_raw时，用的是read_seqcount_begin和read_seqcount_retry，而访问tk_fast_mono和tk_fast_raw用的是raw_read_seqcount_latch和read_seqcount_latch_retry。\n具体可以看内核ktime_get_mono_fast_ns和ktime_get_raw_fast_ns等函数的解释。\n1 update_fast_timekeeper(\u0026amp;tk-\u0026gt;tkr_mono, \u0026amp;tk_fast_mono); 2 update_fast_timekeeper(\u0026amp;tk-\u0026gt;tkr_raw, \u0026amp;tk_fast_raw); 以tk_fast_mono为例，update_fast_timekeeper是把timekeeper的tkr_mono复制到\ntk_fast_mono的base数组，保存两份是为了保证在修改一个时，可以用另一个来获取正确的数值。\n4.3. shadow_timekeeper 如果action指定了TK_MIRROR，则将tk_core.timekeeper备份到shadow_timekeeper，shadow_timekeeper可以用于在resume后恢复timekeeper。这个动作需要在最后进行，以确保在下一次更新时不会用过时的数据重写timekeeper。\n最后再释放一下锁，这样timekeeping就初始化好了。\n在timer_probe时，会注册精度更高的clocksource，这样就可以获取各种时间。\n","date":"February 22, 2023","img":"https://kingdix10.github.io/covers/flowers_leaves_pattern_148777_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.1/time/timekeeping/","series":[{"title":"时间子系统","url":"/zh-cn/series/%E6%97%B6%E9%97%B4%E5%AD%90%E7%B3%BB%E7%BB%9F/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"内核驱动","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"},{"title":"linux-6.1","url":"/zh-cn/tags/linux-6.1/"}],"timestamp":1677024000,"title":"linux内核时间子系统（二）"},{"categories":[{"title":"内存管理","url":"/zh-cn/categories/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}],"content":" 1. kmalloc分配内存的大小 本文基于linux-5.15分析。\nkmalloc会根据申请的内存大小来决定来决定使用块分配器(slab/slub/slob)或页分配器进行内存分配。控制kmalloc分配行为的主要有如下三个宏。\nmacro desc KMALLOC_MAX_SIZE kmalloc可以分配的最大内存，超过此大小时返回NULL KMALLOC_MAX_CACHE_SIZE kmalloc使用slab分配器分配的最大内存，超过此大小后会通过伙伴系统分配页 KMALLOC_MIN_SIZE kmalloc可以分配的最小内存，小于此大小时，kmalloc内部会按此大小分配 1.1. KMALLOC_MAX_SIZE：kmalloc可以分配的最大内存 KMALLOC_MAX_SIZE与块分配器类型(slab/slub/slob)和页面大小以及MAX_ORDER有关，相关定义在include/linux/slab.h中。一般最大为2 ^ (MAX_ORDER + PAGE_SHIFT - 1)，也就是2 ^ (MAX_ORDER - 1)个页面，就是伙伴系统所管理的最大内存块。通常MAX_ORDER为11，页面大小为4K，相应的，kmalloc最大可以分配1024个页面，也就是4M。\n分配器类型 KMALLOC_MAX_SIZE slab 2 ^ (MAX_ORDER + PAGE_SHIFT - 1)，但不得超过32M(2^25) slub 2 ^ (MAX_ORDER + PAGE_SHIFT - 1) slob 2 ^ (MAX_ORDER + PAGE_SHIFT - 1) 另外，早期的slab是可以支持分配64M的，在5.13版本时，改为了32M，具体可以参考commit 588c7fa022d7b2361500ead5660d9a1a2ecd9b7d\n1.2. KMALLOC_MAX_CACHE_SIZE：kmalloc使用slab分配器分配的最大内存 当kmalloc申请的内存大小小于或等于KMALLOC_MAX_CACHE_SIZE时，使用块分配器(slab/slub/slob)进行分配。\n当kmalloc申请的内存大小超过KMALLOC_MAX_CACHE_SIZE时，使用页分配器（伙伴系统）进行分配。\n块分配器类型使用slab时，KMALLOC_MAX_CACHE_SIZE定义为KMALLOC_MAX_SIZE，kmalloc总是使用slab分配器。\n分配器类型 KMALLOC_MAX_CACHE_SIZE slab 2 ^ (MAX_ORDER + PAGE_SHIFT - 1)，最大限制为32M(2^25) slub 2 ^ (PAGE_SHIFT + 1)，2个页面大小 slob 2 ^ PAGE_SHIFT，1个页面大小 1.3. KMALLOC_MIN_SIZE：kmalloc可以分配的最小内存 KMALLOC_MIN_SIZE与ARCH_DMA_MINALIGN大小有关。\n1/* 2 * Some archs want to perform DMA into kmalloc caches and need a guaranteed 3 * alignment larger than the alignment of a 64-bit integer. 4 * Setting ARCH_KMALLOC_MINALIGN in arch headers allows that. 5 */ 6#if defined(ARCH_DMA_MINALIGN) \u0026amp;\u0026amp; ARCH_DMA_MINALIGN \u0026gt; 8 7#define ARCH_KMALLOC_MINALIGN ARCH_DMA_MINALIGN 8#define KMALLOC_MIN_SIZE ARCH_DMA_MINALIGN 9#define KMALLOC_SHIFT_LOW ilog2(ARCH_DMA_MINALIGN) 10#else 11#define ARCH_KMALLOC_MINALIGN __alignof__(unsigned long long) 12#endif 13 14 15#ifndef KMALLOC_MIN_SIZE 16#define KMALLOC_MIN_SIZE (1 \u0026lt;\u0026lt; KMALLOC_SHIFT_LOW) 17#endif 在没有定义ARCH_DMA_MINALIGN的情况下，KMALLOC_MIN_SIZE的默认值如下\n分配器类型 默认KMALLOC_MIN_SIZE slab 2 ^ 5 slub 2 ^ 3 slob 2 ^ 3 接下来看一下ARCH_DMA_MINALIGN，linux-5.15的arch目录下共24个目录，其中18个对ARCH_DMA_MINALIGN进行了定义，且很多都将ARCH_DMA_MINALIGN定义为L1 cache的大小，这样可以提高性能。\n1arch/arc/include/asm/cache.h:52:#define ARCH_DMA_MINALIGN SMP_CACHE_BYTES 2arch/arm/include/asm/cache.h:18:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 3arch/arm64/include/asm/cache.h:50:#define ARCH_DMA_MINALIGN (128) 4arch/csky/include/asm/cache.h:11:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 5arch/hexagon/include/asm/cache.h:15:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 6arch/m68k/include/asm/cache.h:12:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 7arch/microblaze/include/asm/page.h:34:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 8arch/mips/include/asm/mach-generic/kmalloc.h:10:#define ARCH_DMA_MINALIGN 128 9arch/mips/include/asm/mach-ip32/kmalloc.h:7:#define ARCH_DMA_MINALIGN 32 10arch/mips/include/asm/mach-ip32/kmalloc.h:9:#define ARCH_DMA_MINALIGN 128 11arch/mips/include/asm/mach-n64/kmalloc.h:6:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 12arch/mips/include/asm/mach-tx49xx/kmalloc.h:5:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 13arch/nds32/include/asm/cache.h:10:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 14arch/nios2/include/asm/cache.h:21:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 15arch/parisc/include/asm/cache.h:23:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 16arch/powerpc/include/asm/page_32.h:16:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 17arch/sh/include/asm/page.h:184:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 18arch/xtensa/include/asm/cache.h:32:#define ARCH_DMA_MINALIGN L1_CACHE_BYTES 1.4. 关于KMALLOC_MIN_SIZE的进一步说明 KMALLOC_MIN_SIZE的效果会跟块分配器的类型有关。\n1.4.1. slab/slub KMALLOC_MIN_SIZE必须是2的整数次幂，且不能超过256。具体可以看下边setup_kmalloc_cache_index_table。\n1/* 2 * Patch up the size_index table if we have strange large alignment 3 * requirements for the kmalloc array. This is only the case for 4 * MIPS it seems. The standard arches will not generate any code here. 5 * 6 * Largest permitted alignment is 256 bytes due to the way we 7 * handle the index determination for the smaller caches. 8 * 9 * Make sure that nothing crazy happens if someone starts tinkering 10 * around with ARCH_KMALLOC_MINALIGN 11 */ 12void __init setup_kmalloc_cache_index_table(void) 13{ 14 unsigned int i; 15 16 BUILD_BUG_ON(KMALLOC_MIN_SIZE \u0026gt; 256 || 17 (KMALLOC_MIN_SIZE \u0026amp; (KMALLOC_MIN_SIZE - 1))); 18 19 ... 1.4.2. slob slob分配器中，实际起作用的是SLAB_OBJ_MIN_SIZE，而SLAB_OBJ_MIN_SIZE被限制为最大16字节。\n1/* 2 * This restriction comes from byte sized index implementation. 3 * Page size is normally 2^12 bytes and, in this case, if we want to use 4 * byte sized index which can represent 2^8 entries, the size of the object 5 * should be equal or greater to 2^12 / 2^8 = 2^4 = 16. 6 * If minimum size of kmalloc is less than 16, we use it as minimum object 7 * size and give up to use byte sized index. 8 */ 9#define SLAB_OBJ_MIN_SIZE (KMALLOC_MIN_SIZE \u0026lt; 16 ? \\ 10 (KMALLOC_MIN_SIZE) : 16) 1.5.size为0时的处理 kmalloc允许传入值为0，此时kmalloc返回ZERO_SIZE_PTR。可以借用此值来判断是内存不足，还是传入参数为0。\n如下代码可以在kmalloc和__kmalloc(slab/slub/slob)的路径中找到。\n1 if (!size) 2 return ZERO_SIZE_PTR; 1/* 2 * ZERO_SIZE_PTR will be returned for zero sized kmalloc requests. 3 * 4 * Dereferencing ZERO_SIZE_PTR will lead to a distinct access fault. 5 * 6 * ZERO_SIZE_PTR can be passed to kfree though in the same way that NULL can. 7 * Both make kfree a no-op. 8 */ 9#define ZERO_SIZE_PTR ((void *)16) 10 11#define ZERO_OR_NULL_PTR(x) ((unsigned long)(x) \u0026lt;= \\ 12 (unsigned long)ZERO_SIZE_PTR) 将ZERO_SIZE_PTR传给kfree也是可以的。\n1void kfree(const void *x) 2{ 3 ... 4 if (unlikely(ZERO_OR_NULL_PTR(x))) 5 return; 6 ... 7} 2. kmalloc内存分配大小计算 kmalloc只能分配几个固定大小的内存，申请值不在这些固定值之内时，会按向上对齐的原则，分配最接近申请值的内存块。\nkmalloc_index定义为#define kmalloc_index(s) __kmalloc_index(s, true)。\nkmalloc_index和__kmalloc_index的定义在include/linux/slab.h。\n1/* 2 * Figure out which kmalloc slab an allocation of a certain size 3 * belongs to. 4 * 0 = zero alloc 5 * 1 = 65 .. 96 bytes 6 * 2 = 129 .. 192 bytes 7 * n = 2^(n-1)+1 .. 2^n 8 * 9 * Note: __kmalloc_index() is compile-time optimized, and not runtime optimized; 10 * typical usage is via kmalloc_index() and therefore evaluated at compile-time. 11 * Callers where !size_is_constant should only be test modules, where runtime 12 * overheads of __kmalloc_index() can be tolerated. Also see kmalloc_slab(). 13 */ 14static __always_inline unsigned int __kmalloc_index(size_t size, 15 bool size_is_constant) 16{ 17 if (!size) 18 return 0; 19 20 if (size \u0026lt;= KMALLOC_MIN_SIZE) 21 return KMALLOC_SHIFT_LOW; 22 23 if (KMALLOC_MIN_SIZE \u0026lt;= 32 \u0026amp;\u0026amp; size \u0026gt; 64 \u0026amp;\u0026amp; size \u0026lt;= 96) 24 return 1; 25 if (KMALLOC_MIN_SIZE \u0026lt;= 64 \u0026amp;\u0026amp; size \u0026gt; 128 \u0026amp;\u0026amp; size \u0026lt;= 192) 26 return 2; 27 if (size \u0026lt;= 8) return 3; 28 if (size \u0026lt;= 16) return 4; 29 if (size \u0026lt;= 32) return 5; 30 if (size \u0026lt;= 64) return 6; 31 if (size \u0026lt;= 128) return 7; 32 if (size \u0026lt;= 256) return 8; 33 if (size \u0026lt;= 512) return 9; 34 if (size \u0026lt;= 1024) return 10; 35 if (size \u0026lt;= 2 * 1024) return 11; 36 if (size \u0026lt;= 4 * 1024) return 12; 37 if (size \u0026lt;= 8 * 1024) return 13; 38 if (size \u0026lt;= 16 * 1024) return 14; 39 if (size \u0026lt;= 32 * 1024) return 15; 40 if (size \u0026lt;= 64 * 1024) return 16; 41 if (size \u0026lt;= 128 * 1024) return 17; 42 if (size \u0026lt;= 256 * 1024) return 18; 43 if (size \u0026lt;= 512 * 1024) return 19; 44 if (size \u0026lt;= 1024 * 1024) return 20; 45 if (size \u0026lt;= 2 * 1024 * 1024) return 21; 46 if (size \u0026lt;= 4 * 1024 * 1024) return 22; 47 if (size \u0026lt;= 8 * 1024 * 1024) return 23; 48 if (size \u0026lt;= 16 * 1024 * 1024) return 24; 49 if (size \u0026lt;= 32 * 1024 * 1024) return 25; 50 51 if ((IS_ENABLED(CONFIG_CC_IS_GCC) || CONFIG_CLANG_VERSION \u0026gt;= 110000) 52 \u0026amp;\u0026amp; !IS_ENABLED(CONFIG_PROFILE_ALL_BRANCHES) \u0026amp;\u0026amp; size_is_constant) 53 BUILD_BUG_ON_MSG(1, \u0026#34;unexpected size in kmalloc_index()\u0026#34;); 54 else 55 BUG(); 56 57 /* Will never be reached. Needed because the compiler may complain */ 58 return -1; 59} 可以看到kmalloc_index对(64, 96]和(128, 192]这两个区间做了特殊处理。 96和192不是2的整数次幂，但内核中很多地方需要申请与96或192字节大小相近的内存，内核舍弃了2字节(index=1)和4字节(index=2)的cache。将这两个index留给了96和192，内核会根据KMALLOC_MIN_SIZE的大小来决定是否创建对应的cache，以此来减少内存浪费。\nkmalloc_index和mm/slab_common.c中的kmalloc_info[]是对应的，kmalloc_index返回的就是所需大小在kmalloc_info[]数组中对应的索引。\n1#define INIT_KMALLOC_INFO(__size, __short_size) \\ 2{ \\ 3 .name[KMALLOC_NORMAL] = \u0026#34;kmalloc-\u0026#34; #__short_size, \\ 4 .name[KMALLOC_RECLAIM] = \u0026#34;kmalloc-rcl-\u0026#34; #__short_size, \\ 5 KMALLOC_CGROUP_NAME(__short_size) \\ 6 KMALLOC_DMA_NAME(__short_size) \\ 7 .size = __size, \\ 8} 9 10/* 11 * kmalloc_info[] is to make slub_debug=,kmalloc-xx option work at boot time. 12 * kmalloc_index() supports up to 2^25=32MB, so the final entry of the table is 13 * kmalloc-32M. 14 */ 15const struct kmalloc_info_struct kmalloc_info[] __initconst = { 16 INIT_KMALLOC_INFO(0, 0), 17 INIT_KMALLOC_INFO(96, 96), 18 INIT_KMALLOC_INFO(192, 192), 19 INIT_KMALLOC_INFO(8, 8), 20 INIT_KMALLOC_INFO(16, 16), 21 INIT_KMALLOC_INFO(32, 32), 22 INIT_KMALLOC_INFO(64, 64), 23 INIT_KMALLOC_INFO(128, 128), 24 INIT_KMALLOC_INFO(256, 256), 25 INIT_KMALLOC_INFO(512, 512), 26 INIT_KMALLOC_INFO(1024, 1k), 27 INIT_KMALLOC_INFO(2048, 2k), 28 INIT_KMALLOC_INFO(4096, 4k), 29 INIT_KMALLOC_INFO(8192, 8k), 30 INIT_KMALLOC_INFO(16384, 16k), 31 INIT_KMALLOC_INFO(32768, 32k), 32 INIT_KMALLOC_INFO(65536, 64k), 33 INIT_KMALLOC_INFO(131072, 128k), 34 INIT_KMALLOC_INFO(262144, 256k), 35 INIT_KMALLOC_INFO(524288, 512k), 36 INIT_KMALLOC_INFO(1048576, 1M), 37 INIT_KMALLOC_INFO(2097152, 2M), 38 INIT_KMALLOC_INFO(4194304, 4M), 39 INIT_KMALLOC_INFO(8388608, 8M), 40 INIT_KMALLOC_INFO(16777216, 16M), 41 INIT_KMALLOC_INFO(33554432, 32M) 42}; 内核按按KMALLOC_MIN_SIZE的倍数创建cache， 当KMALLOC_MIN_SIZE \u0026lt;= 32时，创建大小为96和192字节的cache。 当KMALLOC_MIN_SIZE \u0026lt;= 64时，创建大小为192字节的cache。 当KMALLOC_MIN_SIZE \u0026gt; 64时，不会额外创建96和192字节的cache。\n1/* 2 * Create the kmalloc array. Some of the regular kmalloc arrays 3 * may already have been created because they were needed to 4 * enable allocations for slab creation. 5 */ 6void __init create_kmalloc_caches(slab_flags_t flags) 7{ 8 int i; 9 enum kmalloc_cache_type type; 10 11 /* 12 * Including KMALLOC_CGROUP if CONFIG_MEMCG_KMEM defined 13 */ 14 for (type = KMALLOC_NORMAL; type \u0026lt;= KMALLOC_RECLAIM; type++) { 15 for (i = KMALLOC_SHIFT_LOW; i \u0026lt;= KMALLOC_SHIFT_HIGH; i++) { 16 if (!kmalloc_caches[type][i]) 17 new_kmalloc_cache(i, type, flags); 18 19 /* 20 * Caches that are not of the two-to-the-power-of size. 21 * These have to be created immediately after the 22 * earlier power of two caches 23 */ 24 if (KMALLOC_MIN_SIZE \u0026lt;= 32 \u0026amp;\u0026amp; i == 6 \u0026amp;\u0026amp; 25 !kmalloc_caches[type][1]) 26 new_kmalloc_cache(1, type, flags); 27 if (KMALLOC_MIN_SIZE \u0026lt;= 64 \u0026amp;\u0026amp; i == 7 \u0026amp;\u0026amp; 28 !kmalloc_caches[type][2]) 29 new_kmalloc_cache(2, type, flags); 30 } 31 } 32 ... 2.1. __kmalloc_index编译时优化 对于slab和slub，__kmalloc_index可以实现编译时优化。这种优化体现在kmalloc和kmalloc_node，当传入参数size在编译时为定值时，会在编译时优化分配路径。\nslab/slub/slob分别实现了各自的__kmalloc和__kmalloc_node，对于slab或size编译时不为定值时，kmalloc或kmalloc_node会分别走到分配器对应的__kmalloc或__kmalloc_node。\n1static __always_inline void *kmalloc(size_t size, gfp_t flags) 2{ 3 if (__builtin_constant_p(size)) { 4#ifndef CONFIG_SLOB 5 unsigned int index; 6#endif 7 if (size \u0026gt; KMALLOC_MAX_CACHE_SIZE) 8 return kmalloc_large(size, flags); 9#ifndef CONFIG_SLOB 10 index = kmalloc_index(size); 11 12 if (!index) 13 return ZERO_SIZE_PTR; 14 15 return kmem_cache_alloc_trace( 16 kmalloc_caches[kmalloc_type(flags)][index], 17 flags, size); 18#endif 19 } 20 return __kmalloc(size, flags); 21} 22 23static __always_inline void *kmalloc_node(size_t size, gfp_t flags, int node) 24{ 25#ifndef CONFIG_SLOB 26 if (__builtin_constant_p(size) \u0026amp;\u0026amp; 27 size \u0026lt;= KMALLOC_MAX_CACHE_SIZE) { 28 unsigned int i = kmalloc_index(size); 29 30 if (!i) 31 return ZERO_SIZE_PTR; 32 33 return kmem_cache_alloc_node_trace( 34 kmalloc_caches[kmalloc_type(flags)][i], 35 flags, node, size); 36 } 37#endif 38 return __kmalloc_node(size, flags, node); 39} 2.2. kmalloc的运行时路径 前边KMALLOC_MAX_SIZE、KMALLOC_MAX_CACHE_SIZE、KMALLOC_MIN_SIZE三个宏直接起作用主要是在编译时，运行时的大小计算不一定会直接使用，但其实在运行时，分配内存的限制也会与这三个宏保持一致。\n先说slab，__do_kmalloc中会直接判断申请内存大小是否超过KMALLOC_MAX_CACHE_SIZE，如果是，则直接返回NULL。注意，对于slab，KMALLOC_MAX_CACHE_SIZE等于KMALLOC_MAX_SIZE。\n再看slub和slob，在申请大块内存时，最终都会调到alloc_pages，这个是通过伙伴系统来分配页，最大为2 ^ (MAX_ORDER + PAGE_SHIFT - 1)字节，也就是2 ^ (MAX_ORDER - 1)个页面，与KMALLOC_MAX_SIZE一致。\nKMALLOC_MIN_SIZE的情况相对复杂，暂不详述。\n","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/wall_brick_neon_150470_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/mm/kmalloc/","series":[{"title":"内存管理","url":"/zh-cn/series/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"linux-5.15","url":"/zh-cn/tags/linux-5.15/"},{"title":"内存管理","url":"/zh-cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}],"timestamp":1672358400,"title":"kmalloc分配内存的大小"},{"categories":[{"title":"linux命令","url":"/zh-cn/categories/linux%E5%91%BD%E4%BB%A4/"}],"content":" 1. PS1示例 先说一下bash版本\n1$ bash --version 2GNU bash, version 5.1.4(1)-release (x86_64-pc-linux-gnu) 3Copyright (C) 2020 Free Software Foundation, Inc. 4License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; 5 6This is free software; you are free to change and redistribute it. 7There is NO WARRANTY, to the extent permitted by law. bash中的PS1是主提示符变量，也是默认提示符变量。另外需要注意，PS1对bash起作用，对sh是无效的。可以通过echo $SHELL确认当前用户使用的shell是否为bash。除了PS1外，还有PS2、PS3、PS4几个环境变量用来提示一些其他信息。\n下面看几个示例\n1export PS1=\u0026#39;\\e[1;32m\\][\\e[1m\\]\\e[3;35m\\]\\u\\e[0;34m\\]@\\e[1;33m\\]\\H\\e[1;32m\\]][\\e[1;34m\\]\\t\\e[1;32m\\]] \\e[1m\\]\\e[3;30m\\]\\w\\e[0m\\]\\n\\$ \u0026#39; 上边示例的闪烁版本，用户名和主机会闪烁显示\n1export PS1=\u0026#39;\\e[1;32m\\][\\e[1m\\]\\e[5m\\]\\e[3;35m\\]\\u\\e[0m\\]\\e[5;34m\\]@\\e[1;33m\\]\\H\\e[0m\\]\\e[1;32m\\]][\\e[1;34m\\]\\t\\e[1;32m\\]] \\e[1;30m\\]\\e[3;30m\\]\\w\\e[0m\\]\\n\\$ \u0026#39; 参考最好看的Bash美化——打造ParrotOS风格的Bash改的版本\n1export PS1=\u0026#39;\\e[0;31m\\]\\342\\224\\214\\342\\224\\200\\e[1;32m\\][\\e[1m\\]\\e[3;35m\\]\\u\\e[0m\\]@\\e[1;33m\\]\\H\\e[1;32m\\]][\\e[1;34m\\]\\t\\e[1;32m\\]] \\e[1;30m\\]\\e[3;30m\\]$PWD\\e[0m\\]\\n\\e[0;31m\\]\\342\\224\\224\\342\\224\\200\\342\\224\\200\\342\\225\\274 \\e[0m\\]\\$ \u0026#39; 2. 颜色设置 2.1. 颜色设置格式 1\\e[A;F;Bm文本 2\\e[A;F;Bm\\]文本 3\\[\\e[A;F;Bm\\]文本 \\e[A;F;Bm控制文本格式，\\[和\\]分别表示不可见字符的起始和结束，所以三种格式效果是一样的。个人比较喜欢用\\e[A;F;Bm\\]。\n需要注意的是，格式设置后，会对后边所有文本起作用，包括我们在终端输入的命令。而且A/F/B是分别起作用的，只要不被重置，效果会一直延续，后边会详细解释。\n如果想取消文本效果，可以在文本前添加如下格式。当然下边格式之后也可以加文本，只是文本显示为默认样式。\n1\\e[0m 2\\e[0m\\] 3\\[\\e[0m\\] 2.2. 颜色格式说明 这里说一下，格式中A/F/B的位置是任意的，bash是依靠值来对格式进行解析。也就是说\\e[A;F;Bm\\]、\\e[F;B;Am\\]、\\e[F;B;Am\\]等效果都是一样的。而且因为A/F/B的位置是任意的，为了书写简便，就可以省略A/F/B中的1个或2个参数。\n下面对格式进行详细说明 \\e表示Esc，也可以替换为\\033\nA表示字体样式，其中数字可以使用多位数，如03与3效果相同\n10 OFF，默认样式 21 高亮加粗显示 32 变暗 43 斜体 54 显示下划线 65 闪烁显示 77 反色显示 88 颜色不可见 F表示字体颜色，B表示背景颜色\n1F B 颜色 230 40 黑色 331 41 红色 432 42 绿色 533 43 黄色 634 44 蓝色 735 45 紫红色 836 46 青蓝色 937 47 白色 2.3. 格式组合 字体样式A只能控制一种格式，如果想要加粗斜体、红字黄底该怎么办呢？\n1\\e[1;31;43m\\]\\e[3m\\]文本 2\\e[3;31;43m\\]\\e[1m\\]文本 3\\e[1;31m\\]\\e[3;43m\\]文本 下面来详细分解下，关于\\u、\\H等变量的说明见后边bash提示符中的变量\n1export PS1=\u0026#39;\\e[1;32m\\][\\e[1m\\]\\e[3;35m\\]\\u\\e[0;34m\\]@\\e[1;33m\\]\\H\\e[1;32m\\]][\\e[1;34m\\]\\t\\e[1;32m\\]] \\e[1m\\]\\e[3;30m\\]\\w\\e[0m\\]\\n\\$ \u0026#39; 1\\e[1;32m\\][ 加粗绿色显示[ 2\\e[1m\\]\\e[3;35m\\]\\u 加粗斜体紫红色显示用户名 3\\e[0;34m\\]@ 默认样式蓝色显示@ 4\\e[1;33m\\]\\H 加粗黄色显示主机名 5\\e[1;32m\\]][ 加粗绿色显示][ 6\\e[1;34m\\]\\t 加粗蓝色显示时间 7\\e[1;32m\\]] 加粗绿色显示]和空格 8\\e[1m\\]\\e[3;30m\\]\\w 加粗斜体黑色显示工作路径 9\\e[0m\\]\\n\\$ 清除所有格式，换行显示提示符，注意提示符后有空格 前边提到A/F/B起作用，以上边用户名显示举例来说 如果把\\e[3;35m\\]\\u中的紫色显示去掉，用户名会继续显示绿色。\n1\\e[1;32m\\][\\e[1;32m\\][\\e[1m\\]\\e[3;35m\\]\\u 2# 去掉紫色部分 3\\e[1;32m\\][\\e[1;32m\\][\\e[1m\\]\\e[3m\\]\\u 3. bash提示符中的变量 官方链接：Controlling the Prompt (Bash Reference Manual)\n1\\a ASCII响铃字符(07) 2\\d 日期，格式为\u0026#34;周 月 日\u0026#34; 3\\D{format} 参数format被传递给strftime(3)来构造自定格式的时间并入提示符中； 4 该参数为空时根据本地化设置自动生成格式。 5\\e ASCII转义字符(ESC)同\\033 6\\h 简略主机名，在第一个点号前的内容 7\\H 完整主机名 8\\j shell当前管理的任务数 9\\l shell终端设备的基本名称 10\\n 换行 11\\r 回车，到当前行的起始位置 12\\s shell的名称，$0的基本名称（最后一个斜杠后面的部分） 13\\t 当前时间（24小时） HH:MM:SS 14\\T 当前时间（12小时） HH:MM:SS 15\\@ 当前时间（12小时） am/pm 16\\A 当前时间（24小时） HH:MM 17\\u 当前用户名称 18\\v bash版本(如\u0026#34;2.00\u0026#34;) 19\\V bash版本+补丁号(如\u0026#34;2.00.0\u0026#34;) 20\\w 当前工作目录，主目录会显示为~ 21\\W 当前工作目录的基本名称，只会列出最后一个目录，主目录会显示为~ 22\\! 该命令在历史文件中的位置 23\\# 该命令在当前shell中执行的序列位置 24\\$ 提示符，root用户为#，普通用户为$ 25\\nnn 八进制数ASCII，用于显示一些特殊字符 26\\\\ 反斜杠 27\\[ 非打印字符起始，可以用来将终端控制序列嵌入到提示符中 28\\] 非打印字符起始结束 3.1. 其他扩展 除了bash提供的变量之外，还可以使用其他的环境变量，如PWD等，也可以使用一些命令表达式。\n比如可以把\\w换乘${PWD}或$(pwd -P)。\n再比如添加$([[ $? != 0 ]] \u0026amp;\u0026amp; echo -ne \u0026quot;\\e[31mFAIL\\e[0m\u0026quot; || echo -ne \u0026quot;\\e[34mOK\\e[0m\u0026quot;)，显示上一条命令的执行结果\n1export PS1=\u0026#39;\\e[1;32m\\][\\e[1m\\]\\e[3;35m\\]\\u\\e[0;34m\\]@\\e[1;33m\\]\\H\\e[1;32m\\]][\\e[1;34m\\]\\t\\e[1;32m\\]][$([[ $? != 0 ]] \u0026amp;\u0026amp; echo -ne \u0026#34;\\e[31mFAIL\\e[0m\u0026#34; || echo -ne \u0026#34;\\e[34mOK\\e[0m\u0026#34;)\\e[1;32m\\]] \\e[1m\\]\\e[3;30m\\]\\w\\e[0m\\]\\n\\$ \u0026#39; 4. 参考 最好看的Bash美化——打造ParrotOS风格的Bash\nControlling the Prompt (Bash Reference Manual)\n","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/keyboard_laptop_gradient_203739_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/linux/shell/bash_decorate/","series":[{"title":"linux命令","url":"/zh-cn/series/linux%E5%91%BD%E4%BB%A4/"}],"smallImg":"","tags":[{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"},{"title":"Bash","url":"/zh-cn/tags/bash/"}],"timestamp":1672358400,"title":"Linux Bash终端美化"},{"categories":[{"title":"内核基础","url":"/zh-cn/categories/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"},{"title":"内核调试","url":"/zh-cn/categories/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"}],"content":" 1. 说明 根据内核文档整理而成，具体格式含义可查看内核文档，或点击如何获得正确的printk格式占位符(v6.6)或如何获得正确的printk格式占位符(latest)查看。 linux-6.6相关内核文档路径如下:\nDocumentation/core-api/printk-formats.rst Documentation/translations/zh_CN/core-api/printk-formats.rst\n2. 整数类型 内核的printk不支持%n，也不支持浮点格式(%e / %f / %g / %a)。在printk中使用任何不支持的占位符或长度限定符都会导致一个WARN并且终止vsnprintf()执行。注意，sizeof()返回类型为size_t。\ntype format(DEC) format(HEX) char / short int / int %d %x unsigned char / unsigned short int / unsigned int %u %x long %ld %lx unsigned long %lu %lx long long %lld %llx unsigned long long %llu %llx s8 / s16 / s32 %d %x u8 / u16 / u32 %u %x s64 %lld %llx u64 %llu %llx size_t %zu %zx ssize_t %zd %zx 如果type的大小依赖于配置选项 (例如sector_t, blkcnt_t) 或其大小依赖于架构(例如tcflag_t)，则使用其可能的最大类型的格式占位符并显式强制转换为它。例如:\n1printk(\u0026#34;test: sector number/total blocks: %llu/%llu\\n\u0026#34;, 2 (unsigned long long)sector, (unsigned long long)blockcount); 3. 指针类型 一个原始指针值可以用%p打印，它将在打印前对地址进行哈希处理。内核也支持扩展占位符来打印不同类型的指针。\ntype format 普通指针 %p 错误指针 %pe 符号/函数指针 %ps / %pS[Rb] / %pB[b] 来自BPF / tracing追踪的探查指针 %p[ku]s 内核指针 %pK 未经修改的地址 %px 指针差异 %t[dx] 结构体资源（Resources） %p[rR] 物理地址类型 phys_addr_t %pa[p] DMA地址类型dma_addr_t %pad 原始缓冲区为转义字符串 %*pE[achnops] 原始缓冲区为十六进制字符串 %*ph[CDN] MAC/FDDI地址 %pM[RF] / % pm[R] IPv4地址 %p[Ii]4[hnbl] IPv6 地址 %pi6[c] / %pI6[c] IPv4/IPv6地址(generic, with port, flowinfo, scope) %p[Ii]S[pfschnbl] UUID/GUID地址 %pU[BbLl] 目录项（dentry）的名称 %p[Dd]{,2,3,4} 块设备（block_device）名称 %pg va_format结构体 %pV 设备树节点 %pOF[fnpPcCF] Fwnode handles %pfw[fP] 时间和日期 %pt[RT][dt][r][s] clk结构体 %pC[n] 位图及其衍生物，如cpumask和nodemask %*pb[l] 标志位字段，如页标志、gfp_flags %pG[pgv] 网络设备特性 %pNF V4L2和DRM FourCC代码(像素格式) %p4cc 一些扩展占位符会打印给定地址上的数据，而不是打印地址本身。在这种情况下，以下错误消息可能会被打印出来，而不是无法访问的消息\n打印内容 描述 (null) data on plain NULL address (efault) data on invalid address (einval) invalid data on a valid address 4. 参考资料 How to get printk format specifiers right(v6.6) 如何获得正确的printk格式占位符(v6.6) How to get printk format specifiers right(latest) 如何获得正确的printk格式占位符(latest) ","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/hologram_scheme_scifi_139294_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/debug/printk-formats/","series":[{"title":"内核基础","url":"/zh-cn/series/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"}],"smallImg":"","tags":[{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"},{"title":"内核调试","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"}],"timestamp":1672358400,"title":"Linux printk日志输出格式控制"},{"categories":[{"title":"thermal子系统","url":"/zh-cn/categories/thermal%E5%AD%90%E7%B3%BB%E7%BB%9F/"}],"content":" 1. thermal简介 内核版本：linux-6.1\nthermal子系统主要用来监测和调节CPU、GPU等芯片或设备的温度。三个主要结构体的关系：从thermal_zone_device获取温度后，根据governor指定的策略，来控制thermal_cooling_device进行温度调节。\n结构体 描述 举例 struct thermal_zone_device 对温度调节域的抽象，包含配置信息和传感器信息 NTC、Temperature Sensor ADC(TSADC) struct thermal_cooling_device 用于冷却的设备 CPU、GPU、风扇 struct thermal_governor 温度调节策略 power_allocator、user_space、step_wise、bang_bang、fair_share CPU和GPU可以通过调压调频来调节功耗，也可以作为cooling device。\n2. thermal子系统初始化 thermal_init实现的工作比较简单\n如果使能了CONFIG_THERMAL_NETLINK，就注册thermal_gnl_family。 注册governor，并设置def_governor。 注册thermal_class。 注册thermal_pm_nb通知链。 2.1. thermal_governor注册 governor由THERMAL_GOVERNOR_DECLARE静态声明。 在thermal_init中，thermal_register_governors会注册thermal_governor，将governor添加到thermal_governor_list链表，并根据DEFAULT_THERMAL_GOVERNOR，设定def_governor。\n1drivers/thermal/gov_bang_bang.c 2113:THERMAL_GOVERNOR_DECLARE(thermal_gov_bang_bang); 3drivers/thermal/gov_fair_share.c 4122:THERMAL_GOVERNOR_DECLARE(thermal_gov_fair_share); 5drivers/thermal/gov_power_allocator.c 6744:THERMAL_GOVERNOR_DECLARE(thermal_gov_power_allocator); 7drivers/thermal/gov_step_wise.c 8177:THERMAL_GOVERNOR_DECLARE(thermal_gov_step_wise); 9drivers/thermal/gov_user_space.c 1056:THERMAL_GOVERNOR_DECLARE(thermal_gov_user_space); thermal_register_governor在注册一个新的governor时，还会遍历thermal_tz_list链表，尝试绑定thermal zone。但是thermal_init的调用时机比较早，通常来说thermal_tz_list链表是空的。\n3. thermal_zone_device thermal_zone_device是对温度调节区域的一个抽象，这个区域可以是CPU，也可以是GPU或其他设备。thermal_zone_device会对应一个物理传感器或多个物理传感器，也可以对应传感器的一个通道或多个通道。 thermal_zone_device包含一些配置信息，以及温度读取和调节的操作函数。thermal_zone_device配置信息记录在dtb中的 thermal-zones节点。\n3.1. thermal_zone_device注册 thermal_zone_device_register_with_trips是注册thermal_zone_device的核心函数。\n1/** 2 * thermal_zone_device_register_with_trips() - register a new thermal zone device 3 * @type: the thermal zone device type 4 * @trips: a pointer to an array of thermal trips 5 * @num_trips: the number of trip points the thermal zone support 6 * @mask: a bit string indicating the writeablility of trip points 7 * @devdata: private device data 8 * @ops: standard thermal zone device callbacks 9 * @tzp: thermal zone platform parameters 10 * @passive_delay: number of milliseconds to wait between polls when 11 * performing passive cooling 12 * @polling_delay: number of milliseconds to wait between polls when checking 13 * whether trip points have been crossed (0 for interrupt 14 * driven systems) 15 * 16 * This interface function adds a new thermal zone device (sensor) to 17 * /sys/class/thermal folder as thermal_zone[0-*]. It tries to bind all the 18 * thermal cooling devices registered at the same time. 19 * thermal_zone_device_unregister() must be called when the device is no 20 * longer needed. The passive cooling depends on the .get_trend() return value. 21 * 22 * Return: a pointer to the created struct thermal_zone_device or an 23 * in case of error, an ERR_PTR. Caller must check return value with 24 * IS_ERR*() helpers. 25 */ thermal_zone_device_register_with_trips主要流程如下：\nkzalloc申请结构体\n申请ida\n设置设备名\n变量赋值\n1tz-\u0026gt;ops = ops; 2tz-\u0026gt;tzp = tzp; 3tz-\u0026gt;device.class = \u0026amp;thermal_class; 4tz-\u0026gt;devdata = devdata; 5tz-\u0026gt;trips = trips; 6tz-\u0026gt;num_trips = num_trips; 指定默认的critical回调为thermal_zone_device_critical\n记录passive_delay和polling_delay\nthermal_zone_create_device_groups在sysfs创建目录和文件\ndevice_register注册设备\n查找governor并绑定\n判断是否需要在sysfs添加hwmon相关文件，如果需要，则调用thermal_add_hwmon_sysfs\n将设备添加到thermal_tz_list\n调用bind_bz遍历thermal_cdev_list，绑定匹配的cooling device\n初始化poll_queue为thermal_zone_device_check\nthermal_zone_device_init做一些变量初始化\n根据条件判断是否需要调用thermal_zone_device_update来进行温度调节\nthermal_notify_tz_create使用netlink通知用户态\n3.2. thermal_of_zone_register 在linux-6.0之前，thermal_init中会调用of_parse_thermal_zones来将dts中所有thermal_zone添加到列表。在probe sensor时，再调用thermal_zone_of_sensor_register来匹配zone下的thermal-sensor节点，并从列表中找到对应的zone。\n在6.0版本之后，则是各个sensor的设备驱动在probe时，调用devm_thermal_of_zone_register或thermal_of_zone_register来判断是否有使用该sensor的zone，再创建该温度域。比如：\n1 tsadc: tsadc@ff260000 { 2 compatible = \u0026#34;rockchip,rk3399-tsadc\u0026#34;; 3 ... 4 }; 5 ... 6 thermal_zones: thermal-zones { 7 cpu_thermal: cpu-thermal { 8 polling-delay-passive = \u0026lt;100\u0026gt;; 9 polling-delay = \u0026lt;1000\u0026gt;; 10 11 thermal-sensors = \u0026lt;\u0026amp;tsadc 0\u0026gt;; 12 ... thermal_of_zone_register需要传入sensor和ops参数，其主要流程如下：\n复制ops为of_ops\nof_thermal_zone_find查找thermal-zones节点，遍历所有的zone，根据该zone下thermal-sensors节点，判断该zone是否使用了sensor，如果是，则返回该zone对应的device_node\nthermal_of_trips_init从zone中找到trips节点（包括temperature和hysteresis），填充到struct thermal_trip数组\nthermal_of_monitor_init解析polling-delay-passive和polling-delay\nthermal_of_parameters_init解析sustainable-power和coefficients节点，填充到struct thermal_zone_params\n填充默认回调\n1of_ops-\u0026gt;get_trip_type = of_ops-\u0026gt;get_trip_type ? : of_thermal_get_trip_type; 2of_ops-\u0026gt;get_trip_temp = of_ops-\u0026gt;get_trip_temp ? : of_thermal_get_trip_temp; 3of_ops-\u0026gt;get_trip_hyst = of_ops-\u0026gt;get_trip_hyst ? : of_thermal_get_trip_hyst; 4of_ops-\u0026gt;set_trip_hyst = of_ops-\u0026gt;set_trip_hyst ? : of_thermal_set_trip_hyst; 5of_ops-\u0026gt;get_crit_temp = of_ops-\u0026gt;get_crit_temp ? : of_thermal_get_crit_temp; 6of_ops-\u0026gt;bind = thermal_of_bind; 7of_ops-\u0026gt;unbind = thermal_of_unbind; thermal_zone_device_register_with_trips\nthermal_zone_device_enable\n3.3. thermal-sensor注册 thermal_zone_device.devdata记录了sensor相关的信息。通过各个设备的驱动中调用thermal_zone_of_sensor_register及其相关函数进行注册。\n4. cooling device register 核心函数是__thermal_cooling_device_register\n1/** 2 * __thermal_cooling_device_register() - register a new thermal cooling device 3 * @np: a pointer to a device tree node. 4 * @type: the thermal cooling device type. 5 * @devdata: device private data. 6 * @ops: standard thermal cooling devices callbacks. 7 * 8 * This interface function adds a new thermal cooling device (fan/processor/...) 9 * to /sys/class/thermal/ folder as cooling_device[0-*]. It tries to bind itself 10 * to all the thermal zone devices registered at the same time. 11 * It also gives the opportunity to link the cooling device to a device tree 12 * node, so that it can be bound to a thermal zone created out of device tree. 13 * 14 * Return: a pointer to the created struct thermal_cooling_device or an 15 * ERR_PTR. Caller must check return value with IS_ERR*() helpers. 16 */ 主要流程\n从thermal_cdev_ida申请ida 设置名字 初始化变量 thermal_cooling_device_setup_sysfs配置sysfs相关参数 device_register注册设备 添加cooling device到thermal_cdev_list bind_cdev遍历thermal_tz_list，查看是否有使用此cooling device的zone 根据条件，判断是否需要针对匹配上的zone调用thermal_zone_device_update来进行温度调节 5. tz和cdev的绑定 thermal_zone_bind_cooling_device负责绑定thermal_zone_device和thermal_cooling_deivce，两者之间的绑定是通过thermal_instance来实现的。\n绑定部分的核心代码如下：\n1\tmutex_lock(\u0026amp;tz-\u0026gt;lock); 2\tmutex_lock(\u0026amp;cdev-\u0026gt;lock); 3\tlist_for_each_entry(pos, \u0026amp;tz-\u0026gt;thermal_instances, tz_node) 4\tif (pos-\u0026gt;tz == tz \u0026amp;\u0026amp; pos-\u0026gt;trip == trip \u0026amp;\u0026amp; pos-\u0026gt;cdev == cdev) { 5\tresult = -EEXIST; 6\tbreak; 7\t} 8\tif (!result) { 9\tlist_add_tail(\u0026amp;dev-\u0026gt;tz_node, \u0026amp;tz-\u0026gt;thermal_instances); 10\tlist_add_tail(\u0026amp;dev-\u0026gt;cdev_node, \u0026amp;cdev-\u0026gt;thermal_instances); 11\tatomic_set(\u0026amp;tz-\u0026gt;need_update, 1); 12\t} 13\tmutex_unlock(\u0026amp;cdev-\u0026gt;lock); 14\tmutex_unlock(\u0026amp;tz-\u0026gt;lock); 6. 温度调节 6.1. 温度调节的时机 在注册设备时，thermal_zone_device_register_with_trips中将 tz-\u0026gt;poll_queue的工作函数设置为 thermal_zone_device_check。\nupdate_temperature调用sensor的get_temp函数读取温度，并保存到 thermal_zone_device.temperature，thermal_zone_device.temperature的值记录到 thermal_zone_device.last_temperature。 __thermal_zone_set_trips判断温度变换趋势，并更新当前的温度区间，用来决定使用那种温度调节策略 遍历温度区间，调用handle_thermal_trip来做需要执行的动作，比如调节风扇、重启。 monitor_thermal_zone根据当前温度区间，调用thermal_zone_device_set_polling来调节轮询时间；如果设备被disable，则不再执行轮询。轮询工作由system_freezable_power_efficient_wq来负责。 如果sensor有中断信号给到CPU，当温度超过设置的阈值时，会上报中断，通常会在中断服务函数中调用thermal_zone_device_update，来达到温度实时调节的目的。 6.2. 核心函数：thermal_zone_device_update thermal_zone_device_update是温度监测和调节的核心函数。\n1void thermal_zone_device_update(struct thermal_zone_device *tz, 2 enum thermal_notify_event event) 3{ 4 int count; 5 6 if (atomic_read(\u0026amp;in_suspend)) 7 return; 8 9 if (WARN_ONCE(!tz-\u0026gt;ops-\u0026gt;get_temp, \u0026#34;\u0026#39;%s\u0026#39; must not be called without \u0026#34; 10 \u0026#34;\u0026#39;get_temp\u0026#39; ops set\\n\u0026#34;, __func__)) 11 return; 12 13 mutex_lock(\u0026amp;tz-\u0026gt;lock); 14 15 if (!thermal_zone_device_is_enabled(tz)) 16 goto out; 17 18 update_temperature(tz); 19 20 __thermal_zone_set_trips(tz); 21 22 tz-\u0026gt;notify_event = event; 23 24 for (count = 0; count \u0026lt; tz-\u0026gt;num_trips; count++) 25 handle_thermal_trip(tz, count); 26 27 monitor_thermal_zone(tz); 28out: 29 mutex_unlock(\u0026amp;tz-\u0026gt;lock); 30} 6.2.1. handle_thermal_trip handle_thermal_trip主要工作是对 thermal_zone_device.temperature与各个阈值温度进行对比，并根据阈值温度的类型执行相应操作，最后调用monitor_thermal_zone来决定下一次执行 tz-\u0026gt;poll_queue的时机。\n阈值温度的类型由 enum thermal_trip_type描述\nthermal_trip_type 温度调节策略 THERMAL_TRIP_ACTIVE, THERMAL_TRIP_PASSIVE 由governor指定的策略来调节 THERMAL_TRIP_HOT 执行thermal_zone_device_ops的notify函数(可能为NULL) THERMAL_TRIP_CRITICAL 执行poweroff_work指定的工作 handle_thermal_trip主要流程如下：\n通过netlink通知温度变化趋势：thermal_notify_tz_trip_up/down 对于类型为CRITICAL或HOT，调用handle_critical_trips，否则调用handle_non_critical_trips handle_critical_trips会通过 tz-\u0026gt;ops-\u0026gt;notify发送通知，如果是CRITICAL，则会调用orderly_poweroff，执行poweroff_work指定的工作。 调用thermal_governar的throttle函数，如果thermal_zone_device没有指定thermal_governor，则使用def_governor handle_thermal_trip及后续相关函数会用到thermal_zone_device_ops的一些函数，这些是在注册设备时指定的，如thermal_of_zone_register中指定的默认回调。除了OF系列函数外，还有ACPI等系列函数。\n7. 部分dts节点说明 主要的属性描述参考 Documentation/devicetree/bindings/thermal/下的几个文件。\n1thermal-cooling-devices.yaml 2thermal-idle.yaml 3thermal-sensor.yaml 4thermal-zones.yaml thermal-zones：每个子节点对应一个温度调节域，也就是一个thermal_zone_device设备。 thermal-sensors：温度传感器，可以指定多个。 polling-delay：温度未超过阈值时的轮询时间，单位ms，为0表示不做轮询 polling-delay-passive：温度超过阈值时的轮询时间，单位ms，为0表示不做轮询 trip：指向触发温度调节对应的温度阈值trip节点 cooling-device：包含cooling_device、最小和最大冷却状态的列表 temperature：阈值温度，单位千分之一摄氏度 hysteresis：滞后温度，表示当下降到temperature – hysteresis度时解除温度调节，防止解除温度调节后温度回升导致频繁启动温度调节 type：阈值类型：active/passive/hot/critical，与enum thermal_trip_type对应 coefficients：线性方程系数的数组，该线性方程将该thermal-zone中列出的所有传感器绑定在一起 sustainable-power：该thermal-zone在所需控制温度下可耗散的可持续功率（热量）的估计值，单位mW contribution：cooling_device在thermal-zone的权重 8. sysfs下的文件 thermal相关文件路径位于 /sys/devices/virtual/thermal/，/sys/class/thermal/的也会有这些文件的链接。\n8.1. thermal_zoneX目录 包含了 struct thermal_zone_params的参数\nfile perm desc available_policies r 可选的温度调节策略 emul_temp w 模拟设置thermal的温度，单位毫摄氏度，设置后和实际达到这个温度同效果。值为0时读取的是真正的温度 integral_cutoff rw 用于power_alloctor策略，误差不再累积的阈值 k_d rw 用于power_alloctor策略，PID控制器的微分参数 k_i rw 用于power_alloctor策略，PID控制器的积分参数 k_po rw 用于power_alloctor策略，超调时PID控制器的比例参数 k_pu rw 用于power_alloctor策略，下冲时PID控制器的比例参数 mode rw 此thermal-zone是否使能了，若是为disabled，对其sys文件的操作不生效，可以echo enabled使能 offset rw 线性温度调节曲线的偏移，Used by thermal zone drivers (default 0) passive rw 用于step-wise，如果大于0，打开所有ACPI处理器冷却设备的温度 policy rw 当前使用的governor，也可以通过写入来修改策略 slope rw 线性温度调节曲线的斜率，Used by thermal zone drivers sustainable_power rw 该thermal-zone可耗散的可持续功率（热量），单位mW temp r 当前温度，向emul_temp中写的值也体现在这里 trip_point_0_hyst r 滞后温度，来自设备树trips下的子节点0的hysteresis字段 trip_point_0_temp r 触发温度，来自设备树trips下的子节点0的temperature字段 trip_point_0_type r 触发温度类型，来自设备树trips下的子节点0的type字段 trip_point_N_xxx r 来自设备树trips下的子节点N的字段 type r 该thermal-zone的名称，对应于设备树thermal-zones下子节点的名字 8.2. cooling_deviceX目录 file perm desc cur_state rw 当前的cooling state max_state r 最大的cooling state type r cooling device的名称 stats/reset w 对统计状态进行复位 stats/time_in_state_ms r 在每个state下停留的时间 stats/total_trans r 不同state之间转换的次数 stats/trans_table r 记录各个state状态转换表 ","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/blinds_lines_shade_143653_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.1/thermal/thermal/","series":[{"title":"内核驱动","url":"/zh-cn/series/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"内核驱动","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"},{"title":"linux-6.1","url":"/zh-cn/tags/linux-6.1/"}],"timestamp":1672358400,"title":"linux thermal子系统简介"},{"categories":[{"title":"内核基础","url":"/zh-cn/categories/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"},{"title":"C语言","url":"/zh-cn/categories/c%E8%AF%AD%E8%A8%80/"}],"content":" 1. Linux的errno和指针 常见的Linux函数返回值类型包括整型和指针，内核中这两种返回值类型的函数会互相调用。Linux的errno为整型，为了与errno对应，Linux将指针分为3种：\n空指针：NULL，地址为0 异常指针：地址空间的高4095个字节。0xfffff001 - 0xffffffff(32位)和0xfffffffffffff001 - 0xffffffffffffffff(64位) 普通指针 errno的最大值MAX_ERRNO在err.h定义，值为4095。关于变量转换类型后的值，可以使用测试程序来进行测试。\nlong void *(arm) unsigned long(arm) void *(arm64) unsigned long(arm64) 0 (nil) 0 (nil) 0 -1 0xffffffff 0xFFFFFFFF 0xffffffffffffffff 0xFFFFFFFFFFFFFFFF -MAX_ERRNO 0xfffff001 0xFFFFF001 0xfffffffffffff001 0xFFFFFFFFFFFFF001 为了处理两种数据类型的转换，内核提供了include/linux/err.h。\n1.1. 整型和指针类型转换 interface input output function IS_ERR_VALUE any bool 强制转换为unsigned long后，判断是否大于(unsigned long)-MAX_ERRNO ERR_PTR long void * errno转指针 PTR_ERR pointer long 指针转errno IS_ERR pointer bool 判断指针是否异常 IS_ERR_OR_NULL pointer bool 判断指针是否异常或NULL ERR_CAST pointer void * 将任意类型的指针转为void型指针 PTR_ERR_OR_ZERO pointer int 如果是异常指针，返回指针对应的errno，否则返回0 2. C语言中整型数据的存储和数据类型转换原理 其实，在C语言中，数值是以补码的形式存储的，正数存储的内容就是其本身(原码)，负数补码的计算方法如下：\n取绝对值 取反码，也就是对每一位取反 对反码加1，得到补码 以char型为例，-1在内存中的表示计算方法如下：\ngraph TB; A[\u0026#34;0000 0001\u0026#34;] -- 取反码 --\u0026gt; B[\u0026#34;1111 1110\u0026#34;] B -- 反码加1 --\u0026gt; C[\u0026#34;1111 1111\u0026#34;] 关于为什么使用补码存储数据，可以参整数在内存中是如何存储的，为什么它堪称天才般的设计。\n2.1. 负数的强制类型转换 做强制类型转换时，就是把内存中的数据(补码)看作要转换的类型。将-1强制转换为unsigned char型时，就可得到值为0xFF，以此类推，可知将-转换为unsigned long时，值为0xFFFFFFFF(32位)或0xFFFFFFFFFFFFFFFF(64位)。同样的道理-4095转换为unsigned long时，值为0xFFFFF001(32位)或0xFFFFFFFFFFFFF001(64位)。需要注意的是，类型转换是临时的，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。\n2.2. 强制数据类型降级 数据类型级别从高到低为：\n1unsigned long long 2long long 3unsigned long 4long 5unsigned int 6int 7unsigned short 8short 9unsigned char 10char 从高级到低级转换时，超出数值位数的高位部分将被丢弃。另外，降级转换也是是临时的。\n3. 测试程序 1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;string.h\u0026gt; 3 4#define MAX_ERRNO 4095 5 6union err_t { 7 int i; 8 long l; 9 unsigned int ui; 10 unsigned long ul; 11 void *p; 12 char ch[sizeof(unsigned long)]; 13}; 14 15static void test(long val) 16{ 17 union err_t err; 18 memcpy(\u0026amp;err, \u0026amp;val, sizeof(val)); 19 20 printf(\u0026#34;int: %d\\n\u0026#34;, err.i); 21 printf(\u0026#34;long: %ld\\n\u0026#34;, err.l); 22 printf(\u0026#34;unsigned int: %u, 0x%08X\\n\u0026#34;, err.ui, err.ui); 23 printf(\u0026#34;unsigned long: %lu, 0x%08lX\\n\u0026#34;, err.ul, err.ul); 24 printf(\u0026#34;void *: %p\\n\u0026#34;, err.p); 25} 26 27int main(void) 28{ 29 printf(\u0026#34;\\ntesting: 0\\n\u0026#34;); 30 test(0); 31 32 printf(\u0026#34;\\ntesting: -1\\n\u0026#34;); 33 test(-1); 34 35 printf(\u0026#34;\\ntesting: -MAX_ERRNO\\n\u0026#34;); 36 test(-MAX_ERRNO); 37 38#if 0 39 printf(\u0026#34;\\ntesting: -4096\\n\u0026#34;); 40 test(-4096); 41#endif 42 return 0; 43} 3.1. ARM测试结果 交叉编译后使用QEMU运行查看结果。\n1arm-linux-gnueabihf-gcc -static -o err_arm err.c 2qemu-arm err_arm 1testing: 0 2int: 0 3long: 0 4unsigned int: 0, 0x00000000 5unsigned long: 0, 0x00000000 6void *: (nil) 7 8testing: -1 9int: -1 10long: -1 11unsigned int: 4294967295, 0xFFFFFFFF 12unsigned long: 4294967295, 0xFFFFFFFF 13void *: 0xffffffff 14 15testing: -MAX_ERRNO 16int: -4095 17long: -4095 18unsigned int: 4294963201, 0xFFFFF001 19unsigned long: 4294963201, 0xFFFFF001 20void *: 0xfffff001 3.2. ARM64测试结果 交叉编译后使用QEMU运行查看结果。\n1aarch64-linux-gnu-gcc -static -o err_aarch64 err.c 2qemu-aarch64 err_aarch64 1testing: 0 2int: 0 3long: 0 4unsigned int: 0, 0x00000000 5unsigned long: 0, 0x00000000 6void *: (nil) 7 8testing: -1 9int: -1 10long: -1 11unsigned int: 4294967295, 0xFFFFFFFF 12unsigned long: 18446744073709551615, 0xFFFFFFFFFFFFFFFF 13void *: 0xffffffffffffffff 14 15testing: -MAX_ERRNO 16int: -4095 17long: -4095 18unsigned int: 4294963201, 0xFFFFF001 19unsigned long: 18446744073709547521, 0xFFFFFFFFFFFFF001 20void *: 0xfffffffffffff001 ","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/lines_intersection_oblique_153331_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/misc/linux-err-return/","series":[{"title":"C语言","url":"/zh-cn/series/c%E8%AF%AD%E8%A8%80/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"C语言","url":"/zh-cn/tags/c%E8%AF%AD%E8%A8%80/"}],"timestamp":1672358400,"title":"Linux的errno简介"},{"categories":[{"title":"内核基础","url":"/zh-cn/categories/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"}],"content":" 1. 打开dynamic_debug 1CONFIG_DYNAMIC_DEBUG=y /proc/dynamic_debug/control 如果开启了CONFIG_DEBUG_FS，在\u0026lt;debugfs\u0026gt;/dynamic_debug/control，两者效果是相同的。\n2. 使用dynamic_debug 1#define pr_fmt(fmt) fmt 2 3#include \u0026lt;linux/kernel.h\u0026gt; 4#include \u0026lt;linux/init.h\u0026gt; 5#include \u0026lt;linux/module.h\u0026gt; 6 7static int __init hello_init(void) 8{ 9 pr_info(\u0026#34;%s enter\\n\u0026#34;, __func__); 10 pr_debug(\u0026#34;debug enter\\n\u0026#34;); 11 return 0; 12} 13 14static void __exit hello_exit(void) 15{ 16 pr_info(\u0026#34;%s exit\\n\u0026#34;, __func__); 17 pr_debug(\u0026#34;debug exit\\n\u0026#34;); 18} 19 20module_init(hello_init); 21module_exit(hello_exit); 按照如下步骤查看输出，发现只有hello_exit中的pr_debug可以输出。\n1echo 8 \u0026gt; /proc/sys/kernel/printk 2insmod hello.ko 3echo -n \u0026#39;module hello +p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control 4rmmod hello 5dmesg | tail 2.1. 让hello_init中的pr_debug也可以输出 一种方式是在modprobe时，指定dyndbg==p，insmod不适用。 另一种方法是在文件头部定义DEBUG。\n1#define DEBUG 2#define pr_fmt(fmt) fmt 3 4#include \u0026lt;linux/kernel.h\u0026gt; 5#include \u0026lt;linux/init.h\u0026gt; 6#include \u0026lt;linux/module.h\u0026gt; 原理是使pr_debug内部的static struct _ddebug变量中的flags默认值（_DPRINTK_FLAGS_DEFAULT）为_DPRINTK_FLAGS_PRINT。\n1#if defined DEBUG 2#define _DPRINTK_FLAGS_DEFAULT _DPRINTK_FLAGS_PRINT 3#else 4#define _DPRINTK_FLAGS_DEFAULT 0 5#endif Dynamic debug — The Linux Kernel documentation\n","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/wavy_curvy_lines_146044_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/debug/dynamic_debug/","series":[{"title":"内核基础","url":"/zh-cn/series/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"}],"smallImg":"","tags":[{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"},{"title":"内核调试","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"}],"timestamp":1672358400,"title":"linux内核dynamic_debug"},{"categories":[{"title":"进程管理","url":"/zh-cn/categories/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"content":" 1/// kernel/sched/sched.h 2/* 3 * Helper to define a sched_class instance; each one is placed in a separate 4 * section which is ordered by the linker script: 5 * 6 * include/asm-generic/vmlinux.lds.h 7 * 8 * *CAREFUL* they are laid out in *REVERSE* order!!! 9 * 10 * Also enforce alignment on the instance, not the type, to guarantee layout. 11 */ 12#define DEFINE_SCHED_CLASS(name) \\ 13const struct sched_class name##_sched_class \\ 14\t__aligned(__alignof__(struct sched_class)) \\ 15\t__section(\u0026#34;__\u0026#34; #name \u0026#34;_sched_class\u0026#34;) 16 17/* Defined in include/asm-generic/vmlinux.lds.h */ 18extern struct sched_class __sched_class_highest[]; 19extern struct sched_class __sched_class_lowest[]; 20 21#define for_class_range(class, _from, _to) \\ 22\tfor (class = (_from); class \u0026lt; (_to); class++) 23 24#define for_each_class(class) \\ 25\tfor_class_range(class, __sched_class_highest, __sched_class_lowest) 26 27#define sched_class_above(_a, _b)\t((_a) \u0026lt; (_b)) 28 29extern const struct sched_class stop_sched_class; 30extern const struct sched_class dl_sched_class; 31extern const struct sched_class rt_sched_class; 32extern const struct sched_class fair_sched_class; 33extern const struct sched_class idle_sched_class; shced_class列表 member idle fair rt dl stop uclamp_enabled 1 1 enqueue_task enqueue_task_fair enqueue_task_rt enqueue_task_dl enqueue_task_stop dequeue_task dequeue_task_idle dequeue_task_fair dequeue_task_rt dequeue_task_dl dequeue_task_stop yield_task yield_task_fair yield_task_rt yield_task_dl yield_task_stop yield_to_task yield_to_task_fair check_preempt_curr check_preempt_curr_idle check_preempt_wakeup check_preempt_curr_rt check_preempt_curr_dl check_preempt_curr_stop pick_next_task pick_next_task_idle __pick_next_task_fair pick_next_task_rt pick_next_task_dl pick_next_task_stop put_prev_task put_prev_task_idle put_prev_task_fair put_prev_task_rt put_prev_task_dl put_prev_task_stop set_next_task set_next_task_idle set_next_task_fair set_next_task_rt set_next_task_dl set_next_task_stop balance balance_idle balance_fair balance_rt balance_dl balance_stop select_task_rq select_task_rq_idle select_task_rq_fair select_task_rq_rt select_task_rq_dl select_task_rq_stop pick_task pick_task_idle pick_task_fair pick_task_rt pick_task_dl pick_task_stop migrate_task_rq migrate_task_rq_fair migrate_task_rq_dl task_woken task_woken_rt task_woken_dl set_cpus_allowed set_cpus_allowed_common set_cpus_allowed_common set_cpus_allowed_common set_cpus_allowed_dl set_cpus_allowed_common rq_online rq_online_fair rq_online_rt rq_online_dl rq_offline rq_offline_fair rq_offline_rt rq_offline_dl find_lock_rq find_lock_lowest_rq find_lock_later_rq task_tick task_tick_idle task_tick_fair task_tick_rt task_tick_dl task_tick_stop task_fork task_fork_fair task_fork_dl task_dead task_dead_fair switched_from switched_from_fair switched_from_rt switched_from_dl switched_to switched_to_idle switched_to_fair switched_to_rt switched_to_dl switched_to_stop prio_changed prio_changed_idle prio_changed_fair prio_changed_rt prio_changed_dl prio_changed_stop get_rr_interval get_rr_interval_fair get_rr_interval_rt update_curr update_curr_idle update_curr_fair update_curr_rt update_curr_dl update_curr_stop task_change_group task_change_group_fair task_is_throttled task_is_throttled_fair task_is_throttled_rt task_is_throttled_dl ","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/wavy_motley_metallic_139065_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/sched/sched_class_table/","series":[{"title":"进程管理","url":"/zh-cn/series/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"进程管理","url":"/zh-cn/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1672358400,"title":"Linux内核sched_class汇总"},{"categories":[{"title":"时间子系统","url":"/zh-cn/categories/%E6%97%B6%E9%97%B4%E5%AD%90%E7%B3%BB%E7%BB%9F/"}],"content":" 1. 简介 内核版本：linux-6.1\n时间子系统的作用：\n时间读取功能 定时器功能，有传统的定时器timer、高精度定时器hrtimer 提供用于调度的tick，有周期tick和动态tick 2. Linux的各种时间 Linux的系统时钟ID定义如下，选其中常用的简单介绍一下。\n相关的文档可以查看内核文档 Documentation/core-api/timekeeping.rst或ktime accessors — The Linux Kernel documentation。\n用户态的clock_gettime相关接口也有一些介绍，Linux系统上，可以用 man 2 clock_gettime查看，或者查看网页版clock_getres(2) - Linux manual page。\nwowotech介绍：Linux的时钟。\n1/* 2 * The IDs of the various system clocks (for POSIX.1b interval timers): 3 */ 4#define CLOCK_REALTIME 0 5#define CLOCK_MONOTONIC 1 6#define CLOCK_PROCESS_CPUTIME_ID 2 7#define CLOCK_THREAD_CPUTIME_ID 3 8#define CLOCK_MONOTONIC_RAW 4 9#define CLOCK_REALTIME_COARSE 5 10#define CLOCK_MONOTONIC_COARSE 6 11#define CLOCK_BOOTTIME 7 12#define CLOCK_REALTIME_ALARM 8 13#define CLOCK_BOOTTIME_ALARM 9 2.1. 墙上时间(REALTIME) 真实时间的时间，也就是协调世界时(UTC) ，起始于1970年1月1日0时0分0秒。\n在内核中，REALTIME用在需要在重启期间保持的时间戳，如文件inode时间。这个时间会受到系统时间不连续跳跃的影响，比如闰秒更新、NTP调整settimeofday操作，应尽量避免用于内部使用。\n2.2. 单调时间(MONOTONIC) 不可设置的全系统时钟，表示单调时间，正如POSIX所描述的那样——“过去某个未指定的点”。在Linux上，该点对应于系统自启动以来运行的秒数。CLOCK_MONOTONIC时钟不受系统时间不连续跳跃的影响（例如，如果系统管理员手动更改时钟），但受adjtime和NTP执行的增量调整的影响。此时钟不计算系统暂停的时间。在内核中用于可靠的时间戳和精确测量短时间间隔。用户态所有CLOCK_MONOTONIC变体都保证连续调用返回的时间不会倒退，但连续调用可能会根据体系结构返回相同（而不是增加）的时间值。\n2.3. 单调时间(MONOTONIC_RAW) 与MONOTONIC类似，是基于硬件的原始时间，不受adjtime或NTP（Network Time Protocol，网络时间协议）调整的影响。在内核中也很少用到。\n2.4. 系统启动时间(BOOTTIME) 不可设置的全系统时钟，与MONOTONIC类似，但它会统计系统挂起的时间。会受到settimeofday获取其他相关系统调用影响。\n内核中可以用在需要系统挂起之后与其他机器保持时间同步的场景，比如密钥过期时间。\n2.5. 国际原子时(TAI) TAI是International Atomic Time的反向简称。一种不可设置的全系统时钟，源自墙上时间，忽略闰秒问题，不会有REALTIME由NTP插入闰秒引起的中断和向后跳转。内核中很少用到。\n3. 时间子系统的初始化 时间子系统初始化中调用关系如下，其中timekeeping_init和time_init是比较重要的函数。后边会再做介绍。\n3.1. tick_init broadcast和nohz初始化，这里都是针对子系统软件上的初始化，没有实际的硬件操作。\nbroadcast用来实现CPU suspend后的唤醒等，nohz则与动态时钟调度相关。\ntick_broadcast_init主要是一些CPU mask标志的初始化。\ntick_nohz_init也依赖tick_nohz_full_running，如果tick_nohz_full_running为false，就直接返回了。而tick_nohz_full_running只有在housekeeping_setup -\u0026gt; tick_nohz_full_setup才会被设为true，需要使能CONFIG_CPU_ISOLATION才有可能被调到。\n1/** 2 * tick_init - initialize the tick control 3 */ 4void __init tick_init(void) 5{ 6 tick_broadcast_init(); 7 tick_nohz_init(); 8} 3.2. init_timers init_timers是针对传统定时器的初始化，主要完成两个工作：\npercpu变量timer_bases。 打开TIMER_SOFTIRQ软中断 1void __init init_timers(void) 2{ 3 init_timer_cpus(); 4 posix_cputimers_init_work(); 5 open_softirq(TIMER_SOFTIRQ, run_timer_softirq); 6} 3.3. hrtimers_init hrtimer顾名思义就是高精度定时器，hrtimers_init主要完成两个工作：\n初始struct hrtimer_cpu_base，percpu变量hrtimer_bases。 打开HRTIMER_SOFTIRQ软中断 1void __init hrtimers_init(void) 2{ 3 hrtimers_prepare_cpu(smp_processor_id()); 4 open_softirq(HRTIMER_SOFTIRQ, hrtimer_run_softirq); 5} 3.4. timekeeping_init timekeeping_init是时间子系统非常重要的一个初始化，实现了各种时间基准的初始化，tk_core的timekeeper是timekeeping核心，并由tk_core衍生出了tk_fast_mono和tk_fast_raw，ktime_get相关的接口都是基于tk_core.timekeeper或tk_fast_mono、tk_fast_raw来获取时间的。\n3.5. time_init time_init是一个体系结构相关的函数，arm64的代码位于arch/arm64/kernel/time.c，主要流程如下。\nof_clk_init初始化时钟 timer_probe查找系统定时器并初始化 tick_setup_hrtimer_broadcast，在使能高精度timer和broadcast的情况下有用，创建一个名为bctimer的hrtimer，并注册ce_broadcast_hrtimer作为clock_event_device。 arch_timer_get_rate，获取arch timer的速率，如果为0，直接panic。正常情况下，在timer_probe初始化定时器后，会返回系统定时器速率。 直接用获取的arch_timer速率计算lpj_fine，lpj_fine = arch_timer_rate / HZ。作为loops_per_jiffy的一种快速获取方法，从而节省启动时间。 3.5.1. timer_probe 这里比较重要的是timer_probe，arm和arm64都要求必须要有arch_timer用来做为clocksource，提供tick来驱动系统调度。这些timer用TIMER_OF_DECLARE来声明，TIMER_OF_DECLARE用于声明一个struct of_device_id，并放到 __timer_of_table段，其中struct of_device_id的data成员指向初始化换函数。比如 drivers/clockcource/arm_arch_timer.c。\n1TIMER_OF_DECLARE(armv7_arch_timer, \u0026#34;arm,armv7-timer\u0026#34;, arch_timer_of_init); 2TIMER_OF_DECLARE(armv8_arch_timer, \u0026#34;arm,armv8-timer\u0026#34;, arch_timer_of_init); 在内核启动过程中，timer_probe遍历 __timer_of_table段，扫描设备树中可以匹配的定时器节点，并调用对应的初始化函数。\n","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/wood_texture_logs_159793_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.1/time/time/","series":[{"title":"时间子系统","url":"/zh-cn/series/%E6%97%B6%E9%97%B4%E5%AD%90%E7%B3%BB%E7%BB%9F/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"内核驱动","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"},{"title":"linux-6.1","url":"/zh-cn/tags/linux-6.1/"},{"title":"启动流程","url":"/zh-cn/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"timestamp":1672358400,"title":"linux内核时间子系统（一）"},{"categories":[{"title":"中断管理","url":"/zh-cn/categories/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"content":"sequenceDiagram participant caller as caller participant irq as irq.c participant irqdomain as irqdomain.c participant irqdesc as irqdesc.c participant bitmap as bitmap.c activate caller caller -\u0026gt;\u0026gt; irq: irq_of_parse_and_map activate irq Note right of irq: irq_of_parse_and_map irq -\u0026gt;\u0026gt; irq: of_irq_parse_one irq -\u0026gt;\u0026gt; irqdomain: irq_create_of_mapping activate irqdomain Note right of irqdomain :irq_create_of_mapping irqdomain -\u0026gt;\u0026gt; irqdomain: of_phandle_args_to_fwspec irqdomain -\u0026gt;\u0026gt; irqdomain: irq_create_fwspec_mapping activate irqdomain Note right of irqdomain :irq_create_fwspec_mapping irqdomain -\u0026gt;\u0026gt; irqdomain: irq_domain_translate irqdomain -\u0026gt;\u0026gt; irqdomain: irq_find_mapping opt irq_find_mapping \u0026gt; 0 irqdomain --\u0026gt;\u0026gt; irq: return irq --\u0026gt;\u0026gt; caller: return end alt irq_domain_is_hierarchy irqdomain -\u0026gt;\u0026gt; irqdomain: irq_domain_alloc_irqs irqdomain -\u0026gt;\u0026gt; irqdesc: irq_domain_alloc_descs activate irqdesc Note right of irqdesc :irq_domain_alloc_descs else irqdomain -\u0026gt;\u0026gt; irqdomain: irq_create_mapping irqdomain -\u0026gt;\u0026gt; irqdesc: irq_domain_alloc_descs end irqdesc -\u0026gt;\u0026gt; irqdesc : __irq_alloc_descs activate irqdesc Note right of irqdesc: __irq_alloc_descs irqdesc -\u0026gt;\u0026gt; bitmap: bitmap_find_next_zero_area activate bitmap bitmap -\u0026gt;\u0026gt; bitmap: bitmap_find_next_zero_area_off bitmap --\u0026gt;\u0026gt; irqdesc: return deactivate bitmap irqdesc --\u0026gt;\u0026gt; irqdomain: return deactivate irqdomain deactivate irqdesc deactivate irqdesc irqdomain --\u0026gt;\u0026gt; irq: return deactivate irqdomain irq --\u0026gt;\u0026gt; caller: return deactivate irq deactivate caller ","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/code_programming_text_140050_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/interrupt/irq_flow/","series":[{"title":"中断管理","url":"/zh-cn/series/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"}],"timestamp":1672358400,"title":"Linux中断处理流程图"},{"categories":[{"title":"内核基础","url":"/zh-cn/categories/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"},{"title":"内核调试","url":"/zh-cn/categories/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"}],"content":" 1. printk /proc/sys/kernel/printk /sys/kernel/debug/printk/index/\n2. 常见pr_*()接口 include/linux/printk.h\n三种类型的接口说明如下：\npr_xxx：按照pr_fmt(fmt)指定的格式输出日志。 pr_xxx_once：日志只输出一次。 pr_xxx_ratelimited：通常来说终端是慢速设备，pr_xxx_ratelimited可以限制日志输出速率，避免信息过多导致CPU阻塞。 pr_xxx pr_xxx_once pr_xxx_ratelimited loglevel description pr_emerg pr_emerg_once pr_emerg_ratelimited KERN_EMERG system is unusable pr_alert pr_alert_once pr_alert_ratelimited KERN_ALERT action must be taken immediately pr_crit pr_crit_once pr_crit_ratelimited KERN_CRIT critical conditions pr_err pr_err_once pr_err_ratelimited KERN_ERR error conditions pr_warn pr_warn_once pr_warn_ratelimited KERN_WARNING warning conditions pr_notice pr_notice_once pr_notice_ratelimited KERN_NOTICE normal but significant condition pr_info pr_info_once pr_info_ratelimited KERN_INFO informational pr_devel pr_devel_once pr_devel_ratelimited KERN_DEBUG debug-level message conditionally pr_debug pr_debug_once pr_debug_ratelimited KERN_DEBUG/dynamic (dynamic) debug-level message conditionally 对于驱动代码，内核提供了dev_xxx函数来方便打印调试信息，这些函数的实现都是调用printk。include/linux/dev_printk.h\ndev_xxx dev_xxx_once dev_xxx_ratelimited loglevel description dev_emerg dev_emerg_once dev_emerg_ratelimited KERN_EMERG system is unusable dev_alert dev_alert_once dev_alert_ratelimited KERN_ALERT action must be taken immediately dev_crit dev_crit_once dev_crit_ratelimited KERN_CRIT critical conditions dev_err dev_err_once dev_err_ratelimited KERN_ERR error conditions dev_warn dev_warn_once dev_warn_ratelimited KERN_WARNING warning conditions dev_notice dev_notice_once dev_notice_ratelimited KERN_NOTICE normal but significant condition dev_info dev_info_once dev_info_ratelimited KERN_INFO informational dev_debug dev_debug_once dev_debug_ratelimited KERN_DEBUG/dynamic (dynamic) debug-level message conditionally 1/// include/linux/dev_printk.h 2#ifdef VERBOSE_DEBUG 3#define dev_vdbg\tdev_dbg 4#else 5#define dev_vdbg(dev, fmt, ...)\t\\ 6({\t\\ 7\tif (0)\t\\ 8\tdev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__); \\ 9}) 10#endif 除此之外，还有netdev_xxx和netif_xxx系列接口，而且提供了netdev_vdbg、netif_vdbg和netif_cond_dbg来更精细化的控制，只是linux-6.6还不能使用类似pr_fmt(fmt)来提供更丰富的打印格式。\n2.1. pr_devel和pr_debug pr_*()中比较特殊的是pr_devel和pr_debug，它们需要在特定条件下才会有实际作用。\npr_devel在没有定义DEBUG的情况下不做任何工作。 pr_debug在pr_devel的基础上增加了动态调试部分，如果使能了动态调试，则实际为dynamic_pr_debug，否则与pr_devel效果一致。 关于动态调试，可以参考TODO。\n1#ifdef DEBUG 2#define pr_devel(fmt, ...) \\ 3 printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__) 4#else 5#define pr_devel(fmt, ...) \\ 6 no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__) 7#endif 1/* If you are writing a driver, please use dev_dbg instead */ 2#if defined(CONFIG_DYNAMIC_DEBUG) || \\ 3 (defined(CONFIG_DYNAMIC_DEBUG_CORE) \u0026amp;\u0026amp; defined(DYNAMIC_DEBUG_MODULE)) 4#include \u0026lt;linux/dynamic_debug.h\u0026gt; 5 6#define pr_debug(fmt, ...) \\ 7 dynamic_pr_debug(fmt, ##__VA_ARGS__) 8#elif defined(DEBUG) 9#define pr_debug(fmt, ...) \\ 10 printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__) 11#else 12#define pr_debug(fmt, ...) \\ 13 no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__) 14#endif 3. 关于no_printk no_printk表示信息不会被输出，但是为了在不同的配置下，内核都可以正常工作，这里需要让编译器对传入pr_xxx的参数进行检查。\n4. pr_fmt和dev_fmt 在阅读Linux内核或其他开源代码时，在文件的开始部分，通常能看到类似如下代码。但是代码中又没有看到使用的地方。\n1#define pr_fmt(fmt) KBUILD_MODNAME \u0026#34;: \u0026#34; fmt 2 3#include \u0026lt;...\u0026gt; 4#include \u0026lt;...\u0026gt; 其实pr_fmt是通常和大名鼎鼎的printk一起来合作实现其他宏，比较常见的就是pr_*()系列宏，另外一些模块或驱动中也会利用pr_fmt来输出日志信息。使用pr_fmt可以在要输出的信息前再添加额外的信息。\n1/// include/linux/printk.h 2/** 3 * pr_fmt - used by the pr_*() macros to generate the printk format string 4 * @fmt: format string passed from a pr_*() macro 5 * 6 * This macro can be used to generate a unified format string for pr_*() 7 * macros. A common use is to prefix all pr_*() messages in a file with a common 8 * string. For example, defining this at the top of a source file: 9 * 10 * #define pr_fmt(fmt) KBUILD_MODNAME \u0026#34;: \u0026#34; fmt 11 * 12 * would prefix all pr_info, pr_emerg... messages in the file with the module 13 * name. 14 */ 15#ifndef pr_fmt 16#define pr_fmt(fmt) fmt 17#endif 如果在#include \u0026lt;linux/printk.h\u0026gt;之前没有定义pr_fmt，include/linux/printk.h中会将pr_fmt(fmt)定义为fmt，也就是输出信息的原始格式。如果在#include \u0026lt;linux/printk.h\u0026gt;之后定义pr_fmt，编译时就会提示重复定义警告或错误。所以通常来说，对pr_fmt的定义都是放到了文件的最前端。\n5. dev_xxx 1/// include/linux/dev_printk.h 2#ifndef dev_fmt 3#define dev_fmt(fmt) fmt 4#endif 6. 常用pr_fmt定义 6.1. 打印模块名、函数名和行号 KBUILD_MODNAME是编译时通过编译选项指定的，无需自己定义。\n1#define pr_fmt(fmt) \\ 2 KBUILD_MODNAME \u0026#34;: [%s:%d] \u0026#34; fmt, __func__, __LINE__ 6.2. 打印CPU号 使用raw_smp_processor_id需要包含linux/smp.h。\n1#define pr_fmt(fmt) \\ 2 KBUILD_MODNAME \u0026#34;: \u0026lt;C%u\u0026gt; \u0026#34; fmt, raw_smp_processor_id() 6.3. 打印线程pid和线程名 线程的task_struct使用current宏来获取，需要包含linux/sched.h。\n1#define pr_fmt(fmt) \\ 2 \u0026#34;{t%d-%s} \u0026#34; fmt, current-\u0026gt;pid, current-\u0026gt;comm 6.4. 打印进程pid和进程名 进程的task_struct可以通过current-\u0026gt;group_leader来获取。\n1#define pr_fmt(fmt) \\ 2 \u0026#34;{p%d-%s} \u0026#34; fmt, \\ 3 current-\u0026gt;group_leader-\u0026gt;pid, current-\u0026gt;group_leader-\u0026gt;comm 6.5. 打印进程pid和线程pid 进程pid current-\u0026gt;tgid与current-\u0026gt;group_leader-\u0026gt;pid相同。\n1#define pr_fmt(fmt) \\ 2 \u0026#34;{p%d:t%d} \u0026#34; fmt, current-\u0026gt;tgid, current-\u0026gt;pid 6.6. 大杂烩 1#define pr_fmt(fmt) \\ 2 KBUILD_MODNAME \u0026#34;: \u0026lt;C%u\u0026gt;{p%d-%s}{t%d-%s}[%s:%d] \u0026#34; fmt, raw_smp_processor_id(), \\ 3 current-\u0026gt;group_leader-\u0026gt;pid, current-\u0026gt;group_leader-\u0026gt;comm, \\ 4 current-\u0026gt;pid, current-\u0026gt;comm, __func__, __LINE__ ","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/lens_camera_glare_147903_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/debug/printk-pr_fmt/","series":[{"title":"内核基础","url":"/zh-cn/series/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"}],"smallImg":"","tags":[{"title":"linux-6.6","url":"/zh-cn/tags/linux-6.6/"},{"title":"内核调试","url":"/zh-cn/tags/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"}],"timestamp":1672358400,"title":"printk的pr_fmt"},{"categories":[{"title":"启动流程","url":"/zh-cn/categories/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"content":" 1. 查找入口 u-boot版本：2024.01 参考defconfig：imx8qm_mek_defconfig\n通过编译生成的u-boot.lds，U-Boot的入口为_start。而程序的一开始存放的指令是由start.c生成的。\n1ENTRY(_start) 1 . = 0x00000000; 2 . = ALIGN(8); 3 .text : 4 { 5 *(.__image_copy_start) 6 arch/arm/cpu/armv8/start.o (.text*) 7 } 2. 程序流程 2.1. _start 默认情况下_start会直接通过b reset跳转到reset处。 在反汇编中，1400000a就是b reset的二进制码。\n10000000000000000 \u0026lt;__image_copy_start\u0026gt;: 2_start(): 3/home/owo/disk/02-coding/eos/u-boot/arch/arm/cpu/armv8/start.S:31 4 0:\t0a 00 00 14 1f 20 03 d5 ..... .. 3. main_loop 4. SPL 1/// arch/arm/mach-exynos/spl_boot.c 2void board_init_f(unsigned long bootflag) 3{ 4\t__aligned(8) gd_t local_gd; 5\t__attribute__((noreturn)) void (*uboot)(void); 6 7\tsetup_global_data(\u0026amp;local_gd); 8 9\tif (do_lowlevel_init()) 10\tpower_exit_wakeup(); 11 12\tcopy_uboot_to_ram(); 13 14\t/* Jump to U-Boot image */ 15\tuboot = (void *)CONFIG_SYS_TEXT_BASE; 16\t(*uboot)(); 17\t/* Never returns Here */ 18} ","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/code_letters_screen_137590_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/03-boot/u-boot/u-boot-bootflow/","series":[{"title":"u-boot","url":"/zh-cn/series/u-boot/"}],"smallImg":"","tags":[{"title":"启动流程","url":"/zh-cn/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"u-boot","url":"/zh-cn/tags/u-boot/"}],"timestamp":1672358400,"title":"U-Boot启动分析"},{"categories":[{"title":"C语言","url":"/zh-cn/categories/c%E8%AF%AD%E8%A8%80/"}],"content":" 1. 方法一：传递数组 C语言对多维数组的存储是按照一维数组来处理的，数组的每个维度在内存中按顺序存储。所以将多维数组作为参数传递时，必须指定多维数组子维度的大小，否则函数无法得知每个子维度结束地址。 第一维的长度可以指定，也可以不指定。\n1void func1(int a1[], int x); 2void func2(int a2[][4], int x, int y); 3void func3(int a3[][4][8], int x, int y, int z); 2. 方法二：数组指针 把参数声明为指向数组的指针，此方法还是需要指定数组的子维度大小，不然函数内部无法使用下标去访问数组。\n1void func1(int *a1, int x); 2void func2(int (*a2)[4], int x, int y); 3void func3(int (*a3)[4][8], int x, int y, int z); 3. 方法三：多重指针 采用多重指针的方法，需要通过其他方式，如函数参数来指定数组子维度的大小。\n1void func1(int *a1, int x); 2void func2(int **a2, int x, int y); 3void func3(int ***a3, int x, int y, int z); 4. 数组作为参数时可以用sizeof(a)或ARRAY_SIZE(a)来获取大小吗？ 答案是不可以。\n数组作为函数参数时，相当于指向该数组第一个元素的指针。这样传递给函数的效率非常高，而且函数内部对数组的修改也会保留。但是，作为指针，函数内部就无法通过sizeof(a)或ARRAY_SIZE(a)来获取数组大小。\n","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/pattern_frosty_frost_134125_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/05-program/ccpp/array_func/","series":[{"title":"C语言","url":"/zh-cn/series/c%E8%AF%AD%E8%A8%80/"}],"smallImg":"","tags":[{"title":"C语言","url":"/zh-cn/tags/c%E8%AF%AD%E8%A8%80/"},{"title":"数组","url":"/zh-cn/tags/%E6%95%B0%E7%BB%84/"}],"timestamp":1672358400,"title":"多维数组作为函数参数"},{"categories":[{"title":"启动流程","url":"/zh-cn/categories/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"content":" 1. 内核启动入口 根据Makefile对KBUILD_LDS的定义，链接vmlinux使用的连接脚本为 arch/$(SRCARCH)/kernel/vmlinux.lds，实际上这个脚本是在编译过程中生成的。从链接脚本 arch/arm64/kernel/vmlinux.lds可以查到，程序的入口为 _text，镜像起始位置存放的是 .head.text段生成的指令。\n1OUTPUT_ARCH(aarch64) 2ENTRY(_text) 3 4SECTIONS 5{ 6 . = ((((((-(((1)) \u0026lt;\u0026lt; ((((48))) - 1)))) + (0x08000000))) + (0x08000000))); 7 .head.text : { 8 _text = .; 9 KEEP(*(.head.text)) 10 } 11 ... 12} 也就是说，内核镜像的起始位置是 .head.text段生成的指令。\n搜索 .head.text，可以找到 include/linux/init.h对 __HEAD定义 .section \u0026quot;.head.text\u0026quot;,\u0026quot;ax\u0026quot;。\n1/* For assembly routines */ 2#define __HEAD .section \u0026#34;.head.text\u0026#34;,\u0026#34;ax\u0026#34; 3#define __INIT .section \u0026#34;.init.text\u0026#34;,\u0026#34;ax\u0026#34; 4#define __FINIT .previous 再看一下 arch/arm64/kernel/vmlinux.lds是怎么生成的，编译日志中，会有 LDS arch/arm64/kernel/vmlinux.lds，scripts/Makefile.build中可以看到是对 arch/arm64/kernel/vmlinux.lds.S进行预处理得到了最终的链接脚本。\n1# Linker scripts preprocessor (.lds.S -\u0026gt; .lds) 2# --------------------------------------------------------------------------- 3quiet_cmd_cpp_lds_S = LDS $@ 4 cmd_cpp_lds_S = $(CPP) $(cpp_flags) -P -U$(ARCH) \\ 5 -D__ASSEMBLY__ -DLINKER_SCRIPT -o $@ $\u0026lt; 6 7$(obj)/%.lds: $(src)/%.lds.S FORCE 8 $(call if_changed_dep,cpp_lds_S) 通过搜索 __HEAD，可以看到程序起始代码位于 arch/arm64/kernel/head.S。\n2. head.S总览 head.S可以分为三段，分别为 .head.text、.init.text和 .idmap.text。各个段包含的符号可以通过objdump或nm查看。\narch/arm64/boot/head.S开始的注释简单说明了内核启动的条件。更详细的内容可以查看内核文档 Documentation/arm64/booting.rst或 Documentation/translations/zh_CN/arm64/booting.txt。\n1/* 2 * Kernel startup entry point. 3 * --------------------------- 4 * 5 * The requirements are: 6 * MMU = off, D-cache = off, I-cache = on or off, 7 * x0 = physical address to the FDT blob. 8 * 9 * Note that the callee-saved registers are used for storing variables 10 * that are useful before the MMU is enabled. The allocations are described 11 * in the entry routines. 12 */ 2.1. .head.text 顾名思义，这部分为头部内容，根据是否使能 CONFIG_EFI而有所不同，在未定义 CONFIG_EFI的情况下，实际工作只是跳转到 primary_entry。\n1 __HEAD 2 /* 3 * DO NOT MODIFY. Image header expected by Linux boot-loaders. 4 */ 5 efi_signature_nop\t// special NOP to identity as PE/COFF executable 6 b\tprimary_entry\t// branch to kernel start, magic 7 .quad\t0\t// Image load offset from start of RAM, little-endian 8 le64sym\t_kernel_size_le\t// Effective size of kernel image, little-endian 9 le64sym\t_kernel_flags_le\t// Informative flags, little-endian 10 .quad\t0\t// reserved 11 .quad\t0\t// reserved 12 .quad\t0\t// reserved 13 .ascii\tARM64_IMAGE_MAGIC\t// Magic number 14 .long\t.Lpe_header_offset\t// Offset to the PE header. 15 16 __EFI_PE_HEADER 2.2. .init.text 1primary_entry 2preserve_boot_args 3clear_page_tables 4remap_region 5create_idmap 6create_kernel_mapping 7__primary_switched 2.3. .idmap.text 用于恒等映射，需要编译为位置无关码。\n1init_kernel_el 2init_el1 3init_el2 4set_cpu_boot_mode_flag 5secondary_holding_pen 6secondary_entry 7secondary_startup 8__secondary_switched 9__secondary_too_slow 10__enable_mmu 11__cpu_secondary_check52bitva 12__no_granule_support 13__primary_switch 3. 概览：从入口到start_kernel 从入口到start_kernel的部分主要是汇编代码，后续的很多子系统都会依赖这部分代码做的初始化。\n查看6.1和6.6的修改，git diff v6.1 v6.6 -- arch/arm64/kernel/head.S，启动文件arch/arm64/kernel/head.S流程前后对比如下：\n3.1. linux-6.6 1_text() /// 内核启动入口 2\\-- primary_entry() 3 +-- record_mmu_state() /// 记录当前MMU状态，保存到x19 4 +-- preserve_boot_args() /// 保存x0~x3到boot_args[0~3] 5 +-- create_idmap() /// 建立恒等映射init_idmap_pg_dir和内核镜像映射init_pg_dir的页表 6* +-- dcache_clean_poc() /// 清空.idmap.text段数据缓存 7 +-- init_kernel_el() /// 根据内核运行异常等级进行配置，返回启动模式 8 | +-- init_el1() /// 通常情况下从EL1启动内核 9 | \\-- init_el2() /// 从EL2启动内核，用于开启VHE(Virtualization Host Extensions) 10 +-- __cpu_setup() /// 为开启MMU做的CPU初始化 11 \\-- __primary_switch() 12 +-- __enable_mmu() /// 开启MMU，将init_idmap_pg_dir加载到ttbr0，reserved_pg_dir加载到ttbr1 13 +-- clear_page_tables() /// 清空init_pg_dir 14 +-- create_kernel_mapping() /// 填充init_pg_dir 15 +-- load_ttbr1() /// 将init_pg_dir加载到ttbr1 16 \\-- __primary_switched() /// 初始化init_task栈，设置VBAR_EL1，保存FDT地址，计算kimage_voffset，清空bss段 17 +-- set_cpu_boot_mode_flag()/// 设置__boot_cpu_mode变量 18 +-- early_fdt_map() 19 | +-- early_fixmap_init() /// 尝试建立fixmap的页表，可能失败，后边init_feature_override会用到 20 | \\-- fixmap_remap_fdt() /// 如果成功建立fixmap页表，将fdt映射到fixmap的FIX_FDT区域 21 +-- init_feature_override() /// 根据BootLoader传入的bootargs，对一些参数的改写 22 +-- finalise_el2() /// Prefer VHE if possible 23 \\-- start_kernel() /// 跳转到start_kernel执行 24 +-- setup_machine_fdt() 25 +-- arm64_memblock_init() 26 \\-- paging_init() 3.2. linux-6.1 1+-- _text() /// 内核启动入口 2 \\-- primary_entry() 3 +-- preserve_boot_args() /// 保存x0~x3到boot_args[0~3] 4 +-- init_kernel_el() /// 根据内核运行异常等级进行配置，返回启动模式 5 | +-- init_el1() /// 通常情况下从EL1启动内核 6 | \\-- init_el2() /// 从EL2启动内核，用于开启VHE(Virtualization Host Extensions) 7 +-- create_idmap() /// 建立恒等映射init_idmap_pg_dir和内核镜像映射init_pg_dir的页表 8 +-- __cpu_setup() /// 为开启MMU做的CPU初始化 9 \\-- __primary_switch() 10 +-- __enable_mmu() /// 开启MMU，将init_idmap_pg_dir加载到ttbr0，reserved_pg_dir加载到ttbr1 11 +-- clear_page_tables() /// 清空init_pg_dir 12 +-- create_kernel_mapping() /// 填充init_pg_dir 13 +-- load_ttbr1() /// 将init_pg_dir加载到ttbr1 14 \\-- __primary_switched() /// 初始化init_task栈，设置VBAR_EL1，保存FDT地址，计算kimage_voffset，清空bss段 15 +-- set_cpu_boot_mode_flag()/// 设置__boot_cpu_mode变量 16 +-- early_fdt_map() 17 | +-- early_fixmap_init() /// 尝试建立fixmap的页表，可能失败，后边init_feature_override会用到 18 | \\-- fixmap_remap_fdt() /// 如果成功建立fixmap页表，将fdt映射到fixmap的FIX_FDT区域 19 +-- init_feature_override() /// 根据BootLoader传入的bootargs，对一些参数的改写 20 +-- finalise_el2() /// Prefer VHE if possible 21 \\-- start_kernel() /// 跳转到start_kernel执行 如下代码分析来自linux-6.1。\n4. MMU开启之前：primary_entry 在内核启动入口直接跳转到primary_entry，这是MMU开启之前所有函数的总流程。\n1 /* 2 * The following callee saved general purpose registers are used on the 3 * primary lowlevel boot path: 4 * 5 * Register Scope Purpose 6 * x20 primary_entry() .. __primary_switch() CPU boot mode 7 * x21 primary_entry() .. start_kernel() FDT pointer passed at boot in x0 8 * x22 create_idmap() .. start_kernel() ID map VA of the DT blob 9 * x23 primary_entry() .. start_kernel() physical misalignment/KASLR offset 10 * x24 __primary_switch() linear map KASLR seed 11 * x25 primary_entry() .. start_kernel() supported VA size 12 * x28 create_idmap() callee preserved temp register 13 */ 14SYM_CODE_START(primary_entry) 15 bl\tpreserve_boot_args /// 保存启动参数到boot_args数组 16 bl\tinit_kernel_el /// 返回时，w0=cpu_boot_mode 17 mov\tx20, x0 /// 保存cpu_boot_mode到x20 18 bl\tcreate_idmap 19 20 /* 21 * The following calls CPU setup code, see arch/arm64/mm/proc.S for 22 * details. 23 * On return, the CPU will be ready for the MMU to be turned on and 24 * the TCR will have been set. 25 */ 26#if VA_BITS \u0026gt; 48 27 mrs_s\tx0, SYS_ID_AA64MMFR2_EL1 28 tst\tx0, #0xf \u0026lt;\u0026lt; ID_AA64MMFR2_LVA_SHIFT 29 mov\tx0, #VA_BITS 30 mov\tx25, #VA_BITS_MIN 31 csel\tx25, x25, x0, eq 32 mov\tx0, x25 33#endif 34 bl\t__cpu_setup /// 为开启MMU做的CPU初始化 35 b\t__primary_switch 36SYM_CODE_END(primary_entry) 4.1. preserve_boot_args 主要工作是将FDT的基地址保存到x21寄存器，将启动参数（x0~x3）保存到boot_args数组。\n1/* 2 * Preserve the arguments passed by the bootloader in x0 .. x3 3 */ 4SYM_CODE_START_LOCAL(preserve_boot_args) 5 mov\tx21, x0\t/// x21=FDT，x0是uboot传入的第一个参数，记录fdt的基地址，将x0的值保存到x21寄存器备份 6 7 adr_l\tx0, boot_args /// 读取boot_args变量的当前地址到x0，此时MMU处于关闭状态，访问的是物理地址 8 stp\tx21, x1, [x0] /// record the contents of, x0 .. x3 at kernel entry 9 stp\tx2, x3, [x0, #16] /// 将x0~x3保存到boot_args[0~3] 10 11 dmb\tsy /// 确保stp指令完成 12 13 add\tx1, x0, #0x20 /// 4 x 8 bytes，boot_args数组的大小 14 b\tdcache_inval_poc /// 使boot_args[]数组对应的高速缓存失效 15SYM_CODE_END(preserve_boot_args) adr_l是在 arch/arm64/include/asm/assembler.h定义的一个宏，用于操作当前PC值前后4G范围内存。\ndmb sy在全系统高速缓冲范围内做一次内存屏障，保证前面的stp指令运行顺序正确，保证stp在调用dcache_inval_poc前完成。 dcache_inval_poc传入参数为boot_args数组的起始和结束地址，函数的作用是使boot_args数组对应的高速缓存失效，并清除这些缓存。\n1/* 2 *\tdcache_inval_poc(start, end) 3 * 4 * Ensure that any D-cache lines for the interval [start, end) 5 * are invalidated. Any partial lines at the ends of the interval are 6 *\talso cleaned to PoC to prevent data loss. 7 * 8 *\t- start - kernel start address of region 9 *\t- end - kernel end address of region 10 */ 4.2. init_kernel_el 判断启动的模式是EL2还是非安全模式的EL1，并进行相关级别的系统配置(ARMv8中EL2是hypervisor模式，EL1是标准的内核模式)，然后使用w0返回启动模式（BOOT_CPU_MODE_EL1或BOOT_CPU_MODE_EL2）。\n1#define BOOT_CPU_MODE_EL1\t(0xe11) 2#define BOOT_CPU_MODE_EL2\t(0xe12) 3 4/* Current Exception Level values, as contained in CurrentEL */ 5#define CurrentEL_EL1\t(1 \u0026lt;\u0026lt; 2) 6#define CurrentEL_EL2\t(2 \u0026lt;\u0026lt; 2) 1/* 2 * Starting from EL2 or EL1, configure the CPU to execute at the highest 3 * reachable EL supported by the kernel in a chosen default state. If dropping 4 * from EL2 to EL1, configure EL2 before configuring EL1. 5 * 6 * Since we cannot always rely on ERET synchronizing writes to sysregs (e.g. if 7 * SCTLR_ELx.EOS is clear), we place an ISB prior to ERET. 8 * 9 * Returns either BOOT_CPU_MODE_EL1 or BOOT_CPU_MODE_EL2 in x0 if 10 * booted in EL1 or EL2 respectively, with the top 32 bits containing 11 * potential context flags. These flags are *not* stored in __boot_cpu_mode. 12 */ 13SYM_FUNC_START(init_kernel_el) 14 mrs\tx0, CurrentEL /// 读取当前EL等级 15 cmp\tx0, #CurrentEL_EL2 /// 如果是EL2则跳转到init_el2，否则继续向下执行init_el1的代码 16 b.eq\tinit_el2 17 18SYM_INNER_LABEL(init_el1, SYM_L_LOCAL) 19 ... 20 eret 21SYM_INNER_LABEL(init_el2, SYM_L_LOCAL) 22 ... 23 eret 24SYM_FUNC_END(init_kernel_el) 4.2.1. init_el1 配置CPU的大小端模式，将启动模式BOOT_CPU_MODE_EL1写入w0，然后返回到primary_entry。\n1#define INIT_SCTLR_EL1_MMU_OFF \\ 2 (ENDIAN_SET_EL1 | SCTLR_EL1_LSMAOE | SCTLR_EL1_nTLSMD | \\ 3 SCTLR_EL1_EIS | SCTLR_EL1_TSCXT | SCTLR_EL1_EOS) 4 5#define INIT_PSTATE_EL1 \\ 6 (PSR_D_BIT | PSR_A_BIT | PSR_I_BIT | PSR_F_BIT | PSR_MODE_EL1h) 1SYM_INNER_LABEL(init_el1, SYM_L_LOCAL) 2 mov_q\tx0, INIT_SCTLR_EL1_MMU_OFF /// MMU关闭时，对sctlr_el1的赋值 3 msr\tsctlr_el1, x0 /// 配置CPU的大小端模式，EE域用来配置EL1，E0E域用来配置EL0 4 isb /// 配置CPU大小端模式后，确保前面的指令都运行完成 5 mov_q\tx0, INIT_PSTATE_EL1 /// 6 msr\tspsr_el1, x0 /// 将INIT_PSTATE_EL1写入spsr_el1 7 msr\telr_el1, lr /// 将返回地址写入elr_el1，lr是primary_entry中`bl init_kernel_el`的下一条指令地址 8 mov\tw0, #BOOT_CPU_MODE_EL1 /// 记录启动模式 9 eret /// 通过eret来使用ELR_ELx和SPSR_ELx来恢复PC和PSTATE 4.2.2. init_el2 vhe的全称是Virtualization Host Extension support。是armv8.1的新特性，其最终要就是支持type-2的hypervisors 这种扩展让kernel直接跑在el2上，这样可以减少host和guest之间share的寄存器，并减少overhead of virtualization 具体实现如下面的https://lwn.net/Articles/650524\n1SYM_INNER_LABEL(init_el2, SYM_L_LOCAL) 2 mov_q\tx0, HCR_HOST_NVHE_FLAGS 3 msr\thcr_el2, x0 4 isb 5 6 init_el2_state 7 8 /* Hypervisor stub */ 9 adr_l\tx0, __hyp_stub_vectors 10 msr\tvbar_el2, x0 11 isb 12 13 mov_q\tx1, INIT_SCTLR_EL1_MMU_OFF 14 15 /* 16 * Fruity CPUs seem to have HCR_EL2.E2H set to RES1, 17 * making it impossible to start in nVHE mode. Is that 18 * compliant with the architecture? Absolutely not! 19 */ 20 mrs\tx0, hcr_el2 21 and\tx0, x0, #HCR_E2H 22 cbz\tx0, 1f 23 24 /* Set a sane SCTLR_EL1, the VHE way */ 25 msr_s\tSYS_SCTLR_EL12, x1 26 mov\tx2, #BOOT_CPU_FLAG_E2H 27 b\t2f 28 291: 30 msr\tsctlr_el1, x1 31 mov\tx2, xzr 322: 33 msr\telr_el2, lr 34 mov\tw0, #BOOT_CPU_MODE_EL2 35 orr\tx0, x0, x2 36 eret 37SYM_FUNC_END(init_kernel_el) 4.2.2.1. init_el2_state 1/** 2 * Initialize EL2 registers to sane values. This should be called early on all 3 * cores that were booted in EL2. Note that everything gets initialised as 4 * if VHE was not evailable. The kernel context will be upgraded to VHE 5 * if possible later on in the boot process 6 * 7 * Regs: x0, x1 and x2 are clobbered. 8 */ 9.macro init_el2_state 10 __init_el2_sctlr 11 __init_el2_timers 12 __init_el2_debug 13 __init_el2_lor 14 __init_el2_stage2 15 __init_el2_gicv3 16 __init_el2_hstr 17 __init_el2_nvhe_idregs 18 __init_el2_nvhe_cptr 19 __init_el2_fgt 20 __init_el2_nvhe_prepare_eret 21.endm 4.3. create_idmap 填充init_idmap_pg_dir和init_pg_dir页表，这个时候的映射是以块为单位的，每个块大小为2M。在开启MMU时，init_idmap_pg_dir会被加载到ttbr0。\ninit_idmap_pg_dir用于恒等映射，就是虚拟地址和物理地址相同的映射。linux-6.1的init_idmap_pg_dir替代了早期版本的idmap_pg_dir。之前版本的idmap_pg_dir只会映射idmap.text段，而init_idmap_pg_dir会映射整个内核镜像，在内核镜像之后，还会映射FDT，所以init_idmap_pg_dir映射的空间会比内核镜像大一些。 create_idmap首先将整个区间（包含内核镜像和FDT）映射为RX属性，再将init_pg_dir~init_pg_end重新映射为RW属性，最后把FDT以RW属性映射到内核镜像之后。\n4.4. __cpu_setup 代码位于 arch/arm64/mm/proc.S。是为开启MMU而初始化处理器相关的代码，配置MMU，配置访问权限，内存地址划分等。 在虚拟地址小于48bit时，调用此函数前，x0记录虚拟地址位数。函数返回时x0记录了SCTLR_EL1要写入的值，最后传给__enable_mmu。\n1/* 2 *\t__cpu_setup 3 * 4 *\tInitialise the processor for turning the MMU on. 5 * 6 * Input: 7 *\tx0 - actual number of VA bits (ignored unless VA_BITS \u0026gt; 48) 8 * Output: 9 *\tReturn in x0 the value of the SCTLR_EL1 register. 10 */ 5. 开启MMU：__primary_switch __primary_switch表示重要的切换，这个非常重要的切换就是开启MMU。开启MMU(__enable_mmu)前，CPU访问的是物理地址，__enable_mmu之后，CPU访问的是虚拟地址。这个虚拟地址最高位为0，使用的是TTBR0，而此时TTBR0执行的页表是init_idmap_pg_dir。而reserved_pg_dir这个时候还没有填充。\n1SYM_FUNC_START_LOCAL(__primary_switch) 2 adrp\tx1, reserved_pg_dir /// ttbr1 3 adrp\tx2, init_idmap_pg_dir /// ttbr0 4 bl\t__enable_mmu /// 开启MMU 5#ifdef CONFIG_RELOCATABLE 6 adrp\tx23, KERNEL_START 7 and\tx23, x23, MIN_KIMG_ALIGN - 1 8#ifdef CONFIG_RANDOMIZE_BASE 9 mov\tx0, x22 10 adrp\tx1, init_pg_end 11 mov\tsp, x1 12 mov\tx29, xzr 13 /// kaslr_early_init@arch/arm64/kernel/pi/kaslr_early.c 14 /// OBJCOPYFLAGS := --prefix-symbols=__pi_ 15 bl\t__pi_kaslr_early_init 16 and\tx24, x0, #SZ_2M - 1\t// capture memstart offset seed 17 bic\tx0, x0, #SZ_2M - 1 18 orr\tx23, x23, x0\t// record kernel offset 19#endif 20#endif 21 bl\tclear_page_tables /// 清空init_pg_dir 22 bl\tcreate_kernel_mapping /// 填充init_pg_dir 23 24 adrp\tx1, init_pg_dir 25 load_ttbr1 x1, x1, x2 /// 加载init_pg_dir到ttbr1，为跳转到新的地址做准备 26#ifdef CONFIG_RELOCATABLE 27 bl\t__relocate_kernel 28#endif 29 ldr\tx8, =__primary_switched /// __primary_switched编译时的地址，如果使能了CONFIG_RELOCATABLE，__relocate_kernel会给__primary_switched加上一个偏移 30 adrp\tx0, KERNEL_START\t// __pa(KERNEL_START) /// 运行时的物理地址 31 br\tx8 /// 跳转到__primary_switched虚拟地址运行 32SYM_FUNC_END(__primary_switch) 在 __primary_switch的最后，使用 adrp x0, KERNEL_START记录了 _text的地址，也就是内核镜像起始的物理地址。\n1#define KERNEL_START\t_text 2#define KERNEL_END\t_end 5.1. __enable_mmu 主要工作：\n检查CPU是否支持软件设置的页面大小，如果不支持，CPU会在停止在这里。 将init_idmap_pg_dir和reserved_pg_dir分别加载到TTBR0_EL1和TTBR1_EL1。 开启MMU，并使本地icache失效。 1/* 2 * Enable the MMU. 3 * 4 * x0 = SCTLR_EL1 value for turning on the MMU. 5 * x1 = TTBR1_EL1 value 6 * x2 = ID map root table address 7 * 8 * Returns to the caller via x30/lr. This requires the caller to be covered 9 * by the .idmap.text section. 10 * 11 * Checks if the selected granule size is supported by the CPU. 12 * If it isn\u0026#39;t, park the CPU 13 */ 14SYM_FUNC_START(__enable_mmu) 15 mrs\tx3, ID_AA64MMFR0_EL1 16 ubfx\tx3, x3, #ID_AA64MMFR0_EL1_TGRAN_SHIFT, 4 17 cmp x3, #ID_AA64MMFR0_EL1_TGRAN_SUPPORTED_MIN 18 b.lt __no_granule_support 19 cmp x3, #ID_AA64MMFR0_EL1_TGRAN_SUPPORTED_MAX 20 b.gt __no_granule_support 21 phys_to_ttbr x2, x2 22 msr\tttbr0_el1, x2\t// load TTBR0 23 load_ttbr1 x1, x1, x3 24 25 set_sctlr_el1\tx0 26 27 ret 28SYM_FUNC_END(__enable_mmu) 1SYM_FUNC_START_LOCAL(__no_granule_support) 2 /* Indicate that this CPU can\u0026#39;t boot and is stuck in the kernel */ 3 update_early_cpu_boot_status \\ 4 CPU_STUCK_IN_KERNEL | CPU_STUCK_REASON_NO_GRAN, x1, x2 51: 6 wfe 7 wfi 8 b\t1b 9SYM_FUNC_END(__no_granule_support) 5.2. clear_page_tables create_idmap填充了init_pg_dir，这里对init_pg_dir进行清零。\nmemset(init_pg_dir, 0, init_pg_end - init_pg_dir)\n1SYM_FUNC_START_LOCAL(clear_page_tables) 2 /* 3 * Clear the init page tables. 4 */ 5 adrp\tx0, init_pg_dir /// 起始地址 6 adrp\tx1, init_pg_end /// 结束地址 7 sub\tx2, x1, x0 8 mov\tx1, xzr /// xzr是一个特殊寄存器，读取时值为0 9 b\t__pi_memset\t// tail call 10SYM_FUNC_END(clear_page_tables) 5.3. create_kernel_mapping 创建内核镜像映射，填充init_pg_dir，注意此时还是使用的块映射。\n6. 开启MMU之后：__primary_switched 开启MMU之后，CPU访问的是虚拟地址。\n准备0号进程内核栈 VBAR_EL1中断向量表配置 计算kimage_voffset 保存CPU启动模式 清空BSS段 尝试fixmap映射 解析boot_args中CPU相关的一些特性，并修改默认值 跳转到start_kernel。 1/* 2 * The following fragment of code is executed with the MMU enabled. 3 * 4 * x0 = __pa(KERNEL_START) 5 */ 6SYM_FUNC_START_LOCAL(__primary_switched) 6.1. 初始化init_task栈空间 主要工作：\n设置SP_EL0、SP_ELx、x29(FP)寄存器，配置init_task的栈 将per_cpu_offset写入TPIDR_ELx 1 adr_l\tx4, init_task 2 init_cpu_task x4, x5, x6 6.1.1. init_cpu_task 先看一下涉及到的几个宏。arch/arm64/kernel/asm-offsets.c\n1#define TSK_TI_CPU 16 /* offsetof(struct task_struct, thread_info.cpu) */ 2#define TSK_STACK 32 /* offsetof(struct task_struct, stack) */ 3#define S_STACKFRAME 304 /* offsetof(struct pt_regs, stackframe) */ 4#define PT_REGS_SIZE 336 /* sizeof(struct pt_regs) */ 在task_pt_regs(current)-\u0026gt;stackframe创建一个最终帧记录，这样unwinder就可以根据任务堆栈中的位置来识别任何任务的最终帧记录。保留整个pt_regs空间使用户任务和kthread保持一致性。\n1 /* 2 * Initialize CPU registers with task-specific and cpu-specific context. 3 * 4 * Create a final frame record at task_pt_regs(current)-\u0026gt;stackframe, so 5 * that the unwinder can identify the final frame record of any task by 6 * its location in the task stack. We reserve the entire pt_regs space 7 * for consistency with user tasks and kthreads. 8 */ 9 .macro\tinit_cpu_task tsk, tmp1, tmp2 10 msr\tsp_el0, \\tsk /// 将init_task的地址写入sp_el0，内核运行于EL2或EL1，内核中会使用sp_el0来作为current 11 12 ldr\t\\tmp1, [\\tsk, #TSK_STACK] /// 获取init_task的栈地址，offsetof(struct task_struct, stack) 13 add\tsp, \\tmp1, #THREAD_SIZE /// 栈是由高地址向下生长的，所以SP_ELx要加上THREAD_SIZE，init_task的栈是静态分配的，它指向init_stack这是一个数组。 14 sub\tsp, sp, #PT_REGS_SIZE /// 为struct pt_regs留出空间 15 16 stp\txzr, xzr, [sp, #S_STACKFRAME] /// 将struct pt_regs的u64 stackframe[2]清零 17 add\tx29, sp, #S_STACKFRAME /// x29(FP)指向栈中pt_regs的stackframe 18 19 scs_load \\tsk /// 此处为空操作，详细信息可以参考arch/Kconfig中的SHADOW_CALL_STACK 20 21 adr_l\t\\tmp1, __per_cpu_offset /// 读取__per_cpu_offset[NR_CPUS]数组基地址 22 ldr\tw\\tmp2, [\\tsk, #TSK_TI_CPU] /// offsetof(struct task_struct, thread_info.cpu) 23 ldr\t\\tmp1, [\\tmp1, \\tmp2, lsl #3] /// tmp1 = __per_cpu_offset[init_task.cpu \u0026lt;\u0026lt; 3]，通常来说，bootcpu为0 24 set_this_cpu_offset \\tmp1 /// 将当前cpu的per_cpu变量的offset值写入TPIDR_ELx 25 .endm 几个寄存器的最终结果：\nSP_EL0 = \u0026amp;init_task SP_ELx = init_task.stack + THREAD_SIZE - sizeof(struct pt_regs) x29(FP) = SP_ELx + S_STACKFRAME\n6.2. 中断向量基地址寄存器配置 将中断向量表的起始虚拟地址写入到VBAR_EL1。\n1 adr_l\tx8, vectors\t// load VBAR_EL1 with virtual 2 msr\tvbar_el1, x8\t// vector table address 3 isb 6.3. 备份fp和lr寄存器 此时sp的值为 init_task.stack + THREAD_SIZE - sizeof(struct pt_regs)。主要工作如下：\n将x29(FP)和x30(LR)分别保存到 sp-16和 sp-8的地址上，然后 sp -= 16。 将sp的值写入到x29(FP) 这是实现了ARM64函数调用标准规定的栈布局，为后续函数调用的入栈出栈做好了准备。\n1 stp\tx29, x30, [sp, #-16]! 2 mov\tx29, sp 6.4. 保存设备树物理地址到__fdt_pointer __fdt_pointer是一个全局变量，在后续进行FDT映射时需要用到。\n1 str_l\tx21, __fdt_pointer, x5\t// Save FDT pointer 6.5. 计算kimage_voffset arch/arm64/mm/mmu.c。\n1u64 kimage_vaddr __ro_after_init = (u64)\u0026amp;_text; 2EXPORT_SYMBOL(kimage_vaddr); 3 4u64 kimage_voffset __ro_after_init; 5EXPORT_SYMBOL(kimage_voffset); kimage_voffset记录了内核镜像映射后的虚拟地址与内核镜像在内存中的物理地址之间的差值。kimage_vaddr记录了 _text的链接地址，也就是最终 _text的虚拟地址（如果使能了CONFIG_RELOCATE，此值会在运行过程中改变），x0作为传入参数记录了 _text的物理地址，相减即可得到 kimage_voffset。\n1 ldr_l\tx4, kimage_vaddr\t// Save the offset between 2 sub\tx4, x4, x0\t// the kernel virtual and 3 str_l\tx4, kimage_voffset, x5\t// physical mappings 6.6. set_cpu_boot_mode_flag 将启动时的特权级别保存到__boot_cpu_mode[2]全局数组。 早期版本的内核set_cpu_boot_mode_flag会在primary_entry中执行，set_cpu_boot_mode_flag会在ret之前调用 dmb sy和 dc ivac, x1来保证指令执行顺序和使高速缓存失效。 6.1版本内核改到了在 __primary_switched中执行，等到清空bss段后，通过 dsb\tishst完成高速缓存的失效操作。\n1/* 2 * Sets the __boot_cpu_mode flag depending on the CPU boot mode passed 3 * in w0. See arch/arm64/include/asm/virt.h for more info. 4 */ 5SYM_FUNC_START_LOCAL(set_cpu_boot_mode_flag) 6 adr_l\tx1, __boot_cpu_mode /// x1记录__boot_cpu_mode[]的起始地址 7 cmp\tw0, #BOOT_CPU_MODE_EL2 /// w0记录启动时的异常等级 8 b.ne\t1f /// 如果不是从EL2启动，则跳转到1处 9 add\tx1, x1, #4 /// 如果是从EL2启动，地址指向__boot_cpu_mode[1] 10 /// 保存启动模式到x1指向的地址，如果是从EL1启动，地址指向__boot_cpu_mode[0] 111:\tstr\tw0, [x1]\t// Save CPU boot mode 12 ret 13SYM_FUNC_END(set_cpu_boot_mode_flag) 简化的C语言伪代码：\n1 u32 *x1 = \u0026amp;__boot_cpu_mode[0]; 2 if (w0 == BOOT_CPU_MODE_EL2) { 3 x1++; // *x1 = \u0026amp;__boot_cpu_mode[1] 4 } 5 *x1 = w0; 最终结果与如下代码相同\n1 if (w0 == BOOT_CPU_MODE_EL2) { 2 __boot_cpu_mode[1] = BOOT_CPU_MODE_EL2; 3 } else { 4 __boot_cpu_mode[0] = BOOT_CPU_MODE_EL1; 5 } 6.7. 清空BSS段 清空BSS后，要使高速缓存失效。\n1 // Clear BSS 2 adr_l\tx0, __bss_start /// 起始地址 3 mov\tx1, xzr /// 要写入的值，xzr是一个特殊的寄存器，值为64位的0 4 adr_l\tx2, __bss_stop /// 结束地址 5 sub\tx2, x2, x0 /// size = __bss_stop - __bss_start 6 bl\t__pi_memset /// memset(x0, x1, x2) 7 dsb\tishst\t// Make zero page visible to PTW 6.8. 一些其他工作 1#if VA_BITS \u0026gt; 48 2 adr_l\tx8, vabits_actual\t// Set this early so KASAN early init 3 str\tx25, [x8]\t// ... observes the correct value 4 dc\tcivac, x8\t// Make visible to booting secondaries 5#endif 6 7#ifdef CONFIG_RANDOMIZE_BASE 8 adrp\tx5, memstart_offset_seed\t// Save KASLR linear map seed 9 strh\tw24, [x5, :lo12:memstart_offset_seed] 10#endif 11#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS) 12 bl\tkasan_early_init 13#endif 6.9. early_fdt_map 尝试建立fixmap的页表，可能失败，后边init_feature_override会用到。 如果失败，会在setup_arch通过early_fixmap_init重新映射。\n1 mov\tx0, x21\t// pass FDT address in x0 2 bl\tearly_fdt_map\t// Try mapping the FDT early 6.10. init_feature_override 根据BootLoader传入的bootargs参数，对一些参数的改写。\n1 mov\tx0, x20\t// pass the full boot status 2 bl\tinit_feature_override\t// Parse cpu feature overrides 6.11. finalise_el2 1 mov\tx0, x20 2 bl\tfinalise_el2\t// Prefer VHE if possible 6.12. 跳转start_kernel 从栈中恢复x29(FP)和x30(LR)，sp重新指向 init_task.stack + THREAD_SIZE - sizeof(struct pt_regs)。\n1 ldp\tx29, x30, [sp], #16 /// 从栈中恢复x29(FP)和x30(LR)，sp += 16 2 bl\tstart_kernel /// 跳转到start_kernel 3 ASM_BUG() /// 如果start_kernel返回到这里说明出错了 4SYM_FUNC_END(__primary_switched) 7. 参考资料 Documentation/arm64/booting.rst Documentation/translations/zh_CN/arm64/booting.txt Linux 内核启动分析-BugMan-ChinaUnix博客 中断管理基础学习笔记 - 5.1 ARM64底层中断处理 Linux kernel ARM64 寄存器tpidr_el1 的用处 arm64: Extract early FDT mapping from kaslr_early_init() kernel启动流程-head.S的执行_4.el2_setup_kernel5.10 内核流程 ","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/code_text_colorful_140555_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/04-kernel/linux-6.6/boot/entry/","series":[{"title":"启动流程","url":"/zh-cn/series/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"smallImg":"","tags":[{"title":"linux内核","url":"/zh-cn/tags/linux%E5%86%85%E6%A0%B8/"},{"title":"启动流程","url":"/zh-cn/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"timestamp":1672358400,"title":"内核启动流程（一）"},{"categories":[{"title":"启动流程","url":"/zh-cn/categories/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"content":" 1. 启动流程 1.1. bootrom 芯片上电后，会自动执行bootrom代码，bootrom是各家厂商定制的，但完成的工作基本相同。bootrom通常支持从多种不同的介质启动，如SD卡、NADN、eMMC、USB等。以Exynos4412为例，bootrom会读取OM引脚指定的启动介质。以eMMC为例，eMMC分为boot0、boot1、RPMB和user四个物理分区，四个物理分区独立寻址。可以通过寄存器指定eMMC的bootmode，也就是eMMC启动时，读取那个物理分区的数据。这就需要根据厂家需要，提前设置eMMC的寄存器。对于Exynos4412来说，bootrom会去读boot0分区的内容。\n短接emmc clk到GND会使emmc启动识别，fallback到其他启动模式，可以进行救砖刷机。\n1.2. BootLoader 在bootrom运行时，使用的是芯片内部的SRAM，SRAM不需要初始化，但容量比较小。 BootLoader通常会分为多个阶段，每个阶段有自己独立的镜像文件。以U-Boot的SPL（Secondary Program Loader）为例，SPL镜像体积较小，可以在启动时被加载的SRAM执行，完成基本的外设初始化和DDR初始化后，可以读取完整U-Boot镜像到DDR中执行，由U-Boot初始化更多的外设、实现更多更复杂的功能。最后，U-Boot读取Kernel镜像、Kernel启动参数或dtb镜像、rootfs镜像，并跳转到Kernel执行。\n1.3. Kernel 跳转到Kernel后\n建立页表 开启MMU 配置bootcpu的idle线程，之后的处理在idle线程的上下文执行 跳转到start_kernel，完成一些重要的初始 start_kernel的最后fork 1号进程(init)和2号进程(kthreadd)，之后的初始化主要1号进程的上下文指向 1号进程会进一步做一下初始化，其中包括设备驱动的初始化，为每个处理创建idle线程等，其中很多初始化会通过创建新的kthread线程来完成 挂载rootfs fork 1号进程，并最终启动rootfs中的init程序，作为用户态的1号进程 1.4. Init 用户态的init程序有多种选择，比如busybox、systemd、SysV等。init启动后，会fork出各个用户进程，直到整个系统启动。\n","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/bubbles_drops_macro_126764_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/03-boot/u-boot/boot_flow/","series":[{"title":"启动流程","url":"/zh-cn/series/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"smallImg":"","tags":[{"title":"启动流程","url":"/zh-cn/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}],"timestamp":1672358400,"title":"嵌入式系统启动流程"},{"categories":[{"title":"C语言","url":"/zh-cn/categories/c%E8%AF%AD%E8%A8%80/"}],"content":" 1. 测试结果 分别声明一个一维数组a1[8]和二维数组a2[4][8]，查看各个表达式的类型、地址、与首地址的差值，以及内存地址内存储的int变量值。数组内变量的低8位记录数组的行号和列号，其中高4位为行，低4位为列。先看一下测试程序给出的结果。\n一维数组\n1int a1[8]; 2sizeof(a1): 32(0x20) var typeof(var) (void *)(var) offset *(int *)(var) a1 int * 0x7ffe2034d2d0 0x00 0x00 \u0026amp;a1 int (*)[8] 0x7ffe2034d2d0 0x00 0x00 \u0026amp;a1[0] int * 0x7ffe2034d2d0 0x00 0x00 a1 + 1 int * 0x7ffe2034d2d4 0x04 0x01 \u0026amp;a1 + 1 int (*)[8] 0x7ffe2034d2f0 0x20 0x20 \u0026amp;a1[0] + 1 int * 0x7ffe2034d2d4 0x04 0x01 二维数组\n1int a2[4][8]; 2sizeof(a2): 128(0x80) var typeof(var) (void *)(var) offset *(int *)(var) a2 int (*)[8] 0x7ffe2034d250 0x00 0x00 a2[0] int * 0x7ffe2034d250 0x00 0x00 \u0026amp;a2 int (*)[4][8] 0x7ffe2034d250 0x00 0x00 \u0026amp;a2[0] int (*)[8] 0x7ffe2034d250 0x00 0x00 \u0026amp;a2[0][0] int * 0x7ffe2034d250 0x00 0x00 a2 + 1 int (*)[8] 0x7ffe2034d270 0x20 0x10 a2[0] + 1 int * 0x7ffe2034d254 0x04 0x01 \u0026amp;a2 + 1 int (*)[4][8] 0x7ffe2034d2d0 0x80 0x00 \u0026amp;a2[0] + 1 int (*)[8] 0x7ffe2034d270 0x20 0x10 \u0026amp;a2[0][0] + 1 int * 0x7ffe2034d254 0x04 0x01 (a2 + 1) + 1 int (*)[8] 0x7ffe2034d290 0x40 0x20 (\u0026amp;a2 + 1) + 1 int (*)[4][8] 0x7ffe2034d350 0x100 0x00 (\u0026amp;a2[0] + 1) + 1 int (*)[8] 0x7ffe2034d290 0x40 0x20 2. 结果分析 2.1. 数组名a总是被视为一个一维数组 一维数组a1[8]的类型为int *，而二维数组a2[4][8]的类型为int (*)[8]，意思是每个数组元素为一个长度为8的数组，如a2[0]表示第0个子数组。\n2.2. a、\u0026a、\u0026a[0]、\u0026a[0][0]值相同 表达式 含义 a 代表整个数组，值为数组的起始地址 \u0026amp;a 取整个数组的地址 \u0026amp;a[0] 数组首元素a[0]的地址。对于一维数组，是数组首元素的地址；对于二维数组，是子维度数组的首地址 2.3. 数据类型不同 类型不同体现在做加减运算时\n表达式 含义 a + 1 下一个元素的地址。对于一维数组，是下一个数组元素地址；对于二维数组，是下一个子维度数组的首地址 \u0026amp;a + 1 跳过整个数组（不论一维还是多维），相当于指针指向数组首地址 + sizeof(a)处。实际上这部分不属于这个数组 \u0026amp;a[0] + 1 同a + 1 3. 测试代码 测试代码中__check传入参数为char *，编译时添加-Wall选项，可以触发编译器类型检测，打印出变量的实际类型。\n测试程序运行后，会按照Markdown表格的形式输出结果，整理编译输出和程序输出可以得到上边的测试结果。\n编译命令\n1gcc -Wall array_type.c 2\u0026gt;\u0026amp;1 | grep \u0026#39; int\u0026#39; | sed -e \u0026#39;s%.*int%int%g\u0026#39; 2./a.out 测试程序源码\n1 2#include \u0026lt;stdio.h\u0026gt; 3 4static inline void __check(char *a) { } 5 6#define to_var(x) ((unsigned long)(void *)(x) \u0026gt; 0xFF ? *(int *)(x) : 0xFF) 7#define to_off(base, x) ((unsigned long)(x) - (unsigned long)(base)) 8 9#define __pr(base, a) \\ 10 do { \\ 11 __check(a); \\ 12 printf(\u0026#34;| %-16s| | %p | 0x%02lX | 0x%02X |\\n\u0026#34;, \\ 13 #a, (void *)(a), to_off(base, a), to_var(a)); \\ 14 } while (0) 15 16 17int main(void) 18{ 19 unsigned long size; 20 int i, j; 21 int a1[8]; 22 int a2[4][8]; 23 24 for (i = 0; i \u0026lt; 8; i++) { 25 a1[i] = i; 26 } 27 for (i = 0; i \u0026lt; 4; i++) { 28 for (j = 0; j \u0026lt; 8; j++) { 29 a2[i][j] = (i \u0026lt;\u0026lt; 4) | j; 30 } 31 } 32 33 size = (unsigned long)sizeof(a1); 34 printf(\u0026#34;sizeof(a1): %lu(0x%lX)\\n\u0026#34;, size, size); 35 printf(\u0026#34;| var | typeof(var) | (void *)(var) | offset | *(int *)(var) |\\n\u0026#34;); 36 printf(\u0026#34;| :------| :---------- | :-------------- | :-----: | :-----------: |\\n\u0026#34;); 37 38 __pr(a1, a1); 39 40 __pr(a1, \u0026amp;a1); 41 __pr(a1, \u0026amp;a1[0]); 42 43 __pr(a1, a1 + 1); 44 __pr(a1, \u0026amp;a1 + 1); 45 __pr(a1, \u0026amp;a1[0] + 1); 46 47 48 size = (unsigned long)sizeof(a2); 49 printf(\u0026#34;sizeof(a2): %lu(0x%lX)\\n\u0026#34;, size, size); 50 printf(\u0026#34;| var | typeof(var) | (void *)(var) | offset | *(int *)(var) |\\n\u0026#34;); 51 printf(\u0026#34;| :------| :---------- | :-------------- | :-----: | :-----------: |\\n\u0026#34;); 52 53 __pr(a2, a2); 54 __pr(a2, a2[0]); 55 56 __pr(a2, \u0026amp;a2); 57 __pr(a2, \u0026amp;a2[0]); 58 __pr(a2, \u0026amp;a2[0][0]); 59 60 __pr(a2, a2 + 1); 61 __pr(a2, a2[0] + 1); 62 63 __pr(a2, \u0026amp;a2 + 1); 64 __pr(a2, \u0026amp;a2[0] + 1); 65 __pr(a2, \u0026amp;a2[0][0] + 1); 66 67 __pr(a2, (a2 + 1) + 1); 68 __pr(a2, (\u0026amp;a2 + 1) + 1); 69 __pr(a2, (\u0026amp;a2[0] + 1) + 1); 70 71 return 0; 72} 参考资料 数组中\u0026amp;a与\u0026amp;a[0]的区别 C语言基础知识：a a[0] \u0026amp;a \u0026amp;a[0] ","date":"December 30, 2022","img":"https://kingdix10.github.io/covers/scheme_glow_blue_140190_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/05-program/ccpp/array_type/","series":[{"title":"C语言","url":"/zh-cn/series/c%E8%AF%AD%E8%A8%80/"}],"smallImg":"","tags":[{"title":"C语言","url":"/zh-cn/tags/c%E8%AF%AD%E8%A8%80/"},{"title":"数组","url":"/zh-cn/tags/%E6%95%B0%E7%BB%84/"}],"timestamp":1672358400,"title":"数组a、\u0026a、\u0026a[0]、\u0026a[0][0]的区别与联系"},{"categories":[{"title":"linux命令","url":"/zh-cn/categories/linux%E5%91%BD%E4%BB%A4/"}],"content":" 1. 准备工作 如果是虚拟机中安装的Linux系统，需要新建一个网络适配器，模式为桥接模式。\n如果是独立的物理机安装了Linux系统，可以在路由器或交换机中，将物理机的IP地址设为固定的IP地址。\n1.1. 查看Linux IP地址 使用ip addr或ifconfig查看Linux系统IP地址。这个在Windows映射磁盘时会用到。\n2. Linux搭建samba服务器 如下操作可以使用smb_conf.sh完成。\n2.1. 安装samba服务 1sudo apt install samba 2.2. 创建samba用户 执行sudo smbpasswd –a username，根据提示，输入密码，username和密码会在Windows映射磁盘时用到。username需要是系统中已存在的用户。\n2.3. 修改samba配置文件 修改/etc/samba/smb.conf文件，添加如下内容，其中[]中是自定义共享路径名，在Windows下映射磁盘时会用到。\n1[share_name] 2 path = 需要共享的目录路径 3 writable = yes 4# 以下可选 5 browseable = yes 6 guest ok = yes 7 write list = username 8 create mask = 0644 9 directory mask = 0755 2.4. 重启samba服务 1sudo /etc/init.d/smbd restart 3. 访问samba 3.1. Windows映射磁盘 进入我的电脑-\u0026gt;映射网络驱动器 选择相应的驱动器，其实就是选择盘符 文件夹部分填写\\\\\u0026lt;ip_addr\u0026gt;\\share_name，其中IP地址为Linux系统地址，share_name为smb.conf中自定义的共享文件夹名称。 勾选使用其他凭据连接，输入创建samba用户时的用户名和密码。完成后在我的电脑中会增加一个网络磁盘，就可以像访问C盘、D盘下的文件来访问Linux下的文件。 3.2. Linux挂载 1MP=/mnt/smb_share 2mkdir -p ${MP} 3mount -t cifs //${IPADDR}/share ${MP} \\ 4 -o rw,noatime,nodiratime,file_mode=0644,dir_mode=0755,gid=1000,uid=1000,,username=${USERNAME},pass=${PASSWORD} ","date":"January 9, 2022","img":"https://kingdix10.github.io/covers/iridescent_colorful_lines_130978_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/02-dev_env/samba/","series":[{"title":"linux命令","url":"/zh-cn/series/linux%E5%91%BD%E4%BB%A4/"}],"smallImg":"","tags":[{"title":"samba","url":"/zh-cn/tags/samba/"},{"title":"linux命令","url":"/zh-cn/tags/linux%E5%91%BD%E4%BB%A4/"}],"timestamp":1641686400,"title":"samba服务器搭建和使用"},{"categories":[{"title":"u-boot","url":"/zh-cn/categories/u-boot/"}],"content":" 1. U-Boot版本 1VERSION = 2021 2PATCHLEVEL = 10 3SUBLEVEL = 4EXTRAVERSION = 5NAME = 2. 涉及的文件 include/_exports.h，辅助文件，在包含_exports.h前，定义不同的EXPORT_FUNC来实现不同的功能，其内容为一系列EXPORT_FUNC修饰的函数。 include/exports.h，函数声明。 examples/standalone/stubs.c，用于建立jumptable，将U-Boot的函数指针存入jumptable中。 common/exports.c，初始化jumptable。 examples/standalone/hello_world.c，独立于U-Boot的程序代码，编译目标文件为单独的bin，可以调用U-Boot的函数。 类似的还有kernel的include/uapi/asm-generic/unistd.h文件（以v5.15为例）。\n3. 原理 EXPORT_FUNC巧妙的借助了C语言中的宏来实现，通过对同一个宏进行不同的定义，使得编译器在预处理阶段产生不同的代码，使用尽量少的代码来实现不同的功能。\n在包含_exports.h前，定义不同的EXPORT_FUNC。\n3.1. include/exports.h 1struct jt_funcs { 2#define EXPORT_FUNC(impl, res, func, ...) res(*func)(__VA_ARGS__); 3#include \u0026lt;_exports.h\u0026gt; 4#undef EXPORT_FUNC 5}; 3.2. common/exports.c 1#define EXPORT_FUNC(f, a, x, ...) gd-\u0026gt;jt-\u0026gt;x = f; 2 3int jumptable_init(void) 4{ 5\tgd-\u0026gt;jt = malloc(sizeof(struct jt_funcs)); 6#include \u0026lt;_exports.h\u0026gt; 7 8\treturn 0; 9} 3.3. examples/standalone/stubs.c 1#ifdef CONFIG_ARM64 2/* 3 * x18 holds the pointer to the global_data, x9 is a call-clobbered 4 * register 5 */ 6#define EXPORT_FUNC(f, a, x, ...) \\ 7\tasm volatile (\t\\ 8\u0026#34;\t.globl \u0026#34; #x \u0026#34;\\n\u0026#34;\t\\ 9#x \u0026#34;:\\n\u0026#34;\t\\ 10\u0026#34;\tldr\tx9, [x18, %0]\\n\u0026#34;\t\\ 11\u0026#34;\tldr\tx9, [x9, %1]\\n\u0026#34;\t\\ 12\u0026#34;\tbr\tx9\\n\u0026#34;\t\\ 13\t: : \u0026#34;i\u0026#34;(offsetof(gd_t, jt)), \u0026#34;i\u0026#34;(FO(x)) : \u0026#34;x9\u0026#34;); 14#else 15/* 16 * r9 holds the pointer to the global_data, ip is a call-clobbered 17 * register 18 */ 19#define EXPORT_FUNC(f, a, x, ...) \\ 20\tasm volatile (\t\\ 21\u0026#34;\t.globl \u0026#34; #x \u0026#34;\\n\u0026#34;\t\\ 22#x \u0026#34;:\\n\u0026#34;\t\\ 23\u0026#34;\tldr\tip, [r9, %0]\\n\u0026#34;\t\\ 24\u0026#34;\tldr\tpc, [ip, %1]\\n\u0026#34;\t\\ 25\t: : \u0026#34;i\u0026#34;(offsetof(gd_t, jt)), \u0026#34;i\u0026#34;(FO(x)) : \u0026#34;ip\u0026#34;); 26#endif 27 28void __attribute__((unused)) dummy(void) 29{ 30#include \u0026lt;_exports.h\u0026gt; 31} ","date":"January 9, 2022","img":"https://kingdix10.github.io/covers/drone_camera_technology_171576_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/03-boot/u-boot/u-boot-stubs/","series":[{"title":"u-boot","url":"/zh-cn/series/u-boot/"}],"smallImg":"","tags":[{"title":"u-boot","url":"/zh-cn/tags/u-boot/"}],"timestamp":1641686400,"title":"u-boot的stubs机制"},{"categories":[{"title":"linux命令","url":"/zh-cn/categories/linux%E5%91%BD%E4%BB%A4/"},{"title":"文件管理","url":"/zh-cn/categories/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"}],"content":" 1. 打包隐藏文件 1tar -czf data.tar.gz ./.[!.]* 2. find 2.1. 查找文件并按大小排序 1find -type f -name \u0026#39;*.md\u0026#39; -printf \u0026#39;%s\\t%p\\n\u0026#39; | grep -v \u0026#39;\\.git\u0026#39; | sort -nr | less -N 2.2. 批量删除7天前的文件 1find -type f -mtime +7 -exec rm -rf {} \\; 2find -type f -mtime +7 -exec rm -fr {} \\; 2.3. 多个条件(-o) find ./ -name \u0026lsquo;.c\u0026rsquo; -o -name \u0026lsquo;.h\u0026rsquo; find ./ -name \u0026lsquo;*.[ch];\n2.4. 忽略大小写(-iname) find ./ -iname \u0026lsquo;makefile\u0026rsquo;\n3. 文件监控inotify 1sudo apt install inotify-tools 监控文件的打开关闭次数\n1inotifywatch -v -e open -e close -t 60 -r $(pwd)/test.c 4. 文件查重工具fdupes 4.1. 保留最早的文件 1fdupes --recurse --noempty --nohidden --size --time --minsize=10240000 --log=del10M.log -d -N 4.2. 保留最新的文件 1fdupes --recurse --reverse --noempty --nohidden --size --time --minsize=10240000 --log=del10M.log -d -N 4.3. 其他 1fdupes -r -S -t -n -G 1000000 01-document/ zzzzzzzzzz/01-document/ \u0026gt; doc.log 2fdupes -r -S -t -n -G 1000 -L 1000000 01-document/ zzzzzzzzzz/01-document/ \u0026gt; doc.log 3fdupes -r -S -t -n -o name 04-personal/photos/ /export/new/photos-mage20/ \u0026gt; photos.log 4.4. 帮助信息 1Usage: fdupes [options] DIRECTORY... 2 3 -r --recurse for every directory given follow subdirectories 4 encountered within 5 -R --recurse: for each directory given after this option follow 6 subdirectories encountered within (note the \u0026#39;:\u0026#39; at the 7 end of the option, manpage for more details) 8 -s --symlinks follow symlinks 9 -H --hardlinks normally, when two or more files point to the same 10 disk area they are treated as non-duplicates; this 11 option will change this behavior 12 -G --minsize=SIZE consider only files greater than or equal to SIZE bytes 13 -L --maxsize=SIZE consider only files less than or equal to SIZE bytes 14 -n --noempty exclude zero-length files from consideration 15 -A --nohidden exclude hidden files from consideration 16 -f --omitfirst omit the first file in each set of matches 17 -1 --sameline list each set of matches on a single line 18 -S --size show size of duplicate files 19 -t --time show modification time of duplicate files 20 -m --summarize summarize dupe information 21 -q --quiet hide progress indicator 22 -d --delete prompt user for files to preserve and delete all 23 others; important: under particular circumstances, 24 data may be lost when using this option together 25 with -s or --symlinks, or when specifying a 26 particular directory more than once; refer to the 27 fdupes documentation for additional information 28 -P --plain with --delete, use line-based prompt (as with older 29 versions of fdupes) instead of screen-mode interface 30 -N --noprompt together with --delete, preserve the first file in 31 each set of duplicates and delete the rest without 32 prompting the user 33 -I --immediate delete duplicates as they are encountered, without 34 grouping into sets; implies --noprompt 35 -p --permissions don\u0026#39;t consider files with different owner/group or 36 permission bits as duplicates 37 -o --order=BY select sort order for output and deleting; by file 38 modification time (BY=\u0026#39;time\u0026#39;; default), status 39 change time (BY=\u0026#39;ctime\u0026#39;), or filename (BY=\u0026#39;name\u0026#39;) 40 -i --reverse reverse order while sorting 41 -l --log=LOGFILE log file deletion choices to LOGFILE 42 -v --version display fdupes version 43 -h --help display this help message 1fdupes --recurse --noempty --nohidden --size --time --log=1111.log -d -N 5. 文件查重工具rdfind 6. 文件查重工具fslint 7. 同步工具rsync 1# -v：显示rsync过程中详细信息。可以使用\u0026#34;-vvvv\u0026#34;获取更详细信息。 2# -P：显示文件传输的进度信息。(实际上\u0026#34;-P\u0026#34;=\u0026#34;--partial --progress\u0026#34;，其中的\u0026#34;--progress\u0026#34;才是显示进度信息的)。 3# -n --dry-run ：仅测试传输，而不实际传输。常和\u0026#34;-vvvv\u0026#34;配合使用来查看rsync是如何工作的。 4# -a --archive ：归档模式，表示递归传输并保持文件属性。等同于\u0026#34;-rtopgDl\u0026#34;。 5# -r --recursive：递归到目录中去。 6# -t --times：保持mtime属性。强烈建议任何时候都加上\u0026#34;-t\u0026#34;，否则目标文件mtime会设置为系统时间，导致下次更新 7# ：检查出mtime不同从而导致增量传输无效。 8# -o --owner：保持owner属性(属主)。 9# -g --group：保持group属性(属组)。 10# -p --perms：保持perms属性(权限，不包括特殊权限)。 11# -D ：是\u0026#34;--device --specials\u0026#34;选项的组合，即也拷贝设备文件和特殊文件。 12# -l --links：如果文件是软链接文件，则拷贝软链接本身而非软链接所指向的对象。 13# -z ：传输时进行压缩提高效率。 14# -R --relative：使用相对路径。意味着将命令行中指定的全路径而非路径最尾部的文件名发送给服务端，包括它们的属性。用法见下文示例。 15# --size-only ：默认算法是检查文件大小和mtime不同的文件，使用此选项将只检查文件大小。 16# -u --update ：仅在源mtime比目标已存在文件的mtime新时才拷贝。注意，该选项是接收端判断的，不会影响删除行为。 17# -d --dirs ：以不递归的方式拷贝目录本身。默认递归时，如果源为\u0026#34;dir1/file1\u0026#34;，则不会拷贝dir1目录，使用该选项将拷贝dir1但不拷贝file1。 18# --max-size ：限制rsync传输的最大文件大小。可以使用单位后缀，还可以是一个小数值(例如：\u0026#34;--max-size=1.5m\u0026#34;) 19# --min-size ：限制rsync传输的最小文件大小。这可以用于禁止传输小文件或那些垃圾文件。 20# --exclude ：指定排除规则来排除不需要传输的文件。 21# --delete ：以SRC为主，对DEST进行同步。多则删之，少则补之。注意\u0026#34;--delete\u0026#34;是在接收端执行的，所以它是在 22# ：exclude/include规则生效之后才执行的。 23# -b --backup ：对目标上已存在的文件做一个备份，备份的文件名后默认使用\u0026#34;~\u0026#34;做后缀。 24# --backup-dir：指定备份文件的保存路径。不指定时默认和待备份文件保存在同一目录下。 25# -e ：指定所要使用的远程shell程序，默认为ssh。 26# --port ：连接daemon时使用的端口号，默认为873端口。 27# --password-file：daemon模式时的密码文件，可以从中读取密码实现非交互式。注意，这不是远程shell认证的密码，而是rsync模块认证的密码。 28# -W --whole-file：rsync将不再使用增量传输，而是全量传输。在网络带宽高于磁盘带宽时，该选项比增量传输更高效。 29# --existing ：要求只更新目标端已存在的文件，目标端还不存在的文件不传输。注意，使用相对路径时如果上层目录不存在也不会传输。 30# --ignore-existing：要求只更新目标端不存在的文件。和\u0026#34;--existing\u0026#34;结合使用有特殊功能，见下文示例。 31# --remove-source-files：要求删除源端已经成功传输的文件。 1OPTS=\u0026#34;\u0026#34; 2OPTS=\u0026#34;${OPTS} -P\u0026#34; 3OPTS=\u0026#34;${OPTS} -r\u0026#34; 4OPTS=\u0026#34;${OPTS} -o\u0026#34; 5OPTS=\u0026#34;${OPTS} -g\u0026#34; 6OPTS=\u0026#34;${OPTS} -t\u0026#34; 7OPTS=\u0026#34;${OPTS} -p\u0026#34; 8OPTS=\u0026#34;${OPTS} -l\u0026#34; 9# OPTS=\u0026#34;${OPTS} -u\u0026#34; 10OPTS=\u0026#34;${OPTS} \u0026#34; 11OPTS=\u0026#34;${OPTS} \u0026#34; 12# OPTS=\u0026#34;${OPTS} --delete \u0026#34; 13 14# NOT endswith \u0026#39;/\u0026#39; 15dst=/export/new 16 17set -ex 18 19# NOT endswith \u0026#39;/\u0026#39; 20src=srd_path 21rsync ${OPTS} ${src} ${dst} 8. 同步工具unison 9. 同步工具lsyncd ","date":"September 2, 2019","img":"https://kingdix10.github.io/covers/camera_lens_strap_145518_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/linux/shell/cmd_file/","series":[{"title":"linux命令","url":"/zh-cn/series/linux%E5%91%BD%E4%BB%A4/"}],"smallImg":"","tags":[{"title":"工具","url":"/zh-cn/tags/%E5%B7%A5%E5%85%B7/"},{"title":"linux命令","url":"/zh-cn/tags/linux%E5%91%BD%E4%BB%A4/"},{"title":"文件管理","url":"/zh-cn/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"}],"timestamp":1567382400,"title":"linux常用命令-文件管理"},{"categories":[{"title":"C语言","url":"/zh-cn/categories/c%E8%AF%AD%E8%A8%80/"}],"content":" 1. 连接符 1.1. 字符串转换# #用来把参数转换成字符串\n1#define pr_var(var) printf(#var \u0026#34; is %d\\n\u0026#34;, var); 2 3int main(int argc, char **argv) 4{ 5 int a = 1, b = 2; 6 7 pr_var(a); 8 pr_var(b); 9 pr_var(a+b); 10} 1.2. 参数连接## 在宏中，##可以用于参数连接。\n1#define regname(n) x ## n regname(8)会被展开成x8。 2. 可变参数 2.1. 可变参数__VA_ARGS__ __VA_ARGS__ 是一个可变参数的宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支持（VC6.0的编译器不支持）。\n2.2. 可编参数##__VA_ARGS__ ##__VA_ARGS__前面加上##的作用在于，当可变参数的个数为0时，##把前面多余的,去掉，防止编译出错\n1#define log1(...) printf(__VA_ARGS__) 2#define log2(fmt, ...) printf(fmt, __VA_ARGS__) 3#define log3(fmt, ...) printf(fmt, ##__VA_ARGS__) 4 5/// 正常 6log1(\u0026#34;i=%d, j=%d\\n\u0026#34;, i, j) 7 8/// 正常 9log2(\u0026#34;i=%d, j=%d\\n\u0026#34;, i, j) 10/// 编译失败，至少要两个及以上参数 11log2(\u0026#34;hello\\n\u0026#34;) 12 13/// 正常 14log3(\u0026#34;i=%d, j=%d\\n\u0026#34;, i, j) 15/// 正常 16log3(\u0026#34;hello\\n\u0026#34;) ","date":"July 18, 2019","img":"https://kingdix10.github.io/covers/fabric_texture_colorful_142186_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/05-program/ccpp/macro_link_args/","series":[{"title":"C语言","url":"/zh-cn/series/c%E8%AF%AD%E8%A8%80/"}],"smallImg":"","tags":[{"title":"编译器","url":"/zh-cn/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"timestamp":1563408000,"title":"gcc宏定义中的连接符和可变参数"},{"categories":[],"content":" 1. 环境准备 Windows映射Linux下的Samba共享目录 工具脚本：https://gitee.com/kingdix10/eel-ctools 2. SourceInsight快速建工程 2.1. 修改代码，保留编译中间生成物 1keepdep_patch.sh kernel/scirpts 2keepdep_patch.sh u-boot/scirpts 原理是保留编译过程中的.d文件，这个是编译器查找的依赖文件，可以保证添加文件时不会有多余的文件。\n2.2. 代码编译 在Linux下编译源码。如果之前编译过，最好clean后再编译。\n2.3. 生成文件列表 1$ depfilelist.sh -h 2Usage: depfilelist.sh -d [directory] -o [outfile] -i [ignore pattern of .d path] 在Linux命令行下，使用下边命令生成文件列表:\n1depfilelist.sh -d /path/to/output \u0026gt; filelist.txt filelist.txt中的文件路径是Linux下的，可以使用文本编辑工具或sed将其改为Windows映射的Samba路径。Windows也可以识别路径中的/，可以不做修改。\n2.4. 新建SourceInsight工程 新建工程，过程中会提示选择源码路径。如果忘记修改，可以通过Project -\u0026gt; Project setting再进行修改。\n2.5. 添加文件 Project -\u0026gt; Add and remove project files。 文件较多的情况可能比较卡，等待完成即可。\n","date":"July 18, 2019","img":"https://kingdix10.github.io/covers/pink_color_background_153889_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/01-os/win/sourceinsight/","series":[{"title":"未分类","url":"/zh-cn/series/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"smallImg":"","tags":[],"timestamp":1563408000,"title":"sourceinsight快速建工程"},{"categories":[{"title":"C语言","url":"/zh-cn/categories/c%E8%AF%AD%E8%A8%80/"}],"content":" 1. 查看gcc预定义宏 在Linux下可以输入如下命令：\n1gcc -posix -E -dM - \u0026lt; /dev/null window下，命令稍有不同\n1gcc -posix -E -dM - \u0026lt; nul 1.1. 常见宏 macro desc __FILE__ 文件名 __LINE__ 行号 __func__ 函数名，早期版本为__FUNCTION__ __DATE__ 编译日期 __TIME__ 编译时间 __linux__ 编译平台是linux时定义 ","date":"July 18, 2019","img":"https://kingdix10.github.io/covers/pixels_circles_colorful_121100_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/05-program/ccpp/gcc_predefine/","series":[{"title":"C语言","url":"/zh-cn/series/c%E8%AF%AD%E8%A8%80/"}],"smallImg":"","tags":[{"title":"编译器","url":"/zh-cn/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"timestamp":1563408000,"title":"编译器预定义宏"},{"categories":[],"content":" 1. 常用命令 1.1. 文件 1fatload # load binary file from a dos filesystem 2fatls # list files in a directory (default /) 3fatsize # determine a file\u0026#39;s size 4 5ext4ls 6ext4size 7ext4load 1.2. 内存 1cmp # memory compare 2cp # memory copy 3md # memory display 4mm # memory modify (auto#incrementing address) 5mw # memory write (fill) 6mwm # mw mask function 7nm # memory modify (constant address) 1.3. 环境变量 1env # environment handling commands 2saveenv # save environment variables to persistent storage 3setenv # set environment variables env命令：\n1env - environment handling commands 2 3Usage: 4env default [-f] -a - [forcibly] reset default environment 5env default [-f] var [...] - [forcibly] reset variable(s) to their default values 6env delete [-f] var [...] - [forcibly] delete variable(s) 7env export [-t | -b | -c] [-s size] addr [var ...] - export environment 8env import [-d] [-t [-r] | -b | -c] addr [size] - import environment 9env print [-a | name ...] - print environment 10env run var [...] - run commands in an environment variable 11env save - save environment 12env set [-f] name [arg ...] ","date":"July 18, 2019","img":"https://kingdix10.github.io/covers/cameras_photography_accessories_197110_300x168.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/docs/03-boot/u-boot/u-boot_commands/","series":[{"title":"未分类","url":"/zh-cn/series/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"smallImg":"","tags":[],"timestamp":1563408000,"title":"常见u-boot命令"},{"categories":[],"content":" 欢迎，这里是kingdix10的小站. 本站是个人博客，主要记录学习与生活的历程。 ","date":"February 28, 2019","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/about/","series":[],"smallImg":"","tags":[],"timestamp":1551312000,"title":"关于我"},{"categories":[],"content":" Welcome, there is the site of kingdix10. This site is a personal blog, mainly recording the process of learning and life. ","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/en/about/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"About"},{"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/en/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Contact Us"},{"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/zh-cn/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"联系我们"}]
